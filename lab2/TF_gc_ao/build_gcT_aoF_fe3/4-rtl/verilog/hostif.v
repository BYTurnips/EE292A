// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// Host interface with the core.This file multiplexes ARC data flows
// with those from the host, in order to allow host access to the core
// and auxiliary registers.
//
//======================= Inputs to this block =======================--
//
// en3_niv_a        Pipeline stage 3 enable. When this signal is true,
//                  the instruction in stage 3 can pass into stage 4 at
//                  the end of the cycle. When it is false, it will
//                  probably hold up stages one (pcen), two (en2), and
//                  three. This version of this signal is not qualified
//                  with ivalid_aligned.
//
// h_addr[31:0]     From Debugger. This is a 32-bit address (it may be
//                  smaller, but packed with zeroes) from the host which
//                  is used to access registers in the ARC in conjuction
//                  with aux_access and core_access. The width of the
//                  decode applied to this 32-bit quantity is defined by
//                  the AUXDECSZ constant, foundin extutil.v. It is
//                  defined as being a 32-bit bus at this level to 
//                  maintain compatibility with the LR and SR
//                  instructions which can generate a 32-bit value for
//                  the address to be used for auxiliary register
//                  accesses.
//
// h_dataw[31:0]    From Debugger. Data from the host to be stored into
//                  registers in the ARC/extensions.
//
// h_write          From Debugger. When it is true, this signal indicates
//                  that a host write is taking place.
//
// h_read           From Debugger. When it is true, this signal indicates
//                  that a host read is taking place.
//
// aux_access       From mc/host. This signal is used to inform the ARC 
//                  that address supplied on h_addr[31:0] applies to
//                  the auxiliary register set. 
//
// core_access      From mc/host. This signal is used to inform the ARC 
//                  that address supplied on h_addr[31:0] applies to
//                  the core register set. The signals core_access and 
//                  aux_access are provided so that the designer of the 
//                  memory controller can decide how the auxiliary
//                  registers and core registers will appear to the host
//                  processor.
//  
// fs2a[5:0]        From rctl.v. The source 2 register address live
//                  and direct from the stage 2 input latches. It is
//                  muxed with the host address to allow host accesses
//                  to registers when the ARC is stopped, before being
//                  output on s2a[5:0]
//
// h_rr_data[31:0]  Data to the host port from register reads. Also
//                  allows the debugger to read p1iw[] for cache
//                  testing. Does not include any returning load data,
//                  or shortcuts from stage three instructions.
//
// s1val[31:0]      From rctl.v. This is the stage 3 source 1 value
//                  direct from the stage 3 input latches. It is used to
//                  generate the auxiliary register bus address, after
//                  being muxed with host accesses.
//
// s2val[31:0]      From rctl.v. This is the stage 3 source 2 value
//                  direct from the stage 3 input latches. It is used to
//                  generate the auxiliary register write data, after
//                  being muxed with host accesses.
//              
// p3lr             U This signal is generated by rctl. It is produced
//                  from a decode of p3opcode, p3iw(13) (check for LR)
//                  and includes p3iv.
//
// p3sr             U This signal is generated by rctl. It is produced
//                  from a decode of p3opcode, p3iw(25) (check for SR)
//                  and includes p3iv.
//
// aux_datar[31:0]  From aux_regs.v. This is the data provided by the 
//                  auxiliary register set in response to a read. It
//                  does not include data from the pc/status register as
//                  these are handled in a special way. It also goes to
//                  the stage3 alu mux logic as it is used to load core
//                  registers as the result of an LR instruction.
//
// aux_dar[31:0]    From aux_regs.v. This is the data from the
//                  PC/status, semaphore and identity registers which
//                  can be read whilst the ARC is running, and hence
//                  does not go down the aux_datar[31:0] bus.
//
// da_auxam         From aux_regs.v. This signal is true when the
//                  address on h_addr[31:0] matches one of the dual
//                  access auxiliary registers (pc/status, semaphore,
//                  and indentity registers).
//
// p3_docmprel_a    A mispredicted BRcc of BBITx has been taken by the ARC
//                  processor in stage 3. The corrective action will be taken
//                  in stage 4 where the correct PC will be presented at the
//                  instruction fetch interface.
//
// ldvalid          From the LSU. This signal indicates that the LSU
//                  will be doing a register writeback on the nxt cycle,
//                  and that any host accesses must be held off.
//  
// instr_pending_r  This signal is true when an instruction fetch has
//                  been issued, and it has not yet completed. It is not
//                  true directly after a reset before the ARC has
//                  started, as no instruction fetch will have been
//                  issued. It is used to hold off host writes to the
//                  program counter when the ARC is halted, as these
//                  accesses will trigger an instruction fetch.
//
// xnoaccess        U From extensions. Directly ORed onto noaccess. 
//
// xhold_host       U From extensions. Directly ORed onto hold_host.
//
// ck_gated         U This is the gate signal that gates the clocks clk
//                  and ck_phi2 if the ARC is ready to be temporarily
//                  shut down. It is used here to hold off the host
//                  until the ARC is not gated.
//
//====================== Output from this block ======================--
//
// h_datar[31:0]    To Debugger. Data read from ARC/extensions.
//
// noaccess         To Debugger. This signal is used to reject host
//                  accesses which are not allowed when the ARC is
//                  running, ie any core register, and any aux register
//                  except the dual access register (PC, Semaphore, and
//                  identity registers)
//
// hold_host        This signal is used to tell the mc/host that the
//                  register access which it is attempting will not
//                  complete on this cycle, and should be held (by the
//                  mc/host) until the next cycle. This will happen if
//                  the host is attempting to do an access to the core
//                  register set whilst a delayed load is completing, or
//                  if the host is writing the program counter whilst an
//                  instruction fetch is still in progress.
//
// s2a[5:0]         To coreregs.v etc. This is the source1 register
//                  address after the muxer which is used to facilitate
//                  host accesses.
//
// aux_addr[31:0]   To aux_regs.v. This is the auxiliary register bus
//                  address value. Width of decode is set by AUXDECSZ. 
//
// aux_dataw[31:0]  To aux_regs.v. This is the auxiliary register bus 
//                  write data value.
//
// aux_write        To aux_regs.v. This signal indicates that a write
//                  (either from the ARC or host) is being performed to
//                  the auxiliary register specified on aux_addr[31:0].
//
// aux_read         To aux_regs.v. This signal indicates that a read
//                  (either from the ARC or host) is being performed
//                  from the auxiliary register specified on
//                  aux_addr[31:0].
//  
// cr_hostw         To rctl, alu. This indicates that the host will
//                  perform a write to the core registers on the next
//                  cycle, provided that a load writeback does not
//                  bounce it out of the way.
//                   This signal is of a lower priority than ldvalid, so
//                  when both are true, cr_hostw is ignored.
//
// cr_hostr         To sync_regs or regs. This indicates that the host
//                  will perform a read from the core registers on the
//                  next cycle.
//
// h_regadr[5:0]    The register number to be written to by host writes
//                  to the core registers. Used in rctl.v when
//                  cr_hostw is true.
//
// host_rw          This signal is true when an host access occurs, that
//                  is either a write (h_write = '1') or a read
//                  (h_read = '1').
//
// do_inst_step_r   This signal is set when the single step flag (SS)
//                  and the instruction step flag (is) in the debug
//                  register has been written to simultaneously through
//                  the host interface. It indicates that an instruction
//                  step is being performed. When the instruction step
//                  has finished this signal goes low.
//
//====================================================================--
//
module hostif (clk,
               rst_a,
               en,
               fs2a,
               h_rr_data,
               s1val,
               s2val,
               p3lr,
               p3sr,
               aux_datar,
               aux_dar,
               da_auxam,
               en3_niv_a,
               p3_docmprel_a,
	       pcounter_jmp_restart_a,
               ldvalid,
               instr_pending_r,
               do_inst_step_r,
               ck_gated,
               hold_host_intrpt_a,
               hold_host_multic_a,
               host_write_en_n_a,
               xnoaccess,
               xhold_host,
               xcache_hold_host,
               h_addr,
               h_dataw,
               h_write,
               h_read,
               aux_access,
               core_access,

               s2a,
               aux_addr,
               aux_dataw,
               aux_read,
               aux_write,
               cr_hostr,
               cr_hostw,
               h_regadr,
               host_rw,
               h_datar,
               noaccess,
               hold_host);

`include "arcutil_pkg_defines.v"
`include "arcutil.v" 
`include "extutil.v" 

   input          clk;   //  core clock
   input          rst_a; //  system reset
   input          en;    //  system go

//  Signals which connect rctl, aux_regs and
//  core connections to hostif (stage 2)
//
   input   [5:0]  fs2a; 
   input   [31:0] h_rr_data; 

//  core connections to hostif (stage 3)
//
   input   [31:0] s1val; 
   input   [31:0] s2val; 
   input          p3lr; 
   input          p3sr; 

//  hostif connections to auxiliary registers (stage 3)
//
   input   [31:0] aux_datar; 
   input   [31:0] aux_dar; 
   input          da_auxam; 

//  hostif connections to core (stage 3)
//
   input          en3_niv_a; 
   input          p3_docmprel_a;
   input          pcounter_jmp_restart_a;

//  signals to hold off host accesses //
//
   input          ldvalid; 
   input          instr_pending_r; 
   input          do_inst_step_r; 
   input          ck_gated;
   input          hold_host_intrpt_a;
   input          hold_host_multic_a;
   input          host_write_en_n_a;

// extensions signals
//
   input          xnoaccess; 
   input          xhold_host; 
   input          xcache_hold_host; 

// Group Four : Host interface
//
   input   [31:0] h_addr; 
   input   [31:0] h_dataw; 
   input          h_write; 
   input          h_read; 
   input          aux_access; 
   input          core_access; 
 
//  Signals which connect hostif, rctl and auxregs //
//  core connections to hostif (stage 2)
//
   output  [5:0]  s2a; 

//  hostif connections to auxiliary registers (stage 3)
//
   output  [31:0] aux_addr; 
   output  [31:0] aux_dataw; 
   output         aux_read; 
   output         aux_write; 

//  hostif connections to core (stage 3)
//
   output         cr_hostr; 
   output         cr_hostw; 
   output   [5:0] h_regadr; 
   output         host_rw; 

// Group Four : Host interface
//
   output  [31:0] h_datar; 
   output         noaccess; 
   output         hold_host;

   reg            hold_host; 
   wire    [31:0] h_datar; 
   wire           noaccess;
   wire    [5:0]  s2a; 
   wire    [31:0] aux_addr; 
   wire    [31:0] aux_dataw; 
   wire           aux_read; 
   wire           aux_write; 
   wire           cr_hostw; 
   wire           cr_hostr; 
   wire    [5:0]  h_regadr; 
   wire           host_rw;
 
   wire    [31:0] i_h_datar_nxt; 
   reg     [31:0] i_h_datar_r; 
   wire           i_hold_host_brcc_a;
   wire           i_hold_host_ctrl_trans_a;
   wire           i_host_rw_a; 
   wire           i_invalid_access;
   wire           i_pc_hostw_a; 
   wire           i_v_core_access;
   wire           i_v_aux_access;
   wire           i_v_h_read;
   wire           i_v_h_write;

//====================================================================--

   // Invalid Access when trying to read and write at the same time
   // or when trying to access core and aux regs at the same time
   //
   assign i_invalid_access = (h_read & h_write) |
                             (core_access & aux_access);

   // Validate access and r/w signals. Then use the validated versions
   // of this signals in the rest of the logic.
   //
   assign i_v_core_access = core_access & ~i_invalid_access;
   assign i_v_aux_access  = aux_access  & ~i_invalid_access;
   assign i_v_h_write     = h_write     & ~i_invalid_access;
   assign i_v_h_read      = h_read      & ~i_invalid_access;

   // Connections to stage 2:
   //
   // The source 1 bus is used to provide the host with access to the
   // core registers when the ARC is stopped. The lower part of the
   // host address is used to produce the register number.
   //
   assign s2a = (en == 1'b 1) ? fs2a : h_addr[OPERAND_MSB:0]; 

   // Connections to stage 3:
   //
   // The host interface produces the address for the regular auxiliary
   // registers from s1val/s2val when the ARC is running, or from part 
   // of the host address when the ARC is stopped.
   // Host access to the PC and semaphore registers whilst the ARC is 
   // running is acheived by a seperate (direct) data path to the
   // auxiliary register module.
   // 
   // ** Note that aux_read and aux_write include en3 so that only    **
   // ** one set of signals is required for arc and host accesses     **
   //
   assign aux_addr = (en == 1'b 1) ? s2val : 
          h_addr;

   assign aux_dataw = (en == 1'b 1) ? s1val : 
          h_dataw;

   assign aux_read = (en == 1'b 1) ? p3lr & en3_niv_a : 
          i_v_h_read & i_v_aux_access;

   assign aux_write = (en == 1'b 1) ? p3sr & en3_niv_a : 
          i_v_h_write & i_v_aux_access;
 
   // Connections to the memory controller's host interface.
   //
   // Three data paths are muxed together to go out to the host, these
   // being data from the core registers (h_rr_data), data from the
   // auxiliary registers (aux_datar) and data from the semaphore & PC
   // auxiliary registers (aux_dar).
   // 
   assign i_h_datar_nxt = ((da_auxam        == 1'b 1) ||
                           (en              == 1'b 1)) ?
          aux_dar : 
                          (i_v_core_access == 1'b 1) ?
          h_rr_data : 
          aux_datar;

 
   always @(posedge rst_a or posedge clk)
   begin : hdata_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_h_datar_r <= {32{1'b 0}};  
      end
   else
      begin
      i_h_datar_r <= i_h_datar_nxt; 
      end
   end

   assign h_datar = i_h_datar_r;
 
   // The noaccess signal is used to reject host accesses which are not
   // allowed when the ARC is running, ie any core register, and any
   // auxiliary register except the dual access registers (PC,
   // semaphore and identity registers). In addition, the extensions
   // can reject any accesses they object to, using the xnoaccess
   // signal.
   //
   assign i_host_rw_a = i_v_h_read | i_v_h_write; 
   assign host_rw = i_host_rw_a; 
   assign noaccess =(((en               == 1'b 1) &
                      (i_v_core_access  == 1'b 1)) | 
                     ((en               == 1'b 1) &
                      (i_v_aux_access   == 1'b 1) & 
                      (da_auxam         == 1'b 0)) |
                     (xnoaccess        == 1'b 1)) ?
          i_host_rw_a : 
                     (i_invalid_access == 1'b 1) ?
          1'b 1:
          1'b 0;

   //  Decode for host write to the program counter.
   // 
   assign i_pc_hostw_a = (i_v_aux_access == 1'b 1) &&
                         (i_v_h_write    == 1'b 1) &&
                         (en             == 1'b 0) &&
                         ( (auxdc(h_addr, AX_PC_N)       == 1'b 1) ||
                           (auxdc(h_addr, AX_PC32_N)     == 1'b 1) ||
                           (auxdc(h_addr, AX_STATUS32_N) == 1'b 1) ) ?
          1'b 1 :
          1'b 0;

   // The ARC holds the debugger off for 1 cycle when:
   //
   // [1] There is a host write.
   //
   // [2] The host access is to auxiliary Debug register.
   //
   // [3] The halt bit in the Debug register is accessed.
   //
   // [4] A mispredicted BRcc/BBITx has been taken by the ARC processor.
   //
   assign i_hold_host_brcc_a = h_write                   &
                               auxdc(h_addr, AX_DEBUG_N) &
                               h_dataw[DB_HALT_N]        &
                               p3_docmprel_a;

   // The ARC holds the debugger off for 1 cycle when:
   //
   // [1] There is a host write.
   //
   // [2] The host access is to auxiliary Debug register.
   //
   // [3] The halt bit in the Debug register is accessed.
   //
   // [4] A control transfer is going to happen.
   //			       
   assign i_hold_host_ctrl_trans_a = h_write                   &
                                     auxdc(h_addr, AX_DEBUG_N) &
                                     h_dataw[DB_HALT_N]        &
				     pcounter_jmp_restart_a;

   // This signal is set true when the host must be held off for a
   // cycle
   // 
   // [1] The host is writing to a core register whilst a delayed load is
   //     completing, whilst the ARC is halted.
   //
   // [2] The host wants to change the PC (when ARC is halted) and there is
   //     still an instruction fetch pending.
   //
   // [3] The extensions ask for the host to be held.
   //
   // [4] The instruction cache ask for the host to be held.
   //
   // [5] A single instruction step is being executed.
   //
   // [6] The host is halting the processor at the same time corrective
   //     action for a mispredicted compare&branch is being taken. 
   //
   // [7] The host is halting the processor at the same time a multi-cycle
   //     instruction is in progress. 
   //
   // [8] The host is halting the processor at the same time an interrupt
   //     is in progress. 
   //
   // [9] The ARC is gated, until it wakes up.
   //
   always @(en or
            i_v_core_access or 
            i_host_rw_a or 
            ldvalid or
            i_pc_hostw_a or 
            instr_pending_r or
            xhold_host or
            xcache_hold_host or
            ck_gated or 
            do_inst_step_r or
            hold_host_intrpt_a or
            hold_host_multic_a or
            host_write_en_n_a or
            i_hold_host_brcc_a or
	    i_hold_host_ctrl_trans_a)
         
      begin : hold_host_async_PROC
   if (((en                == 1'b 0)   &&
        (i_v_core_access   == 1'b 1)   && 
        (i_host_rw_a       == 1'b 1)   &&
        (ldvalid           == 1'b 1))  || 

       ((i_pc_hostw_a      == 1'b 1)   &&
        (instr_pending_r   == 1'b 1))  || 

       (ck_gated           == 1'b 1)   ||
       (xhold_host         == 1'b 1)   ||
       (xcache_hold_host   == 1'b 1)   ||
       (do_inst_step_r     == 1'b 1)   || 
       (hold_host_intrpt_a == 1'b 1)   ||
       (hold_host_multic_a == 1'b 1)   ||
       (host_write_en_n_a  == 1'b 1)   ||
       (i_hold_host_brcc_a == 1'b 1)   ||
       (i_hold_host_ctrl_trans_a == 1'b 1))

      begin
      hold_host = 1'b 1;   
      end
   else
      begin
      hold_host = 1'b 0;   
      end
   end

//  Generate a signal to indicate that the host will write to the core
//  registers on the next cycle. This signal does not include hold_host
//  as the write would be ignored if a delayed load writeback were to
//  take place. It is never true when the ARC is running.
//
assign cr_hostw = (~en) & i_v_core_access & i_v_h_write; 

//  Generate a signal to indicate that the host will read to the core
//  registers on the next cycle.
//
assign cr_hostr = (~en) & i_v_h_read & i_v_core_access; 

//
//  Extract the register number to be written to from auxiliary address.
//
assign h_regadr = h_addr[OPERAND_MSB:0]; 

endmodule // module hostif
