// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2004-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This is the section of the JTAG port that runs on the core
// clock.
//
//======================= Inputs to this block =======================--
//
// clk_ungated      The ungated CPU clock, always running
//
// rst_a            The core reset signal
//
// do_bvci_cycle  From debug_port, and synchronous to jtag_tck. Any edge
//                signals a request for a BVCI transaction
//
// bvci_addr_r      From debug_port, synchronous to jtag_tck. The variable
//                portion of the BVCI address
//
// bvci_cmd_r       From debug_port, synchronous to jtag_tck. The BVCI
//                command
//
//====================== Output from this block ======================--
//
// debug_address  The BVCI address to the core's debug port
//
// debug_cmd      The BVCI command to the core's debug port
//
// debug_cmdval   The BVCI command-valid signal.
//
//====================================================================--
//

module sys_clk_sync(
  clk_ungated,
  rst_a,
  test_mode,
  do_bvci_cycle,
  bvci_addr_r,
  bvci_cmd_r,

  debug_address,
  debug_cmd,
  debug_cmdval
);

`include "extutil.v"

  input                       clk_ungated;
  input                       rst_a;
  input                       test_mode;
  input                       do_bvci_cycle;
  input  [`ADDR_SIZE - 1 : 2] bvci_addr_r;
  input  [1 : 0]              bvci_cmd_r;
  output [31 : 0]             debug_address;
  output [1 : 0]              debug_cmd;
  output                      debug_cmdval;

  wire   [31 : 0]             debug_address;
  wire   [1 : 0]              debug_cmd;
  wire                        debug_cmdval;

  reg    [`ADDR_SIZE - 1 : 2] i_bvci_addr_synchro_r;
  reg    [`ADDR_SIZE - 1 : 2] i_bvci_addr_r1_r;
  reg    [1 : 0]              i_bvci_cmd_synchro_r;
  reg    [1 : 0]              i_bvci_cmd_r1_r;
  reg                         i_rq_r1_r;
  reg                         i_rq_r2_r;
  reg                         i_rq_synchro_r;
  reg                         i_rst_mask_r3_r;
  reg                         i_rst_mask_r2_r;
  reg                         i_rst_mask_r1_r;
  
  //  This process implements a very restricted BVCI initiator. It is
  //  designed only to connect to the BVCI target in the ARC 600 / 700 debug
  //  port, which responds in a single cycle and has cmdack tied true. It
  //  gets a command via the do_bvci_cycle signal, which is generated on
  //  the JTAG clock. That signal gets double-synchronized, and the leading
  //  edge of the result is put out as cmdval.
  //
  //  Nota bene: We need to be able to generate BVCI cycles on consecutive
  //  cycles of the JTAG clock. In order to do this without logic asynchronous
  //  to that clock, the signal do_bvci_cycle is edge-signaling rather than
  //  level- signaling. That is, *any* edge will cause a BVCI cycle to be
  //  initiated.
  always @(posedge clk_ungated or posedge rst_a)
  begin : POSEDGE_SYNC_PROC
    if (rst_a == 1'b1)
    begin
      i_rq_r2_r        <= 1'b0;
      i_rq_r1_r        <= 1'b0;
      i_rq_synchro_r   <= 1'b0;
      i_rst_mask_r3_r  <= 1'b1;
      i_rst_mask_r2_r  <= 1'b1;
      i_rst_mask_r1_r  <= 1'b1;
      i_bvci_addr_r1_r <= { `ADDR_SIZE - 2 { 1'b0 }};
      i_bvci_cmd_r1_r  <= 2'b00;
    end

    else
    begin
      i_rq_r2_r        <= i_rq_r1_r;             // For the edge detector
      i_rq_r1_r        <= i_rq_synchro_r;        // Form the double synchronizer
      i_rq_synchro_r   <= do_bvci_cycle;
      i_rst_mask_r3_r  <= i_rst_mask_r2_r;
      i_rst_mask_r2_r  <= i_rst_mask_r1_r;
      i_rst_mask_r1_r  <= 1'b0;
      i_bvci_addr_r1_r <= i_bvci_addr_synchro_r; // Just a delay
      i_bvci_cmd_r1_r  <= i_bvci_cmd_synchro_r;
    end
  end

  // This capturing of the address and command on the negative edge is done
  // to guarantee that if the edges of the JTAG clock and core clock
  // happen to align, the BVCI interface won't see the command and data
  // from the wrong cycle. The reason this works is somewhat subtle.
  // Because do_bvci_cycle and the address/command combo are being captured
  // on different clock edges, they cannot go metastable at the same time.
  // If this stage goes metastable, because address, command, and
  // do_bvci_cycle are changing when the core clock is falling, then this
  // stage will be invalid, but the capture of do_bvci_cycle will happen
  // half a cycle later and will be valid. Call this negative edge t0. Then
  // do_bvci_cycle will be captured cleanly at t0.5, and cmdval will be
  // true from t1.5-t2.5. The output of these flops is metastable, so it
  // may be wrong when it's captured by the next rank above at t0.5. But
  // the fact that we require the JTAG clock to be no faster than 1/2 the
  // core clock speed means that it won't change again until t2, and will
  // be captured cleanly at t1. This in turn means that the second rank of
  // flops above will present clean data to the BVCI interface from
  // t1.5-t2.5, at the same time as cmdval. For a more thorough analysis, see
  // the ARC 600/ARC 700 JTAG Port Implementation Reference
  //.

wire clk_ungated_n;
assign clk_ungated_n = (test_mode) ? clk_ungated : ~clk_ungated;

//  leda NTL_CLK03 off
  always @(posedge clk_ungated_n or posedge rst_a)
  begin : NEGEDGE_SYNC_PROC
    if (rst_a == 1'b1)
    begin
      i_bvci_addr_synchro_r <= { `ADDR_SIZE - 2 { 1'b0 }};
      i_bvci_cmd_synchro_r  <= 2'b00;
    end

    else
    begin
      i_bvci_addr_synchro_r <= bvci_addr_r;
      i_bvci_cmd_synchro_r  <= bvci_cmd_r;
    end
  end
//  leda NTL_CLK03 on
  // This violation of the normal standard, which specifies that all the
  // outputs from a module must be latched, is done to eliminate the extra
  // cycle required on a transaction across the BVCI bus. This seems
  // a compelling reason to add one level of gating to this path. It is
  // read in synchronous circuitry on the other side of the interface.
  //
  // Note: Edge-detect the request.
  //
  assign debug_cmdval   = (i_rq_r2_r != i_rq_r1_r) &
                          (i_rst_mask_r3_r != 1'b1); 

  // Drive the outputs. The fixed parts of the address are added here.
  //
  assign debug_cmd      = i_bvci_cmd_r1_r;
  assign debug_address  = { `BASE_ADDR, i_bvci_addr_r1_r, 2'b00 };

endmodule // module sys_clk_sync
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2004-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// The JTAG Debug Port is the module that contains all the
// internal JTAG registers and performs the actual communication
// between the ARC600 and the host. Refer to the JTAG section in
// the ARC interface manual for an explanation on how to
// communicate with the complete module. In this revision, the
// debug port does not contain the address, data, command, or
// status registers.  These physically reside on the other side
// of a BVCI interface, and are read by the debug port during the
// Capture-DR state and written during the Update-DR state. A
// command is initiated during the Run-Test/Idle state by writing
// a do-command address over the BVCI interface, and the
// registers are reset during the Test-Logic-Reset state by
// writing a reset address.
//
//======================= Inputs to this block =======================--
//
// jtag_trst_a          The internal version of TRST*, conditioned to be
//                      asynchronously applied and synchronously released
//
// jtag_tck             The JTAG clock
//
// jtag_tck_muxed       The inverted JTAG clock during functional mode
//                      JTAG clock during test mode
//
// jtag_tdi             JTAG Test Data In, input to the data and instruction
//                      shift registers
//
// jtag_bsr_tdo         Test Data Out from the user's boundary scan register
//
// test_logic_reset     TAP controller state decodes
//                      run_test_idle
//                      capture_ir
//                      shift_ir
//                      update_ir
//                      capture_dr
//                      shift_dr
//
// select_r             Selects instruction or data shift register for TDO
//
// test_logic_reset_nxt TAP controller next state decodes
//                      run_test_idle_nxt
//                      select_dr_scan_nxt
//                      capture_dr_nxt
//                      update_dr_nxt
//
// debug_rdata_r          Read data from the BVCI debug port
//
//====================== Output from this block ======================--
//
// bvci_addr_r            Variable part of BVCI address, to be synchronized with
//                      clk_main
//
// bvci_cmd_r             BVCI command, to be synchronized with clk_main
//
// debug_be             BVCI Byte Enables. All bytes always enabled
//
// debug_eop            BVCI End Of Packet. Always true; we only do one-word
//                      transfers
//
// debug_rspack         BVCI Response Acknowledge. Always true.
//
// debug_wdata          BVCI Write Data. Only changed on entry to Update-DR, do
//                      doesn't need to be synchronized
//
// do_bvci_cycle        Request to perform a transaction on the BVCI debug
//                      interface. Edge-signaling.
//
// arca_busy            JTAG busy signal. Used for activity LED if desired
//
// jtag_tdo_r             JTAG Test Data Out. Output from shift registers
//
// jtag_extest_mode     Decodes for user boundary scan circuitry
// jtag_sample_mode
//
//====================================================================--
//
module debug_port(
  jtag_tck,
  jtag_tck_muxed,
  jtag_trst_a,
  jtag_tdi,
  debug_rdata_r,
  jtag_bsr_tdo,
  test_logic_reset,
  run_test_idle,
  shift_ir,
  update_ir,
  shift_dr,
  capture_dr,
  capture_ir,
  select_r,
  test_logic_reset_nxt,
  run_test_idle_nxt,
  select_dr_scan_nxt,
  capture_dr_nxt,
  update_dr_nxt,

  do_bvci_cycle,
  arca_busy,
  jtag_tdo_r,
  bvci_addr_r,
  debug_be,
  bvci_cmd_r,
  debug_eop,
  debug_rspack,
  debug_wdata,
  jtag_extest_mode,
  jtag_sample_mode
  );

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"

  // Inputs for JTAG interface
  input                       jtag_tck;
  input                       jtag_tck_muxed;
  input                       jtag_trst_a;
  input                       jtag_tdi;

  //  This input is generated in the BVCI target, synchronous to the system
  //  clock.
  //
  input  [31 : 0]             debug_rdata_r;  // Read data

  // Connection to a Boundary Scan Register (scan chain) will involve decoding
  // eight signals called jtag_bsr_tdo, jtag_extest_mode, jtag_sample_mode,
  // capture_en, shiftdr_en, updatedr_en and jtag_tdi. The jtag_tdi is connected
  // to the first cell in the Boundary Scan Register. The jtag_bsr_tdo pin is
  // wired to the final cell of the Boundary Scan Register.

  // The jtag_extest_mode and jtag_sample_mode signals are used as master
  // enables. This allow the Boundary Scan Register to be activated
  // whenever the EXTEST or SAMPLE instruction is selected.

  // The shiftdr_en, capturedr_en and updatedr_en enable signals are
  // combined with decoding logic allowing the shift and latch elements of
  // the Boundary Scan Register to be controlled in the Shift-DR,
  // Capture-DR and Update-DR TAP states.

  input                       jtag_bsr_tdo; // Output from boundary scan cell

  //  TAP Controller Interface (state control signals) Signals indicating that
  //  the TAP controller is in a certain state
  input                       test_logic_reset;
  input                       run_test_idle;
  input                       shift_ir;
  input                       update_ir;
  input                       shift_dr;
  input                       capture_dr;
  input                       capture_ir;

  input                       select_r;

  // Signals indicating that the TAP controller will enter a certain state
  // on the next clock
  input                       test_logic_reset_nxt;
  input                       run_test_idle_nxt;
  input                       select_dr_scan_nxt;
  input                       capture_dr_nxt;
  input                       update_dr_nxt;

  // Signals from here on are synchronous to the JTAG clock.
  //
  // BVCI transaction request. Edge-signaling, and synchronized to system clock
  // in sys_clk_sync.
  output                      do_bvci_cycle;

  // Used to indicate that a transaction is taking place. Tied to activity LED
  // on ARCangel 3 board.
  output                      arca_busy;

  //  Additional signals for JTAG Interface
  //
  output                      jtag_tdo_r;

  //  BVCI initiator interface, except for cmdval, which is generated in the
  //  sys_clk_sync module on the system clock. These are all generated on the
  //  JTAG clock, but are not sampled in the BVCI target until it sees cmdval,
  //  which is guaranteed to be later since it's generated from
  //  a system-clock-synchronized version of a signal generated on the JTAG
  //  clock.
  output [`ADDR_SIZE - 1 : 2] bvci_addr_r;    // Longword address, variable part
  output [3 : 0]              debug_be;     // Byte enables
  output [1 : 0]              bvci_cmd_r;     // Command
  output                      debug_eop;    // End-of-packet
  output                      debug_rspack; // Response acknowledge
  output [31 : 0]             debug_wdata;  // Write data

  output                      jtag_extest_mode; // IR decode to boundary scan
  output                      jtag_sample_mode; // IR decode to boundary scan


  reg    [`ADDR_SIZE - 1 : 2] bvci_addr_r;
  wire   [3 : 0]              debug_be;
  reg    [1 : 0]              bvci_cmd_r;
  wire                        debug_eop;
  wire                        debug_rspack;
  wire   [31 : 0]             debug_wdata;
  wire                        do_bvci_cycle;
  wire                        arca_busy;
  reg                         jtag_tdo_r;
  wire                        jtag_extest_mode;
  wire                        jtag_sample_mode;

  //  Signal used to communicate with the BVCI cycle initiator.
  reg                         i_do_bvci_cycle_r;

  //  The following signals are generated from D-type-flops with enables
  //  and are used to hold the data register contents. The registers are
  //  commonly referred to as shadow latches (IEEE Std 1149.1).
  reg    [31 : 0]             shift_register_r;   // the shift reg (used by DRs)
  reg    [3 : 0]              ir_latch_r;         // the instruction register
  reg    [3 : 0]              ir_sreg_r;          // shift register for IR
  reg                         bypass_reg_r;       // bypass reg, a one bit reg

  //  The following signals are used to connect to the TDO output. The TDO
  //  output can be connected to two source outputs, the data registers or
  //  the instruction register.
  wire                        tdo_src_dr;       // DRs muxed to TDO
  wire                        tdo_src_ir;       // IR muxed to TDO

  //  Misc signals used in decoding and other stuff
  integer                     index;            // used for the shift register

  //  interface signals that connect to the boundary scan register. The two
  //  signals are driven when a specific instruction is selected.
  assign jtag_extest_mode = (ir_latch_r == `IR_EXTEST);
  assign jtag_sample_mode = (ir_latch_r == `IR_SAMPLE);

  //  The busy signal that goes onto the orange led of the ARCAngel
  assign arca_busy = ~ (run_test_idle | test_logic_reset);

  //  The concurrent statement below is used to select the appropriate data
  //  register output for the TDO signal. The signal inputs to this mux are
  //  taken from the LSB of the shift register, the boundary scan register
  //  last cells output and the bypass register. Only one of LSB bits is
  //  selected to the tdo_src_dr output dependent upon the value contained
  //  in the instruction latch. The selected signal is then pass on into
  //  the final mux, which determines what goes onto the TDO output pin.
  //  As per the JTAG spec, all unused instructions select the bypass
  //  register.
  assign tdo_src_dr = ((ir_latch_r == `IR_STATUS)||(ir_latch_r == `IR_COMMAND)||
                       (ir_latch_r == `IR_ADDRESS)||(ir_latch_r == `IR_DATA)  ||
                       (ir_latch_r == `IR_IDCODE)) ?
                      shift_register_r[0] :

                      ((ir_latch_r == `IR_EXTEST)||(ir_latch_r == `IR_SAMPLE)) ?
                      jtag_bsr_tdo :

                      bypass_reg_r; // Covers ir_latch_r == `IR_BYPASS
                                  // and all other cases

  //  the LSB of the instruction register is always selected for this source.
  assign tdo_src_ir = ir_sreg_r[0];

  //  The process statement below selects between the data or instruction
  //  register to the main TDO output. The selection is made according to
  //  the select_r signal that comes from the TAP controller. It indicates
  //  what type of register is being accessed (if any). HIGH = instruction
  //  register access, LOW = data register access. The TDO output always
  //  changes on the falling edge of TCK, which is implemented by inverting
  //  jtag_tck to jtag_tck_muxed in functional mode
  always @(posedge jtag_tck_muxed or posedge jtag_trst_a)
  begin : TDO_OUTPUT_PROC
    if (jtag_trst_a == 1'b1)
      jtag_tdo_r <= 1'b0;

    else
      if (test_logic_reset == 1'b1)
        jtag_tdo_r <= 1'b0;

      else if ((shift_dr == 1'b1) | (shift_ir == 1'b1))
        if (select_r == 1'b0)
          jtag_tdo_r <= tdo_src_dr;
        else
          jtag_tdo_r <= tdo_src_ir;
  end

  //  The shift Data Register Cell
  //
  //  The shift data register is used to load and unload data from the
  //  selected data register and serially shift data in from TDI and out
  //  through TDO. Data is loaded into the shift cell when the capture_dr
  //  state is entered and the instruction register contains a valid
  //  instruction code.
  always @(posedge jtag_tck or posedge jtag_trst_a)
  begin : DR_SHIFT_REG_CELL_PROC
    if (jtag_trst_a == 1'b1)
      shift_register_r <= { `SREG_SIZE { 1'b0 }};

    else
      if (test_logic_reset == 1'b1)
        shift_register_r <= { `SREG_SIZE { 1'b0 }};

      else if (shift_dr == 1'b1)
        //  Command is 4 bits
        if (ir_latch_r == `IR_COMMAND)
        begin //  shift register on by one
          for (index = 0; index < (`JTAG_CMD_SIZE - 1); index = index + 1)
            shift_register_r[index] <= shift_register_r[index + 1];
          shift_register_r[`JTAG_CMD_MSB] <= jtag_tdi; // latch new data
        end
        // Status is 6 bits
        else if (ir_latch_r == `IR_STATUS)
        begin //  shift register on by one
          for (index = 0; index < (`JTAG_STATUS_SIZE - 1); index = index + 1)
            shift_register_r[index] <= shift_register_r[index + 1];
          shift_register_r[`JTAG_STATUS_MSB] <= jtag_tdi; // latch new data
        end
        else //  All others are 32 bits
        begin //  shift register on by one
          for (index = 0; index < (`SREG_SIZE - 1); index = index + 1)
            shift_register_r[index] <= shift_register_r[index + 1];
          shift_register_r[`SREG_MSB] <= jtag_tdi; // latch new data
        end

      else if (capture_dr == 1'b1)
        case (ir_latch_r)
          `IR_ADDRESS, `IR_DATA :
            shift_register_r <= debug_rdata_r;

          `IR_COMMAND :
          begin
            shift_register_r[`JTAG_CMD_MSB : 0] <=
              debug_rdata_r[`JTAG_CMD_MSB : 0];
            shift_register_r[`SREG_MSB : `JTAG_CMD_SIZE] <=
              { `SREG_SIZE - `JTAG_CMD_SIZE { 1'b0 }}; // Zero upper bits
          end

          `IR_STATUS :
          begin
            shift_register_r[`JTAG_STATUS_MSB : 0] <=
              debug_rdata_r[`JTAG_STATUS_MSB : 0];
            shift_register_r[`SREG_MSB : `JTAG_STATUS_SIZE] <=
              { `SREG_SIZE - `JTAG_STATUS_SIZE { 1'b0 }}; // Zero upper bits
          end

          `IR_IDCODE :
            shift_register_r <= {`JTAG_VERSION, `TWO_ZEROS, `ARCNUM, `ARC_TYPE,
                               `ARC_JEDEC_CODE, 1'b1}; //  load id register

          default :
            shift_register_r <= { `SREG_SIZE { 1'b0 }};

        endcase
  end

  //  The Shift Instruction Register Cell
  //
  //  The shift instruction register cell is used to shift the elements of the
  //  instruction register.  The capture circuitry loads a 0001 pattern into the
  //  instruction register every time the Capture-IR state is entered. This
  //  allow the communicating device to detect faults along a 1149.1 bus.
  always @(posedge jtag_tck or posedge jtag_trst_a)
  begin : IR_SHIFT_REG_CELL_PROC
    if (jtag_trst_a == 1'b1)
      ir_sreg_r <= 4'b0000;

    else
      if (capture_ir == 1'b1)
        ir_sreg_r <= `IR_INIT; //  whenever we capture IR we must load a 01 into
                             //  the two LSBs. This aids in diagnosing
                             //  faults along the IEEE 1149.1-1990 bus

    else if (shift_ir == 1'b1)
    begin
      ir_sreg_r[3] <= jtag_tdi;   // latch new data in on TDI
      ir_sreg_r[2] <= ir_sreg_r[3]; // shift register on by one
      ir_sreg_r[1] <= ir_sreg_r[2];
      ir_sreg_r[0] <= ir_sreg_r[1];
    end
  end

  //  The following processes are used to load shifted data into instruction or
  //  a selected data register. A D type flip flop with an enable is inferred
  //  for all registers. The enable is asserted active on all data registers
  //  only when the update_dr state is entered and the instruction latch
  //  contains the selected data register code. The instruction register is
  //  updated only when the update-ir state is entered. Note all registers are
  //  updated on the falling edge of the TCK clock when in the update-ir/dr
  //  state, except for the address, command, and data registers, which are
  //  updated via a write over the BVCI interface.
  always @(posedge jtag_tck or posedge jtag_trst_a)
  begin : BVCI_PROC
    if (jtag_trst_a == 1'b1)
    begin
      bvci_cmd_r  <= `BVCI_CMD_NOP;
      bvci_addr_r <= `RESET_ADDR;
    end

    else //  Generate the BVCI address and command
      if (update_dr_nxt == 1'b1)
      begin
        bvci_cmd_r <= `BVCI_CMD_WRITE;
        case (ir_latch_r)
          `IR_ADDRESS :
            bvci_addr_r <= `ADDRESS_R_ADDR;
          `IR_DATA :
            bvci_addr_r <= `DATA_R_ADDR;
          `IR_COMMAND :
            bvci_addr_r <= `COMMAND_R_ADDR;
          default :
            bvci_addr_r <= `RESET_ADDR;
        endcase
      end

      // The address must be presented for two clocks to allow the
      // returned read data to be synchronized before use, as it's
      // generated on the system clock.
      else if ((capture_dr_nxt == 1'b1) || (select_dr_scan_nxt == 1'b1))
      begin
        bvci_cmd_r <= `BVCI_CMD_READ;
        case (ir_latch_r)
          `IR_ADDRESS :
            bvci_addr_r <= `ADDRESS_R_ADDR;
          `IR_DATA :
            bvci_addr_r <= `DATA_R_ADDR;
          `IR_COMMAND :
            bvci_addr_r <= `COMMAND_R_ADDR;
          `IR_STATUS :
            bvci_addr_r <= `STATUS_R_ADDR;
          default :
            bvci_addr_r <= `RESET_ADDR;
        endcase
      end

      else if (run_test_idle_nxt == 1'b1)
      begin
        bvci_cmd_r  <= `BVCI_CMD_WRITE;
        bvci_addr_r <= `DO_CMD_ADDR;
      end

      else if (test_logic_reset_nxt == 1'b1)
      begin
        bvci_cmd_r  <= `BVCI_CMD_WRITE;
        bvci_addr_r <= `RESET_ADDR;
      end

      else
      begin
        bvci_cmd_r  <= `BVCI_CMD_NOP;
        bvci_addr_r <= `RESET_ADDR;
      end
  end

  assign debug_wdata = shift_register_r;

  //  These signals are fixed in this implementation
  assign debug_be     = 4'b1111; // We always write all the bytes
  assign debug_eop    = 1'b1;    // We only do one word
  assign debug_rspack = 1'b1;    // We always take the data in a cycle

  //  This process manages the do_bvci_cycle flop, which is toggled to
  //  request a BVCI cycle. This edge-signaling, rather than level-
  //  signaling, is done so that we can request BVCI cycles on consecutive
  //  JTAG clocks.
  always @(posedge jtag_tck or posedge jtag_trst_a)
  begin : DO_BVCI_CMD_PROC
    if (jtag_trst_a == 1'b1)
      i_do_bvci_cycle_r <= 1'b0;

    else
      if (update_dr_nxt == 1'b1)
        case (ir_latch_r)
          `IR_ADDRESS, `IR_DATA, `IR_COMMAND :
            i_do_bvci_cycle_r <= ~ i_do_bvci_cycle_r;
          default :
            ;
        endcase

      else if (select_dr_scan_nxt == 1'b1) // We do the read speculatively
        case (ir_latch_r)
          `IR_ADDRESS, `IR_DATA, `IR_COMMAND, `IR_STATUS :
            i_do_bvci_cycle_r <= ~ i_do_bvci_cycle_r;
          default :
            ;
        endcase

      else if ((run_test_idle_nxt == 1'b1) && (run_test_idle == 1'b0))
        case (ir_latch_r)
          `IR_BYPASS, `IR_EXTEST, `IR_SAMPLE, `IR_UNUSED0, `IR_UNUSED1,
          `IR_UNUSED2, `IR_UNUSED3, `IR_UNUSED4, `IR_UNUSED5, `IR_UNUSED6,
          `IR_UNUSED7 :
            ;
          default :
            i_do_bvci_cycle_r <= ~ i_do_bvci_cycle_r;
        endcase

      else if (test_logic_reset_nxt == 1'b1)
        i_do_bvci_cycle_r <= ~ i_do_bvci_cycle_r;
  end

  assign do_bvci_cycle = i_do_bvci_cycle_r; //  Drive the output

  //  Note that the instruction register, as required by the JTAG spec, updates
  //  on the falling edge of JTAG clock, which is implemented by inverting 
  //  jtag_tck to jtag_tck_muxed in functional mode
  always @(posedge jtag_tck_muxed or posedge jtag_trst_a)
  begin : THE_INSTRUCTION_REG_PROC
    if (jtag_trst_a == 1'b1)
      ir_latch_r <= `IR_IDCODE;

    else
      if (test_logic_reset == 1'b1)
        ir_latch_r <= `IR_IDCODE;

      else if (update_ir == 1'b1)
        ir_latch_r <= ir_sreg_r; //  update the instruction reg
  end

  //  The following process defines the BYPASS register. The Bypass mode is set
  //  when all ones have been written into instruction register or when the JTAG
  //  port has be reset. The bypass register is set to zero on during
  //  Capture-DR, and to TDI during Shift-DR, and is held in all other states,
  //  as per the JTAG spec.
  always @(posedge jtag_tck or posedge jtag_trst_a)
  begin : BYPASS_BIT_PROC
    if (jtag_trst_a == 1'b1)
      bypass_reg_r <= 1'b0;

    else
      if (capture_dr == 1'b1)
        bypass_reg_r <= 1'b0;

      else if (shift_dr == 1'b1)
        bypass_reg_r <= jtag_tdi;
  end

endmodule // module debug_port
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2004-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// The Test Access Port (TAP) Controller is the master control module of
// the JTAG port. It has been designed according to the IEEE 1149.1 JTAG
// specification and allows the host device to communicate with all
// internal JTAG registers and initiate transaction protocols to the
// ARC600 and its system memory.  Overview of the function provided in
// this file.
//
//======================= Inputs to this block =======================--
//
// jtag_tms             JTAG Test Mode Select. Controls state transitions
//                      in the TAP controller. From TMS at I/O pad ring
//
// jtag_tck             JTAG clock, from TCK at I/O pad ring
//
// jtag_tck_muxed       The inverted JTAG clock during functional mode
//                      JTAG clock during test mode
//
// jtag_trst_a          JTAG reset. Synchronized version of TRST*
//
//====================== Output from this block ======================--
//
// select_r             Signals whether access is to IR or DR
//
// jtag_tdo_zen_n       Enable for TDO at I/O pad ring
//
// test_logic_reset     TAP controller state decodes
//                      run_test_idle
//                      capture_dr
//                      shift_dr
//                      update_dr
//                      capture_ir
//                      shift_ir
//                      update_ir
//
// test_logic_reset_nxt TAP controller next state decodes
//                      run_test_idle_nxt
//                      select_dr_scan_nxt
//                      capture_dr_nxt
//                      update_dr_nxt
//
//====================================================================--
//

module tap_controller(
  jtag_tck,
  jtag_tck_muxed,
  jtag_trst_a,
  jtag_tms,
  select_r,
  jtag_tdo_zen_n,
  test_logic_reset,
  run_test_idle,
  shift_ir,
  update_ir,
  shift_dr,
  capture_dr,
  capture_ir,
  update_dr,
  test_logic_reset_nxt,
  run_test_idle_nxt,
  select_dr_scan_nxt,
  capture_dr_nxt,
  update_dr_nxt
);

  //  The controller interface signals
  //
  input  jtag_tck;
  input  jtag_tck_muxed;
  input  jtag_trst_a;
  input  jtag_tms;
  output select_r;
  output jtag_tdo_zen_n;

  //  State control signals
  //
  output test_logic_reset;
  output run_test_idle;
  output shift_ir;
  output update_ir;
  output shift_dr;
  output capture_dr;
  output capture_ir;
  output update_dr;
  output test_logic_reset_nxt;
  output run_test_idle_nxt;
  output select_dr_scan_nxt;
  output capture_dr_nxt;
  output update_dr_nxt;

  wire   select_r;
  reg    jtag_tdo_zen_n;
  wire   test_logic_reset;
  wire   run_test_idle;
  wire   shift_ir;
  wire   update_ir;
  wire   shift_dr;
  wire   capture_dr;
  wire   capture_ir;
  wire   update_dr;
  wire   test_logic_reset_nxt;
  wire   run_test_idle_nxt;
  wire   select_dr_scan_nxt;
  wire   capture_dr_nxt;
  wire   update_dr_nxt;

  //  TAP Controller State Codes
  //
  //  The following enumerated types define all 16 states of the TAP
  //  controller.  These states are used to communicate with the debug
  //  port, a module that is responsible for communicating with the ARC and
  //  local memory.
  `define S_TEST_LOGIC_RESET  4'd0  // TAP controller reset state
  `define S_RUN_TEST_IDLE     4'd1  // the transaction trigger state
  `define S_SELECT_DR_SCAN    4'd2  // select register type
  `define S_CAPTURE_DR        4'd3  // load selected register into shift reg
  `define S_SHIFT_DR          4'd4  // clock the data shift cell
  `define S_EXIT1_DR          4'd5  // exit state 1 for DR scan
  `define S_PAUSE_DR          4'd6  // pause state for data register
  `define S_EXIT2_DR          4'd7  // exit state 2 for DR scan
  `define S_UPDATE_DR         4'd8  // update state for the selected DR
  `define S_SELECT_IR_SCAN    4'd9  // select register type
  `define S_CAPTURE_IR        4'd10 // load instruction data in shift cell
  `define S_SHIFT_IR          4'd11 // clock the instruction shift cell
  `define S_EXIT1_IR          4'd12 // exit state 1 for IR scan
  `define S_PAUSE_IR          4'd13 // pause state for IR scan
  `define S_EXIT2_IR          4'd14 // exit state 2 for IR scan
  `define S_UPDATE_IR         4'd15 // update state for the IR

  // State Machine signal declarations
  reg [3 : 0] i_tap_state_r;    // TAP controller state signal

  always @(posedge jtag_tck or posedge jtag_trst_a)
  begin : THE_TAP_CONTROLLER_PROC
    //  The Asynchronous Reset
    //
    if (jtag_trst_a == 1'b1)
      i_tap_state_r <= `S_TEST_LOGIC_RESET;

    else
      case (i_tap_state_r)
        //  The Test-Logic-Reset State
        //
        //  The Test Logic Reset state is used to initialize all internal
        //  registers and external signals to inactive contents and logic levels
        //  respectively. This state is the only state steady for when TMS is
        //  HIGH. This means that you can be guaranteed to enter this state by
        //  driving TMS high and applying the minimum of five clock pulse on
        //  TCK. If TMS is zero on the rising edge of TCK the the RUN- TEST/IDLE
        //  state is entered.  evaluate TMS only on TCK
        `S_TEST_LOGIC_RESET :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_RUN_TEST_IDLE;
          else
            i_tap_state_r <= `S_TEST_LOGIC_RESET;

        //  The Run-Test/Idle State
        //
        //  The Run-Test/Idle state is used to place the JTAG module in an idle
        //  state or run an internal or external test. Providing that the
        //  Command register is set to a valid protocol value a transaction is
        //  triggered by entering this state.
        `S_RUN_TEST_IDLE :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_RUN_TEST_IDLE;
          else
            i_tap_state_r <= `S_SELECT_DR_SCAN;

        //  >>>>>>>>>>>>>>>>>>>>> DATA REGISTER STATE STRUCTURE <<<<<<<<<<<<<<<<
        //
        //  The Select-DR-Scan State
        //
        //  The Select-DR-State is used as gateway to access the selected data
        //  register.  This state has no other purpose.
        `S_SELECT_DR_SCAN :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_CAPTURE_DR;
          else
            i_tap_state_r <= `S_SELECT_IR_SCAN;

        //  The Capture-DR State
        //
        //  The Capture-DR state is used to capture the selected data
        //  register(selected by the value present in the Instruction Register)
        //  into the shift chain. The data is captured only when the state
        //  exited.
        `S_CAPTURE_DR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_SHIFT_DR;
          else
            i_tap_state_r <= `S_EXIT1_DR;

        //  The Shift-DR State
        //
        //  The Shift-DR state is a steady state for when TMS is low and is used
        //  to serially load in and out data to and from registers using the TDI
        //  and TDO signals. Data is sampled always on the rising edge of TCK.
        //  The data shifted out is placed on TDO at its falling edge.
        `S_SHIFT_DR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_SHIFT_DR;
          else
            i_tap_state_r <= `S_EXIT1_DR;

        //  The Exit1-DR State
        //
        //  The Exit1-DR state is entered when the selected data register has
        //  been accessed or the shift process must be suspended for number of
        //  TCK clock cycles (assuming a continuing frequency on TCK).
        `S_EXIT1_DR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_PAUSE_DR;
          else
            i_tap_state_r <= `S_UPDATE_DR;

        //  The Pause-DR State
        //
        //  The Pause-DR state is a steady state for when TMS is low and is
        //  entered when data cannot be supplied on TDI or received at TDO
        //  before next rising/falling edge of TCK. This state is general used
        //  for a when TCK is applied as a continuous frequency.
        `S_PAUSE_DR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_PAUSE_DR;
          else
            i_tap_state_r <= `S_EXIT2_DR;

        //  The Exit2-DR State
        //
        //  The Exit2-DR state is entered always from the PAUSE_DR state and can
        //  be used to re-enter the shifting phase or continue on to update the
        //  selected data register.
        `S_EXIT2_DR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_SHIFT_DR;
          else
            i_tap_state_r <= `S_UPDATE_DR;

        //  The Update-DR State
        //
        //  The Update-DR state is used to update the target register with the
        //  shifted in contents. The selected data register is updated on the
        //  falling edge of TCK as this state is entered.
        `S_UPDATE_DR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_RUN_TEST_IDLE;
          else
            i_tap_state_r <= `S_SELECT_DR_SCAN;

        //  >>>>>>>>>>>>>>>>>>>>> INSTRUCTION REGISTER STATE STRUCTURE <<<<<<<<<
        //
        //  The Select-IR-Scan State
        //
        //  The Select-IR-State is used as gateway to access the instruction
        //  register. This state has no other purpose.
        `S_SELECT_IR_SCAN :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_CAPTURE_IR;
          else
            i_tap_state_r <= `S_TEST_LOGIC_RESET;

        //  The Capture-IR State
        //
        //  The Capture-IR state is used to capture the instruction into its own
        //  shift chain.  The data is captured only when the state exited.
        `S_CAPTURE_IR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_SHIFT_IR;
          else
            i_tap_state_r <= `S_EXIT1_IR;

        //  The Shift-IR State
        //
        //  The Shift-IR state is a steady state for when TMS is low and is used
        //  to serially load in and out data to and from the instruction
        //  register using the TDI and TDO signals. Data is sampled always on
        //  the rising edge of TCK. The data shifted out is placed on TDO at its
        //  falling edge.
        `S_SHIFT_IR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_SHIFT_IR;
          else
            i_tap_state_r <= `S_EXIT1_IR;

        //  The Exit1-IR State
        //
        //  The Exit1-IR state is entered when the instruction register has been
        //  accessed or the shift process must be suspended for number of TCK
        //  clock cycles (assuming a continuing frequency on TCK).
        `S_EXIT1_IR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_PAUSE_IR;
          else
            i_tap_state_r <= `S_UPDATE_IR;

        //  The Pause-IR State
        //
        //  The Pause-IR state is a steady state for when TMS is low and is
        //  entered when data cannot be supplied on TDI or received at TDO
        //  before next rising/falling edge of TCK. This state is general used
        //  for a when TCK is applied as a continuous frequency.
        `S_PAUSE_IR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_PAUSE_IR;
          else
            i_tap_state_r <= `S_EXIT2_IR;

        //  The Exit2-IR State
        //
        //  The Exit2-DR state is entered always from the PAUSE_DR state and can
        //  be used to re-enter the shifting phase or continue on to update the
        //  instruction register.
        `S_EXIT2_IR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_SHIFT_IR;
          else
            i_tap_state_r <= `S_UPDATE_IR;

        //  The Update-IR State
        //
        //  The Update-DR state is used to update the instruction register with
        //  the shifted in contents. The instruction register is updated on the
        //  falling edge of TCK when this state is entered.
        `S_UPDATE_IR :
          if (jtag_tms == 1'b0)
            i_tap_state_r <= `S_RUN_TEST_IDLE;
          else
            i_tap_state_r <= `S_SELECT_DR_SCAN;

        default :
          i_tap_state_r <= `S_TEST_LOGIC_RESET;
      endcase
  end

  //  The following logic is used to generate an enable signal that wired
  //  to a tri-state buffer, this enables the TDO output to go high
  //  impedence when a JTAG register is not being accessed.  This signal is
  //  active low enabled, hence the TDO pin should be 'Z' when it is '0'.
  //  In accordance with the JTAG spec, the pin is enabled or disabled on
  //  the falling edge of TCK, which is implemented by inverting jtag_tck
  //  to jtag_tck_muxed in functional mode
  always @(posedge jtag_tck_muxed or posedge jtag_trst_a)
  begin : JTAG_TDO_ZEN_N_PROC
    if (jtag_trst_a == 1'b1)
      jtag_tdo_zen_n <= 1'b0;   //  Disable output on reset

    else
      if (( i_tap_state_r == `S_SHIFT_IR ) || ( i_tap_state_r == `S_SHIFT_DR ))
        jtag_tdo_zen_n <= 1'b1; //  Enable during Shift-DR and Shift-IR
      else
        jtag_tdo_zen_n <= 1'b0; //  Disable otherwise
  end

  //  The following two concurrent statements are used to generate a high
  //  when the update_ir or update_dr state is entered. These signals are
  //  the used as enables into d-type flip flops for updating the selected
  //  data or instruction register on the falling edge of the jtag clock.
  //
  //  combinational logic
  assign update_ir = ( i_tap_state_r == `S_UPDATE_IR );
  assign update_dr = ( i_tap_state_r == `S_UPDATE_DR );

  //  The select_r signal is used to control a mux that selects between the
  //  internal data registers or the instruction register for the TDO output.
  assign select_r = ( i_tap_state_r == `S_CAPTURE_IR ) ||
                    ( i_tap_state_r == `S_SHIFT_IR ) ||
                    ( i_tap_state_r == `S_EXIT1_IR ) ||
                    ( i_tap_state_r == `S_PAUSE_IR ) ||
                    ( i_tap_state_r == `S_EXIT2_IR ) ||
                    ( i_tap_state_r == `S_UPDATE_IR ) ? 1'b1 :
                    ( i_tap_state_r == `S_CAPTURE_DR ) ||
                    ( i_tap_state_r == `S_SHIFT_DR ) ||
                    ( i_tap_state_r == `S_EXIT1_DR ) ||
                    ( i_tap_state_r == `S_PAUSE_DR ) ||
                    ( i_tap_state_r == `S_EXIT2_DR ) ||
                    ( i_tap_state_r == `S_UPDATE_DR ) ? 1'b0 :
                    1'b0;

  //  The following concurrent statements are state control signal that are
  //  driven when the selected state has been entered. These signals are
  //  used to capture data register contents into shift cells, reset
  //  internal state machines, clock the shift cells and initiate
  //  communication transactions.
  //
  //  combinatorial logic
  assign capture_dr           = ( i_tap_state_r == `S_CAPTURE_DR );
  assign capture_ir           = ( i_tap_state_r == `S_CAPTURE_IR );
  assign test_logic_reset     = ( i_tap_state_r == `S_TEST_LOGIC_RESET );
  assign run_test_idle        = ( i_tap_state_r == `S_RUN_TEST_IDLE );
  assign shift_ir             = ( i_tap_state_r == `S_SHIFT_IR );
  assign shift_dr             = ( i_tap_state_r == `S_SHIFT_DR );

  //  These signals are generated one JTAG clock earlier than the
  //  equivalent states
  assign run_test_idle_nxt    = (( i_tap_state_r == `S_TEST_LOGIC_RESET ) ||
                                 ( i_tap_state_r == `S_RUN_TEST_IDLE )    ||
                                 ( i_tap_state_r == `S_UPDATE_DR )        ||
                                 ( i_tap_state_r == `S_UPDATE_IR )) &&
                                ( jtag_tms == 1'b0 );

  assign capture_dr_nxt       = ( i_tap_state_r == `S_SELECT_DR_SCAN ) &&
                                ( jtag_tms == 1'b0 );

  assign update_dr_nxt        = (( i_tap_state_r == `S_EXIT1_DR )        ||
                                 ( i_tap_state_r == `S_EXIT2_DR )) &&
                                ( jtag_tms != 1'b0 );

  assign test_logic_reset_nxt = (( i_tap_state_r == `S_TEST_LOGIC_RESET ) ||
                                 ( i_tap_state_r == `S_SELECT_IR_SCAN )) &&
                                ( jtag_tms != 1'b0 );

  assign select_dr_scan_nxt   = (( i_tap_state_r == `S_RUN_TEST_IDLE )   ||
                                 ( i_tap_state_r == `S_UPDATE_DR )       ||
                                 ( i_tap_state_r == `S_UPDATE_IR )) &&
                                ( jtag_tms != 1'b0 );

endmodule // module tap_controller
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2004-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// The JTAG Debug Port is the module that contains all the internal JTAG
// registers and performs the actual communication between the ARC and
// Refer to the JTAG section in the ARC interface manual for an explanation
// on how to communicate with the complete module.  In this revision, the
// debug port does not contain the address, data, command, or status
// registers.  These physically reside on the other side of a BVCI
// interface, and are read by the debug port during the Capture-DR state
// and written during the Update-DR state. A command is initiated during
// the Run-Test/Idle state by writing a do-command address over the BVCI
// interface, and the registers are reset during the Test-Logic-Reset state
// by writing a reset address.
//
//========================== Inputs to this block ==========================--
//
//  clk_ungated         The core clock, which is never gated
//
//  rst_a               The asynchronous system reset
//
//  debug_address       BVCI debug port inputs
//  debug_be
//  debug_cmd
//  debug_cmdval
//  debug_eop
//  debug_rspack
//  debug_wdata
//
//  noaccess            An illegal access has been attempted, such as
//                      an access to a core register while the ARC is
//                      running.
//
//  hold_host           True while waiting for a load return or other
//                      stall
//
//  h_datar             Returning core or auxiliary read data
//
//  pc_sel_r            Processor-writable bit that can be read by the
//                      host.
//
// en                   The global run bit.
//
// reset_applied_r      This bit in the debug register is set to true when a
//                      a reset happens. The bit is read only from the
//                      processor side and the debugger clears this bit when
//                      it performs a read.
//
//  pcp_ack             Memory channel command acknowledge
//
//  pcp_dlat            Memory channel data ready signal
//
//  pcp_dak             Memory channel data taken signal
//
//  pcp_d_rd            Memory channel read data
//
//  pm_powered_down_r   True when the Power Management Unit has
//                      'powered down' the core.
//
//========================= Output from this block =========================--
//
//  debug_cmdack        BVCI debug port outputs
//  debug_rdata_r
//  debug_reop
//  debug_rspval
//  debug_rerror_r
//
//  h_addr              Core or auxiliary register address
//
//  h_dataw             Core or auxiliary write data
//
//  h_write             Core or auxiliary write command
//
//  h_read              Core or auxiliary read command
//
//  aux_access          Address space selects for non-memory access
//  core_access
//  madi_access         (deprecated)
//
//  halt                (tied off)
//
//  xstep               (tied off)
//
//  pcp_wr_rq           Memory write request
//
//  pcp_rd_rq           Memory read request
//
//  pcp_addr            Memory address
//
//  pcp_brst            Memory request burst size, always one longword
//
//  pcp_mask            Memory request byte enables, always all true
//
//  pcp_d_wr            Memory write data
//
//==========================================================================--
//
module hif2bt(
  clk_ungated,
  rst_a,
  debug_address,
  debug_be,
  debug_cmd,
  debug_cmdval,
  debug_eop,
  debug_rspack,
  debug_wdata,
  noaccess,
  hold_host,
  h_datar,
  pc_sel_r,
  en,
  reset_applied_r,
  pcp_ack,
  pcp_dlat,
  pcp_dak,
  pcp_d_rd,

  debug_cmdack,
  debug_rdata_r,
  debug_reop,
  debug_rspval,
  debug_rerror_r,
  h_write,
  h_read,
  h_addr,
  h_dataw,
  aux_access,
  core_access,
  madi_access,
  halt,
  xstep,
  pcp_wr_rq,
  pcp_rd_rq,
  pcp_addr,
  pcp_brst,
  pcp_mask,
  pcp_d_wr
  );

  `include "arcutil_pkg_defines.v"
  `include "arcutil.v"
  `include "extutil.v"
  `include "ext_msb.v"

  input                   clk_ungated;     //  clock
  input                   rst_a;            //  reset async

  // ARC interface
  //
  output                  h_write;
  output                  h_read;
  output [31 : 0]         h_addr;
  output [31 : 0]         h_dataw;
  input  [31 : 0]         h_datar;
  output                  aux_access;
  output                  core_access;
  output                  madi_access;
  input                   noaccess;
  input                   hold_host;
  output                  halt;
  output                  xstep;

  //  from xaux_regs for debug_port status reg
  //
  input                   pc_sel_r;

  //  from aux_regs for debug_port status reg
  //
  input                   en;
  input                   reset_applied_r;

  //  Arbitrator interface
  //
  output                  pcp_wr_rq;
  output                  pcp_rd_rq;
  output [EXT_A_MSB : 0]  pcp_addr;
  output [7 : 0]          pcp_brst;
  output [3 : 0]          pcp_mask;
  output [31 : 0]         pcp_d_wr;
  input  [31 : 0]         pcp_d_rd;
  input                   pcp_ack;
  input                   pcp_dlat;
  input                   pcp_dak;

  // BVCI target interface
  //
  input  [31 : 0]         debug_address;  //  Byte Address
  input  [3 : 0]          debug_be;       //  Byte enables
  input  [1 : 0]          debug_cmd;      //  Command
  input                   debug_cmdval;   //  Command Valid
  input                   debug_eop;      //  End Of Packet
  input                   debug_rspack;   //  Response ACK
  input  [31 : 0]         debug_wdata;    //  Write Data
  output                  debug_cmdack;   //  Command Ack
  output [31 : 0]         debug_rdata_r;    //  Read Data
  output                  debug_reop;     //  (unused)
  output                  debug_rspval;   //  Rsp Valid
  output                  debug_rerror_r;   //  Rsp error

  wire   [31 : 0]         h_addr;
  wire   [31 : 0]         h_dataw;
  reg                     h_write;
  reg                     h_read;
  wire                    aux_access;
  wire                    core_access;
  wire                    madi_access;
  wire                    halt;
  wire                    xstep;
  reg                     pcp_wr_rq;
  reg                     pcp_rd_rq;
  wire   [EXT_A_MSB : 0]  pcp_addr;
  wire   [7 : 0]          pcp_brst;
  wire   [3 : 0]          pcp_mask;
  wire   [31 : 0]         pcp_d_wr;
  wire                    debug_cmdack;
  reg    [31 : 0]         debug_rdata_r;
  wire                    debug_reop;
  wire                    debug_rspval;
  reg                     debug_rerror_r;

  //  These signals are all to do with the registers. There are the registers
  //  themselves, the signals used to increment the address after an operation,
  //  and the signal, resulting from a write to the status register, that
  //  initiates an operation.
  reg                     do_command_nxt;
  reg                     do_command_r;
  reg                     increment_address_nxt;
  reg                     increment_address_r;
  wire   [31 : 0]         address_increment;
  reg    [31 : 0]         i_data_out_nxt;
  reg    [31 : 0]         i_data_out_r;
  reg    [31 : 0]         i_data_in_nxt;
  reg    [31 : 0]         i_data_in_r;
  reg    [31 : 0]         i_address_nxt;
  reg    [31 : 0]         i_address_r;
  reg    [31 : 0]         debug_rdata_nxt;
  wire   [31 : 0]         debug_rdata_src;
  reg    [3 : 0]          i_command_nxt;
  reg    [3 : 0]          i_command_r;
  reg                     i_rspval_nxt;
  reg                     i_rspval_r;
  reg                     debug_rerror_nxt;

  reg                     fail_nxt;
  reg                     fail;               //  Access failed status
  reg                     stalled;            //  Waiting for memory
  reg                     i_pc_sel_r;         //  from xaux_regs
  reg                     ready_nxt;
  reg                     ready;              //  Ready to access ARC

  reg    [3 : 0]          tsm_fsm_nxt;
  reg    [3 : 0]          tsm_fsm_r;

  // ------------------begin rtl architecture-------------------------------
  // -------------------------------------------------------------------------
  //  drive constant values
  // -------------------------------------------------------------------------
  //
  //  These are registers, so they all respond in a single cycle
  assign debug_cmdack = 1'b1;

  //  These signals are unused and tied off
  assign halt         = 1'b0;
  assign xstep        = 1'b0;

  //  This one is ignored, but always true since we only support
  //  one-cell packets
  assign debug_reop   = 1'b1;

  // -------------------------------------------------------------------------
  //  read/write registers: address, data, command
  //  special register: status
  // -------------------------------------------------------------------------
  always @(debug_cmdval or debug_address or debug_cmd or debug_wdata or
           i_rspval_r or debug_rspack or increment_address_r or i_address_r or
           address_increment or debug_rerror_r or i_data_out_r or i_command_r or
           debug_rdata_r or debug_rdata_src)
  begin : HIF_ASYNC_PROC
    do_command_nxt    = 1'b0; // default values
    debug_rerror_nxt  = debug_rerror_r;
    i_address_nxt   = i_address_r;
    i_data_out_nxt  = i_data_out_r;
    i_command_nxt   = i_command_r;
    i_rspval_nxt    = i_rspval_r;
    debug_rdata_nxt   = debug_rdata_r;

    if (debug_cmdval == 1'b1)
    begin
      if ((debug_address[31 : `ADDR_SIZE] == `BASE_ADDR) &&
          (debug_address[1 : 0] == 2'b00))
      begin
        debug_rerror_nxt          = 1'b0; // default value
        case (debug_cmd)
          `BVCI_CMD_READ :
            case (debug_address[`ADDR_SIZE - 1 : 2])
              `ADDRESS_R_ADDR, `DATA_R_ADDR, `COMMAND_R_ADDR, `STATUS_R_ADDR :
                debug_rdata_nxt   = debug_rdata_src;

              default :
                debug_rerror_nxt  = 1'b1;
            endcase

          `BVCI_CMD_WRITE :
            case (debug_address[`ADDR_SIZE - 1 : 2])
              `ADDRESS_R_ADDR :
                i_address_nxt   = debug_wdata;

              `DATA_R_ADDR :
                i_data_out_nxt  = debug_wdata;

              `COMMAND_R_ADDR :
                i_command_nxt   = debug_wdata[3 : 0];

              `DO_CMD_ADDR :
                do_command_nxt  = 1'b1;

              `RESET_ADDR :
              begin
                i_address_nxt   = { 32 { 1'b0 }};
                i_data_out_nxt  = { 32 { 1'b0 }};
                i_command_nxt   = `CMD_RESET_VALUE;
              end

              default :
                debug_rerror_nxt  = 1'b1;
            endcase

          `BVCI_CMD_NOP :
            ;

          default :
            debug_rerror_nxt      = 1'b1;

        endcase
      end

      else
        debug_rerror_nxt          = 1'b1;

      i_rspval_nxt    = 1'b1;
    end

    //  Handle the generation of debug_rspval
    if ((i_rspval_r == 1'b1) && (debug_rspack == 1'b1))
      i_rspval_nxt    = 1'b0;

    //  Increment the address register if necessary
    if (increment_address_r == 1'b1)
      i_address_nxt   = i_address_r + address_increment;
  end

  always @(posedge clk_ungated or posedge rst_a)
  begin : HIF_SYNC_PROC
    if (rst_a == 1'b1)
    begin
      i_address_r   <= { 32 { 1'b0 }};
      i_data_out_r  <= { 32 { 1'b0 }};
      i_command_r   <= `CMD_RESET_VALUE;
      debug_rdata_r <= { 32 { 1'b0 }};
      i_rspval_r    <= 1'b0;
      debug_rerror_r <= 1'b0;
      do_command_r    <= 1'b0;
      i_pc_sel_r    <= 1'b0;
    end

    else
    begin
      i_address_r   <= i_address_nxt;
      i_data_out_r  <= i_data_out_nxt;
      i_command_r   <= i_command_nxt;
      debug_rdata_r <= debug_rdata_nxt;
      i_rspval_r    <= i_rspval_nxt;
      debug_rerror_r <= debug_rerror_nxt;
      do_command_r    <= do_command_nxt;
      i_pc_sel_r    <= pc_sel_r;
    end
  end

  //  Drive outputs
  assign debug_rdata_src  =
    (debug_address[`ADDR_SIZE - 1 : 2] == `ADDRESS_R_ADDR)  ? i_address_r :
    (debug_address[`ADDR_SIZE - 1 : 2] == `DATA_R_ADDR)     ? i_data_in_r :
    (debug_address[`ADDR_SIZE - 1 : 2] == `COMMAND_R_ADDR)  ? i_command_r :
    (debug_address[`ADDR_SIZE - 1 : 2] == `STATUS_R_ADDR)   ?
      { 
      reset_applied_r,
      en,
      i_pc_sel_r, ready, 
      fail, 
      stalled
      } : { 32 { 1'b0 }};

  assign debug_rspval     = i_rspval_r;

  //  This is the state machine that performs the actual communication with
  //  the ARC and local memory. The state machine is kicked off when a BVCI
  //  write to the status register causes do_command_r to be asserted.
  always @(tsm_fsm_r or do_command_r or fail or ready or i_command_r or 
           pcp_ack or pcp_dlat or pcp_d_rd or pcp_dak or noaccess or
           hold_host or 
           h_datar or i_data_in_r)
  begin : TXN_FSM_ASYNC_PROC
    increment_address_nxt = 1'b0; // default values
    fail_nxt                  = fail;
    ready_nxt                 = ready;
    tsm_fsm_nxt               = tsm_fsm_r;
    i_data_in_nxt             = i_data_in_r;

    case (tsm_fsm_r)
      //  The reset state is used to direct the Transaction State Machine
      //  to the idle state after a system reset.
      `S_RST :
      begin
        ready_nxt             = 1'b1;
        tsm_fsm_nxt           = `S_IDLE;
      end

      //  The `S_WAIT_H state is entered at the end of a transaction. It
      //  handles incrementing of the address register, then goes to the
      //  idle state. It isn't strictly necesary, but there is no real
      //  speed constraint and it makes the code simpler.
      `S_WAIT_H :
      begin
        increment_address_nxt = 1'b1;
        ready_nxt             = 1'b1;
        tsm_fsm_nxt           = `S_IDLE;
      end

      //  The `S_IDLE state is held until do_command_r has been asserted and
      //  there is a valid transaction code in the command register. When
      //  the trigger signal has been asserted and there is a valid
      //  command, the Transaction State Machine enters the starting
      //  state of the requested transaction.
      `S_IDLE :
        if (do_command_r == 1'b1)
        begin
          //  Clear out the fail bit now that a new mode has started
          fail_nxt  = 1'b0;
          ready_nxt = 1'b0; // We're starting a transaction

          //  Determine the transaction protocol to run
          case (i_command_r)
            `CMD_RD_MEM :
              tsm_fsm_nxt = `S_MR_RQ; //  do mem read request

            `CMD_WR_MEM :
              tsm_fsm_nxt = `S_MW_RQ; //  do mem write request

            `CMD_RD_AUX :
              tsm_fsm_nxt = `S_ARC_READ; //  do arc aux space read request

            `CMD_RD_MADI :
              tsm_fsm_nxt = `S_ARC_READ; //  do arc madi space read request

            `CMD_RD_CORE :
              tsm_fsm_nxt = `S_ARC_READ; //  do arc core register read request

            `CMD_WR_AUX :
              tsm_fsm_nxt = `S_ARC_WRITE; //  do arc aux space write request

            `CMD_WR_MADI :
              tsm_fsm_nxt = `S_ARC_WRITE; //  do arc madi space write request

            `CMD_WR_CORE :
              tsm_fsm_nxt = `S_ARC_WRITE; //  do arc core register write request

            `CMD_RESET_VALUE :
            begin
              tsm_fsm_nxt = `S_IDLE; //  reset value is a nop
              ready_nxt   = 1'b1;
            end

            default :
            begin
              tsm_fsm_nxt = `S_IDLE; //  everything else is an error
              fail_nxt    = 1'b1;
              ready_nxt   = 1'b1;
            end
          endcase
        end

      //  Wait for a memory read acknowledge
      //
      //  In the `S_MR_RQ state the Transaction State Machine waits until
      //  the memory has acknowledged the request. When the request has
      //  been acknowledged the state machine moves onto the `S_MR_WAIT
      //  state. Otherwise the state is held.
      `S_MR_RQ :
        if (pcp_ack == 1'b1)
          tsm_fsm_nxt = `S_MR_WAIT;

      //  Latch the data present on the read bus
      //
      //  In the `S_MR_WAIT state, the Transaction State Machine waits for
      //  the latch permission signal pcp_d_rd to be asserted before
      //  latching the data present on the read bus into the data register.
      //  latching takes place on the next rising edge after the pcp_dlat
      //  signal has been asserted. The state machine then moves onto the
      //  `S_WAIT_H state.
      `S_MR_WAIT :
           begin
             if (pcp_dlat == 1'b 1)
              begin
                i_data_in_nxt = pcp_d_rd;
                tsm_fsm_nxt   = `S_WAIT_H;
              end
           end

      //  Wait for a memory write acknowledge
      //
      //  In the `S_MW_RQ state the Transaction State Machine waits until
      //  the memory has acknowledged the write request. When the request
      //  has been acknowledged the state machine then state checks the
      //  state of the pcp_dak signal. If the signal has been asserted the
      //  state machine goes to the S_WAIT state, if it has not been
      //  asserted then the state machine waits for the data to be taken by
      //  entering the `S_MW_WAIT  state.
      `S_MW_RQ :
          if (pcp_ack == 1'b 1)
                 //
                 //  we can accept ACK and DAK on the same cycle
                 //
                begin
                  if (pcp_dak == 1'b1) tsm_fsm_nxt = `S_WAIT_H;
                  else                 tsm_fsm_nxt = `S_MW_WAIT;
                end

      //  Wait until memory accept the data
      //
      //  The `S_MW_RQ state is entered from `S_MW_RQ when the memory has
      //  not yet accepted the data present on the write bus. The state is
      //  held until the pcp_dak signal has been asserted.
      `S_MW_WAIT :
            begin
              if (pcp_dak == 1'b 1) tsm_fsm_nxt = `S_WAIT_H;
            end

      //  ARC read request evaluation
      //
      //  The `S_ARC_READ state evaluates a read request to the ARC core.
      //  If the ARC rejects the read request (i.e. if it is running) the
      //  state asserts the fail signal and then enters the `S_WAIT_H
      //  state. If the ARC requests the access to stall, then the state
      //  machine enters the `S_AR_STALL state which is used for stalling
      //  reads. If all is fine the `S_ARC_READ2 state is entered which
      //  captures the data present on the read bus.
      `S_ARC_READ :
        if (noaccess == 1'b1)
        begin
          tsm_fsm_nxt = `S_WAIT_H;
          fail_nxt    = 1'b1;
        end

        else if (hold_host == 1'b1)
          tsm_fsm_nxt = `S_AR_STALL;

        else
          tsm_fsm_nxt = `S_ARC_READ2;

      //  Latch the incoming data
      //
      //  The `S_ARC_READ2 state is used to grab data coming back from the
      //  ARC at the end of a read transaction. The `S_WAIT_H state is
      //  entered on the following rising edge of clk_ungated.
      `S_ARC_READ2 :
      begin
        i_data_in_nxt = h_datar;   //  latch the data on the host read
        tsm_fsm_nxt   = `S_WAIT_H; //  data bus
      end

      //  ARC read stall state
      //
      //  The `S_AR_STALL state is used to halt the Transaction State
      //  Machine when the ARC asserts a hold host. When the host host has
      //  finally deasserted the hold host signal the `S_ARC_READ2 state is
      //  entered to latch the data present on the read data bus.
      `S_AR_STALL :
        if (hold_host == 1'b0)
          tsm_fsm_nxt = `S_ARC_READ2;

      //  ARC write request evaluation
      //
      //  The ARC read request state evaluates a write request to the ARC
      //  core. If the ARC rejects the write request (i.e. if it is
      //  running) the state asserts the fail signal and then enters the
      //  `S_WAIT_H state. If the ARC requests the access to stall, then the
      //  `S_AR_STALL state which is used for stalled reads. If all is fine
      //  the `S_WAIT_H state is entered to end the write transaction.
      `S_ARC_WRITE :
        if (noaccess == 1'b1)
        begin
          tsm_fsm_nxt = `S_WAIT_H;
          fail_nxt    = 1'b1;
        end

        else if (hold_host == 1'b0)
          tsm_fsm_nxt = `S_WAIT_H;

        else
          tsm_fsm_nxt = `S_AW_STALL;

      //  ARC write stall state
      //
      //  The read stall state is used to halt the Transaction State
      //  Machine when the ARC asserts a hold host. When the host host is
      //  finally deasserted the `S_ARC_READ2 state is entered to latch the
      //  data present on the read data bus.
      `S_AW_STALL :
        if (hold_host == 1'b0)
          tsm_fsm_nxt = `S_WAIT_H;

      //  reset to the idle state if we are is an undefined state
      default :
      begin
        tsm_fsm_nxt   = `S_IDLE;
        ready_nxt     = 1'b1;
      end
    endcase
  end

  always @(posedge clk_ungated or posedge rst_a)
  begin : TXN_FSM_SYNC_PROC
    if (rst_a == 1'b1)
    begin
      //  upon a rst_a signal reset the transaction state machine.
      tsm_fsm_r             <= `S_RST;
      fail                <= 1'b0; //  clear out the failed status
      ready               <= 1'b1; //  We can accept a command
      i_data_in_r         <= { 32 { 1'b0 }};
      increment_address_r <= 1'b0;
    end

    else
    begin
      tsm_fsm_r             <= tsm_fsm_nxt;
      fail                <= fail_nxt;
      ready               <= ready_nxt;
      i_data_in_r         <= i_data_in_nxt;
      increment_address_r <= increment_address_nxt;
    end
  end

  //  Host interface state machine
  //
  //  Asynchronous part
  //  This part is used to generate the correct control signals for an upcoming
  //  transaction, as well as the stalled status bit.
  always @(tsm_fsm_r)
  begin : ARC_FSM_ASYNC_PROC
    h_write   = 1'b0;
    h_read    = 1'b0;
    pcp_wr_rq = 1'b0;
    pcp_rd_rq = 1'b0;
    stalled   = 1'b0;

    case (tsm_fsm_r)
      `S_MR_RQ :
        pcp_rd_rq = 1'b1;

      `S_MW_RQ :
        pcp_wr_rq = 1'b1;

      `S_ARC_READ :
        h_read    = 1'b1;

      `S_AR_STALL :
      begin
        h_read    = 1'b1;
        stalled   = 1'b1;
      end

      `S_ARC_WRITE :
        h_write   = 1'b1;

      `S_AW_STALL :
      begin
        h_write   = 1'b1;
        stalled   = 1'b1;
      end

      default :
        ;

    endcase
  end

  //  This concurrent statement produces the amount by which the address
  //  register is incremented after an operation.
  //
  assign address_increment =
    ((i_command_r == `CMD_RD_MEM)||(i_command_r == `CMD_WR_MEM)) ? `MEM_OFFSET :
                                                               `REG_OFFSET;

  // Output drives of signals
  //
  // ARC and memory address will always be from the address register
  assign h_addr   = i_address_r;                // 32 bits
  assign pcp_addr = i_address_r[EXT_A_MSB : 0]; // EXT_A_WIDTH bits

  //  Burst and mask are fixed.
  //
  assign pcp_brst = 8'b00000011;
  assign pcp_mask = 4'b1111;

  //  ARC and memory write data will always be from the 32-bit register
  //
  assign h_dataw  = i_data_out_r;
  assign pcp_d_wr = i_data_out_r;

  //  Select which type of host access is going to happen.
  //
  assign aux_access  = (i_command_r[1 : 0] == `CMD_AUX);
  assign core_access = (i_command_r[1 : 0] == `CMD_CORE);
  assign madi_access = ((i_command_r == `CMD_WR_MADI) ||
                        (i_command_r == `CMD_RD_MADI));
                       

endmodule // module hif2bt
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2004-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// JTAG communications interface.
//  
// This is the overall structural code for the JTAG port. Note that it contains
// two clock domains: the JTAG clock domain and the ungated core clock
// domain.
// The tap_controller and debug_port modules run off of the JTAG clock, and the
// sys_clk_sync and hif2bt modules run off of the core clock.  The
// synchronization philosophy is that all the signals generated by the BVCI
// initiator are generated on JTAG clock. Then a request is made to
// sys_clk_sync, which synchronizes the request to the core clock and
// generates cmdval. All the other signals are thus guaranteed to be stable long
// before they can be latched by the BVCI target. Once this request is
// generated, the logic on the JTAG clock *assumes* that the transaction will
// complete, and in the case of a read the data will be returned, within
// a single cycle of the JTAG clock.  Since the synchronization of the request
// takes two core clocks, the BVCI transaction takes one core clock, and the
// setup of the returning data into the receiving flip-flops takes one core
// clock, the period of the JTAG clock must be at least two times that of the
// core clock.  Note that if a fabric is interposed between the BVCI initiator
// and target, the latency of that fabric must be added to this time.  JTAG
// communications interface.
//
// Connection to a Bounary Scan Register (scan chain) will involve decoding
// eight signals called:
//
//          jtag_bsr_tdo,
//          jtag_extest_mode,
//          jtag_sample_mode,
//          capturedr_en,
//          shiftdr_en,
//          updatedr_en,
//          jtag_tdi.
//
// The jtag_tdi is connected to the first cell in the Boundary Scan Register.
// The jtag_bsr_tdo pin is wired to the final cell of the Boundary Scan
// Register. The jtag_extest_mode and jtag_sample_mode signals are used as
// master enables. This allow the Boundary Scan Register to be activated
// whenever the EXTEST or SAMPLE  instruction is selected.
// The shiftdr_en, capturedr_en and updatedr_en enable signals are combined
// with decoding logic allowing the shift and latch elements of the Boundary
// Scan Register to be controlled in the Shift-DR, Capture-DR and Update-DR
// TAP states.
//
//--------------------------------------------------------------------

module jtag_port(clk_ungated,
                 jtag_tck,
                 jtag_trst_a,
		 rst_a,
                 test_mode,
                 en,
                 reset_applied_r,
                 h_datar,
                 noaccess,
                 hold_host,
                 pcp_d_rd,
                 pcp_ack,
                 pcp_dlat,
                 pcp_dak,
                 pc_sel_r,
                 jtag_tdi,
                 jtag_tms,
                 jtag_bsr_tdo,

                 jtag_busy,
                 h_addr,
                 h_dataw,
                 h_write,
                 h_read,
                 aux_access,
                 core_access,
                 madi_access,
                 halt,
                 xstep,
                 pcp_wr_rq,
                 pcp_rd_rq,
                 pcp_addr,
                 pcp_brst,
                 pcp_mask,
                 pcp_d_wr,
                 jtag_tdo,
                 jtag_tdo_zen_n,
                 jtag_extest_mode,
                 jtag_sample_mode,
                 updatedr_en,
                 capturedr_en,
                 shiftdr_en);

  `include "arcutil_pkg_defines.v"
  `include "arcutil.v"
  `include "extutil.v"
  `include "ext_msb.v"

  input           clk_ungated;
  input           jtag_tck;
  input           jtag_trst_a;
  input   	  rst_a;
  input           test_mode;
  input           en;
  input           reset_applied_r;
  input  [31 : 0] h_datar;
  input           noaccess;
  input           hold_host;
  input  [31 : 0] pcp_d_rd;
  input           pcp_ack;
  input           pcp_dlat;
  input           pcp_dak;
  input           pc_sel_r;
  input           jtag_tdi;
  input           jtag_tms;
  input           jtag_bsr_tdo;

  output          jtag_busy;
  output [31 : 0] h_addr;
  output [31 : 0] h_dataw;
  output          h_write;
  output          h_read;
  output          aux_access;
  output          core_access;
  output          madi_access;
  output          halt;
  output          xstep;
  output          pcp_wr_rq;
  output          pcp_rd_rq;
  output [EXT_A_MSB : 0] pcp_addr;
  output [7 : 0]  pcp_brst;
  output [3 : 0]  pcp_mask;
  output [31 : 0] pcp_d_wr;
  output          jtag_tdo;
  output          jtag_tdo_zen_n;
  output          jtag_extest_mode;
  output          jtag_sample_mode;
  output          updatedr_en;
  output          capturedr_en;
  output          shiftdr_en;

  wire jtag_busy;
  wire [31 : 0] h_addr;
  wire [31 : 0] h_dataw;
  wire h_write;
  wire h_read;
  wire aux_access;
  wire core_access;
  wire madi_access;
  wire halt;
  wire xstep;
  wire pcp_wr_rq;
  wire pcp_rd_rq;
  wire [EXT_A_MSB : 0] pcp_addr;
  wire [7 : 0] pcp_brst;
  wire [3 : 0] pcp_mask;
  wire [31 : 0] pcp_d_wr;
  wire jtag_tdo;
  wire jtag_tdo_zen_n;
  wire jtag_extest_mode;
  wire jtag_sample_mode;
  wire updatedr_en;
  wire capturedr_en;
  wire shiftdr_en;

  wire i_test_logic_reset;
  wire i_run_test_idle;
  wire i_shift_ir;
  wire i_update_ir;
  wire i_shift_dr;
  wire i_capture_dr;
  wire i_capture_ir;
  wire i_update_dr;
  wire i_select_r;
  wire i_test_logic_reset_nxt;
  wire i_run_test_idle_nxt;
  wire i_select_dr_scan_nxt;
  wire i_capture_dr_nxt;
  wire i_update_dr_nxt;

  wire i_do_bvci_cycle;
  wire [`ADDR_SIZE - 1 : 2] i_bvci_addr;
  wire [1 : 0] i_bvci_cmd;
  wire [31 : 0] i_debug_address;
  wire [3 : 0] i_debug_be;
  wire [1 : 0] i_debug_cmd;
  wire i_debug_cmdval;
  wire i_debug_eop;
  wire i_debug_rspack;
  wire [31 : 0] i_debug_wdata;
  wire i_debug_cmdack;
  wire [31 : 0] i_debug_rdata;
  wire i_debug_reop;
  wire i_debug_rspval;
  wire i_debug_rerror;

  wire jtag_tck_muxed;

`ifndef IS_ARCv1_TB

  // Invert jtag_tck in functional mode to be able to use posedge registers,
  // for test mode all registers are clocked on same edge
// leda NTL_CLK07 off
  assign jtag_tck_muxed =  test_mode  ? jtag_tck : ~jtag_tck ;
// leda NTL_CLK07 on

  debug_port
    u_debug_port(.jtag_trst_a(jtag_trst_a),
                 .debug_rdata_r(i_debug_rdata),
                 .jtag_tck(jtag_tck),
                 .jtag_tck_muxed(jtag_tck_muxed),
                 .jtag_tdi(jtag_tdi),
                 .jtag_bsr_tdo(jtag_bsr_tdo),
                 .test_logic_reset(i_test_logic_reset),
                 .run_test_idle(i_run_test_idle),
                 .shift_ir(i_shift_ir),
                 .update_ir(i_update_ir),
                 .shift_dr(i_shift_dr),
                 .capture_dr(i_capture_dr),
                 .capture_ir(i_capture_ir),
                 .select_r(i_select_r),
                 .test_logic_reset_nxt(i_test_logic_reset_nxt),
                 .run_test_idle_nxt(i_run_test_idle_nxt),
                 .select_dr_scan_nxt(i_select_dr_scan_nxt),
                 .capture_dr_nxt(i_capture_dr_nxt),
                 .update_dr_nxt(i_update_dr_nxt),

                 .bvci_addr_r(i_bvci_addr),
                 .debug_be(i_debug_be),
                 .bvci_cmd_r(i_bvci_cmd),
                 .debug_rspack(i_debug_rspack),
                 .debug_eop(i_debug_eop),
                 .debug_wdata(i_debug_wdata),
                 .do_bvci_cycle(i_do_bvci_cycle),
                 .arca_busy(jtag_busy),
                 .jtag_tdo_r(jtag_tdo),
                 .jtag_extest_mode(jtag_extest_mode),
                 .jtag_sample_mode(jtag_sample_mode));

  sys_clk_sync
    u_sys_clk_sync(.clk_ungated(clk_ungated),
                   .rst_a(rst_a),
                   .test_mode(test_mode),
                   .do_bvci_cycle(i_do_bvci_cycle),
                   .bvci_addr_r(i_bvci_addr),
                   .bvci_cmd_r(i_bvci_cmd),

                   .debug_address(i_debug_address),
                   .debug_cmd(i_debug_cmd),
                   .debug_cmdval(i_debug_cmdval));

  tap_controller
    u_tap_controller(.jtag_tck(jtag_tck),
                     .jtag_tck_muxed(jtag_tck_muxed),
                     .jtag_trst_a(jtag_trst_a),
                     .jtag_tms(jtag_tms),

                     .test_logic_reset(i_test_logic_reset),
                     .run_test_idle(i_run_test_idle),
                     .shift_ir(i_shift_ir),
                     .update_ir(i_update_ir),
                     .shift_dr(i_shift_dr),
                     .capture_dr(i_capture_dr),
                     .capture_ir(i_capture_ir),
                     .update_dr(i_update_dr),
                     .jtag_tdo_zen_n(jtag_tdo_zen_n),
                     .select_r(i_select_r),
                     .test_logic_reset_nxt(i_test_logic_reset_nxt),
                     .run_test_idle_nxt(i_run_test_idle_nxt),
                     .select_dr_scan_nxt(i_select_dr_scan_nxt),
                     .capture_dr_nxt(i_capture_dr_nxt),
                     .update_dr_nxt(i_update_dr_nxt));
	     
`endif

  hif2bt
    u_hif2bt(.clk_ungated(clk_ungated),
	     .rst_a(rst_a),
             .noaccess(noaccess),
             .hold_host(hold_host),
             .h_datar(h_datar),
             .pc_sel_r(pc_sel_r),
             .en(en),
             .reset_applied_r(reset_applied_r),

             .h_addr(h_addr),
             .h_dataw(h_dataw),
             .h_write(h_write),
             .h_read(h_read),
             .aux_access(aux_access),
             .core_access(core_access),
             .madi_access(madi_access),
             .halt(halt),
             .xstep(xstep),

             .debug_address(i_debug_address),
             .debug_be(i_debug_be),
             .debug_cmd(i_debug_cmd),
             .debug_cmdval(i_debug_cmdval),
             .debug_eop(i_debug_eop),
             .debug_rspack(i_debug_rspack),
             .debug_wdata(i_debug_wdata),
             .pcp_ack(pcp_ack),
             .pcp_dlat(pcp_dlat),
             .pcp_dak(pcp_dak),
             .pcp_d_rd(pcp_d_rd),

             .debug_cmdack(i_debug_cmdack),
             .debug_rdata_r(i_debug_rdata),
             .debug_reop(i_debug_reop),
             .debug_rspval(i_debug_rspval),
             .debug_rerror_r(i_debug_rerror),
             .pcp_wr_rq(pcp_wr_rq),
             .pcp_rd_rq(pcp_rd_rq),
             .pcp_addr(pcp_addr),
             .pcp_brst(pcp_brst),
             .pcp_mask(pcp_mask),
             .pcp_d_wr(pcp_d_wr));

  //  output drives
  assign shiftdr_en   = i_shift_dr;
  assign updatedr_en  = i_update_dr;
  assign capturedr_en = i_capture_dr;

endmodule // module jtag_port
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2004-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
module ap_compare (
    clk_debug,
    en_debug_r, 
    rst_a, 
    p2_currentpc_r, 
    kill_p2_a,
    p2_iw_r,        
    mc_addr, 
    dwr, 
    drd, 
    aux_addr, 
    aux_dataw, 
    aux_datar, 
    ap_param0, 
    ap_param1, 
    en,
    p2iv, 
    mload, 
    mstore, 
    ldvalid, 
    aux_read_core_a, 
    aux_write_core_a, 
    ap_param0_read, 
    ap_param0_write, 
    ap_param1_read, 
    ap_param1_write, 
    ap_control_r, 
    ap_value_r, 
    ap_mask_r, 
    p2b_jmp_holdup_a,       
    ap_hit_a, 
    ap_hit_value_a);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"

   // Global system signals 
   //
   // System clock
   input                        clk_debug;
   
   // enable Debug
   input                        en_debug_r;
   
   // System reset
   input                        rst_a;
   
   // Actionpoint targets
   // architectural PC
   // pre-aligner instruction word
   input    [PC_MSB:0]          p2_currentpc_r;
   
   // core control signals
   input                        kill_p2_a;
   
   // jmp stall in stage 2b
   input                        p2b_jmp_holdup_a;

   input    [INSTR_UBND:0]      p2_iw_r; 
   // mem access addr
   input    [DATAWORD_MSB:0]    mc_addr; 
   // mem access write data
   input    [DATAWORD_MSB:0]    dwr; 
   // mem access read data
   input    [DATAWORD_MSB:0]    drd; 
   // aux access addr
   input    [DATAWORD_MSB:0]    aux_addr; 
   // aux access write data
   input    [DATAWORD_MSB:0]    aux_dataw; 
   // aux access read data
   input    [DATAWORD_MSB:0]    aux_datar; 
   // external parameter 0
   input    [DATAWORD_MSB:0]    ap_param0; 
   // external parameter 1
   input    [DATAWORD_MSB:0]    ap_param1; 
   // Actionpoint qualifiers
   //
   // global qualifier
   input                        en;
   // for p2_currentpc_r
   input                        p2iv; 
   // for mc_addr
   input                        mload; 
   // for mc_addr, dwr
   input                        mstore; 
   // for drd
   input                        ldvalid; 
   // for aux_addr, aux_datar
   input                        aux_read_core_a; 
   // for aux_addr, aux_dataw
   input                        aux_write_core_a; 
   // for ap_param0
   input                        ap_param0_read; 
   // for ap_param0
   input                        ap_param0_write; 
   // for ap_param1
   input                        ap_param1_read; 
   // for ap_param1
   input                        ap_param1_write; 
   // Control bits for this actionpoint
   input    [AP_AC_SIZE-1:0]    ap_control_r; 
   // Compare bits for this actionpoint
   input    [31:0]              ap_value_r; 
   // Mask bits for this actionpoint
   input    [31:0]              ap_mask_r; 
   
   // Indicates an actionpoint hit
   output                       ap_hit_a; 
   // Indicates what value caused hit
   output   [31:0]              ap_hit_value_a; 

   wire                         ap_hit_a;
   wire     [31:0]              ap_hit_value_a;

   // Main mux selector and actions from control register
   wire     [2:0]               i_target_sel_a; 
   wire                         i_read_check_a;
   wire                         i_write_check_a;
   wire                         i_invert_range_a;
   wire                         i_ld_ret_sr_en_a;
   
   // The output of the main mux
   reg      [31:0]              i_target_a; 
   // The qualifier for the selected target
   reg                          i_target_qual_a; 
   //
   // Signals to decouple aux targets by one cycle to
   // prevent timing loops
   reg      [31:0]              i_aux_target_nxt;
   reg                          i_aux_target_qual_nxt;
   reg      [31:0]              i_aux_target_r;
   reg                          i_aux_target_qual_r;

   reg      [31:0]              i_ldst_target_nxt;
   reg                          i_ldst_target_qual_nxt;   
   reg      [31:0]              i_ldst_target_r;
   reg                          i_ldst_target_qual_r;

   assign i_target_sel_a      = ap_control_r[2:0] ;
   assign i_write_check_a     = ap_control_r[4] ;
   assign i_read_check_a      = ap_control_r[5] ;
   assign i_invert_range_a    = ap_control_r[6];

   assign i_ld_ret_sr_en_a    = (i_target_sel_a == 3'b011 &
                                 i_read_check_a == 1'b1) 
//                 |
//                 i_aux_target_qual_r == 1'b1                                 
                                 ? 1'b1: 1'b0;
                                                
// The main mux that selects and qualifies the target
   always @(i_target_sel_a or p2_iw_r or p2_currentpc_r or p2iv or mc_addr or 
            mload or i_read_check_a or mstore or i_write_check_a or dwr or drd or 
            aux_addr or aux_read_core_a or aux_write_core_a or aux_dataw or kill_p2_a or 
            aux_datar or ap_param0 or ap_param0_read or ap_param0_write or 
            ap_param1 or ap_param1_read or ap_param1_write or ldvalid or  p2b_jmp_holdup_a or 
            i_aux_target_qual_r or i_aux_target_r or i_ldst_target_r or i_ldst_target_qual_r)
   begin : sel_PROC
    // Assign the defaults for the aux delay registers but not
    // in the min_features case because we are only monitoring
    // aux_addr which doesn't case a timing loop
    i_aux_target_nxt = 32'h00000000;
    i_aux_target_qual_nxt = 1'b0;

    i_ldst_target_nxt = 32'b00000000;
    i_ldst_target_qual_nxt = 1'b0;
      
      // select the target that is to be used in the comparison
      // not quite a simple mux because checking for read or write implies
      // different buses when talking about data
      i_target_a = p2_currentpc_r;
      i_target_qual_a = 1'b0;
      case (i_target_sel_a)
         3'b000 :
                  begin
                     // ifetch address
                     i_target_a = p2_currentpc_r ; 
                     i_target_qual_a = p2iv & i_read_check_a & ~kill_p2_a & ~p2b_jmp_holdup_a; 
                  end
//         3'b001 :
//                  begin
//                     // ifetch data (instruction)
//                     i_target_a = p2_iw_r ; 
//                     i_target_qual_a = p2iv & i_read_check_a & ~kill_p2_a & ~p2b_jmp_holdup_a; 
//                  end
         3'b010 :
                  begin
                     // LD/ST address
                     i_ldst_target_nxt = mc_addr; 
                     i_ldst_target_qual_nxt = (mload & i_read_check_a) | (mstore & i_write_check_a) ; 
                  end
//         3'b011 :
//                  begin
//                     // LD/ST data
//                     // when both read and write selected for data, 
//                     //write has priority
//                     if ((i_write_check_a == 1'b1) & mstore)
//                        i_ldst_target_nxt = dwr ;
//                     else
//                        i_ldst_target_nxt = drd ;
//                     i_ldst_target_qual_nxt = (ldvalid & i_read_check_a) |
//                                              (mstore & i_write_check_a) ; 
//                  end
         3'b100 :
                  begin
                     // Aux reg address
                     i_aux_target_nxt = aux_addr ; 
                     i_aux_target_qual_nxt = (aux_read_core_a & i_read_check_a)| 
                     (aux_write_core_a & i_write_check_a) ; 
                  end
//         3'b101 :
//                  begin
//                     // Aux reg data
//                     // when both read and write selected for data, 
//                     // write has priority
//                     if ((i_write_check_a == 1'b1) & aux_write_core_a)
//                        i_aux_target_nxt = aux_dataw ;
//                     else
//                        i_aux_target_nxt = aux_datar ;
//                        i_aux_target_qual_nxt = (aux_write_core_a & i_write_check_a) |
//                                                (aux_read_core_a & i_read_check_a);
//                  end
//         3'b110 :
//                  begin
//                     // Extern param 0
//                     i_target_a = ap_param0 ; 
//                     i_target_qual_a = (ap_param0_read & i_read_check_a) | 
//                     (ap_param0_write & i_write_check_a) ; 
//                  end
         default :
                                  begin
//                     // Extern param 1
//                     i_target_a = ap_param1 ; 
//                     i_target_qual_a = (ap_param1_read & i_read_check_a) | 
//                     (ap_param1_write & i_write_check_a) ;    
                                  end
      endcase 


      // Aux stuff has to be delayed by one cycle to avoid timing loops
      // (because an actionpoint hit modifies the H flag in DEBUG which feeds
      // through to aux_datar). If there was an aux hit last cycle then use that
      // target value.

      if (i_aux_target_qual_r == 1'b1)
      begin
         i_target_a = i_aux_target_r;
         i_target_qual_a = 1'b1;
      end
      else if (i_ldst_target_qual_r == 1'b1)
      begin
         i_target_a = i_ldst_target_r;
         i_target_qual_a = 1'b1;
      end      
      
   end 

      always @(posedge clk_debug or posedge rst_a)
      begin : ap_ldst_sync_PROC
              if (rst_a == 1'b1)
              begin
                  i_ldst_target_r <= {AP_AMV_SIZE{1'b0}};
                  i_ldst_target_qual_r <= 1'b0;
              end
              else
              begin
                  i_ldst_target_r <= i_ldst_target_nxt;
                  i_ldst_target_qual_r <= i_ldst_target_qual_nxt;
              end
      end
		   
      always @(posedge clk_debug or posedge rst_a)
      begin : ap_aux_sync_PROC
                if (rst_a == 1'b1)
                begin
                    i_aux_target_r <= {AP_AMV_SIZE{1'b0}};
                    i_aux_target_qual_r <= 1'b0;
                end
                else
                begin
                    i_aux_target_r <= i_aux_target_nxt;
                    i_aux_target_qual_r <= i_aux_target_qual_nxt;
                end
      end

   // combine hit signals
   assign ap_hit_a = (en | i_ld_ret_sr_en_a | (~i_target_sel_a[2] & ~i_target_sel_a[1])) & en_debug_r &
                       (i_target_qual_a & (i_invert_range_a ^ (&(~((i_target_a | ap_mask_r) ^ (ap_value_r | ap_mask_r)))))) ;
                       
   assign ap_hit_value_a = i_target_a;

                         
endmodule
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2004-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
module actionpoints (
   clk_ungated,
   clk_debug,
   rst_a,
   en,
   en1,
   en2,   
   ivic,
   currentpc_r,
   mc_addr,
   dwr,
   drd,
   aux_addr,
   aux_dataw,
   h_addr,
   h_dataw,  
   aux_datar,
   ap_param0,
   ap_param1,
   kill_p2_a,
   p2b_iv,
   p2_iw_r,
   actionpt_pc_brk_a,
   p2_brcc_instr_a,
   p3_brcc_instr_a,
   p2b_jmp_holdup_a,
   p2_ap_stall_a,
   p2iv,
   mload,
   mstore,
   ldvalid,
   h_write,      
   aux_read,
   aux_write,
   ap_param0_read,
   ap_param0_write,
   ap_param1_read,
   ap_param1_write,
   aux_access,
   actionhalt,
   ap_ahv0,
   ap_ahv1,
   ap_ahv2,
   ap_ahv3,
   ap_ahv4,
   ap_ahv5,
   ap_ahv6,
   ap_ahv7,
   ap_ahc0,
   ap_ahc1,
   ap_ahc2,
   ap_ahc3,
   ap_ahc4,
   ap_ahc5,
   ap_ahc6,
   ap_ahc7,
   ap_ahm0,
   ap_ahm1,
   ap_ahm2,
   ap_ahm3,
   ap_ahm4,
   ap_ahm5,
   ap_ahm6,
   ap_ahm7,
   actionpt_status_r,
   actionpt_brk_a,
   actionpt_swi_a,
   en_debug_r
   );

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"

// Global clock and reset signals
input                       clk_ungated;         // ungated core clock
input                       clk_debug;           // debug clock
input                       rst_a;               // master reset

input                       p2b_iv;
input   [INSTR_UBND:0]      p2_iw_r;
input                       kill_p2_a;
input                       en1;
input                       en2;
input                       p2_brcc_instr_a;
input                       p3_brcc_instr_a;
input                       p2b_jmp_holdup_a;
input                       ivic;

// Global run signal
input                       en;                 // global run

// Actionpoint data sources
input   [PC_MSB:0]          currentpc_r;        // architectural PC
input   [DATAWORD_MSB:0]    mc_addr;            // mem access addr
input   [DATAWORD_MSB:0]    dwr;                // mem access write data
input   [DATAWORD_MSB:0]    drd;                // mem access read data
input   [DATAWORD_MSB:0]    aux_addr;           // aux access addr
input   [DATAWORD_MSB:0]    aux_dataw;          // aux access write data
input   [DATAWORD_MSB:0]    h_addr;             // aux access addr
input   [DATAWORD_MSB:0]    h_dataw;            // aux access write data
input   [DATAWORD_MSB:0]    aux_datar;          // aux access read data
input   [DATAWORD_MSB:0]    ap_param0;          // external parameter 0
input   [DATAWORD_MSB:0]    ap_param1;          // external parameter 1

// Actionpoint data source qualifiers
input                       p2iv;               // for currentpc_r
input                       mload;              // for mc_addr
input                       mstore;             // for mc_addr, dwr
input                       ldvalid;            // for drd
input                       aux_read;           // for aux_addr, aux_datar
input                       h_write;            // for host write
input                       aux_write;          // for aux_addr, aux_dataw
input                       ap_param0_read;     // for ap_param0
input                       ap_param0_write;    // for ap_param0
input                       ap_param1_read;     // for ap_param1
input                       ap_param1_write;    // for ap_param1

// Indicates a host access to auxiliary registers
input                       aux_access;
// Indicators from flags
input                       actionhalt;

// Actionpoint outputs
output   [31:0]             ap_ahv0;            // actionpoint 0 value
output   [31:0]             ap_ahv1;            // actionpoint 1 value

output   [31:0]             ap_ahv2;            // actionpoint 2 value
output   [31:0]             ap_ahv3;            // actionpoint 3 value
output   [31:0]             ap_ahv4;            // actionpoint 4 value
output   [31:0]             ap_ahv5;            // actionpoint 5 value
output   [31:0]             ap_ahv6;            // actionpoint 6 value
output   [31:0]             ap_ahv7;            // actionpoint 7 value

output   [31:0]             ap_ahc0;            // actionpoint 0 control
output   [31:0]             ap_ahc1;            // actionpoint 1 control

output   [31:0]             ap_ahc2;            // actionpoint 2 control
output   [31:0]             ap_ahc3;            // actionpoint 3 control
output   [31:0]             ap_ahc4;            // actionpoint 4 control
output   [31:0]             ap_ahc5;            // actionpoint 5 control
output   [31:0]             ap_ahc6;            // actionpoint 6 control
output   [31:0]             ap_ahc7;            // actionpoint 7 control

output   [31:0]             ap_ahm0;            // actionpoint 0 match
output   [31:0]             ap_ahm1;            // actionpoint 1 match

output   [31:0]             ap_ahm2;            // actionpoint 2 match
output   [31:0]             ap_ahm3;            // actionpoint 3 match
output   [31:0]             ap_ahm4;            // actionpoint 4 match
output   [31:0]             ap_ahm5;            // actionpoint 5 match
output   [31:0]             ap_ahm6;            // actionpoint 6 match
output   [31:0]             ap_ahm7;            // actionpoint 7 match

output   [NUM_APS - 1:0]    actionpt_status_r;  // actionpoint hit bits that
                                                // end up in debug register
output                      actionpt_brk_a;     // signal to pipeline control 
                                                // that a halt is requested
output                      actionpt_swi_a;     // signal to pipeline control 
                                                //that a SWI is requested
output                      en_debug_r;         // enable debug extensions clk

output                      actionpt_pc_brk_a;
output                      p2_ap_stall_a;

reg     [31:0]              ap_ahv0; 
reg     [31:0]              ap_ahv1; 
reg     [31:0]              ap_ahv2; 
reg     [31:0]              ap_ahv3; 
reg     [31:0]              ap_ahv4; 
reg     [31:0]              ap_ahv5; 
reg     [31:0]              ap_ahv6; 
reg     [31:0]              ap_ahv7; 
reg     [31:0]              ap_ahc0; 
reg     [31:0]              ap_ahc1; 
reg     [31:0]              ap_ahc2; 
reg     [31:0]              ap_ahc3; 
reg     [31:0]              ap_ahc4; 
reg     [31:0]              ap_ahc5; 
reg     [31:0]              ap_ahc6; 
reg     [31:0]              ap_ahc7; 
reg     [31:0]              ap_ahm0; 
reg     [31:0]              ap_ahm1; 
reg     [31:0]              ap_ahm2; 
reg     [31:0]              ap_ahm3; 
reg     [31:0]              ap_ahm4; 
reg     [31:0]              ap_ahm5; 
reg     [31:0]              ap_ahm6; 
reg     [31:0]              ap_ahm7; 
wire                        actionpt_brk_a; 
wire                        actionpt_swi_a; 
wire                        en_debug_r; 
wire                        actionpt_pc_brk_a;
wire                        p2_ap_stall_a;


// Set of large vectors that hold the registers associated
// with each actionpoint.
//
// Actionpoint value
reg     [(AP_AMV_SIZE*NUM_APS)-1:0] i_ap_value_nxt; 
reg     [(AP_AMV_SIZE*NUM_APS)-1:0] i_ap_value_r; 
// Actionpoint mask
reg     [(AP_AMV_SIZE*NUM_APS)-1:0] i_ap_mask_nxt; 
reg     [(AP_AMV_SIZE*NUM_APS)-1:0] i_ap_mask_r; 
// Actionpoint control
reg     [(AP_AC_SIZE*NUM_APS)-1:0]  i_ap_control_nxt; 
reg     [(AP_AC_SIZE*NUM_APS)-1:0]  i_ap_control_r; 

// Vectors which hold the decode bits for register access
//
wire    [7:0]               i_v_decode_a;         // Value
wire    [7:0]               i_m_decode_a;         // Mask
wire    [7:0]               i_c_decode_a;         // Control

wire    [7:0]               i_v_decode_h_a;       // Value
wire    [7:0]               i_m_decode_h_a;       // Mask
wire    [7:0]               i_c_decode_h_a;       // Control

// Raw hits from ap_compare
wire    [NUM_APS - 1:0]     i_ap_hit_a; 
// Qualified hits after pairing
reg     [NUM_APS - 1:0]     i_ap_hit_qual_a;
reg     [NUM_APS - 1:0]     i_ap_hit_qual_p3_a; 
 
// Hit indicator for second of paired actionpoints
reg     [NUM_APS - 1:0]     i_ap_hit_pair_a; 
// Qualified hits after pairing where action is BRK
reg     [NUM_APS - 1:0]     i_ap_hit_qual_brk_a; 
reg     [NUM_APS - 1:0]     i_ap_hit_quad_a; 
reg     [NUM_APS - 1:0]     i_ap_hit_sing_a;
reg     [NUM_APS - 1:0]     i_ap_hit_qual_r; 

// Qualified hits after pairing where action is BRK. Used to halt instruction in stage 2
reg     [NUM_APS - 1:0]     i_ap_hit_qual_pc_brk_a; 

// Qualified hits after pairing where action is SWI
reg     [NUM_APS - 1:0]     i_ap_hit_qual_swi_a; 
// Array holding values from all the ap_compares
wire    [(AP_AMV_SIZE*NUM_APS)-1:0] i_ap_hit_value_a; 


// Single bit indicating a BRK hit
wire                        i_ap_hit_comb_brk_a; 
// Single bit indicating a SWI hit
wire                        i_ap_hit_comb_swi_a; 
// Registered version of actionhalt
reg                         i_actionhalt_r;
// Enable Debug (ED) flag internal
wire                        i_en_debug_nxt;
reg                         i_en_debug_r;
// aux read from core
wire                        i_aux_read_core_a;
// aux write from core
wire                        i_aux_write_core_a;

wire                        i_ap_pc_brk_a;
wire                        i_ap_hit_swi_a;
wire                        i_ap_p3_qual_hit_a;
wire                        i_actionhalt_nxt;
wire                        i_brcc_p2b_p3_a;


reg                         i_en_r;
reg                         i_ivic_r;

// preregistered actionpt_status_r
reg     [NUM_APS-1:0]       i_actionpt_status_r;
reg     [NUM_APS-1:0]       i_ap_write_a;
reg     [PC_MSB:0]          i_p2_currentpc_r;        // architectural PC
reg                         i_p2b_brcc_instr_r;

// action-point value register update
function [0:0] avr_update;
  input  [(AP_AC_SIZE*NUM_APS)-1:0] ap_control_r;
  input  [0:0] index;
  input   brcc_p2b_p3_a;
  integer ilp;
  begin  
    ilp = index;
    avr_update = // if it's a general watch point we can trigger
                (~(~ap_control_r[(AP_AC_SIZE*ilp)+1] & ~ap_control_r[(AP_AC_SIZE*ilp)+2] &
                 ~ap_control_r[(AP_AC_SIZE*ilp)+3]) |
           
                    // if it's a Opcode or PC and brcc ahead in the pipeline wait until it resolves
                 (~ap_control_r[(AP_AC_SIZE*ilp)+1] & ~ap_control_r[(AP_AC_SIZE*ilp)+2] &
                  ~ap_control_r[(AP_AC_SIZE*ilp)+3] & ~brcc_p2b_p3_a)); 
  end          
endfunction


// Create three decode vectors These constants are defined in xdefs.v.
// Actionpoint Match Value
assign i_v_decode_a[0] = auxdc(aux_addr, aux_ap_amv0);
assign i_v_decode_a[1] = auxdc(aux_addr, aux_ap_amv1);
assign i_v_decode_a[2] = auxdc(aux_addr, aux_ap_amv2); 
assign i_v_decode_a[3] = auxdc(aux_addr, aux_ap_amv3);
assign i_v_decode_a[4] = auxdc(aux_addr, aux_ap_amv4);
assign i_v_decode_a[5] = auxdc(aux_addr, aux_ap_amv5);
assign i_v_decode_a[6] = auxdc(aux_addr, aux_ap_amv6);
assign i_v_decode_a[7] = auxdc(aux_addr, aux_ap_amv7);

//  Actionpoint Match Mask
assign i_m_decode_a[0] = auxdc(aux_addr, aux_ap_amm0);
assign i_m_decode_a[1] = auxdc(aux_addr, aux_ap_amm1);
assign i_m_decode_a[2] = auxdc(aux_addr, aux_ap_amm2);
assign i_m_decode_a[3] = auxdc(aux_addr, aux_ap_amm3);
assign i_m_decode_a[4] = auxdc(aux_addr, aux_ap_amm4);
assign i_m_decode_a[5] = auxdc(aux_addr, aux_ap_amm5);
assign i_m_decode_a[6] = auxdc(aux_addr, aux_ap_amm6);
assign i_m_decode_a[7] = auxdc(aux_addr, aux_ap_amm7);

//  Actionpoint Control
assign i_c_decode_a[0] = auxdc(aux_addr, aux_ap_ac0);
assign i_c_decode_a[1] = auxdc(aux_addr, aux_ap_ac1);
assign i_c_decode_a[2] = auxdc(aux_addr, aux_ap_ac2);
assign i_c_decode_a[3] = auxdc(aux_addr, aux_ap_ac3);
assign i_c_decode_a[4] = auxdc(aux_addr, aux_ap_ac4);
assign i_c_decode_a[5] = auxdc(aux_addr, aux_ap_ac5);
assign i_c_decode_a[6] = auxdc(aux_addr, aux_ap_ac6);
assign i_c_decode_a[7] = auxdc(aux_addr, aux_ap_ac7);

// For host accesses

assign i_v_decode_h_a[0] = auxdc(h_addr, aux_ap_amv0) & aux_access;
assign i_v_decode_h_a[1] = auxdc(h_addr, aux_ap_amv1) & aux_access;
assign i_v_decode_h_a[2] = auxdc(h_addr, aux_ap_amv2) & aux_access; 
assign i_v_decode_h_a[3] = auxdc(h_addr, aux_ap_amv3) & aux_access;
assign i_v_decode_h_a[4] = auxdc(h_addr, aux_ap_amv4) & aux_access;
assign i_v_decode_h_a[5] = auxdc(h_addr, aux_ap_amv5) & aux_access;
assign i_v_decode_h_a[6] = auxdc(h_addr, aux_ap_amv6) & aux_access;
assign i_v_decode_h_a[7] = auxdc(h_addr, aux_ap_amv7) & aux_access;

//  Actionpoint Match Mask
assign i_m_decode_h_a[0] = auxdc(h_addr, aux_ap_amm0) & aux_access;
assign i_m_decode_h_a[1] = auxdc(h_addr, aux_ap_amm1) & aux_access;
assign i_m_decode_h_a[2] = auxdc(h_addr, aux_ap_amm2) & aux_access;
assign i_m_decode_h_a[3] = auxdc(h_addr, aux_ap_amm3) & aux_access;
assign i_m_decode_h_a[4] = auxdc(h_addr, aux_ap_amm4) & aux_access;
assign i_m_decode_h_a[5] = auxdc(h_addr, aux_ap_amm5) & aux_access;
assign i_m_decode_h_a[6] = auxdc(h_addr, aux_ap_amm6) & aux_access;
assign i_m_decode_h_a[7] = auxdc(h_addr, aux_ap_amm7) & aux_access;

//  Actionpoint Control
assign i_c_decode_h_a[0] = auxdc(h_addr, aux_ap_ac0) & aux_access;
assign i_c_decode_h_a[1] = auxdc(h_addr, aux_ap_ac1) & aux_access;
assign i_c_decode_h_a[2] = auxdc(h_addr, aux_ap_ac2) & aux_access;
assign i_c_decode_h_a[3] = auxdc(h_addr, aux_ap_ac3) & aux_access;
assign i_c_decode_h_a[4] = auxdc(h_addr, aux_ap_ac4) & aux_access;
assign i_c_decode_h_a[5] = auxdc(h_addr, aux_ap_ac5) & aux_access;
assign i_c_decode_h_a[6] = auxdc(h_addr, aux_ap_ac6) & aux_access;
assign i_c_decode_h_a[7] = auxdc(h_addr, aux_ap_ac7) & aux_access;

          
// Infer the registers clocked by clk_debug. This clock is gated to reduce power
// when the clock gating option is used.
//
always @(posedge clk_debug or posedge rst_a)
   begin : regs1_PROC
   if (rst_a == 1'b 1)
      begin
      i_actionhalt_r         <= 1'b0;
      i_p2b_brcc_instr_r     <= 1'b0;
      i_ap_hit_qual_r        <= {(NUM_APS){1'b0}};
      i_ap_value_r           <= {(32*NUM_APS){1'b0}};
      i_ap_mask_r            <= {(32*NUM_APS){1'b0}};
      i_ap_control_r         <= {(AP_AC_SIZE*NUM_APS){1'b0}};      
      i_p2_currentpc_r       <= {(PC_MSB){1'b0}};
      i_actionpt_status_r    <= {(NUM_APS){1'b0}};
      i_en_r                 <= 1'b0;
      i_ivic_r               <= 1'b0;      
                  
      end
   else
      begin
      i_ap_value_r           <= i_ap_value_nxt;
      i_ap_mask_r            <= i_ap_mask_nxt;
      i_ap_control_r         <= i_ap_control_nxt;      
      i_actionhalt_r         <= i_actionhalt_nxt;
      i_en_r                 <= en;
      i_ivic_r               <= ivic;       // delay ivic for one cycle (covers clock gating scenario)

// Update the registered version of the brk hit qualifier signal if hit. We update
// the ap value register with the triggering value, so the combinational qual signal 
// is no longer valid, hence we use the registered version until an IVIC is performed
// which clears stage 1 and 2 and this signal.

      if (i_ivic_r==1'b1)
          i_ap_hit_qual_r        <= {(NUM_APS){1'b0}};
      else if ((i_ap_pc_brk_a==1'b1) && (i_brcc_p2b_p3_a==1'b0) && (i_actionhalt_r==1'b0) && (en==1'b1))
               i_ap_hit_qual_r   <= i_ap_hit_qual_pc_brk_a; 

// Handle the updating of the AP status bits here.     
      if (i_en_r == 1'b0 && en==1'b1)
          i_actionpt_status_r <= {(NUM_APS){1'b0}} | i_ap_hit_qual_brk_a | i_ap_hit_qual_swi_a;
          
      else if (i_ap_hit_comb_brk_a==1'b1)
               i_actionpt_status_r <=  i_actionpt_status_r | i_ap_hit_qual_brk_a | i_ap_hit_qual_p3_a;
               
      else if (i_ap_hit_comb_swi_a == 1'b1 && i_actionhalt_r == 1'b0 && en==1'b1) 
               i_actionpt_status_r <= i_actionpt_status_r | i_ap_hit_qual_swi_a | i_ap_hit_qual_p3_a;               

      else if (i_ap_p3_qual_hit_a==1'b1)
               i_actionpt_status_r <= i_actionpt_status_r | i_ap_hit_qual_p3_a;
      else  
// Update the action status bits for SWI AP writes
               i_actionpt_status_r <= i_actionpt_status_r & (~i_ap_write_a);


      if (en1==1'b1) // log current pc for use in stage 2
          i_p2_currentpc_r     <= currentpc_r;

      if (en2==1'b1) // determine if p2b contains an brcc instruction  
          i_p2b_brcc_instr_r   <= p2_brcc_instr_a; 

      
      end
   end

   assign i_brcc_p2b_p3_a = (i_p2b_brcc_instr_r & p2b_iv) | p3_brcc_instr_a;
   
// Infer the register clocked by ck
// This clock is always active so the 
// en_debug_r bit can always begin controlled
always @(posedge clk_ungated or posedge rst_a)
   begin : regs2_sync_PROC
   if (rst_a == 1'b1)
      i_en_debug_r <= 1'b0;
   else
      i_en_debug_r <= i_en_debug_nxt;
   end


// Delay actionhalt by one cycle for use in AMV update control
assign i_actionhalt_nxt = actionhalt;
         

// Decode access to the registers and update their "nxt" values
always @(i_ap_value_r or i_ap_mask_r or i_ap_control_r or en or
         aux_write or i_v_decode_a or aux_dataw or h_dataw or h_write or
	 i_v_decode_h_a or i_m_decode_h_a or i_c_decode_h_a or en or
        i_m_decode_a or i_c_decode_a  or i_ap_hit_pair_a or 
        i_actionhalt_r or i_ap_hit_value_a or i_actionpt_status_r or 
        i_ap_hit_sing_a or i_ap_hit_quad_a or i_ap_hit_qual_p3_a)
   begin : aux_regs_decode_PROC
   integer ilp,jlp; // Local loop variables

// assign the defaults
   i_ap_value_nxt        = i_ap_value_r;
   i_ap_mask_nxt         = i_ap_mask_r;
   i_ap_control_nxt      = i_ap_control_r;
   i_ap_write_a          = {(NUM_APS){1'b0}};   

//  Registers associated with each actionpoint
   if (aux_write == 1'b 1) // SR instruction from core or host (debugger) write whilst core halted
      begin
      for (ilp = 0; ilp <= NUM_APS - 1; ilp = ilp + 1)
         begin
         
            if (i_v_decode_a[ilp]==1'b 1 || i_m_decode_a[ilp]==1'b1 || i_c_decode_a[ilp]==1'b1)
                 i_ap_write_a[ilp] = 1'b1;  
                 
            for (jlp = 0; jlp < AP_AMV_SIZE; jlp = jlp + 1)
               begin
               if (i_v_decode_a[ilp] == 1'b 1)
                  i_ap_value_nxt[(AP_AMV_SIZE*ilp)+jlp] 
                     = aux_dataw[jlp];   
               if (i_m_decode_a[ilp] == 1'b 1)
                  i_ap_mask_nxt[(AP_AMV_SIZE*ilp)+jlp] 
                     = aux_dataw[jlp];   
               end
            for (jlp = 0; jlp < AP_AC_SIZE; jlp = jlp + 1)
               if (i_c_decode_a[ilp] == 1'b 1)
                  i_ap_control_nxt[(AP_AC_SIZE*ilp)+jlp] 
                     = aux_dataw[jlp];   
         end
      end

   if ((h_write == 1'b1) && (en == 1'b1)) // host (debugger) write whilst core running
      begin
      for (ilp = 0; ilp <= NUM_APS - 1; ilp = ilp + 1)
         begin
         
            if (i_v_decode_h_a[ilp]==1'b 1 || i_m_decode_h_a[ilp]==1'b1 || i_c_decode_h_a[ilp]==1'b1)
                 i_ap_write_a[ilp] = 1'b1;  
                 
            for (jlp = 0; jlp < AP_AMV_SIZE; jlp = jlp + 1)
               begin
	       
               if (i_v_decode_h_a[ilp] == 1'b 1)
                  i_ap_value_nxt[(AP_AMV_SIZE*ilp)+jlp] 
                     = h_dataw[jlp]; 	              
		     
               if (i_m_decode_h_a[ilp] == 1'b 1)
                  i_ap_mask_nxt[(AP_AMV_SIZE*ilp)+jlp] 
                     = h_dataw[jlp]; 
		 
               end
	       
            for (jlp = 0; jlp < AP_AC_SIZE; jlp = jlp + 1)
               if (i_c_decode_h_a[ilp] == 1'b 1)
			      i_ap_control_nxt[(AP_AC_SIZE*ilp)+jlp] 
                     = h_dataw[jlp];   		   
         end
      end

        
// Update the value register with the hit value. Only
// do this once at the beginning of the actionpoint process
// to avoid false triggering with the new match value

      for (ilp = 0; ilp <= NUM_APS - 1; ilp = ilp + 1)
      
         for (jlp = 0; jlp < AP_AMV_SIZE; jlp = jlp + 1) 
            if ((i_ap_hit_sing_a[ilp]==1'b1 || i_ap_hit_quad_a[ilp]==1'b1 || i_ap_hit_pair_a[ilp]==1'b1) 
                && (i_actionhalt_r == 1'b0) && en==1'b1)
                i_ap_value_nxt[(AP_AMV_SIZE*ilp)+jlp] = i_ap_hit_value_a[(AP_AMV_SIZE*ilp)+jlp];
                
            else if (i_ap_hit_qual_p3_a[ilp]==1'b1 && i_actionhalt_r==1'b1 && i_actionpt_status_r[ilp]==1'b0)
                i_ap_value_nxt[(AP_AMV_SIZE*ilp)+jlp] = i_ap_hit_value_a[(AP_AMV_SIZE*ilp)+jlp];   
              
   end



// Enable debug
// This is the Enable Debug flag (ED) in the DEBUG register
// If clock gating has been selected in the build then the ED bit must be
// set to enable actionpoints. If there is no clock gating then the 
// actionpoints are always enabled
assign i_en_debug_nxt = 
    (aux_write & auxdc(aux_addr,AX_DEBUG_N))==1'b1 
    ? aux_dataw[DB_DEBUG_N] 
    : (h_write & auxdc(h_addr,AX_DEBUG_N) & aux_access)==1'b1 
    ? h_dataw[DB_DEBUG_N] 
    : i_en_debug_r;
assign en_debug_r = i_en_debug_r;


// i_ap_hit_a             :   raw hits
// i_ap_hit_qual_a        :   hits qualified with pairing information
// i_ap_hit_qual_brk_a    :   qualified hits that are going to cause a brk
// i_ap_hit_qual_swi_a    :   qualified hits that are going to cause a swi


// Create vectors of valid hit bits for both BRK and SWI cases
// Create vectors of valid hit bits for both BRK and SWI cases
always @(
   i_ap_control_r or
   i_ap_hit_a or
   i_brcc_p2b_p3_a)
   begin : hit_value_PROC
   integer ilp; // Local loop variable
// Qualify the hit vector with pairing information
// If any actionpoint has the pairing bit set then it will only trigger
// if the next higher actionpoint triggers simultaneously. This works in a
// wraparound manner so that if AP7 is paired it will only trigger if AP0
// triggers

// Default value
   i_ap_hit_qual_a = {(NUM_APS){1'b0}};
   i_ap_hit_sing_a = {(NUM_APS){1'b0}};
   i_ap_hit_pair_a = {(NUM_APS){1'b0}};
   i_ap_hit_quad_a = {(NUM_APS){1'b0}};
   
   for (ilp = 0; ilp <= NUM_APS - 1; ilp = ilp + 1)
      begin
      if ((i_ap_control_r[(AP_AC_SIZE*((ilp+NUM_APS-1) % NUM_APS))
          +AP_AC_QUAD] == 1'b 1) ||
          (i_ap_control_r[(AP_AC_SIZE*((ilp+NUM_APS-2) % NUM_APS))
          +AP_AC_QUAD] == 1'b 1) ||
          (i_ap_control_r[(AP_AC_SIZE*((ilp+2*NUM_APS-3) % NUM_APS))
          +AP_AC_QUAD] == 1'b 1))
// Stop an actionpoint hitting individually if it is in a quad
         i_ap_hit_qual_a[ilp] = 1'b0;
      else if (i_ap_control_r[(AP_AC_SIZE*ilp)+AP_AC_QUAD] == 1'b 1)
         begin
// This is a quadded actionpoint so AND the hit bit with
// the next three actionpoints hit bits
         i_ap_hit_qual_a[ilp] = i_ap_hit_a[ilp] & 
                         i_ap_hit_a[(ilp+1) % NUM_APS] &
                         i_ap_hit_a[(ilp+2) % NUM_APS] &
                         i_ap_hit_a[(ilp+3) % NUM_APS];
// indicate in the i_ap_hit_pair_a vector which were the
// quadded actionpoint so their AMVs can begin updated

         i_ap_hit_quad_a[ilp] = i_ap_hit_a[ilp]  &  i_ap_hit_a[(ilp+1) % NUM_APS] & i_ap_hit_a[(ilp+2) % NUM_APS] &
                         i_ap_hit_a[(ilp+3) % NUM_APS] & avr_update(i_ap_control_r, ilp, i_brcc_p2b_p3_a);
                                                                           
         i_ap_hit_quad_a[(ilp+1) % NUM_APS] = i_ap_hit_a[ilp] & i_ap_hit_a[(ilp+1) % NUM_APS] & i_ap_hit_a[(ilp+2) % NUM_APS] &
                         i_ap_hit_a[(ilp+3) % NUM_APS] & avr_update(i_ap_control_r, (ilp+1) % NUM_APS, i_brcc_p2b_p3_a);
                                                          
         i_ap_hit_quad_a[(ilp+2) % NUM_APS] = i_ap_hit_a[ilp] & i_ap_hit_a[(ilp+1) % NUM_APS] & i_ap_hit_a[(ilp+2) % NUM_APS] &
                         i_ap_hit_a[(ilp+3) % NUM_APS] & avr_update(i_ap_control_r, (ilp+2) % NUM_APS, i_brcc_p2b_p3_a);
                                                 
         i_ap_hit_quad_a[(ilp+3) % NUM_APS] = i_ap_hit_a[ilp] & i_ap_hit_a[(ilp+1) % NUM_APS] & i_ap_hit_a[(ilp+2) % NUM_APS] &
                         i_ap_hit_a[(ilp+3) % NUM_APS] & avr_update(i_ap_control_r, (ilp+3) % NUM_APS, i_brcc_p2b_p3_a);
                         
         end
      else if (i_ap_control_r[(AP_AC_SIZE*((ilp+NUM_APS-1) % NUM_APS))
         +AP_AC_PAIR] == 1'b 1)
// Stop an actionpoint hitting if it is paired with the previous one
// ie the pair bit of the previous actionpoint is set
           i_ap_hit_qual_a[ilp] = 1'b0;   
      else if (i_ap_control_r[(AP_AC_SIZE*ilp)+AP_AC_PAIR] == 1'b 1)
         begin
// This is a paired actionpoint so AND the hit bit with the
// next actionpoint hit bit
         i_ap_hit_qual_a[ilp] = i_ap_hit_a[ilp] & 
                                i_ap_hit_a[(ilp+1) % NUM_APS];
// Also indicate in i_ap_hit_pair_a vector which was the paired
// actionpoint so that its AMV can also be updated
         i_ap_hit_pair_a[ilp] = i_ap_hit_a[ilp] & i_ap_hit_a[(ilp+1) % NUM_APS] & 
                                     avr_update(i_ap_control_r, ilp, i_brcc_p2b_p3_a);
                                                                 
         i_ap_hit_pair_a[(ilp+1) % NUM_APS] = i_ap_hit_a[ilp] & i_ap_hit_a[(ilp+1) % NUM_APS] & 
                                              avr_update(i_ap_control_r, (ilp+1) % NUM_APS, i_brcc_p2b_p3_a);
                                                                      

         end
      else
        begin
// Normal (non-paired) case
         i_ap_hit_qual_a[ilp] = i_ap_hit_a[ilp];   
         i_ap_hit_sing_a[ilp] = i_ap_hit_a[ilp] & avr_update(i_ap_control_r, ilp, i_brcc_p2b_p3_a);
         
       end
      end
   end

// Generate the vectors for two different actions depending on the
// contents of the ACTION bit
always @(i_ap_hit_qual_a or i_ap_hit_qual_r or i_ap_control_r or i_brcc_p2b_p3_a or p2iv)
   begin : hit_qual_PROC
   integer ilp; // Local loop variable
   for (ilp = 0; ilp <= NUM_APS - 1; ilp = ilp + 1)
      begin

      // for ld/st/sr/lr (stage 3) instructions that complete after or when the processor has halted
      i_ap_hit_qual_p3_a[ilp] = i_ap_hit_qual_a[ilp] &         
                               ~i_ap_control_r[(AP_AC_SIZE*ilp)+AP_AC_ACTION] &
                               
                               ((i_ap_control_r[(AP_AC_SIZE*ilp)+1] & ~i_ap_control_r[(AP_AC_SIZE*ilp)+2] & ~i_ap_control_r[(AP_AC_SIZE*ilp)+3]) |
                                (~i_ap_control_r[(AP_AC_SIZE*ilp)+1] & i_ap_control_r[(AP_AC_SIZE*ilp)+2] & ~i_ap_control_r[(AP_AC_SIZE*ilp)+3]));
                     
      // i_ap_hit_qual_brk_a is used to signify to the core that the triggering action-point should
      // halt the processor, covers all ap types except SWI. 
                       
      i_ap_hit_qual_brk_a[ilp] = i_ap_hit_qual_a[ilp] &
                                ~i_ap_control_r[(AP_AC_SIZE*ilp)+AP_AC_ACTION] & 
         
                                // if it's a general watch point we can trigger
                                (~(~i_ap_control_r[(AP_AC_SIZE*ilp)+1] & ~i_ap_control_r[(AP_AC_SIZE*ilp)+2] &
                                 ~i_ap_control_r[(AP_AC_SIZE*ilp)+3]) |
           
                                   // if it's a Opcode or PC and brcc ahead in the pipeline wait until it resolves
                                (~i_ap_control_r[(AP_AC_SIZE*ilp)+1] & ~i_ap_control_r[(AP_AC_SIZE*ilp)+2] &
                                 ~i_ap_control_r[(AP_AC_SIZE*ilp)+3] & ~i_brcc_p2b_p3_a)); 

      // i_ap_hit_qual_pc_brk_a is used to signify to the core that the triggering action-point should
      // cause the processor to halt like the BRK instruction. This only effects PC and Opcode type
      // action-points.
      
      i_ap_hit_qual_pc_brk_a[ilp] = (i_ap_hit_qual_a[ilp] | (i_ap_hit_qual_r[ilp] & p2iv)) &
                                    ~i_ap_control_r[(AP_AC_SIZE*ilp)+AP_AC_ACTION] & 
                                    ~i_ap_control_r[(AP_AC_SIZE*ilp)+1] & ~i_ap_control_r[(AP_AC_SIZE*ilp)+2] &
                                    ~i_ap_control_r[(AP_AC_SIZE*ilp)+3];                   
         
      // i_ap_hit_qual_swi_a is used to signify to the core that the triggering action-point should
      // create a software interupt (SWI).
               
      i_ap_hit_qual_swi_a[ilp] =  i_ap_hit_qual_a[ilp] &
                                  i_ap_control_r[(AP_AC_SIZE*ilp)+AP_AC_ACTION];  

            
      end
   end


// determine if a load/store/lr/sr triggers when the processor is about to be halted or is halted
assign i_ap_p3_qual_hit_a  = |i_ap_hit_qual_p3_a;

//  or together all the individual hit bits into a combined hit
assign i_ap_hit_comb_brk_a = |i_ap_hit_qual_brk_a;                  // for aux/ld/st watch-points

assign i_ap_hit_swi_a      = |i_ap_hit_qual_swi_a;                  // for SWI instrutions
assign i_ap_hit_comb_swi_a = i_ap_hit_swi_a & ~i_brcc_p2b_p3_a;

assign i_ap_pc_brk_a       = |i_ap_hit_qual_pc_brk_a;               // for PC/Opcode breakpoint
assign actionpt_pc_brk_a   = i_ap_pc_brk_a & ~i_brcc_p2b_p3_a;  

// generate a stall if action-point hit in stage 2 and brcc in stages 2b or 3
assign p2_ap_stall_a       = (i_ap_pc_brk_a | i_ap_hit_swi_a) & i_brcc_p2b_p3_a; 


// Connect up ports. This is done this way because although there
// are a variable number of actionpoints, there are a fixed number
// of outputs to the auxiliary register read logic so default
// values have to be assigned.
always @(i_ap_value_r or i_ap_control_r or i_ap_mask_r)
begin : pcon_PROC
    ap_ahv0 = {AP_AMV_SIZE{1'b0}};
    ap_ahv1 = {AP_AMV_SIZE{1'b0}};
    ap_ahv2 = {AP_AMV_SIZE{1'b0}};
    ap_ahv3 = {AP_AMV_SIZE{1'b0}};
    ap_ahv4 = {AP_AMV_SIZE{1'b0}};
    ap_ahv5 = {AP_AMV_SIZE{1'b0}};
    ap_ahv6 = {AP_AMV_SIZE{1'b0}};
    ap_ahv7 = {AP_AMV_SIZE{1'b0}};
    ap_ahc0 = {AP_AMV_SIZE{1'b0}};
    ap_ahc1 = {AP_AMV_SIZE{1'b0}};
    ap_ahc2 = {AP_AMV_SIZE{1'b0}};
    ap_ahc3 = {AP_AMV_SIZE{1'b0}};
    ap_ahc4 = {AP_AMV_SIZE{1'b0}};
    ap_ahc5 = {AP_AMV_SIZE{1'b0}};
    ap_ahc6 = {AP_AMV_SIZE{1'b0}};
    ap_ahc7 = {AP_AMV_SIZE{1'b0}};
    ap_ahm0 = {AP_AMV_SIZE{1'b0}};
    ap_ahm1 = {AP_AMV_SIZE{1'b0}};
    ap_ahm2 = {AP_AMV_SIZE{1'b0}};
    ap_ahm3 = {AP_AMV_SIZE{1'b0}};
    ap_ahm4 = {AP_AMV_SIZE{1'b0}};
    ap_ahm5 = {AP_AMV_SIZE{1'b0}};
    ap_ahm6 = {AP_AMV_SIZE{1'b0}};
    ap_ahm7 = {AP_AMV_SIZE{1'b0}};

// now assign the actual hit values from as many
// actionpoints as there are

    ap_ahv0 = i_ap_value_r[(AP_AMV_SIZE*(0+1))-1 : AP_AMV_SIZE*0];
    ap_ahc0 = i_ap_control_r[(AP_AC_SIZE*(0+1))-1 : AP_AC_SIZE*0];
    ap_ahm0 = i_ap_mask_r[(AP_AMV_SIZE*(0+1))-1 : AP_AMV_SIZE*0];
    ap_ahv1 = i_ap_value_r[(AP_AMV_SIZE*(1+1))-1 : AP_AMV_SIZE*1];
    ap_ahc1 = i_ap_control_r[(AP_AC_SIZE*(1+1))-1 : AP_AC_SIZE*1];
    ap_ahm1 = i_ap_mask_r[(AP_AMV_SIZE*(1+1))-1 : AP_AMV_SIZE*1];
end

assign actionpt_brk_a = i_ap_hit_comb_brk_a; 
assign actionpt_swi_a = i_ap_hit_comb_swi_a; 
assign actionpt_status_r = i_actionpt_status_r;

// Qualify the aux access bits so that host accesses are not seen
// aux_access indcates a host access but only when en is low
assign i_aux_read_core_a = aux_read & ~(aux_access & ~en);
assign i_aux_write_core_a = aux_write & ~(aux_access & ~en);

//  This inserts as many instances of ap_compare as there are actionpoints
ap_compare U_ap_compare0 (
   .clk_debug(clk_debug),
   .en_debug_r(i_en_debug_r),
   .rst_a(rst_a),
   .mc_addr(mc_addr), 
   .dwr(dwr), 
   .drd(drd), 
   .aux_addr(aux_addr), 
   .aux_dataw(aux_dataw), 
   .aux_datar(aux_datar), 
   .ap_param0(ap_param0), 
   .ap_param1(ap_param1), 
   .en(en),
   .p2_currentpc_r(i_p2_currentpc_r), 
   .kill_p2_a(kill_p2_a),
   .p2_iw_r(p2_iw_r),       
   .p2iv(p2iv), 
   .mload(mload), 
   .mstore(mstore), 
   .ldvalid(ldvalid), 
   .p2b_jmp_holdup_a(p2b_jmp_holdup_a), 
   .aux_read_core_a(i_aux_read_core_a), 
   .aux_write_core_a(i_aux_write_core_a), 
   .ap_param0_read(ap_param0_read), 
   .ap_param0_write(ap_param0_write), 
   .ap_param1_read(ap_param1_read), 
   .ap_param1_write(ap_param1_write), 
   .ap_control_r(i_ap_control_r[(AP_AC_SIZE*(0+1))-1 : AP_AC_SIZE*0]), 
   .ap_value_r(i_ap_value_r[(AP_AMV_SIZE*(0+1))-1 : AP_AMV_SIZE*0]), 
   .ap_mask_r(i_ap_mask_r[(AP_AMV_SIZE*(0+1))-1 : AP_AMV_SIZE*0]), 

   .ap_hit_a(i_ap_hit_a[0]), 
   .ap_hit_value_a(i_ap_hit_value_a[(AP_AMV_SIZE*(0+1))-1 : AP_AMV_SIZE*0])); 
ap_compare U_ap_compare1 (
   .clk_debug(clk_debug),
   .en_debug_r(i_en_debug_r),
   .rst_a(rst_a),
   .mc_addr(mc_addr), 
   .dwr(dwr), 
   .drd(drd), 
   .aux_addr(aux_addr), 
   .aux_dataw(aux_dataw), 
   .aux_datar(aux_datar), 
   .ap_param0(ap_param0), 
   .ap_param1(ap_param1), 
   .en(en),
   .p2_currentpc_r(i_p2_currentpc_r), 
   .kill_p2_a(kill_p2_a),
   .p2_iw_r(p2_iw_r),       
   .p2iv(p2iv), 
   .mload(mload), 
   .mstore(mstore), 
   .ldvalid(ldvalid), 
   .p2b_jmp_holdup_a(p2b_jmp_holdup_a), 
   .aux_read_core_a(i_aux_read_core_a), 
   .aux_write_core_a(i_aux_write_core_a), 
   .ap_param0_read(ap_param0_read), 
   .ap_param0_write(ap_param0_write), 
   .ap_param1_read(ap_param1_read), 
   .ap_param1_write(ap_param1_write), 
   .ap_control_r(i_ap_control_r[(AP_AC_SIZE*(1+1))-1 : AP_AC_SIZE*1]), 
   .ap_value_r(i_ap_value_r[(AP_AMV_SIZE*(1+1))-1 : AP_AMV_SIZE*1]), 
   .ap_mask_r(i_ap_mask_r[(AP_AMV_SIZE*(1+1))-1 : AP_AMV_SIZE*1]), 

   .ap_hit_a(i_ap_hit_a[1]), 
   .ap_hit_value_a(i_ap_hit_value_a[(AP_AMV_SIZE*(1+1))-1 : AP_AMV_SIZE*1])); 


endmodule // module actionpoints
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1998-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This module contains all the necessary logic for all debug
// extensions in the ARC.
//  
//  This file contains the debug extensions for:
// 
// 
//  L indicates a latched signal and U indicates a signal produced by
//  logic.
//
//======================= Inputs to this block =======================--
// 
//  aux_access       U Auxiliary Access. This signal is flagged by the
//                   host to inform the ARC that the address supplied on
//                   h_addr[31:0] applies to the auxiliary register set. 
// 
//  aux_addr[31:0]   U Auxiliary Register Address. This is produced by 
//                   the hostif.v, from the host address when the ARC
//                   is halted (en = '0') or from source 1 from pipeline
//                   stage 3, when the ARC is running. Width of decode is
//                   set by AUXDECSZ in extutil.v. 
// 
//  aux_dataw[31:0]  U Auxiliary Write Data. The auxiliary register bus 
//                   write data value is latched into auxiliary register
//                   specified by aux_addr[31:0] at the end of the cycle
//                   when aux_write is true. This is generated by 
//                   hostif.v, either from the host's write data bus 
//                   when the ARC is halted (en = '0') or from source 1
//                   from pipeline stage 3, when the ARC is running.
// 
//  aux_read         U Auxiliary Read. This signal indicates that a read 
//                   is taking place on this cycle. This is initiated
//                   either by an LR instruction when the ARC is running,
//                   or by a host read when the ARC is halted (for single 
//                   access aux registers). The data stored at location
//                   aux_addr[31:0] should be placed on drx_reg[31:0].
//                   The xreg_hit signal should be asserted if the
//                   register in question is recognised as a valid
//                   extension auxiliary register. For dual access
//                   registers, aux_regs.v and hostif.v will select
//                   the correct data values to go to the ARC and the
//                   host.
// 
//  aux_write        U Auxiliary Write. This signal indicates that a
//                   write (either from the ARC or host) is being
//                   performed to the auxiliary register specified on 
//                   aux_addr[31:0] on this cycle. This signal is set by
//                   hostif.v by a SR instruction when the ARC is
//                   running or a host when it is halted. The data 
//                   supplied by aux_dataw[31:0] should be latched into
//                   register specified by aux_addr[31:0] at the end of
//                   the cycle. For dual access extension registers,
//                   writes are ignored from regular auxiliary register
//                   bus aux_write, aux_addr(), and aux_dataw() when the
//                   ARC is halted.
// 
//  currentpc_nxt    U Pre-latch PC value. This is the value of program
//                   counter which corresponds to the ifetch_aligned 
//                   signal. It is latched by the ARC onto currentpc_r,
//                   and used by the processor.
//
//  currentpc_r      This is the latched value of the pc which is
//                   currently being used by stage 1 to fetch the next
//                   instruction. 
// 
//  dwr[]            Data value to be stored to memory. It is latched
//                   stval from the ARC interface. The value is latched
//                   when en2='1', i.e. the pipeline is not stalled.
// 
//  en               L Global enable. This is true when the ARC is
//                   running in normal operation.
// 
//  en1              U Stage 2 pipeline latch control. True when an
//                   instruction is being latched into pipeline stage 2.
//                   This will be true at different times to pcen, as it
//                   allows junk instructions to be latched into the
//                   pipeline.
//                   *** A feature of this signal is that it will allow
//                   an instruction be clocked into stage 2 even when
//                   stage 3 is halted, provided that stage 2 contains
//                   a killed instruction (i.e. p2iv = '0'). This is
//                   called a 'catch-up'. ***
// 
//  en2              U Pipeline stage 2 enable. When this signal is true,
//                   the instruction in stage 2 can pass into stage 3 at
//                   the end of the cycle. When it is false, it will
//                   hold up stage 2 and stage 1 (pcen).
// 
//  en3              U Pipeline stage 3 enable. When this signal is true,
//                   the instruction in stage 3 can pass into stage 4 at
//                   the end of the cycle. When it is false, it will
//                   probably hold up stages one (pcen), two (en2), and
//                   three. It is set in the rctl.v block.
//                   
//  h_addr[31:0]     L Host Address. This is a longword-granularity
//                   address latched by the host before being presented
//                   to the register module. This is a 32-bit address (it
//                   may be smaller, but packed with zeroes) from the
//                   host which is used to access registers in the ARC in
//                   conjuction with aux_access and core_access. The
//                   width of the decode applied to this 32-bit quantity
//                   is defined by the AUXDECSZ constant, found in
//                   extutil.v. It is defined as being a 32-bit bus at
//                   this level to maintain compatibility with the LR and 
//                   SR instructions which can generate a 32-bit value
//                   for the address to be used for auxiliary register
//                   accesses.
// 
//  h_dataw[31:0]    L Host Write Data. This bus carries the data which
//                   is to be stored into registers in the ARC or core 
//                   extensions. It is latched by the host as is the
//                   address, h_addr[31:0].
//                   
//  h_read           U Host Read. When the host signals h_read is true, 
//                   this signal indicates that a host read is taking
//                   place, and the register module should latch the data
//                   on h_dataw[31:0] at the end of the cycle.
// 
//  h_write          U Host Write. When the host signals h_write is true, 
//                   this signal indicates that a host write is taking
//                   place, and the register module should latch the data
//                   on h_dataw[31:0] at the end of the cycle.
// 
//  ifetch           U This signal, similar to pcen, indicates to the
//                   memory controller that a new instruction is
//                   required, and should be fetched from memory from the
//                   address which will be clocked into currentpc_r[31:0]
//                   at the end of the cycle. It is also true for one
//                   cycle when the processor has been started following
//                   a reset, in order to get the ball rolling.
//                   An instruction fetch will also be issued if the host
//                   changes the program counter when the ARC is halted,
//                   provided it is not directly after a reset.
//                   The ifetch signal will never be set true whilst the
//                   memory controller is in the process of doing an
//                   instruction fetch, so it may be used by the memory
//                   controller as an acknowledgement of instruction
//                   receipt.
// 
//  ivalid_aligned   U Qualifying signal for p1iw[31:0]. When it is low,
//                   this indicates that the m/c has not been able to
//                   fetch the requested opcode, and that the program
//                   counter should not be incremented. The pipeline
//                   might be stalled, depending upon whether the
//                   instruction in stage 2 needs to look at the
//                   instruction in stage 1. When it is true, the
//                   instruction is clocked into pipeline stage 2
//                   provided that the pipeline is able to move on.
// 
//  ldvalid          U From LSU. This signal is set true by the LSU to
//                   indicate that a delayed load writeback WILL occur on
//                   the next cycle. If the instruction in stage 3 wishes
//                   to perform a writeback, then pipeline stage 1, 2 and
//                   3 will be held. If the instruction is stage 3 is
//                   invalid, or does not want to write a value into the
//                   core register set for some reason, then the
//                   instructions in stages 1 and 2 will move into 2 and
//                   3 respectively, and the instruction that was in
//                   stage 3 will be replaced in stage 4 by the delayed
//                   load writeback. 
//                   ** Note that delayed load writebacks WILL complete,
//                   even if the processor is halted (en=0). In this
//                   instance, the host may be held off for a cycle
//                   (hold_host) if it is attempting to access the core
//                   registers. **
// 
//  mc_addr[]        The result of the adder unit. Goes to LSU, to be 
//                   latched by the memory controller.
// 
//  mstore           U This signal indicates to the LSU that there is a
//                   valid store instruction in stage 3.
// 
//  p2limm           U From rctl.v. This is used by the actionpoint
//                   debugging system when selected to qualify the value
//                   of the PC at stage one of the pipeline. The limm
//                   data is considered to be at the same the value
//                   address as the instruction it is associated with
//                   with regards to the debugger.
// 
//  p2opcode         L Opcode word. This bus contains the instruction
//                   word which is being executed by stage 2. It must be
//                   qualified by p2iv.
// 
//  p2iv             L Opcode valid. This signal is used to indicate that 
//                   the opcode in pipeline stage 2 is a valid
//                   instruction. The instruction may not be valid if a
//                   junk instruction has been allowed to come into the
//                   pipeline in order to allow the pipeline to continue
//                   running when an instruction cannot be fetched by the
//                   memory controller.
// 
//  kill_p1_a     U This signal indicates that the delay slot
//                   mechanism of the jump instruction currently in stage 
//                   2 is requesting that the next instruction be killed
//                   before it gets into stage 2. This signal is produced 
//                   from a decode for a jump instruction code, the 
//                   condition-true signal, p2iv and the delay-slot field
//                   in the instruction. This signal relies on the delay
//                   slot instruction being present in stage 1 before
//                   stage 2 can move on. This is handled elsewhere by
//                   this file.
// 
//  kill_p2_a        Kill Stage 2. This is asserted true when the
//                   instructin in stage 2 should be killed.
//
//  wba[5:0]         L This bus carries the address of the register to
//                   which the data on wbdata[31:0] is to be written at
//                   the end of the cycle if wben is true. It is produced
//                   during stage 3 and takes account of delayed load
//                   register writeback (taking a value from the LSU), 
//                   LD/ST address writeback (address from the B or C 
//                   field), and normal ALU operation destination
//                   addresses (instruction A field).
// 
//  wbdata[31:0]     L This is the bus which carries the latched (stage
//                   4) data to be written into the register file. This
//                   result is selected from numerous ALU results,
//                   delayed load register writebacks, and LR results.
//                   It is written into the register file at the end of
//                   the cycle if wben is true.
// 
//  wben             L This signal is the enable signal which determines
//                   whether the data on wbdata[31:0] is written into the 
//                   register file at stage 4. It is produced in stage 3
//                   and takes into account delayed load writebacks, 
//                   cancelled instructions, and instructions which are
//                   not to be executed due to the cc result being false,
//                   amongst other things.
// 
//======================== Output from this block ====================--
// 
//  actionpt_pc_addr_r
//                   L Actionpoint PC Address.
//
//  actionpt_status_r
//                   L Actionpoint Value. This registered bus can be
//                   read by the debugger from within the debug register 
//                   when the ARC has been halted by an actionpoint to 
//                   determine which one was responsible. There is a bit
//                   for each actionpoint in the system.
// 
//  actionpt_hit_a   U Actionpoint Valid. This signals to the ARC that it
//                   should be halted since a valid actionpoint has been
//                   set when it is true.
// 
//  en_debug_r       This flag is the Enable Debug flag (ED), bit 24 in
//                   the DEBUG register. It enables the debug extensions
//                   when it is set. When it is cleared the debug
//                   extensions are switched off by gating the debug
//                   clock, but only if the option clock gating has been
//                   selected.
//
//====================================================================--
//

module debug_exts (clk,
                   clk_debug,
                   clk_ungated,
                   rst_a,                   
                   ivic,                   
                   p2b_iv,
                   p2_iw_r,
                   actionpt_pc_brk_a,
                   p2_brcc_instr_a,
                   p3_brcc_instr_a,
                   p2_ap_stall_a,
                   p2b_jmp_holdup_a,
                   en,
                   aux_access,
                   aux_read,
                   aux_write,
                   core_access,
                   h_addr,
                   h_dataw,
                   h_write,
                   h_read,
                   en1,
                   en2,
                   en2b,
                   en3,
                   ivalid_aligned,
                   mload2b,
                   mstore2b,
                   mwait,
                   p2limm,
                   p2iv,
                   p2opcode,
                   p2subopcode,
                   currentpc_r,
                   p1iw,
                   mc_addr,
                   dwr,
                   drd,
                   aux_addr,
                   aux_dataw,
                   aux_datar,
                   ap_param0,
                   ap_param1,
                   ivalid,
                   kill_tagged_p1,
                   kill_p2_a,
                   mload,
                   mstore,
                   ldvalid,
                   ap_param0_read,
                   ap_param0_write,
                   ap_param1_read,
                   ap_param1_write,
// <add more signals as appropriate>

//Signals required for extensions are inserted here. The automatic
//hierarchy generation system can be used to create the structural
//HDL to tie all the components together, provided that certain
//naming and usage rules are followed. Please see the document
//'Automatic Hierarchy Generator' - $ARCHOME/arc/docs/hiergen.pdf
//

                   actionhalt,
                   actionpt_status_r,
                   ap_ahv0,
                   ap_ahv1,
                   ap_ahv2,
                   ap_ahv3,
                   ap_ahv4,
                   ap_ahv5,
                   ap_ahv6,
                   ap_ahv7,
                   ap_ahc0,
                   ap_ahc1,
                   ap_ahc2,
                   ap_ahc3,
                   ap_ahc4,
                   ap_ahc5,
                   ap_ahc6,
                   ap_ahc7,
                   ap_ahm0,
                   ap_ahm1,
                   ap_ahm2,
                   ap_ahm3,
                   ap_ahm4,
                   ap_ahm5,
                   ap_ahm6,
                   ap_ahm7,
                   actionpt_hit_a,
                   actionpt_swi_a,
                   en_debug_r);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"

//Extra include files required for extensions are inserted here.

input   clk;        // core clock
input   clk_ungated; // ungated core clock
input   clk_debug;  // debug clock
input   rst_a;      // system reset 
input   en;         // system go

// Debugger Access via Host Interface
// 
input   aux_access; 
input   aux_read; 
input   aux_write; 
input   core_access; 
input   [31:0] h_addr; 
input   [31:0] h_dataw; 
input   h_write; 
input   h_read;

input   ivic; 
input   en1; 
input   en2; 
input   en2b; 
input   en3; 
input   ivalid_aligned; 
input   mload2b; 
input   mstore2b; 
input   mwait; 
input   p2limm; 
input   p2iv; 
input   [4:0] p2opcode;
input   [5:0] p2subopcode;

// Actionpoint Data Sources
// 
input   [PC_MSB:0] currentpc_r; 
input   [31:0] p1iw;
input   [31:0] mc_addr; 
input   [31:0] dwr; 
input   [31:0] drd; 
input   [31:0] aux_addr; 
input   [31:0] aux_dataw; 
input   [31:0] aux_datar; 
input   [31:0] ap_param0;
input   [31:0] ap_param1;

// Actionpoint Data Sources Qualifiers
// 
input   ivalid;
input   kill_tagged_p1;
input   kill_p2_a;
input   p2b_jmp_holdup_a;
input   mload; 
input   mstore; 
input   ldvalid; 
input   ap_param0_read;
input   ap_param0_write;
input   ap_param1_read;
input   ap_param1_write;
input   p2b_iv;
input   [INSTR_UBND:0] p2_iw_r;
input   p2_brcc_instr_a;
input   p3_brcc_instr_a;



// Actionpoint Debug Hardware signals
//
input   actionhalt;

output  [NUM_APS - 1:0] actionpt_status_r; 
output  [31:0] ap_ahv0;
output  [31:0] ap_ahv1;
output  [31:0] ap_ahv2;
output  [31:0] ap_ahv3;
output  [31:0] ap_ahv4;
output  [31:0] ap_ahv5;
output  [31:0] ap_ahv6;
output  [31:0] ap_ahv7;
output  [31:0] ap_ahc0;
output  [31:0] ap_ahc1;
output  [31:0] ap_ahc2;
output  [31:0] ap_ahc3;
output  [31:0] ap_ahc4;
output  [31:0] ap_ahc5;
output  [31:0] ap_ahc6;
output  [31:0] ap_ahc7;
output  [31:0] ap_ahm0;
output  [31:0] ap_ahm1;
output  [31:0] ap_ahm2;
output  [31:0] ap_ahm3;
output  [31:0] ap_ahm4;
output  [31:0] ap_ahm5;
output  [31:0] ap_ahm6;
output  [31:0] ap_ahm7;
output  p2_ap_stall_a;
output  actionpt_pc_brk_a;
output  actionpt_hit_a; 
output  actionpt_swi_a; 
output  en_debug_r;


wire    [NUM_APS - 1:0] actionpt_status_r; 
wire    actionpt_hit_a;
wire    en_debug_r;
wire    i_actionpt_hit_a;
wire    i_actionpt_swi_a;

// Signal declarations for extensions to be added.

// ====================== Debug Modes Inserted Here ===================--
// 
// Drive this signal (to debug.v) when the actionpoint extension is
// not selected.


//Drive this signal (to flags.v) when the actionpoint extension is
//not selected.
//
assign actionpt_hit_a      = i_actionpt_hit_a;
assign actionpt_swi_a      = i_actionpt_swi_a;

// Debug extension logic functions are inserted here.

// ==================== Components Instantiated Below =================--
// 
// Debug component instantiations are inserted here.
   actionpoints U_actionpoints (
   .clk_ungated(clk_ungated), 
   .clk_debug(clk_debug), 
   .rst_a(rst_a), 
   .en(en),
   .kill_p2_a(kill_p2_a),
   .en1(en1),
   .en2(en2),
   .ivic(ivic),
   .actionpt_pc_brk_a(actionpt_pc_brk_a),
   .p2_brcc_instr_a(p2_brcc_instr_a),
   .p3_brcc_instr_a(p3_brcc_instr_a),
   .p2_ap_stall_a(p2_ap_stall_a),
   .p2b_jmp_holdup_a(p2b_jmp_holdup_a),       
   .p2_iw_r(p2_iw_r), 
   .currentpc_r(currentpc_r), 
   .mc_addr(mc_addr), 
   .dwr(dwr), 
   .drd(drd), 
   .aux_addr(aux_addr), 
   .aux_dataw(aux_dataw), 
   .aux_datar(aux_datar),
   .h_addr(h_addr),
   .h_dataw(h_dataw),
   .h_write(h_write ),
   .ap_param0(ap_param0), 
   .ap_param1(ap_param1), 
   .p2iv(p2iv),
   .p2b_iv(p2b_iv), 
   .mload(mload), 
   .mstore(mstore), 
   .ldvalid(ldvalid), 
   .aux_write(aux_write),
   .aux_read(aux_read), 
   .ap_param0_read(ap_param0_read), 
   .ap_param0_write(ap_param0_write), 
   .ap_param1_read(ap_param1_read), 
   .ap_param1_write(ap_param1_write), 
   .aux_access(aux_access),
   .actionhalt(actionhalt),
   .ap_ahv0(ap_ahv0), 
   .ap_ahv1(ap_ahv1), 
   .ap_ahv2(ap_ahv2), 
   .ap_ahv3(ap_ahv3), 
   .ap_ahv4(ap_ahv4), 
   .ap_ahv5(ap_ahv5), 
   .ap_ahv6(ap_ahv6), 
   .ap_ahv7(ap_ahv7), 
   .ap_ahc0(ap_ahc0),
   .ap_ahc1(ap_ahc1),
   .ap_ahc2(ap_ahc2),
   .ap_ahc3(ap_ahc3),
   .ap_ahc4(ap_ahc4),
   .ap_ahc5(ap_ahc5),
   .ap_ahc6(ap_ahc6),
   .ap_ahc7(ap_ahc7),
   .ap_ahm0(ap_ahm0),
   .ap_ahm1(ap_ahm1),
   .ap_ahm2(ap_ahm2),
   .ap_ahm3(ap_ahm3),
   .ap_ahm4(ap_ahm4),
   .ap_ahm5(ap_ahm5),
   .ap_ahm6(ap_ahm6),
   .ap_ahm7(ap_ahm7),
   .actionpt_status_r(actionpt_status_r), 
   .actionpt_swi_a(i_actionpt_swi_a), 
   .actionpt_brk_a(i_actionpt_hit_a), 
   .en_debug_r(en_debug_r)); 

endmodule // module debug_exts

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1999-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// Auxiliary Timer Counter
// 
// ======================= Inputs to this block =======================--
// 
//  aux_write - write strobe for aux register access
//  aux_addr - address for aux register access
//  aux_dataw - data for aux register access
// 
// ====================== Output from this block ======================--
// 
//  timer_r - current timer count value
//  tlimit_r - wrap around limit for the timer
//  timer_pirq_r - flag to indicate a pending interrupt by the timer
//  tcontrol_r - when set enables generation of interrupt
//  timer_mode_r - when set enables cycle count when ARC not halted
//  l_irq_3 - timer interrupt signal
//  timer_clr_r - timer watchdog reset signal
//  twatchdog_r - when set enables generation of watchdog reset
//
// ====================================================================--
//
module timer0 (clk_ungated,
	       rst_a, 
               en,
               aux_write,
               aux_addr,
               aux_dataw,
               timer_r,
               tlimit_r,
               timer_pirq_r,
               tcontrol_r,
               timer_mode_r,
               l_irq_3,
               timer_clr_r,
               twatchdog_r);

`include "arcutil_pkg_defines.v" 
`include "extutil.v" 
`include "xdefs.v"

   input   clk_ungated; 
   input rst_a;
   input   en; 
   input   aux_write; 
   input   [31:0] aux_addr; 
   input   [31:0] aux_dataw; 

   output  [TIMER_MSB:0] timer_r; 
   output  [TIMER_MSB:0] tlimit_r;
   output  timer_pirq_r; 
   output  tcontrol_r; 
   output  timer_mode_r; 
   output  l_irq_3; 
   output  timer_clr_r; 
   output  twatchdog_r; 


   wire    [TIMER_MSB:0] timer_r; 
   wire    [TIMER_MSB:0] tlimit_r;
   wire    timer_pirq_r; 
   wire    tcontrol_r; 
   wire    timer_mode_r; 
   reg     l_irq_3; 
   reg     timer_clr_r; 
   wire    twatchdog_r; 

   wire    [TIMER_MSB:0] i_timer_plus1_a; 
   reg     [TIMER_MSB:0] i_timer_r; 
   reg     [TIMER_MSB:0] i_tlimit_r; 
   reg     i_timer_mode_r; 
   reg     i_timer_pirq_r; 
   reg     i_tcontrol_r; 
   reg     i_twatchdog_r; 


   //  A simple incrementer whose output is latched into the count register
   //  according to the timer mode at every cycle. Note the adder is 1 bit
   //  longer than the maximum range of the timer.
   // 
   assign i_timer_plus1_a = i_timer_r + 1'b 1; 

always @(posedge clk_ungated or posedge rst_a)
   begin : timer_PROC
   if (rst_a == 1'b1) 
         begin
         // if reset is asserted then clear the timer count register and the control
         // flip-flops. The limit register is set to 0x00ffffff for backward 
         // compatibility with the 24 bit timer and both the interrupt and watchdog 
         // signals are cleared as well
         //
         i_timer_r       <= {(TIMER_WIDTH){1'b 0}};
         i_tlimit_r      <= 32'b 00000000111111111111111111111111;
         i_timer_pirq_r  <= 1'b 0;
         i_tcontrol_r    <= 1'b 0;
         i_timer_mode_r  <= 1'b 0;
         i_twatchdog_r   <= 1'b 0;
         l_irq_3 <= 1'b 0;
         timer_clr_r     <= 1'b 0;
         end
      else
         begin
         // If there is a write to the count value then update the internal count
         // else check if the timer count has reached the limit value, if so then
         // clear the timer count register and generate either the watchdog or
         // interrupt signals. Note that there is no need to generate the 
         // interrupt signal if the watchdog signal is to be asserted else check
         // if we are we are free running mode or in not free running mode and not 
         // halted - if so then the timer can take the incremented value from the 
         // adder.
         //
         if (auxdc(aux_addr, aux_timer) == 1'b 1 & aux_write == 1'b 1)
            begin
            i_timer_r <= aux_dataw[TIMER_WIDTH - 1:0];
            end
         else if (i_timer_r == i_tlimit_r)
            begin
            i_timer_r <= {(TIMER_WIDTH){1'b 0}};
            if (i_twatchdog_r == 1'b 1)
               begin
               timer_clr_r <= 1'b 1;
               end
            else if (i_tcontrol_r == 1'b 1 )
               begin
               l_irq_3 <= 1'b 1;
               i_timer_pirq_r  <= 1'b 1;
               end
            end
         else if (i_timer_mode_r == 1'b 0 | (i_timer_mode_r & en) == 1'b 1 )
            begin
            i_timer_r <= i_timer_plus1_a;
            end

         // If there is a write to the timer control register then first remove
         // any pending interrupts (that is how interrupts are cleared). Note
         // that there is no need to remove the watchdog reset since a reset
         // automatically update the timer. Next register the new value by
         // updating the control flipflops. If the write is to the limit register
         // then update the internal limit register
         //
         if (auxdc(aux_addr, aux_tcontrol) == 1'b 1 & aux_write == 1'b 1)
            begin
            l_irq_3 <= 1'b 0;
            i_timer_pirq_r  <= 1'b 0;
            i_tcontrol_r    <= aux_dataw[0];
            i_timer_mode_r  <= aux_dataw[1];
            i_twatchdog_r   <= aux_dataw[2];
            end
         else if (auxdc(aux_addr, aux_tlimit) == 1'b 1 & aux_write == 1'b 1 )
            begin
            i_tlimit_r <= aux_dataw;
            end
         else
            i_tlimit_r <= i_tlimit_r;
      end
   end

   //  update the output signals according to internal signal
   // 
   assign timer_r      = i_timer_r; 
   assign tlimit_r     = i_tlimit_r; 
   assign timer_mode_r = i_timer_mode_r; 
   assign timer_pirq_r = i_timer_pirq_r; 
   assign tcontrol_r   = i_tcontrol_r; 
   assign twatchdog_r  = i_twatchdog_r; 

endmodule // module timer0

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains the status register flag bits including the
// global run signal, en.
//
//
// Bit positions in the program counter/status register:
//
//              +-31----30----29----28-----27-----26----25--+
//              |     |     |     |     |      |      |     |
//              |  Z  |  N  |  C  |  V  |  E2  |  E1  |  H  |
//              |     |     |     |     |      |      |     |
//              +-------------------------------------------+
//
//
//
// Bit positions in the status32 register:
//
//       +-11---10---09---08---07---06---05---04---03---02---01---0-+
//       |    |    |    |    |    |    |    |    |    |    |    |   |
//       | Z  | N  | C  | V  | Rd | Rd | Rd | Rd | Rd | E2 | E1 | H |
//       |    |    |    |    |    |    |    |    |    |    |    |   |
//       +----------------------------------------------------------+
//
//
//======================= Inputs to this block =======================--
//
// clk              Global Clock.
//  
// rst_a            Global Reset (active high).
//
// arc_start_a      This signal defines whether the ARC starts running
//                  on reset, or goes into a halted state. When it is
//                  set to '1' the ARC will start running code from the
//                  reset vector onwards after a reset. It should be
//                  fixed at '1' for start-on-reset or at '0' for
//                  halt-on-reset.
//
// ctrl_cpu_start_r This signal comes from the 'ctrl_cpu_start' input
//                  and will start the ARC running when it is halted.
//
// step             From debug. Do a single step on the next cycle, if
//                  the ARC is stopped.
//
// inst_step        When this signal is set at the same time as the step
//                  signal is set a single instruction step occurs. Only
//                  one instruction is fetched and allowed to complete.
//
// halt             From top level. When this signal is set true, the
//                  ARC will stop running on the next cycle.
//
// aux_dataw[31:0]  from hostif. This is the auxiliary register bus 
//                  write data value.
//
// aux_write        from hostif. This signal indicates that a write
//                  (either from the ARC or host) is being performed to
//                  the auxiliary register specified on aux_addr[31:0].
//
// h_dataw[31:0]    from mc/host. Data from the host to be stored into
//                  registers in the ARC/extensions.
//
// h_write          from mc/host. When it is true, this signal indicates
//                  that a host write is taking place.
//
// h_pchit          This is from auxregs, and is true when h_addr =
//                  ax_pc and aux_access = '1'.
//
// h_status32hit
//                  This is from auxregs, and is true when h_addr =
//                  ax_status32 and aux_access = '1'.
//
// h_dbhit          This is from auxregs, and is true when h_addr =
//                  ax_debug and aux_access = '1'.
//
// xflags[3:0]      from extensions. This contains alu result flags from
//                  the extension alu(s). It is loaded into the flags
//                  when there is an extension instruction at stage 3
//                  which wants to set the flags, provided that the
//                  appropriate pipeline enables are also true.
//                  In addition, the xsetflags signal can be used to
//                  force the flags to be loaded from xflags[].
//  
// x_flgen          Extension basecase flag update. This signal is true
//                  when any extension wants to update the basecase
//                  flags.
//
// xsetflags        from extensions. Load xflags[3:0] into aluflags_r_r
//                  at the end of the cycle, provided that extension-
//                  alu-flag-setting has been globally enabled in
//                  extutil, and that the enable for pipeline stage 3
//                  is valid, and the instruction in stage 3 is an
//                  extension instruction (x_idecode3 is true). This
//                  allows the extensions to override the normal flag
//                  -setting logic in rctl.
//
//  x_idecode3      From extensions. This signal will be true when the
//                  extension logic detects an extension instruction in
//                  stage 3. It is latched from x_idecode2 by the
//                  extensions when en2 is true at the end of a cycle.
//                  It is used to correctly generate p3condtrue,
//                  p3setflags, and to detect (along with xnwb) when a
//                  register writeback will take place.
//
// actionpt_hit_a   From debug_exts. This signal is the output of the
//                  OR-plane for the actionpoint debug hardware. When it
//                  is '1' it signifies that a valid condition has been
//                  detected, and the ARC should be halted. This is part
//                  of the actionpoint extension.
//
// p4_disable_r     From rctl module. This signals to the ARC that the
//                  pipeline has been flushed due to a breakpoint or
//                  sleep instruction. If it was due to a breakpoint
//                  instruction the ARC is halted via the 'en' bit, and
//                  the AH bit is set to '1' in the debug register.
//
// brk_inst_a       From rctl. This signals to the ARC that a
//                  breakpoint instruction has been detected in stage
//                  one of the pipeline. Hence, the halt bit in the flag
//                  register has to be updated in addition to the BH bit
//                  in the debug register. The pipeline is stalled when
//                  this signal is set to '1'.
//
//                  Note: The pipeline is flushed of instructions when
//                  the breakpoint instruction is detected, and it is
//                  important to disable each stage explicity. A normal
//                  instruction in stage one will mean that instructions
//                  in stage two, three and four will be allowed to
//                  complete. However, for an instruction in stage one 
//                  which is in the delay slot of a branch, loop or jump
//                  instruction means that stage two has to be stalled 
//                  as well. Therefore, only stages three and four will
//                  be allowed to complete.
//
// debug_if_r       Debug Memory Access. This is asserted true when a debug
//                  access to memory is in progress.
//
// p2b_opcode[4:0]  From rctl. Pipeline stage 2 instruction opcode word.
//
// p2b_iv           from rctl module, this signal indicates that the
//                  instruction opcode supplied in p2b_opcode is valid,
//                  as we allow blank slots to flow through the
//                  pipeline under certain conditions, and we don't
//                  want these phantom instructions to affect the state
//                  of the processor.
//
// p2int            from rctl, indicates that stage 2 contains an
//                  interrupt jump instruction, and that the pc should 
//                  be loaded with the address from the interrupt vector
//                  bus int_vec[31:0].
//
//
// instr_pending_r  This signal is true when an instruction fetch has
//                  been issued, and it has not yet completed. It is
//                  not true directly after a reset before the ARC has
//                  started, as no instruction fetch will have been
//                  issued. It is used to hold off host writes to the
//                  program counter when the ARC is halted, as these
//                  accesses will trigger an instruction fetch. Used
//                  here to prevent the PC from being updated when a
//                  host access is being held off.
//
// p2b_condtrue     from rctl, indicates that the instruction in stage 2
//                  has a branch/jump condition which is true, hence the
//                  jump will be taken provided that pcen is true.
//
// p2b_setflags     from rctl, this is the .F bit from the instruction
//                  word in stage 2. It is used to determine whether the
//                  flags should be loaded at the same time as the pc
//                  when doing a Jcc instruction.
//
// p2bint           Indicates that an interrupt-op instruction is in
//                  stage 2B. 
// 
// p3ilev1          from rctl, this is used in conjunction with p3int to 
//                  indicate which level of interrupt is being
//                  processed, and hence which of the interrupt mask
//                  bits should be cleared. It comes from bit 7 of the
//                  jump instruction word, which is set when a level1
//                  (lowest level) interrupt is being processed.
//
// p3int            from rctl, indicates that stage 3 contains an
//                  interrupt jump instruction, and that the appropriate
//                  interrupt mask bits should be cleared.
//
// p3iv             from rctl, this signal indicates that the
//                  instruction opcode supplied in p3opcode is valid,
//                  as we allow blank slots to flow through the
//                  pipeline under certain conditions, and we don't want
//                  these phantom instructions to affect the state of
//                  the processor.
//
// p3condtrue       from rctl. This signal is used in flags to control
//                  loading of flags with regular conditional
//                  instructions (ie not jumps/branches/loops etc). It
//                  is set according to whether the condition specified
//                  in the instruction's cc field is true, but if the
//                  instruction does not have a cc field (e.g. short
//                  immediate data) then it is always true.
//
// p3_docmprel_a    A mispredicted BRcc of BBITx has been taken by the ARC
//                  processor in stage 3. The corrective action will be taken
//                  in stage 4 where the correct PC will be presented at the
//                  instruction fetch interface.
//
// pcounter_jmp_restart_a    This signal is true when a delayed control
//                           transfer is pending.  If a control transfer
//                           is resolved and the Instruction cache system
//                           is busy fetching i.e. there is no
//                           instruction in stage 1 ivalid_aligned = '0'
//                           then the cache cannot accept any more
//                           fetches.  This is reconised and this bit is
//                           set, when the cache becomes free the machine
//                           will do the program counter update.
//
// p3setflags       from rctl. This signal is used by regular alu-type
//                  instructions and the jump instruction to control
//                  whether the supplied flags get stored. It is
//                  produced from the set-flags bit in the instruction
//                  word, but if that field is not present in the
//                  instruction (e.g. short immediate data is being
//                  used) then it will either come from the set-flag
//                  modes implied by which short immediate data register
//                  is used, or it will be set false if the instruction
//                  does not affect the flags.
//
// en3              from rctl, this is the stage 3->4 pipeline enable.
//
// s2val[31:0]      Stage 3 operand B value (latched by stage 2,
//                  including any shortcuts which may be appropriate).
//
// alurflags[3:0]   from the ALU. These signals are the flags produced
//                  by the ARC's alu after doing the calculations
//                  required by the instruction currently in stage 3.
//
// stop_step        This signal is set when the single instruction step
//                  has finished.
//
//====================== Output from this block ======================--
//
// aluflags_r       To the ALU. Direct from the latches, the Z N C V
//                  flags supplied to the ALU in stage 3.
//
// e1flag_r         Direct from the latch, the interrupt level 1 mask
//                  bit.
//
// e2flag_r         Direct from the latch, the interrupt level 2 mask
//                  bit.
//
// en_r             The global run bit.
//
// starting         This signal indicates that the ARC is starting, i.e.
//                  en goes high. It is used in debug to clear the sleep
//                  mode flag (bit 23) in the debug register on restart.
//
// selfhalt_r       Direct from the latch, this signal is set when the
//                  ARC is stopped, to show whether the ARC halted
//                  itself by using the FLAG instruction. It can be read
//                  from the debug register. The purpose is to handle
//                  the case when a 'stop' FLAG instruction is being
//                  single-stepped.
//
// actionhalt       From flags. This signal is set true when the
//                  actionpoint (if selected) has been triggered by a
//                  valid condition. The ARC pipeline is halted and
//                  flushed when this signal is '1'.
//
//                  Note: The pipeline is flushed of instructions when
//                  the breakpoint instruction is detected, and it is
//                  important to disable each stage explicity. A normal
//                  instruction in stage one will mean that instructions
//                  in stage two, three and four will be allowed to
//                  complete. However, for an instruction in stage one 
//                  which is in the delay slot of a branch, loop or jump 
//                  instruction means that stage two has to be stalled 
//                  as well. Therefore, only stages three and four will
//                  be allowed to complete.
//
// breakhalt_r      To debug. This signal is set true when the
//                  breakpoint (BRK) instruction has been detected in 
//                  stage one of the pipeline. The ARC pipeline is
//                  halted and flushed when this signal is '1'.
//
//                  Note: The pipeline is flushed of instructions when
//                  the breakpoint instruction is detected, and it is
//                  important to disable each stage explicity. A normal
//                  instruction in stage one will mean that instructions
//                  in stage two, three and four will be allowed to
//                  complete. However, for an instruction in stage one
//                  which is in the delay slot of a branch, loop or jump
//                  instruction means that stage two has to be stalled
//                  as well. Therefore, only stages three and four will
//                  be allowed to complete.
//
// do_inst_step_r   This signal is set when the single step flag (SS)
//                  and the instruction step flag (IS) in the debug
//                  register has been written to simultaneously through
//                  the host interface. It indicates that an instruction
//                  step is being performed. When the instruction step
//                  has finished this signal goes low.
//
//====================================================================--
//
module flags (clk,
              rst_a,
              actionpt_hit_a,
                actionpt_pc_brk_a,
              ctrl_cpu_start_r,
              arc_start_a,
              halt,
              step,
              inst_step,
              aux_dataw,
              aux_l1_wr,
              aux_l2_wr,
              h_dataw,
              h_write,
              h_pchit,
              h_dbhit,
              h_l1_wr,
              h_l2_wr,
              h_pcwr,
              h_status32hit,
              h_status32wr,
              xflags,
              x_flgen,
              xsetflags,
              x_idecode3,
              xcache_hold_host,
              brk_inst_a,
              en2b,
              fs2a,
              instr_pending_r,
              p1int,
              p2int,
              p2b_opcode,
              p2b_subopcode,
              p2b_iv,
              p2b_condtrue,
              p2b_setflags,
              p2bint,
              p4_disable_r,
              p3_flag_instr,
	      p3_sync_instr,
              p3iv,
              p3condtrue,
              p3_docmprel_a,
              p3setflags,
              p3int,
              p3ilev1,
              p3wba,
              en3,
              sleeping,
              s2val,
              alurflags,
              stop_step,
              debug_if_r,
              debug_if_a,	      
              x_multic_busy,
              pcounter_jmp_restart_a,

              aluflags_nxt,
              aluflags_r,
              do_inst_step_r,
              en_r,
              e1flag_r,
              e2flag_r,
              hold_host_intrpt_a,
              hold_host_multic_a,
              host_write_en_n_a,
              status32_l1_r,
              status32_l2_r,
              starting,
              breakhalt_r,
              actionhalt,
              selfhalt_r);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"

   input                   clk; //  system clock
   input                   rst_a; //  system reset
   input                   actionpt_hit_a; 
   input                   actionpt_pc_brk_a;
   input                   ctrl_cpu_start_r;
   input                   arc_start_a; 
   input                   halt; 
   input                   step; 
   input                   inst_step; 
   input [DATAWORD_MSB:0]  aux_dataw; 
   input                   aux_l1_wr; 
   input                   aux_l2_wr; 
   input [DATAWORD_MSB:0]  h_dataw; 
   input                   h_write; 
   input                   h_pchit; 
   input                   h_dbhit; 
   input                   h_l1_wr; 
   input                   h_l2_wr; 
   input                   h_pcwr; 
   input                   h_status32hit; 
   input                   h_status32wr; 
   input  [3:0]            xflags; 
   input                   x_flgen; 
   input                   xsetflags; 
   input                   x_idecode3; 
   input                   xcache_hold_host; 
   input                   brk_inst_a; 
   input                   en2b; 
   input  [5:0]            fs2a; 
   input                   instr_pending_r; 
   input                   p1int;
   input                   p2int;
   input  [4:0]            p2b_opcode; 
   input  [5:0]            p2b_subopcode; 
   input                   p2b_iv; 
   input                   p2b_condtrue; 
   input                   p2b_setflags; 
   input                   p2bint;
   input                   p4_disable_r; 
   input                   p3_flag_instr;
   input                   p3_sync_instr; 
   input                   p3iv; 
   input                   p3condtrue; 
   input                   p3_docmprel_a; 
   input                   p3setflags; 
   input                   p3int; 
   input                   p3ilev1; 
   input  [5:0]            p3wba; 
   input                   en3; 
   input                   sleeping;
   input  [DATAWORD_MSB:0] s2val; 
   input  [3:0]            alurflags; 
   input                   stop_step; 
   input                   debug_if_r;
   input                   debug_if_a;   
   input                   x_multic_busy;
   input                   pcounter_jmp_restart_a;

   output [3:0]            aluflags_nxt; 
   output [3:0]            aluflags_r; 
   output                  do_inst_step_r; 
   output                  en_r; //  system go
   output                  e1flag_r; 
   output                  e2flag_r;
   output                  hold_host_intrpt_a;
   output                  hold_host_multic_a;
   output                  host_write_en_n_a;
   output [DATAWORD_MSB:0] status32_l1_r; 
   output [DATAWORD_MSB:0] status32_l2_r; 
   output                  starting; 
   output                  breakhalt_r; 
   output                  actionhalt; 
   output                  selfhalt_r; 

   wire   [3:0]            aluflags_nxt; 
   wire   [3:0]            aluflags_r; 
   wire                    do_inst_step_r; 
   wire                    en_r; 
   wire                    e1flag_r; 
   wire                    e2flag_r; 
   wire   [DATAWORD_MSB:0] status32_l1_r; 
   wire   [DATAWORD_MSB:0] status32_l2_r; 
   
   //  signals from debug extensions (debug_exts)
   wire                    starting;
   wire                    breakhalt_r; 
   wire                    actionhalt; 
   wire                    selfhalt_r; 

   //====================================================================--

   reg                     i_actionhalt_nxt; 
   reg                     i_actionhalt_r;
   wire   [3:0]            i_aluflags_nxt; 
   reg    [3:0]            i_aluflags_r; 
   wire                    i_alurload_a; 
   wire                    i_breakhalt_nxt; 
   reg                     i_breakhalt_r;
   reg                     i_do_inst_step_r;
   wire                    i_dostep_nxt; 
   reg                     i_dostep_r; 
   wire                    i_e1flag_nxt; 
   reg                     i_e1flag_r; 
   wire                    i_e2flag_nxt; 
   reg                     i_e2flag_r; 
   wire                    i_en_nxt; 
   reg                     i_en_r; 
   wire                    i_extload_a; 
   wire                    i_h_db_halt_a; 
   wire                    i_h_en_write_a; 
   wire                    i_h_en_write32_a; 
   wire                    i_hold_host_intrpt_a;
   wire                    i_hold_host_multic_a;
   wire                    i_hostwrite_a; 
   wire                    i_hostwrite32_a;
   wire                    i_host_write_en_a;
   wire                    i_host_write_en_n_a;
   wire                    i_dojcc_a; 
   wire                    i_doflag_a; 
   wire                    i_doint_a; 
   wire                    i_no_flag_change_a;
   wire                    i_one_a; 
   wire                    i_postrst_a; 
   wire                    i_p3do_ilink1_nxt;
   reg                     i_p3do_ilink1_r;
   wire                    i_p3do_ilink2_nxt;
   reg                     i_p3do_ilink2_r;
   wire                    i_p3_ext_flagset_a; 
   wire                    i_p3xaluop_a; 
   reg                     i_r1q_r; 
   reg                     i_r2q_r; 
   wire                    i_selfhalt_nxt; 
   reg                     i_selfhalt_r; 
   wire   [DATAWORD_MSB:0] i_status32_l1_r;
   wire   [DATAWORD_MSB:0] i_status32_l2_r;
   wire   [AX_ST32_Z_N:0]  i_status_l1_nxt;
   reg    [AX_ST32_Z_N:0]  i_status_l1_r;
   wire   [AX_ST32_Z_N:0]  i_status_l2_nxt;
   reg    [AX_ST32_Z_N:0]  i_status_l2_r;
   wire                    i_starting_a;
   wire                    i_valid_en_write_a;
   wire                    i_intrpt_a;
   wire                    i_ctrl_cpu_start_a;
   reg                     i_cpu_start_r;
   wire                    i_cpu_start_a;
   wire                    i_debug_access_a;   

   // Constant tied high.
   //
   assign i_one_a = 1'b 1; 

   //  The flags are loaded by the jump instruction (at stage 2) when the
   //  PC is being loaded, but only if the .F option is used, thus setting
   //  p2b_setflags.
   //
   assign i_dojcc_a = ((p2b_opcode == OP_FMT1)      &
                       ((p2b_subopcode == SO_J) |
                        (p2b_subopcode == SO_J_D))    &
                        ((p2b_condtrue & p2b_iv) ==  1'b 1) &
                        ((p2b_setflags & en2b) == 1'b 1)) ?  1'b 1 : 
          1'b 0; 

   //  Here we set the flags from jump at stage 3, rather than stage 2.
   //  This allows JLcc.f to operate correctly, storing the present 
   //  flags, and restoring the flag values from the jump value.
   // 
   assign i_p3do_ilink1_nxt = ((i_dojcc_a == 1'b 1) &&
                               (fs2a == RILINK1)) ? 1'b 1 :
          1'b 0;

   assign i_p3do_ilink2_nxt = ((i_dojcc_a == 1'b 1) &&
                               (fs2a == RILINK2)) ?  1'b 1 :
          1'b 0;


   always @(posedge clk or posedge rst_a)
     begin : p3ilink_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_p3do_ilink1_r <= 1'b 0; 
             i_p3do_ilink2_r <= 1'b 0; 
          end
        else
          begin
             // Latch i_p3do_ilinkX_nxt into stage 3 if stage 2 enabled.
             // 
             if (en2b == 1'b 1)
               begin
                  i_p3do_ilink1_r <= i_p3do_ilink1_nxt;  
                  i_p3do_ilink2_r <= i_p3do_ilink2_nxt;  
               end
          end
     end

   //  Status register flag bits, ** including the global run signal en **
   //
   // Bit positions in the program counter/status register:
   //
   //              +-31----30----29----28-----27-----26----25--+
   //              |     |     |     |     |      |      |     |
   //              |  Z  |  N  |  C  |  V  |  E2  |  E1  |  H  |
   //              |     |     |     |     |      |      |     |
   //              +-------------------------------------------+
   //
   //
   //
   // Bit positions in the status32 register:
   //
   //       +-11---10---09---08---07---06---05---04---03---02---01---0-+
   //       |    |    |    |    |    |    |    |    |    |    |    |   |
   //       | Z  | N  | C  | V  | Rd | Rd | Rd | Rd | Rd | E2 | E1 | H |
   //       |    |    |    |    |    |    |    |    |    |    |    |   |
   //       +----------------------------------------------------------+
   //
   //
   //  Load flags (alu & interrupt mask flags) from the host register bus
   //  (i.e. from host) when h_addr=ax_pc and it's a write, and the ARC is
   //  stopped. ** Note that the H bit (en) is not loaded from the aux
   //  register bus, but directly from the host interface bus, as it can be
   //  written when the ARC is running. **
   //  .. and don't update when there is an instruction fetch pending, and
   //  the ARC is stopped, as the host write will be held off with hold_host.
   // 
   //  This signal uses the h_pcwr signal from aux_regs.v, which includes
   //  the stall condition xcache_hold_host - in order to prevent the flags 
   //  from updating before a cache-generated host stall has been removed.
   //
   assign i_hostwrite_a = h_pcwr; 
   assign i_hostwrite32_a = h_status32wr; 

   //  Load flags from xflags[3:0] when the extensions force us to
   //  (xsetflags), the risc control unit says we can (en3) and when the
   //  designer of the extensions has allowed forced flag setting to be
   //  performed (XT_ALUFLAGS), and when the instruction in stage 3 is an
   //  extension instruction, or when a regular extension ALU instruction
   //  is being executed, and p3setflags is true.
   //
   //  ** Note that XT_ALUFLAGS is a constant set in extutil **
   //
   //  Determine whether stage 3 contains a valid extension instruction.
   //
   assign i_p3xaluop_a = (x_flgen & XT_ALUOP); 

   //  Determine whether there is a flag-set request.
   //
   assign i_p3_ext_flagset_a = (xsetflags & XT_ALUFLAGS | p3setflags); 

   //  Calculate whether we want to set flags from xflags[3:0].
   //
   assign i_extload_a = (i_p3xaluop_a & i_p3_ext_flagset_a) ;
   

   //  Load the ALU result flags when: a) the instruction's condition was
   //                                     true
   //                             and  b) flag-setting was requested
   //                                     somehow
   //                             and  c) the cycle is being allowed to
   //                                     complete
   //                             and  d) not an extension instruction.
   // 
   //                             and  e) not a Jcc.f [ilinkX].
   //
   //                             and  f) not a flag instruction.
   //
   //                             and  g) not a sync instruction.
   //
   //                             and  h) not a host write
   //
   assign i_alurload_a = (en3 & 
                          p3condtrue & 
                          p3setflags & 
                          p3iv & 
                          (~x_idecode3) &
                          (~i_p3do_ilink1_r) &
                          (~i_p3do_ilink2_r) &
                          (~p3_flag_instr) &
			  (~p3_sync_instr) & 
                          (~i_hostwrite_a) &
                          (~i_hostwrite32_a))   ;
   
   //  Load the ALU flags from the stage 3 operand b (s2val) bus when it's
   //  a valid FLAG instruction and when any condition is true (p3condtrue).
   // 
   //  The aluflags_r and interrupt mask bits are not set when the H bit is
   //  being set. (This allows for starting and stopping the ARC using the
   //  FLAG instruction without messing up the rest of the flags).
   //
   assign i_doflag_a = (p3_flag_instr & p3iv & p3condtrue & en3); 

   //   Clear one or both of the interrupt mask bits at the same time as the 
   //   PC is being loaded with the interrupt vector.
   //
   assign i_doint_a = (p3int & en3);
   
   
   assign i_no_flag_change_a = ~(i_hostwrite_a     |
                                 i_hostwrite32_a   |
                                 i_p3do_ilink1_r   |
                                 i_p3do_ilink2_r   |
                                 i_extload_a       |
                                 (i_doflag_a
                                  &
                                  (~s2val[F_H_N])) |
                                 i_alurload_a);
   
   //  Make the new values for Z N C V //
   //
   assign i_aluflags_nxt = ((h_dataw[31:28] & {(FOUR){i_hostwrite_a}})
                            |
                            (h_dataw[STATUS32_Z_N:
                                    STATUS32_V_N] & {(FOUR){i_hostwrite32_a}}) 
                            | 
                            (i_status_l1_r[AX_ST32_Z_N:
                                          AX_ST32_V_N] & {(FOUR){i_p3do_ilink1_r}})
                            |
                            (i_status_l2_r[AX_ST32_Z_N:
                                          AX_ST32_V_N] & {(FOUR){i_p3do_ilink2_r}}) 
                            | 
                            (xflags & {(FOUR){i_extload_a}}) 
                            |
                            (s2val[F_Z_N:F_V_N] & {(FOUR){(i_doflag_a &
                                                       ~s2val[F_H_N])}} )
                            |
                            (alurflags & {(FOUR){i_alurload_a}}) 
                            |
                            (i_aluflags_r &  {(FOUR){i_no_flag_change_a}})); 

   //  Make the new value for the interrupt level 1 mask bit //
   // 
   assign i_e1flag_nxt = ((i_p3do_ilink1_r & en3) == 1'b 1)     ?
          i_status_l1_r[AX_ST32_E1_N] : 
                         ((i_p3do_ilink2_r & en3) == 1'b 1)     ?
          i_status_l2_r[AX_ST32_E1_N] : 
                         (i_hostwrite_a          == 1'b 1)    ?
          h_dataw[SR_E1_N] : 
                         (i_hostwrite32_a        == 1'b 1)    ?
          h_dataw[STATUS32_E1_N] : 
                         (i_doint_a              == 1'b 1)    ?
          1'b 0 : 
                         ((i_doflag_a             == 1'b 1) &&
                          (s2val[F_H_N]           == 1'b 0) &&
                          (en3                    == 1'b 1))    ?
          s2val[F_E1_N] : 
                          ((sleeping              == 1'b 1) &&
                           (en3                   == 1'b1))     ?
          (s2val[0] | i_e1flag_r) :
          i_e1flag_r; 


   //  Make the new value for the interrupt level 2 mask bit //
   //  ** Note that a level 1 interrupt (p3ilev1 = '1') does not clear the
   //     e2 bit **
   //
   assign i_e2flag_nxt = ((i_p3do_ilink1_r & en3) == 1'b 1)    ?
          i_status_l1_r[AX_ST32_E2_N] :
                         ((i_p3do_ilink2_r & en3) == 1'b 1)    ?
          i_status_l2_r[AX_ST32_E2_N] : 
                         (i_hostwrite_a          == 1'b 1)   ?
          h_dataw[SR_E2_N] : 
                         (i_hostwrite32_a        == 1'b 1)   ?
          h_dataw[STATUS32_E2_N] : 
                         ((i_doint_a              == 1'b 1) &&
                          ((~p3ilev1)             == 1'b 1))   ?
          1'b 0 : 
                         ((i_doflag_a             == 1'b 1) &&
                          (s2val[F_H_N]           == 1'b 0) && 
                          (en3                    == 1'b 1))   ?
          s2val[F_E2_N] : 
                          ((sleeping              == 1'b 1) &&
                           (en3                   == 1'b1))    ?
          (s2val[1] | i_e2flag_r) :
          i_e2flag_r; 


   //======================== en Generation Logic =======================--
   // 
   //  Produce a signal which is true during the cycle following a reset.
   //  This signal is used to load the required value into en to allow the
   //  ARC to start running after a reset.
   // 
   //  Two latches are used here so that i_postrst_a is true for a whole
   //  cycle, and to reduce the possibility of metastable states due to the 
   //  likely asynchronous nature of the reset line.
   // 
   always @(posedge rst_a or posedge clk)
     begin : r1l_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_r1q_r <= 1'b 0; 
          end
        else
          begin
             i_r1q_r <= i_one_a;   
          end
     end

   always @(posedge rst_a or posedge clk)
     begin : r2l_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_r2q_r <= 1'b 0; 
          end
        else
          begin
             i_r2q_r <= i_r1q_r;   
          end
     end

   assign i_postrst_a = (i_r1q_r & (~i_r2q_r)); 


   //  Single stepping functions.
   // 
   //  Step only when the ARC is stopped, and stop again on the following
   //  cycle provided that the host has not modified the en bit.
   // 
   //  *** Note that if an instruction which writes '0' to the H bit is
   //  executed, it will be ignored, and the processor will go back into the
   //  halted state.
   // 
   assign i_dostep_nxt = (step & ~i_en_r); 

   always @(posedge rst_a or posedge clk)
     begin : step_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_dostep_r <= 1'b 0;  
          end
        else
          begin
             i_dostep_r <= i_dostep_nxt;   
          end
     end

   //  If the Instruction Step flag (IS) in the debug register is written to
   //  as the same time as the Single Step flag (SS) an instruction step
   //  will be performed.
   //
   always @(posedge rst_a or posedge clk)
     begin : inst_step_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_do_inst_step_r <= 1'b 0;    
          end
        else
          begin
             if ((step      == 1'b 1) &&
                 (i_en_r    == 1'b 0) &&
                 (inst_step == 1'b 1))
               begin
                  i_do_inst_step_r <= 1'b 1; 
               end
             else if (stop_step == 1'b 1)
               begin
                  i_do_inst_step_r <= 1'b 0; 
               end
          end
     end

   // There is an interrupt in the processor pipeline.
   //
   assign i_intrpt_a = p1int | p2int | p2bint | p3int;

   assign i_valid_en_write_a = h_write &
                               (~xcache_hold_host) & 
                               (~(instr_pending_r & ~i_en_r)) &
                               (~(i_intrpt_a & i_en_r)) &
                               (~x_multic_busy);


   //  The halt bit can be loaded at any time by the host processor
   // 
   //  Now includes xcache_hold_host signal to ensure that host pc/status
   //  writes can be stalled by the instruction cache system. It also checks
   //  for interrupts when the processor is running.
   // 
   assign i_h_en_write_a = ((h_pchit            == 1'b 1) &&
                            (i_valid_en_write_a == 1'b 1)) ?  1'b 1 : 
          1'b 0; 

   assign i_h_en_write32_a = ((h_status32hit      == 1'b 1) &&
                              (i_valid_en_write_a == 1'b 1)) ? 1'b 1 : 
          1'b 0; 

   // Clear the actionpoint halt when restarting the processor.
   //
   assign i_host_write_en_a = (i_h_en_write_a &
                              (~h_dataw[SR_H_N]) &
                              (~debug_if_r)) |
                              (i_h_en_write32_a & 
                              (~h_dataw[STATUS32_EN_N]) & 
                              (~debug_if_r));

   // The host is held off when any of the following are true:
   //
   // [1] The host is halting the processor by writing to the STATUS register
   //     when a multi-cylce operation is in progress.
   //
   // [2] The host is halting the processor by writing to the STATUS32 register
   //     when a multi-cylce operation is in progress.
   //
   // [1] The host is halting the processor by writing to the DEBUG register
   //     when a multi-cylce operation is in progress.
   //
   assign i_hold_host_multic_a = (i_h_en_write_a &
                                  h_dataw[SR_H_N] &
                                  x_multic_busy) |
                                 (i_h_en_write32_a & 
                                  h_dataw[STATUS32_EN_N] & 
                                  x_multic_busy) |
                                 (h_dbhit &
                                  h_write & 
                                  h_dataw[DB_HALT_N] &
                                  i_en_r  &
                                  x_multic_busy);

   assign i_hold_host_intrpt_a = ((i_h_en_write_a &
                                   h_dataw[SR_H_N] &
                                   i_intrpt_a) |
                                  (i_h_en_write32_a & 
                                   h_dataw[STATUS32_EN_N] & 
                                   i_intrpt_a) |
                                  (h_dbhit &
                                   h_write & 
                                   h_dataw[DB_HALT_N] &
                                   i_en_r  &
                                   i_intrpt_a));

   assign i_host_write_en_n_a = ((i_h_en_write_a &
                                  (~h_dataw[SR_H_N]) &
                                  debug_if_r) |
                                 (i_h_en_write32_a & 
                                  (~h_dataw[STATUS32_EN_N]) & 
                                  debug_if_r));

   //  The ARC can be halted whilst it is running by writing bit 1 of the
   //  debug register with '1'.  There are cases where it can be held off:
   // 
   // [1] Provided a BRcc/BBITx has not been mispredicted.
   //
   // [2] The debug register will not be halted when a multi-cycle instruction
   //     is in progress since it will be held off until it is completed.
   //
   // [3] There is an interrupt being serviced in the pipeline.
   //
   // [4] Processor is not halted if a delayed control transfer is pending
   //
   // This only works from the host port, hence the ARC cannot be halted
   // by writing to the debug register with an SR.
   // 
   assign i_h_db_halt_a = ((h_dbhit             == 1'b 1) &&
                           (h_write             == 1'b 1) &&
                           (h_dataw[DB_HALT_N]  == 1'b 1) &&
                           (i_en_r              == 1'b 1) &&
                           (p3_docmprel_a       == 1'b 0) &&
                           (pcounter_jmp_restart_a == 1'b0) &&
                           (x_multic_busy       == 1'b 0)) ?
        (~i_intrpt_a) : 
          1'b 0; 

   //  Make new value for the en bit.
   // 
   //  Note that the 'H' bit in the status register is the complement of the
   //  en signal, so writing '1' to the status register halts the ARC.
   // 
   //  Note that en is set to i_dostep_nxt when i_dostep_r = '1'. This will
   //  allow multiple host writes to the 'step' bit in the debug register to
   //  do many single step operations. The FLAG instruction is the lowest
   //  priority to prevent a single step of an ordinary FLAG instruction 
   //  (which sets the H bit to 0) from allowing the ARC to start
   //  free-running.
   // 
   //  Note that a host write to the 'H' bit has a higher priority than the
   //  the step line. This must be taken into consideration if the xstep
   //  external-step line is being used, as this could be true at the same
   //  time as a host write was taking place, whereas the host could not
   //  write both to the debug register (step) and to the pc (H) at the
   //  same time.
   // 
   //   The debug register can be written whilst the ARC is running.
   //
   assign i_en_nxt =  (i_ctrl_cpu_start_a == 1'b1 ||
                       i_cpu_start_a == 1'b1) ?
          1'b1 :
                      ((halt              == 1'b 1) ||
                       (i_h_db_halt_a     == 1'b 1))   ?
          1'b 0 : 
                      (i_postrst_a       == 1'b 1)   ?
          arc_start_a : 
                      ((i_h_en_write_a    == 1'b 1) &&
                       (debug_if_r        == 1'b 0))   ?
          (~h_dataw[SR_H_N]) : 
                      ((i_h_en_write32_a  == 1'b 1) &&
                       (debug_if_r        == 1'b 0))   ?
          (~h_dataw[STATUS32_EN_N]) : 
                      ((i_dostep_r        == 1'b 1) &&
                       (i_do_inst_step_r  == 1'b 0))   ?
          i_dostep_nxt : 
                      (i_do_inst_step_r  == 1'b 1)   ?
          (~stop_step) : 
                      (((i_actionhalt_nxt == 1'b 1)  ||
                        (actionpt_pc_brk_a == 1'b 1)  ||                 
                        (brk_inst_a       == 1'b 1)) && 
                       (p4_disable_r     == 1'b 1))  ?
          1'b 0 : 
                      ((i_doflag_a        == 1'b 1) &&
                       (en3               == 1'b 1))   ?
          (~s2val[F_H_N]) : 
           i_en_r | step; 


   //============================ Latch for en ==========================--
   //
   // Update the Processor running 'en' bit.
   //
   always @(posedge rst_a or posedge clk)
     begin : en_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_en_r <= 1'b0;
          end
        else
          begin
             i_en_r <= i_en_nxt; 
          end
     end

   // Used for delaying the starting of the processor if a debug operation is
   // taking place.
   //
   always @(posedge rst_a or posedge clk)
     begin : cpu_start_PROC
        if (rst_a == 1'b 1)
          begin
	     i_cpu_start_r <= 1'b0;
          end
        else
          begin
	  
	     if (ctrl_cpu_start_r==1'b1 & i_en_r==1'b0 & 
	         i_debug_access_a==1'b1 & i_cpu_start_r==1'b0)
	         i_cpu_start_r <= 1'b1;
             else if (i_cpu_start_a==1'b1) 
	         i_cpu_start_r <= 1'b0;
			  
          end
     end
            
   // External start signal will force the ARC to run when set
   // as long as ARC is currently halted.
   //
   assign i_ctrl_cpu_start_a = (i_en_r == 1'b0) ? (ctrl_cpu_start_r & ~i_debug_access_a) : 1'b0;
   
   // for delayed start when the a debug operation was in progress
   //
   assign i_cpu_start_a = i_cpu_start_r & ~debug_if_r;   
   
   // determine whether a debug access is taking place
   //
   assign i_debug_access_a = debug_if_r | debug_if_a;

   //  Starting signal
   // 
   //  This signal is set true when the ARC is starting
   //
   assign i_starting_a = ((i_en_nxt == 1'b 1) && (i_en_r == 1'b 0)) ?
          1'b 1 : 
          1'b 0; 

   //  Selfhalt signal. 
   //  
   //  This signal is set true when the FLAG instruction was used to stop the
   //  ARC. It is cleared whenever the ARC is allowed to execute another 
   //  instruction.
   //
   assign i_selfhalt_nxt = ((s2val[F_H_N]  == 1'b 1) &&
                            (i_doflag_a    == 1'b 1) &&
                            (en3           == 1'b 1)) ?
          1'b 1 : 
                           (i_en_nxt      == 1'b 0) ?
          i_selfhalt_r : 
          1'b 0; 

   // Update the Self halt flag register.
   //
   always @(posedge rst_a or posedge clk)
     begin : selfhalt_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_selfhalt_r <= 1'b 0;    
          end
        else
          begin
             i_selfhalt_r <= i_selfhalt_nxt;   
          end
     end

   //  Breakpoint Instruction halt signal. 
   //  
   //  This signal is set true when the breakpoint instruction is detected in 
   //  stage 1 of the pipeline. It is cleared whenever the ARC is allowed
   //  to execute another instruction.
   //
   assign i_breakhalt_nxt = (brk_inst_a   == 1'b 1) ?
          1'b 1 : 
                            (i_en_nxt     == 1'b 0) ?
          i_breakhalt_r : 
          1'b 0; 


   // Update the Break halt flag register.
   //
   always @(posedge rst_a or posedge clk)
     begin : bpt_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_breakhalt_r <= 1'b 0;   
          end
        else
          begin
             i_breakhalt_r <= i_breakhalt_nxt; 
          end
     end

   //  Actionpoint halt signal. 
   //  
   //  This signal is set true when the output of the OR-plane for the 
   //  Actionpoint is set to '1' thus halting the ARC. It is cleared 
   //  whenever the ARC is allowed to execute another instruction.
   //
   always @(actionpt_hit_a or 
            i_dostep_r or
            i_dostep_nxt or 
            i_actionhalt_r or 
            i_host_write_en_a)
     begin : apt_comb_async_PROC
        if (i_host_write_en_a == 1'b 1)
          begin
             i_actionhalt_nxt = 1'b 0; 
          end
        else if (i_dostep_r == 1'b 1 )
          begin
              i_actionhalt_nxt = i_dostep_nxt;  
          end
        else if (actionpt_hit_a == 1'b 1 )
          begin
             i_actionhalt_nxt = 1'b 1; 
          end
        else
          begin
             i_actionhalt_nxt = i_actionhalt_r;    
          end
     end

   // Update the Actionpoint Halt flag register.
   //
   always @(posedge clk or posedge rst_a)
     begin : apt_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_actionhalt_r <= 1'b 0;   
          end
        else
          begin
             i_actionhalt_r <= i_actionhalt_nxt; 
          end
     end

   //  The ALU flag register, and both interrupt mask bits.
   // 
   //  ** Note that the e1 and e2 interrupt mask bits are both cleared on
   //     reset, this disabling interrupts in the inital state. **
   //
   // Update the Arithmetic ZNCV flag register.
   //
   always @(posedge clk or posedge rst_a)
     begin : alu_flags_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_aluflags_r <= {(FOUR){1'b 0}}; 
          end
        else
          begin
             i_aluflags_r <= i_aluflags_nxt;   

          end
     end

   // Update the Level 1 Interrupt Enable E1 flag register.
   //
   always @(posedge rst_a or posedge clk)
     begin : e1bit_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_e1flag_r <= 1'b 0;  
          end
        else
          begin
             i_e1flag_r <= i_e1flag_nxt;   
          end
     end

   // Update the Level 2 Interrupt Enable E2 flag register.
   //
   always @(posedge rst_a or posedge clk)
     begin : e2bit_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_e2flag_r <= 1'b 0;  
          end
        else
          begin
             i_e2flag_r <= i_e2flag_nxt;   
          end
     end


   //======================= Latch for Status L1/L2 =====================--
   //
   // The Level 1 interrupt status register is updated under the
   // following conditions:
   //
   // [1] when an interrupt reaches stage 3 and the writeback matches
   //     the inlink1 address in the register file,
   // [2] the host writes to the L1 status register,
   // [3] the processor writes to the L1 status register.
   //
   assign i_status_l1_nxt = ((p3wba == RILINK1) &&
                             (p3int == 1'b 1))        ?
          {i_aluflags_r, i_e2flag_r, i_e1flag_r} :
                            (aux_l1_wr == 1'b 1)    ?
          {aux_dataw[STATUS32_Z_N : STATUS32_V_N],
           aux_dataw[STATUS32_E2_N : STATUS32_E1_N]} :
                            (h_l1_wr == 1'b 1)      ?
          {h_dataw[STATUS32_Z_N : STATUS32_V_N],
           h_dataw[STATUS32_E2_N : STATUS32_E1_N]} :
          i_status_l1_r;


   // The Level 2 interrupt status register is updated under the
   // following conditions:
   //
   // [1] when an interrupt reaches stage 3 and the writeback matches
   //     the inlink2 address in the register file,
   // [2] the host writes to the L2 status register,
   // [3] the processor writes to the L2 status register.
   //
   assign i_status_l2_nxt = ((p3wba == RILINK2) &&  
                             (p3int == 1'b 1))     ?
          {i_aluflags_r, i_e2flag_r, i_e1flag_r} :
                            (aux_l2_wr == 1'b 1) ?
          {aux_dataw[STATUS32_Z_N : STATUS32_V_N],
           aux_dataw[STATUS32_E2_N : STATUS32_E1_N]} :
                            (h_l2_wr == 1'b 1)   ?
          {h_dataw[STATUS32_Z_N : STATUS32_V_N],
           h_dataw[STATUS32_E2_N : STATUS32_E1_N]} :
          i_status_l2_r;

   // Update the Level 1/Level 2 Status registers.
   //
   always @(posedge rst_a or posedge clk)
     begin : status_l1_l2_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_status_l1_r <= {(SIX){1'b 0}};    
             i_status_l2_r <= {(SIX){1'b 0}};    
          end
        else
          begin
             i_status_l1_r <= i_status_l1_nxt; 
             i_status_l2_r <= i_status_l2_nxt; 
          end
     end

   assign i_status32_l1_r = {TWENTY_ZERO,
                             i_status_l1_r[AX_ST32_Z_N : AX_ST32_V_N],
                             FIVE_ZERO,
                             i_status_l1_r[AX_ST32_E2_N : AX_ST32_E1_N],
                             ONE_ZERO};

   assign i_status32_l2_r = {TWENTY_ZERO,
                             i_status_l2_r[AX_ST32_Z_N : AX_ST32_V_N],
                             FIVE_ZERO,
                             i_status_l2_r[AX_ST32_E2_N : AX_ST32_E1_N],
                             ONE_ZERO};

   //============================ Output drives =========================--
   //
   assign actionhalt     = i_actionhalt_nxt; 
   assign aluflags_nxt       = i_aluflags_nxt; 
   assign aluflags_r         = i_aluflags_r; 
   assign breakhalt_r        = i_breakhalt_r; 
   assign do_inst_step_r     = i_do_inst_step_r; 
   assign e1flag_r           = i_e1flag_r; 
   assign e2flag_r           = i_e2flag_r; 
   assign en_r               = i_en_r; 
   assign hold_host_intrpt_a = i_hold_host_intrpt_a;
   assign hold_host_multic_a = i_hold_host_multic_a;
   assign host_write_en_n_a  = i_host_write_en_n_a;
   assign selfhalt_r         = i_selfhalt_r; 
   assign starting           = i_starting_a; 
   assign status32_l1_r      = i_status32_l1_r; 
   assign status32_l2_r      = i_status32_l2_r; 

endmodule // module flags
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// Debug auxiliary register (including sleep mode flag)
//
// Note that this register is not dual-access, so the lpending flag can
// only be read by the host when the ARC is stopped.
//
//======================= Inputs to this block =======================--
//
// aux_dataw[31:0]  from hostif. This is the auxiliary register bus 
//                  write data value.
//
// h_a_write        from hostif. This signal indicates that a write
//                  from the host is being performed to
//                  the auxiliary register specified on aux_addr[31:0].
//
// aux_dbhit        is from auxregs, and is true when aux_addr =
//                  ax_debug.
//
// lpending         from lsu. Set true when one or more delayed loads
//                  are pending.
//
// actionhalt       from flags. Set true when ARC is stopped, when the
//                  halt was caused by an actionpoint being triggered by
//                  a valid event. This is a debug extension which can
//                  act as breakpoint and watchpoint. The actionpoints
//                  extension has to be selected for this flag.
//
// breakhalt_r      from flags. Set true when ARC is stopped, when the
//                  halt was caused by a BRK instruction at stage one of
//                  the pipeline. The pipeline is flushed before the ARC
//                  is properly halted.
//
// en_debug_r       This flag is the Enable Debug flag (ED) in the
//                  DEBUG register. It enables the debug extensions when
//                  it is set. When it is cleared the debug extensions
//                  are switched off by gating the debug clock, but only
//                  if the option clock gating has been selected.
//
// selfhalt_r       from flags. Set true when ARC is stopped, when the
//                  halt was caused by a FLAG instruction on the ARC.
//
// actionpt_status_r
//                  from debug_exts. This field shows which of the
//                  actionpoints were triggered in the OR-plane.The 
//                  actionpoints extension has to be selected for this
//                  field.
//
// xstep            from extensions. Single step on the next cycle if
//                  the ARC is stopped.
//
// p2sleep_inst     from rctl. This signal is set when a sleep
//                  instruction has been decoded in pipeline stage 2.
//
// starting         from flags. This signal indicates that the ARC is
//                  starting, i.e. en goes high. This wakes up the ARC
//                  from sleep mode.
//
// p1int            from int_unit. Indicates that an interrupt has been
//                  detected. This wakes up the ARC from sleep mode.
//
// en2              from rctl. Pipeline stage 2 enable. When this
//                  signal is true, the instruction in stage 2 can pass
//                  into stage 3 at the end of the cycle. When it is
//                  false, it will hold up stage 2 and stage 1.
//
//====================== Output from this block ======================--
//
// sleeping         This is the sleep mode flag ZZ in the debug register
//                  It stalls the pipeline when true.
//
// sleeping_r2      This is the pipelined version of sleeping for use by
//                  clock gating.
//
// debug_r[31:0]    The debug register when read from the aux register
//                  bus.
//
// step             To flags. Do a single step on the next cycle, if the
//                  ARC is stopped.
//
// inst_step        To flags. Do instruction step during single step. If
//                  cleared a cycle step occurs.
//
// reset_applied_r  This bit in the debug register is set to true when a
//                  a reset happens. The bit is read only from the
//                  processor side and the debugger clears this bit when
//                  it performs a read.
//
//====================================================================--
//
module debug (clk,
              rst_a,
              aux_dataw,
              h_a_write,
              aux_dbhit,
              actionpt_status_r,
              en_debug_r,
              actionhalt,
              lpending,
              breakhalt_r,
              selfhalt_r,
              xstep,
              p2sleep_inst,
              starting,
              p1int,
              inst_stepping,      
              en2,
              debug_r,
              sleeping,
              sleeping_r2,
              step,
              inst_step,
              reset_applied_r);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"

input          clk; 
input          rst_a; 

//  Auxiliary register signals
input  [DATAWORD_MSB:0] aux_dataw; 
input          h_a_write; 
input          aux_dbhit; 

//  signals for inclusion in the debug register //
input   [NUM_APS - 1:0] actionpt_status_r; 
input          actionhalt; 
input          en_debug_r; 

input          inst_stepping;
input          lpending; 
input          breakhalt_r; 
input          selfhalt_r; 
input          xstep; 
input          p2sleep_inst; 
input          starting; 
input          p1int; 
input          en2; 

//  Output signals
output  [31:0] debug_r; 
output         sleeping; 
output         sleeping_r2;
output         step; 
output         inst_step; 
output         reset_applied_r;

reg     [31:0] debug_r; 
wire           sleeping; 
wire           sleeping_r2;
wire           step; 
wire           inst_step; 

//====================================================================--

wire           i_inst_step_a; 
wire           i_step_a; 
reg            i_sleeping_r; 
reg            i_sleeping_r2;
reg            i_reset_applied_r;
reg            i_external_halt_r;

   // Step:
   // 
   // This signal causes a single step to occur on the next cycle by
   // flags when the ARC is halted. When the DB_STEP bit in the debug
   // register is written with '1' via the auxiliary register bus, the
   // step signal is set true. Depending on the value of instruction
   // step, either an instruction step or a cycle step occurs.
   //
   assign i_step_a = ((aux_dbhit == 1'b 1) &&
                      (h_a_write == 1'b 1) && 
                      ((aux_dataw[`DEBUG_S_STEP_MSB] == 1'b 1) | 
                       (xstep     == 1'b 1))) ?
          ~aux_dataw[`DEBUG_RESET_MSB] : 
          1'b 0; 

   // Instruction Step:
   // 
   // When this signal is set at the same time as the step signal is set
   // a single instruction step occurs. Only one instruction is fetched
   // and allowed to complete.
   // 
   // If this signal is cleared when the step signal is set a single
   // cycle step occurs which means that the ARC is active during only
   // one clock cycle.
   // 
   // A single step generated from the extensions (xstep) can not be run
   // with instruction step.

   assign i_inst_step_a = ((aux_dbhit == 1'b 1)                    &&
                           (h_a_write == 1'b 1)                    && 
                           (aux_dataw[`DEBUG_I_STEP_MSB] == 1'b 1) && 
                           (xstep     == 1'b 0)) ?
          ~aux_dataw[`DEBUG_RESET_MSB] : 
          1'b 0; 
   
   //  Sleep mode:
   // 
   //  Sleep mode is a power saving mode, during which the pipeline is stalled,
   //  but not halted. When the sleep mode flag ZZ (i_sleeping_r) in the debug
   //  register is set the ARC enters sleep mode. This happens when
   //  a sleep instruction is detected in pipeline stage 2
   //  (p2sleep_inst = '1'). The ARC stays in sleep mode until an interrupt
   //  is requested (p1int = '1') or the ARC is restarted (starting = '1').
   //
   always @(posedge rst_a or posedge clk)
      begin : sleep_mode_sync_PROC
      if (rst_a == 1'b 1)
         begin
         i_sleeping_r  <= 1'b 0;  
         i_sleeping_r2 <= 1'b 0;
         end
      else
         begin
         if ((p1int == 1'b 1) | (starting == 1'b 1))
            begin
            i_sleeping_r <= 1'b 0;   
            end
         else if ((p2sleep_inst == 1'b 1) & (en2 == 1'b 1) & (inst_stepping==1'b0) )
            begin
            i_sleeping_r <= 1'b 1;   
            end

         // Pipeline the Sleep signal for clock gating when updating the E1 & E2
         // flags.
         //
         i_sleeping_r2 <= i_sleeping_r;

         end
      end

   //  Reset Applied:
   // 
   //  Reset Applied is set to true when a reset happens. The only operation
   //  that can clear this bit is a write to the debug register or read since
   //  the bit is a sticky bit.
   //
   always @(posedge rst_a or posedge clk)
      begin : reset_applied_sync_PROC
      if (rst_a == 1'b 1)
         begin
         i_reset_applied_r <= 1'b 1;  
         end
      else
         begin
         if ((h_a_write == 1'b 1) &&
             (aux_dbhit == 1'b 1))
            begin
            i_reset_applied_r <= aux_dataw[`DEBUG_RESET_MSB];   
            end
         end
      end


   //  Debug register read result : This defines where the various bits appear 
   //  in the auxiliary register.
   // 
   always @(lpending or selfhalt_r or breakhalt_r or actionhalt or 
            en_debug_r or actionpt_status_r or i_reset_applied_r or
            i_sleeping_r)

   begin : debug_async_PROC

   //  Default values

   debug_r[`DEBUG_AMC_MSB:`DEBUG_EN_DEBUG_MSB] = `FIVE_ZEROS;    
   debug_r[21:0] = `TWENTY_TWO_ZEROS;  

   //  This flag when true signifies a load is pending. 
   debug_r[`DEBUG_LOOP_MSB] = lpending;

   //  This flag when true signifies that the ARC has been halted 
   //  via a flag instruction. 
   debug_r[`DEBUG_S_HALT_MSB] = selfhalt_r; 

   //  This flag when true signifies that the ARC has been halted by a BRK
   //  instruction which was detected at stage one. 
   debug_r[`DEBUG_B_HALT_MSB] = breakhalt_r;    

   debug_r[`DEBUG_SLEEP_MSB] = i_sleeping_r;   
   debug_r[`DEBUG_RESET_MSB] = i_reset_applied_r;   

   //  This field provides the debugger with information for all
   //  the actionpoint valid signals. This shows which of the
   //  actionpoints was triggered.
   debug_r[`DEBUG_EN_DEBUG_MSB] = en_debug_r; 
   debug_r[`DEBUG_AP_MSB:`DEBUG_AP_LSB] = actionpt_status_r; 
   debug_r[`DEBUG_A_HALT_MSB] = actionhalt;    

   end

//============================ Output drives =========================--
//
   assign inst_step = i_inst_step_a; 
   assign reset_applied_r = i_reset_applied_r;
   assign sleeping = i_sleeping_r; 
   assign sleeping_r2 = i_sleeping_r2;
   assign step = i_step_a; 

endmodule // module debug

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains all the auxiliary registers and associated logic,
// including:
//
//            Program counter / Status registers
//            Loop start and loop end registers
//            Identity register
//
//======================= Inputs to this block =======================--
//
// clk              Global Clock.
//  
// rst_a            Global Reset (active high).
//
// arc_start_a      This signal defines whether the ARC starts running
//                  on reset, or goes into a halted state. When it is
//                  set to '1' the ARC will start running code from the
//                  reset vector onwards after a reset. It should be
//                  fixed at '1' for start-on-reset or at '0' for
//                  halt-on-reset.
//
// ctrl_cpu_start_r This signal comes from the 'xctrl_cpu_start_r' input
//                  and will start the ARC running when it is halted.
//
// aux_addr[31:0]   from hostif. This is the auxiliary register bus 
//                  address value. Width of decode is set by AUXDECSZ. 
//
// aux_dataw[31:0]  from hostif. This is the auxiliary register bus 
//                  write data value.
//
// aux_write        from hostif. This signal indicates that a write
//                  (either from the ARC or host) is being performed to
//                  the auxiliary register specified on aux_addr[31:0].
//
// actionpt_status_r
//                  from debug_exts. This field shows which of the
//                  actionpoints were triggered in the OR-plane.The 
//                  actionpoints extension has to be selected for this
//                  field.
//
// actionpt_hit_a   From debug_exts. This signal is the output of the
//                  OR-plane for the actionpoint debug hardware. When it
//                  is '1' it signifies that a valid condition has been
//                  detected, and the ARC should be halted. This is part
//                  of the actionpoint extension.
//
// p4_disable_r     From rctl module. This signals to the ARC that the
//                  pipeline has been flushed due to a breakpoint or
//                  sleep instruction. If it was due to a breakpoint
//                  instruction the ARC is halted via the 'en' bit, and
//                  the AH bit is set to '1' in the debug register.
//
// brk_inst_a       From rctl. This signals to the ARC that a
//                  breakpoint instruction has been detected in stage
//                  one of the pipeline. Hence, the halt bit in the flag
//                  register has to be updated in addition to the BH bit
//                  in the debug register. The pipeline is stalled when
//                  this signal is set to '1'.
//
//                  Note: The pipeline is flushed of instructions when
//                  the breakpoint instruction is detected, and it is
//                  important to disable each stage explicity. A normal
//                  instruction in stage one will mean that instructions
//                  in stage two, three and four will be allowed to
//                  complete. However, for an instruction in stage one 
//                  which is in the delay slot of a branch, loop or jump
//                  instruction means that stage two has to be stalled 
//                  as well. Therefore, only stages three and four will
//                  be allowed to complete.
//
// currentpc_r      This is a latched result, which is passed to the 
//                  memory controller as being the address from which to
//                  fetch the next opcode.
//
// en2              from rctl, this is the stage 2->3 pipeline enable.
//
// debug_if_r       Debug Memory Access. This is asserted true when a debug
//                  access to memory is in progress.
//
// instr_pending_r  This signal is true when an instruction fetch has
//                  been issued, and it has not yet completed. It is
//                  not true directly after a reset before the ARC has
//                  started, as no instruction fetch will have been
//                  issued. It is used to hold off host writes to the
//                  program counter when the ARC is halted, as these
//                  accesses will trigger an instruction fetch. Used
//                  here to prevent the PC from being updated when a
//                  host access is being held off.
//
// p1int            from int_unit. Indicates that an interrupt has been
//                  detected. This wakes up the ARC from sleep mode.
//
// p2int            Indicates that an interrupt-op instruction is in
//                  stage 2. This signal is used in coreregs.v to control
//                  the placing of the pc onto a source bus for writing
//                  back to the interrupt link registers, and by aux_regs
//                  to insert the interrupt vector int_vec[] into the
//                  program counter.
// 
// p2bint           Indicates that an interrupt-op instruction is in
//                  stage 2B. 
// 
// p3iv             from rctl, this signal indicates that the
//                  instruction opcode supplied in p3opcode is valid,
//                  as we allow blank slots to flow through the
//                  pipeline under certain conditions, and we don't
//                  want these phantom instructions to affect the
//                  state of the processor.
//
// p3condtrue       from rctl. This signal is used in flags to control
//                  loading of flags with regular conditional
//                  instructions (ie not jumps/branches/loops etc). It
//                  is set according to whether the condition specified
//                  in the instruction's cc field is true, but if the
//                  instruction does not have a cc field (e.g. short
//                  immediate data) then it is always true.
//
// p3_docmprel_a    A mispredicted BRcc of BBITx has been taken by the ARC
//                  processor in stage 3. The corrective action will be taken
//                  in stage 4 where the correct PC will be presented at the
//                  instruction fetch interface.
//
// p3setflags       from rctl. This signal is used by regular alu-type
//                  instructions and the jump instruction to control
//                  whether the supplied flags get stored. It is
//                  produced from the set-flags bit in the instruction
//                  word, but if that field is not present in the
//                  instruction (e.g. short immediate data is being
//                  used) then it will either come from the set-flag
//                  modes implied by which short immediate data register
//                  is used, or it will be set false if the instruction
//                  does not affect the flags.
//
// p3int            from rctl, indicates that stage 3 contains an
//                  interrupt jump instruction, and that the appropriate
//                  interrupt mask bits should be cleared.
//
// p3ilev1          from rctl, this is used in conjunction with p3int to
//                  indicate which level of interrupt is being
//                  processed, and hence which of the interrupt mask
//                  bits should be cleared. It comes from bit 7 of the
//                  jump instruction word, which is set when a level1
//                  (lowest level) interrupt is being processed.
//
// en3              from rctl, this is the stage 3->4 pipeline enable.
//
// en_debug_r       This flag is the Enable Debug flag (ED), bit 24 in
//                  the DEBUG register. It enables the debug extensions
//                  when it is set. When it is cleared the debug
//                  extensions are switched off by gating the debug
//                  clock, but only if the option clock gating has been
//                  selected.
//
// s2val[31:0]      Stage 3 operand B value (latched by stage 2,
//                  including any shortcuts which may be appropriate).
//  
// alurflags[3:0]   from the ALU. These signals are the flags produced
//                  by the ARC's alu after doing the calculations
//                  required by the instruction currently in stage 3.
//
// lpending         from lsu. Set true when one or more delayed loads
//                  are pending.
//
// h_addr[31:0]     from mc/host. This is a 32-bit address (it may be
//                  smaller, but packed with zeroes) from the host which
//                  is used to access registers in the ARC in conjuction
//                  with aux_access and core_access. The width of the
//                  decode applied to this 32-bit quantity is defined by
//                  the AUXDECSZ constant, found in extutil. It is
//                  defined as being a 32-bit bus at this level to 
//                  maintain compatibility with the LR and SR
//                  instructions which can generate a 32-bit value for
//                  the address to be used for auxiliary register
//                  accesses.
//
// h_dataw[31:0]    from mc/host. Data from the host to be stored into
//                  registers in the ARC/extensions.
//
// h_write          from mc/host. When it is true, this signal indicates
//                  that a host write is taking place.
//
// aux_access       from mc/host. This signal is used to inform the ARC 
//                  that address supplied on h_addr[31:0] applies to
//                  the auxiliary register set. 
//
// xcache_hold_host from extensions. This signal is used in this block
//                  to allow an external cache system to hold off writes
//                  to the program counter whilst the cache is busy. It
//                  does this by detecting a PC write and asserting
//                  xcache_hold_host - thus holding the host device. It is
//                  used here to prevent a held off write to the program
//                  counter from being accepted by the core.
//
// drx_reg[31:0]    from extensions. This bus is used to provide data
//                  from registers implemented in extension logic. This
//                  will be ignored unless enabled using the XT_AUXREG
//                  constant in extutil.
//
// x_multic_busy    From xrctl. Multi-cycle extension is busy. This signal
//                  is true when the multicycle instruction that is currently
//                  being stepped is busy.  The signal will become false
//                  when the extension instruction is finished.
//
// xreg_hit         from extensions. This signal is used to indicate to
//                  the auxiliary register module that data is present
//                  on the drx_regs[31:0] bus, and should be driven onto
//                  aux_datar[].
//                  ** Note that existing auxiliary registers take
//                  priority if this signal is true when internal
//                  auxiliary registers are being accessed **
//
// x_da_am          from extensions. This signal is true when the
//                  address on h_addr[31:0] matches a dual access
//                  auxiliary registers provided by extension logic, and
//                  indicates that aux_regs should place the data on
//                  x_dar[] onto the aux_dar[] bus.
//
// x_dar[31:0]      from extensions. This is the host-side data from a
//                  dual access register provided by extension logic.
//
// xflags[3:0]      from extensions. This contains alu result flags from
//                  the extension alu(s). It is loaded into the flags
//                  when there is an extension instruction at stage 3
//                  which wants to set the flags, provided that the
//                  appropriate pipeline enables are also true.
//                  In addition, the xsetflags signal can be used to
//                  force the flags to be loaded from xflags[].
//  
// x_flgen          Extension basecase flag update. This signal is true
//                  when any extension wants to update the basecase
//                  flags.
//
// xsetflags        from extensions. Load xflags[3:0] into aluflags_r
//                  at the end of the cycle, provided that extension-
//                  alu-flag-settdebug_exts.ving has been globally enabled in
//                  extutil, and that the enable for pipeline stage 3
//                  is valid, and the instruction in stage 3 is an
//                  extension instruction (x_idecode3 is true). This
//                  allows the extensions to override the normal flag
//                  -setting logic in rctl.
//
// x_idecode3       From extensions. This signal will be true when the
//                  extension logic detects an extension instruction in
//                  stage 3. It is latched from x_idecode2 by the
//                  extensions when en2 is true at the end of a cycle.
//                  It is used to correctly generate p3condtrue,
//                  p3setflags, and to detect (along with xnwb) when a
//                  register writeback will take place.
//
// halt             From top level. When this signal is set true, the
//                  ARC will stop running on the next cycle.
//
// id_arcnum[7:0]   This signal defines bits 15:8 of the ARC's identity
//                  register. It will be fixed at some value to allow
//                  different ARCs in a multiple ARC system to have a
//                  unique identity.
//
// loopend_r        Loop End Address Value.
//
// loopstart_r      Loop Start Address Value.
//
// xstep            from extensions. Single step on the next cycle if
//                  the ARC is stopped.
//
// p2sleep_inst     from rctl. This signal is true when a sleep
//                  instruction has been decoded in pipeline stage 2.
//                  When true the sleep mode flag ZZ (bit 23) in the
//                  debug register is set.
//
// stop_step        This signal is set when the single instruction step
//                  has finished.
//
// misaligned_err   LD/ST to a misaligned address detected
//
//====================== Output from this block ======================--
//
// actionhalt       From flags. This signal is set true when the
//                  actionpoint (if selected) has been triggered by a
//                  valid condition. The ARC pipeline is halted and
//                  flushed when this signal is '1'.
//
//                  Note: The pipeline is flushed of instructions when
//                  the breakpoint instruction is detected, and it is
//                  important to disable each stage explicity. A normal
//                  instruction in stage one will mean that instructions
//                  in stage two, three and four will be allowed to
//                  complete. However, for an instruction in stage one 
//                  which is in the delay slot of a branch, loop or jump 
//                  instruction means that stage two has to be stalled 
//                  as well. Therefore, only stages three and four will
//                  be allowed to complete.
//
// aluflags_r       To the ALU. Direct from the latches, the Z N C V
//                  flags supplied to the ALU in stage 3.
//
// aux_datar[31:0]  to hostif. This is the data provided by the 
//                  auxiliary register set in response to a read. It
//                  does not include data from the pc/status register as
//                  these are handled in a special way. It also goes to
//                  the stage 3 alu multiplexer logic as it is used to
//                  load core registers as the result of an LR
//                  instruction.
//
// aux_dar[31:0]    to hostif. This is the data from the PC/status,
//                  semaphore and identity registers which can be read
//                  whilst the ARC is running, and hence does not go
//                  down the aux_datar[31:0] bus.
//
// aux_pchit        Set true when the auxiliary register address (from
//                  s2val when the ARC is running) matches the program 
//                  counter address. The decode takes account of the 
//                  constant in arcutil which determines the size of the
//                  auxiliary register decode.
//
// aux_pc32hit      Set true when the auxiliary register address (from
//                  s2val when the ARC is running) matches the 32-bit 
//                  program counter address. The decode takes account of
//                  the constant in arcutil which determines the size of
//                  the auxiliary register decode.
//
// da_auxam         to hostif. This signal is true when the address on
//                  the h_addr[31:0] matches one of the dual access
//                  auxiliary registers (pc/status, semaphore, and
//                  identity registers). (includes dual access
//                  registers provided by extensions).
//
// do_inst_step_r   This signal is set when the single step flag (SS)
//                  and the instruction step flag (IS) in the debug
//                  register has been written to simultaneously through
//                  the host interface. It indicates that an instruction
//                  step is being performed. When the instruction step
//                  has finished this signal goes low.
//
// e1flag_r         Direct from the latch, the interrupt level 1 mask
//                  bit.
//
// e2flag_r         Direct from the latch, the interrupt level 2 mask
//                  bit.
//
// en               The global run bit.
//
// en_debug_r       This flag is the Enable Debug flag (ED), bit 24 in
//                  the DEBUG register. It enables the debug extensions
//                  when it is set. When it is cleared the debug
//                  extensions are switched off by gating the debug
//                  clock, but only if the option clock gating has been
//                  selected.
//
// h_pcwr           To hostif. This signal is set true when the host is
//                  attempting to write to the pc/status register, and
//                  the ARC is stopped. It is used to trigger an
//                  instruction fetch when the PC is written when the
//                  ARC is stopped. This is necessary to ensure the
//                  correct instruction is executed when the ARC is
//                  restarted. It is also used to latch the new PC
//                  value.
//
// h_pcwr32         From aux_regs. This signal is set true when the host
//                  is attempting to write to the 32-bit pc register,
//                  and the ARC is stopped. It is used to trigger an
//                  instruction fetch when the PC is written when the
//                  ARC is stopped. This is necessary to ensure the
//                  correct instruction is executed when the ARC is
//                  restarted.
//
// sleeping         This is the sleep mode flag ZZ in the debug register
//                  (bit 23). It stalls the pipeline when true.
//
//====================================================================--
//
module aux_regs (clk,
                 rst_a,
                 ctrl_cpu_start_r,
                 arc_start_a,
                 aux_addr,
                 aux_dataw,
                 aux_write,
                 brk_inst_a,
                 stop_step,
                 currentpc_r,
                 en2,
                 fs2a,
                 instr_pending_r,
                 p2int,
                 en2b,
                 p2b_opcode,
                 p2b_subopcode,
                 p2b_iv,
                 p2b_condtrue,
                 p2b_setflags,
                 p1int,
                 p2bint,
                 p3iv,
                 p3condtrue,
                 p3_docmprel_a,
                 p3setflags,
                 p3int,
                 p3ilev1,
                 p3wba,
                 en3,
                 s2val,
                 alurflags,
                 p3_flag_instr,
		 p3_sync_instr,
                 debug_if_r,
                 debug_if_a,	 
                 lpending,
                 aux_access,
                 inst_stepping,
                 h_addr,
                 h_dataw,
                 h_write,
		 noaccess,
                 xcache_hold_host,
                 drx_reg,
                 id_arcnum,
                 xreg_hit,
                 x_da_am,
                 x_dar,
                 xflags,
                 x_flgen,
                 x_idecode3,
                 xsetflags,
                 actionpt_hit_a,
                 p4_disable_r,
                 actionpt_status_r,
                 en_debug_r,
                 actionpt_pc_brk_a,
                 p2sleep_inst,
                 halt,
                 xstep,
                 loopstart_r,
                 loopend_r,
                 x_multic_busy,
                 pcounter_jmp_restart_a,
                 misaligned_err,

                 en_misaligned,
                 en,
                 aux_datar,
                 aux_dar,
                 aux_pchit,
                 aux_pc32hit,
                 da_auxam,
                 do_inst_step_r,
                 h_pcwr,
                 h_pcwr32,
                 h_status32,
                 aluflags_nxt,
                 aluflags_r,
                 e1flag_r,
                 e2flag_r,
                 actionhalt,
                 hold_host_intrpt_a,
                 hold_host_multic_a,
                 host_write_en_n_a,
                 reset_applied_r,
                 sleeping_r2,
                 sleeping,
		 step,
		 inst_step);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"

input          clk;  //  system clock
input          rst_a; //  system reset
input          ctrl_cpu_start_r;
input          arc_start_a; 

// hostif connections to auxiliary registers

input   [31:0] aux_addr; 
input   [31:0] aux_dataw; 
input          aux_write; 

// connections to rctl stage 1

input          brk_inst_a; 
input          stop_step; 

//  connections to coreregs, stage 2

input   [PC_MSB:0] currentpc_r; 

//  connections to rctl, stage 2

input          en2; 
input   [5:0]  fs2a; 
input          instr_pending_r; 
input          p2int;

//  connections to rctl, stage 2B

input          en2b;
input   [4:0]  p2b_opcode; 
input   [5:0]  p2b_subopcode; 
input          p2b_iv; 
input          p2b_condtrue; 
input          p2b_setflags; 

// connections to interrupt unit
input          p1int; 
input          p2bint;

// connections to rctl and ALU, stage 3

input          p3iv; 
input          p3condtrue; 
input          p3_docmprel_a;
input          p3setflags; 
input          p3int; 
input          p3ilev1; 
input   [5:0]  p3wba; 
input          en3; 
input   [31:0] s2val;  
input   [3:0]  alurflags; 
input          p3_flag_instr; 
input          p3_sync_instr;

// Debug Memory Access

input          debug_if_r;
input          debug_if_a;

//  from lsu

input          lpending; 

//  Group Four : Host interface

input          aux_access; 
input   [31:0] h_addr; 
input   [31:0] h_dataw; 
input          h_write; 
input          noaccess;
input          xcache_hold_host; 

// Signals from extensions

input   [31:0] drx_reg; 
input   [7:0]  id_arcnum; 
input          xreg_hit; 
input          x_da_am; 
input   [31:0] x_dar; 
input   [3:0]  xflags; 
input          x_flgen; 
input          x_idecode3; 
input          xsetflags; 

// Debugging and sleep mode

input          inst_stepping;
input          actionpt_hit_a; 
input          p4_disable_r; 
input   [NUM_APS - 1:0] actionpt_status_r; 
input          en_debug_r; 
input          actionpt_pc_brk_a;
input          p2sleep_inst; 
input          halt; 
input          xstep; 

// LP_COUNT logic
   
input   [PC_MSB:0] loopstart_r; 
input   [PC_MSB:0] loopend_r; 

// Multi Cycle Instruction

input          x_multic_busy;

// Delayed control transfer is pending

input          pcounter_jmp_restart_a;

// Misaligned access error
input          misaligned_err;

//  system go

output         en_misaligned;
output         en;

// hostif connections to auxiliary registers

output  [31:0] aux_datar; 
output  [31:0] aux_dar; 
output         aux_pchit; 
output         aux_pc32hit; 
output         da_auxam; 

// connections to rctl stage 1

output          do_inst_step_r; 
output          h_pcwr; 
output          h_pcwr32; 
output          h_status32; 

// connections to rctl and ALU, stage 3

output  [3:0]  aluflags_nxt; 
output  [3:0]  aluflags_r; 
output         e1flag_r; 
output         e2flag_r; 

// Debugging and sleep mode

output         actionhalt; 
output         hold_host_intrpt_a;
output         hold_host_multic_a;
output         host_write_en_n_a;
output         reset_applied_r; 
output         sleeping_r2;
output         sleeping;
output         step;
output         inst_step;


wire           en; 
wire    [31:0] aux_datar; 
wire    [31:0] aux_dar; 
wire           aux_pchit; 
wire           aux_pc32hit; 
wire           h_status32; 

wire           da_auxam; 
wire           do_inst_step_r; 

wire           h_pcwr; 

wire    [3:0]  aluflags_r; 
wire           e1flag_r; 
wire           e2flag_r; 

wire           actionhalt; 
wire           sleeping; 
wire           sleeping_r2;

//===================================================================//

wire    i_en_r;                //  internal en signal
wire    i_actionhalt_a; 
wire    [3:0] i_aluflags_nxt; 
wire    [3:0] i_aluflags_r; 
wire    i_aux_l1_hit_a;        //  }
wire    i_aux_l2_hit_a;        //  }
wire    i_aux_l1_wr_a;         //  }
wire    i_aux_l2_wr_a;         //  }
wire    i_aux_pchit_a;         //  }
wire    i_aux_pc32hit_a;       //  }
wire    i_aux_status32hit_a;   //  }
wire    i_aux_lshit_a;         //   } decodes from aux_addr
wire    i_aux_lehit_a;         //   }
wire    i_aux_dbhit_a;         //  }
wire    i_aux_misalign_ctrl_a;
reg     [1:0] i_misalign_ctrl_r;
wire    i_breakhalt_r; 
wire    [DATAWORD_MSB:0] i_debug_r; 
wire    i_e1flag_r; 
wire    i_e2flag_r; 

wire	i_h_aux_write_always_a;
wire    i_h_aux_write_a; 
wire    i_h_dbhit_a;              //  } decodes from h_addr and
wire    i_h_idhit_a;              //  } aux_access.
wire    i_h_l1_hit_a;             //  }
wire    i_h_l2_hit_a;             //  }
wire    i_h_l1_wr_a;              //  }
wire    i_h_l2_wr_a;              //  }
wire    i_h_pchit_a;              //  }
wire    i_h_pchit32_a;            //  }
wire    i_h_pcwr_a; 
wire    i_h_pcwr32_a; 
wire    i_h_status32hit_a;        //  }
wire    i_h_status32wr_a;         //  }
wire    [DATAWORD_MSB:0] i_host_pc_r;       //  pc/status reg
wire    [DATAWORD_MSB:0] i_identity_r;       //  identity register
wire    i_inst_step; 
wire    i_selfhalt_r; 
wire    i_starting; 
wire    [11:0] i_status12_r; 
wire    [DATAWORD_MSB:0] i_status32_l1_r; 
wire    [DATAWORD_MSB:0] i_status32_l2_r; 
wire    [DATAWORD_MSB:0] i_status32_r; 
wire    i_step; 


   // Produce decodes for individual auxiliary registers from aux_addr
   // (uses special decode function which only decodes to AUXDECSZ 
   // width)
   //
   assign i_aux_dbhit_a       = auxdc(aux_addr, AX_DEBUG_N);
   assign i_aux_l1_hit_a      = auxdc(aux_addr, AX_STATUS32_L1_N); 
   assign i_aux_l2_hit_a      = auxdc(aux_addr, AX_STATUS32_L2_N); 
   assign i_aux_lshit_a       = auxdc(aux_addr, AX_LSTART_N); 
   assign i_aux_lehit_a       = auxdc(aux_addr, AX_LEND_N); 
   assign i_aux_pchit_a       = 1'b0; // this register has been removed from arcver 25 onward
   assign i_aux_pc32hit_a     = auxdc(aux_addr, AX_PC32_N); 
   assign i_aux_status32hit_a = auxdc(aux_addr, AX_STATUS32_N); 
   assign i_aux_misalign_ctrl_a = auxdc(aux_addr, AUX_ALIGN_CTRL);

   //  Produce decodes for individual auxiliary registers from h_addr
   //  (uses special decode function which only decodes to AUXDECSZ 
   // width)
   //
   // Valid host access allowed while running:
   assign i_h_aux_write_always_a   = h_write & aux_access & ~noaccess;
   // Valid host access, but processor must be halted:
   assign i_h_aux_write_a   = i_h_aux_write_always_a & ~i_en_r;
   assign i_h_dbhit_a       = aux_access & auxdc(h_addr, AX_DEBUG_N); 
   assign i_h_idhit_a       = aux_access & auxdc(h_addr, AX_ID_N); 
   assign i_h_l1_hit_a      = aux_access & auxdc(h_addr, AX_STATUS32_L1_N); 
   assign i_h_l2_hit_a      = aux_access & auxdc(h_addr, AX_STATUS32_L2_N); 
   assign i_h_pchit_a       = 1'b0; // this register has been removed from arcver 25 onward
   assign i_h_pchit32_a     = aux_access & auxdc(h_addr, AX_PC32_N);
   assign i_h_status32hit_a = aux_access & auxdc(h_addr, AX_STATUS32_N);

   //  Here we generate the master signal which controls external load
   //  of the program counter. It is set true when a host interface 
   //  write to PC/status register is received, except:
   // 
   //  i. an instruction fetch is pending - and therefore any writes 
   //     will be held off by hold_host logic in the hostif module. 
   //     (instr_pending_r)
   // 
   //  ii. an external instruction cache system has detected a write 
   //      to the program counter which needs to be held off. This is
   //      achieved by setting the xcache_hold_host signal. It is included 
   //      here to prevent the ARC from changing the PC and 
   //      generating an ifetch before the external cache system is 
   //      ready.
   // 
   assign i_h_pcwr_a   = (i_h_pchit_a & i_h_aux_write_a & 
                         ~instr_pending_r & ~xcache_hold_host);

   assign i_h_pcwr32_a = (i_h_pchit32_a & i_h_aux_write_a & 
                         ~instr_pending_r & ~xcache_hold_host); 

   assign i_h_status32wr_a = (i_h_status32hit_a & i_h_aux_write_a & 
                         ~instr_pending_r & ~xcache_hold_host); 

   assign i_h_l1_wr_a  = (i_h_l1_hit_a & i_h_aux_write_a &
                         ~instr_pending_r & ~xcache_hold_host); 

   assign i_h_l2_wr_a  = (i_h_l2_hit_a & i_h_aux_write_a &
                         ~instr_pending_r & ~xcache_hold_host);

   // The signals below flag that the processor wishes to write to the
   // Status32 L1/L2 registers.
   //
   assign i_aux_l1_wr_a = i_aux_l1_hit_a & aux_write;
   assign i_aux_l2_wr_a = i_aux_l2_hit_a & aux_write;


// Misaligned Control Register

  always @(posedge clk or posedge rst_a)
  begin
    if (rst_a == 1'b 1)
    begin
      i_misalign_ctrl_r <= 2'b00;
    end
    else if (i_aux_misalign_ctrl_a && aux_write)
    begin
        i_misalign_ctrl_r[0] <= aux_dataw[0];
        i_misalign_ctrl_r[1] <= aux_dataw[31] ? 1'b 0 : i_misalign_ctrl_r[1];
    end
    else if (misaligned_err)
    begin
        i_misalign_ctrl_r[1] <= 1'b 1;
    end
  end


//===================== Component Instantiations =====================--
//
flags U_flags (

          .clk(clk),
          .rst_a(rst_a),

          .actionpt_hit_a(actionpt_hit_a),
            .actionpt_pc_brk_a(actionpt_pc_brk_a),
          .ctrl_cpu_start_r(ctrl_cpu_start_r),
          .arc_start_a(arc_start_a),
          .halt(halt),
          .step(i_step),
          .inst_step(i_inst_step),

          .aux_dataw(aux_dataw),
          .aux_l1_wr(i_aux_l1_wr_a),
          .aux_l2_wr(i_aux_l2_wr_a),

          .h_dataw(h_dataw),
          .h_write(h_write),
          .h_pchit(i_h_pchit_a),
          .h_dbhit(i_h_dbhit_a),
          .h_l1_wr(i_h_l1_wr_a),
          .h_l2_wr(i_h_l2_wr_a),
          .h_pcwr(i_h_pcwr_a),
          .h_status32hit(i_h_status32hit_a),
          .h_status32wr(i_h_status32wr_a),

          .xflags(xflags),
          .x_flgen(x_flgen),
          .xsetflags(xsetflags),
          .x_idecode3(x_idecode3),
          .xcache_hold_host(xcache_hold_host),
          .brk_inst_a(brk_inst_a),

          .en2b(en2b),
          .fs2a(fs2a),
          .instr_pending_r(instr_pending_r),
          .p1int(p1int),
          .p2int(p2int),
          .p2b_opcode(p2b_opcode),
          .p2b_subopcode(p2b_subopcode),
          .p2b_iv(p2b_iv),
          .p2b_condtrue(p2b_condtrue),
          .p2b_setflags(p2b_setflags),
          .p2bint(p2bint),

          .p4_disable_r(p4_disable_r),
          .p3_flag_instr(p3_flag_instr),
	  .p3_sync_instr(p3_sync_instr),
          .p3iv(p3iv),
          .p3condtrue(p3condtrue),
          .p3_docmprel_a(p3_docmprel_a),
          .p3setflags(p3setflags),
          .p3int(p3int),
          .p3ilev1(p3ilev1),
          .p3wba(p3wba),
          .en3(en3),
          .sleeping(sleeping),
          .s2val(s2val),
          .alurflags(alurflags),
          .stop_step(stop_step),
          .debug_if_r(debug_if_r),
          .debug_if_a(debug_if_a),
          .x_multic_busy(x_multic_busy),
          .pcounter_jmp_restart_a(pcounter_jmp_restart_a),

          .aluflags_nxt(i_aluflags_nxt),
          .aluflags_r(i_aluflags_r),
          .do_inst_step_r(do_inst_step_r),
          .en_r(i_en_r),
          .e1flag_r(i_e1flag_r),
          .e2flag_r(i_e2flag_r),
          .hold_host_intrpt_a(hold_host_intrpt_a),
          .hold_host_multic_a(hold_host_multic_a),
          .host_write_en_n_a(host_write_en_n_a),
          .status32_l1_r(i_status32_l1_r),
          .status32_l2_r(i_status32_l2_r),
          .starting(i_starting),
          .breakhalt_r(i_breakhalt_r),
          .actionhalt(i_actionhalt_a),
          .selfhalt_r(i_selfhalt_r));


debug U_debug (   

          .clk(clk),
          .rst_a(rst_a),

          .aux_dataw(aux_dataw),
          .h_a_write(i_h_aux_write_a),
          .aux_dbhit(i_aux_dbhit_a),
          .actionpt_status_r(actionpt_status_r),
          .actionhalt(i_actionhalt_a),
          .en_debug_r(en_debug_r),
          .lpending(lpending),
          .breakhalt_r(i_breakhalt_r),
	  .inst_stepping(inst_stepping),
          .selfhalt_r(i_selfhalt_r),
          .xstep(xstep),
          .p2sleep_inst(p2sleep_inst),
          .starting(i_starting),
          .p1int(p1int),
          .en2(en2),

          .debug_r(i_debug_r),
          .sleeping(sleeping),
          .sleeping_r2(sleeping_r2),
          .step(i_step),
          .inst_step(i_inst_step),
          .reset_applied_r(reset_applied_r));

//  This signal informs the control unit that the actionpoint system 
//  has been triggered by a valid condition, and that the ARC should 
//  be halted.
//  The debug register is also updated.

   assign actionhalt = i_actionhalt_a;

//  The ARC's identity register is a fixed quantity, and can be read 
//  from both the ARC and the host simultaneously. It is produced from
//  constants in arcutil and extutil.

   assign i_identity_r = {`MANCODE, `MANVER, id_arcnum, `ARCVER}; 

//  Produce the 32-bit word supplied to the host when it asks for the 
//  pc/status register.

   assign i_host_pc_r = 32'h0; // this register has been removed from arcver 25 onward

// Produce the 32-bit word supplied to the host when it asks for the  
// status32 register.
//
   assign i_status12_r = {i_aluflags_r, FIVE_ZERO, i_e2flag_r,
                          i_e1flag_r, (~i_en_r)};

   assign i_status32_r = {TWENTY_ZERO, i_status12_r};


//  Select the data value to be driven onto the aux_datar[31:0] bus
//  (*** Note that the pc/status register is never driven onto this
//   bus).
// 
//  (*** also note that drx_reg is only used when constant 
//   XT_AUXREG = '1' - this is defined in extutil).
// 
   assign aux_datar = 
	  (i_aux_lshit_a       == 1'b 1) ? loopstart_r : 
	  (i_aux_lehit_a       == 1'b 1) ? loopend_r : 
	  (i_aux_dbhit_a       == 1'b 1) ? i_debug_r : 
	  (i_aux_status32hit_a == 1'b 1) ? i_status32_r : 
	  (i_aux_l1_hit_a      == 1'b 1) ? i_status32_l1_r : 
	  (i_aux_l2_hit_a      == 1'b 1) ? i_status32_l2_r : 
          (i_aux_misalign_ctrl_a == 1'b 1) ? {i_misalign_ctrl_r[1], {30{1'b0}}, i_misalign_ctrl_r[0]} :
	  ((xreg_hit            == 1'b 1) & (XT_AUXREG  == 1'b 1)) ? drx_reg : 
          i_identity_r; 

//  Select the data value to be supplied to the host when it reads 
//  dual-access registers (pc/status, semaphore register, i_identity_r 
//  register).
// 
   assign aux_dar = 
	(i_h_pchit_a         == 1'b 1) ? i_host_pc_r : 
	(i_h_pchit32_a       == 1'b 1) ? currentpc_r : 
	((x_da_am             == 1'b 1) & (XT_AUXDAR  == 1'b 1)) ? x_dar : 
	(i_h_dbhit_a         == 1'b 1) ? i_debug_r :
	(i_h_status32hit_a   == 1'b 1) ? i_status32_r : 
	(i_h_l1_hit_a        == 1'b 1) ? i_status32_l1_r : 
	(i_h_l2_hit_a        == 1'b 1) ? i_status32_l2_r :
          i_identity_r; 

//  This signal is true when h_addr,aux_access point to a dual-access
//  register (includes registers provided by extensions)

   assign da_auxam = i_h_pchit_a       | 
                     i_h_pchit32_a     | 
                     i_h_dbhit_a       | 
                     i_h_status32hit_a | 
                     i_h_l1_hit_a      | 
                     i_h_l2_hit_a      | 
                     i_h_idhit_a       | 
                     (x_da_am   &
                      XT_AUXDAR &
                      aux_access); 

//========================== Output Drives ===========================--
//
//  ** This includes the global enable signal en. **

   assign en_misaligned = i_misalign_ctrl_r[0];
   assign en           = i_en_r; 
   assign aluflags_nxt = i_aluflags_nxt; 
   assign aluflags_r   = i_aluflags_r; 
   assign e1flag_r     = i_e1flag_r; 
   assign e2flag_r     = i_e2flag_r; 
   assign aux_pchit    = i_aux_pchit_a; 
   assign aux_pc32hit  = i_aux_pc32hit_a; 
   
   assign h_pcwr       = i_h_pcwr_a; 
   assign h_pcwr32     = i_h_pcwr32_a; 
   assign h_status32   = i_h_status32wr_a; 
   assign step         = i_step;
   assign inst_step    = i_inst_step;

endmodule // module aux_regs

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file is extension auxiliary register unit for:
//       Gate-level power meterics toggle switch, power_toggle signal.
//       On-chip LD/ST RAM.
//       ICCM RAM Configuration (i.e. IVIC)
//       JTAG Port Interface, i.e. pc_sel signal.
//       Small Score Boarded Multiply Instruction, Revision info. :  600 Architecture IP Library version 4.9.7, file revision  $Date$
//       Auxiliary Timer Counter 0
// 
//
//=========================== Inputs to this block ==========================--
//
// aux_access       U Auxiliary Access. This signal is flagged by the host to
//                  inform the ARC that the address supplied on h_addr[31:0]
//                  applies to the auxiliary register set. 
//
// aux_addr[31:0]   U Auxiliary Register Address. This is produced by the 
//                  hostif.v, from the host address when the ARC is halted
//                  (en = '0') or from source 1 from pipeline stage 3, when
//                  the ARC is running. Width of decode is set by AUXDECSZ 
//                  in extutil.v. 
//
// aux_dataw[31:0]  U Auxiliary Write Data. The auxiliary register bus 
//                  write data value is latched into auxiliary register
//                  specified by aux_addr[31:0] at the end of the cycle when
//                  aux_write is true. This is generated by hostif.v, 
//                  either from the host's write data bus when the ARC is 
//                  halted (en = '0') or from source 1 from pipeline stage 3,
//                  when the ARC is running.
//
// aux_read         U Auxiliary Read. This signal indicates that a read is 
//                  taking place on this cycle. This is initiated either by
//                  an LR instruction when the ARC is running, or by a host
//                  read when the ARC is halted (for single access aux 
//                  registers). The data stored at location aux_addr[31:0]
//                  should be placed on drx_reg[31:0]. The xreg_hit signal
//                  should be asserted if the register in question is
//                  recognised as a valid extension auxiliary register.
//                  For dual access registers, aux_regs.v and hostif.v
//                  will select the correct data values to go to the ARC and
//                  the host.
//
// aux_write        U Auxiliary Write. This signal indicates that a write
//                  (either from the ARC or host) is being performed to
//                  the auxiliary register specified on aux_addr[31:0] on 
//                  this cycle. This signal is set by hostif.v by a SR
//                  instruction when the ARC is running or a host when it is
//                  halted. The data supplied by aux_dataw[31:0] should be 
//                  latched into register specified by aux_addr[31:0] at the
//                  end of the cycle.
//                  For dual access extension registers, writes are ignored
//                  from regular auxiliary register bus aux_write, aux_addr[],
//                  and aux_dataw[] when the ARC is halted.
//
// core_access      U Core Access. This enable signal is held high by the host
//                  to indicate that it is accessing core registers.
//
// en2b             U Pipeline stage 2B enable. When this signal is true, the
//                  instruction in stage 2B can pass into stage 3 at the end
//                  of the cycle. When it is false, it will hold up stage 2B,
//                  stage 2 and stage 1 (pcen).
//
// en3              U Pipeline stage 3 enable. When this signal is true, the
//                  instruction in stage 3 can pass into stage 4 at the end
//                  of the cycle. When it is false, it will probably hold up
//                  stages one (pcen), two (en2), two B (en2b)and three. It
//                  is set in the rctl block.
//
// h_addr[31:0]     L Host Address. This is a longword-granularity address
//                  latched by the host before being presented to the register
//                  module. This is a 32-bit address (it may be smaller,
//                  but packed with zeroes) from the host which is used to
//                  access registers in the ARC in conjuction with aux_access
//                  and core_access. The width of the decode applied to this
//                  32-bit quantity is defined by the AUXDECSZ constant, found
//                  in extutil.v. It is defined as being a 32-bit bus
//                  at this level to maintain compatibility with the LR and 
//                  SR instructions which can generate a 32-bit value for the
//                  address to be used for auxiliary register accesses.
//
// h_dataw[31:0]    L Host Write Data. This bus carries the data which is to
//                  be stored into registers in the ARC/extensions. It is 
//                  latched by the host as is the address, h_addr[31:0].
//                  
// h_write          U Host Write. When the host signals h_write is true, this 
//                  signal indicates that a host write is taking place, and
//                  the register module should latch the data on h_dataw[31:0]
//                  at the end of the cycle.
//
// h_read           U Host Read. This signal is held high by the host to
//                  indicate that a host read is taking place, and the data
//                  will be latched from h_datar[31:0] at the end of the
//                  cycle.
//
// ic_busy          U No Invalidate Instruction Cache. This signal is set true
//                  by dmcc.v, to indicate that no instruction cache
//                  invalidate requests (ivic) are to be made as the cache is
//                  busy. It is set true during tag clearing and line loads 
//                  from memory.
//
// l_irq[31:3]      L Latched external interrupts. A maximum of 8 external
//                  external interrupt may be generated.
//
// p3sr             U Pipeline Stage 3, SR. This signal is generated by 
//                  rctl.v to indicate that a valid SR instruction is in 
//                  stage 3.  It is produced from a decode of p3i[4:0], 
//                  p3iw(25) (check for SR) and includes p3iv. Here it is
//                  basically used for separate decoding of auxiliary accesses
//                  from host and ARC.
//
// p3lr             U Pipeline Stage 3, LR. This signal is generated by 
//                  rctl.v to indicate that a valid LR instruction is in 
//                  stage 3 and includes p3iv. Here it is basically used for
//                  separate decoding of auxiliary accesses from host and ARC.
//
// s1val[31:0]      U This bus is the source 1 bus latched from s1bus[31:0] 
//                  when the instruction in stage 2 passes on to stage 3.
//                  It is used as an input to the ALU, and for various other
//                  purposes outside rctl.v.
//
// s2val[31:0]      U This bus is the source 2 bus latched from s2bus[31:0] 
//                  when the instruction in stage 2 passes on to stage 3.
//                  It is used as an input to the ALU, and for various other
//                  purposes outside rctl.v.
//
// sr_xhold_host_a  U Stall From Register File for Host Access. The register
//                  file signals a stall to xhold_host if it has not completed
//                  a read from the register file. Hence a stall is
//                  generated when :
//
//                  The ARC is halted,
//                  The host is attempting a core register read,
//                  The previous cycle's host access was OK (not stalled).
//                  This is not necessary for the ARCAngel build.
//
// aux_lv12         L signal directly from the l_aux_lv12 register in int_unit
//                  module. This 2 bit register indicates when either level 1
//                  or level 2 interrupts are taken in the interrupt subsystem.
//
// aux_hint         L signal directly from the l_aux_h_int register in int_unit
//                  module. This 5 bit register contains the interrupt number
//                  for the software triggered interrupt.
//
// aux_lev          L signal directly from the l_aux_lev register in int_unit
//                  module. This 13 (or 29 bit for extended case) register
//                  is used for programming the interrupt level of each
//                  configured interrupt signal.
//
//========================= Output from this block ==========================--
//
// drx_reg[31:0]    U Data Read Extension Register. This bus carries the value
//                  from the extension auxiliary register specified by 
//                  aux_addr[31:0]. The data is placed onto aux_datar[31:0] by
//                  the ARC auxiliary register unit when xreg_hit is true. 
//                  Note this will be ignored unless enabled using the
//                  XT_AUXREG constant in extutil.v.
//
// xreg_hit         U Extension Register Hit. This signal is used to indicate
//                  to the auxiliary register module that the location
//                  aux_addr[31:0] is valid extension auxiliary register,
//                  hence the data present on the drx_regs[31:0] bus, and 
//                  should be driven onto aux_datar[]. This controls the data
//                  that gets onto the bus between hostif.v and
//                  aux_regs.v for single access reads. For dual access 
//                  reads xreg_hit is ignored by hostif.v when the ARC is
//                  halted.
//                  ** Note that existing auxiliary registers take priority
//                     if this signal is true when internal aux registers are
//                     being accessed **
//
// x_da_am          U Extension Dual Access Address Match. This signal is true
//                  when the address on h_addr[31:0] matches a dual access
//                  auxiliary registers provided by extension logic, and
//                  indicates that aux_regs should place the data on x_dar[]
//                  onto the aux_dar[] bus.
//
// x_dar[31:0]      U Extension Dual Access Read. This is the host-side data
//                  from a extension dual access register to xaux_regs.v,
//                  where it is multiplexed with data from basecase dual 
//                  access registers before being passed onto the hostif.v.
//
// id_arcnum[7:0]   C ARC Identity Number. This signal defines bits 15:8 of 
//                  the ARC's identity register. It will be fixed at some 
//                  value to allow different ARCs in a multiple ARC system to
//                  have a unique identity.
//
// xnoaccess        U Extension No Host Access. This indicates to the host 
//                  interface that the extension auxiliary unit rejects the
//                  host access when it is true.
//
// xhold_host       U Stall Host Access. When true this signal indicates that
//                  the host must be held off for a cycle since the extension
//                  auxiliary unit is busy completing a task.
//
// dc_disable_r     L Data cache disable flag (DC flag). If there is no data
//                  cache in the build then this signal is always set.
//
// ivic             U Invalidate Instruction Cache. This indicates that all 
//                  values in the cache are to be invalidated. (it stands for
//                  InValidate Instruction Cache). It is anticipated that this
//                  signal will be generated from a decode of an store (SR) 
//                  instruction.
//                  Note that due to the pipelined nature of the ARC, up to  
//                  three instructions could be issued following the SR which 
//                  generates the ivic signal to dmcc.v. Cache invalidates  
//                  must be supressed when a line is being loaded from memory. 
//
// irq[31:3]        L Interrupt signals send to the interrupt unit. The
//                  interrupts may be externally generated i.e. connected to
//                  external pins, connected to on-chip peripherals, e.g. UARTs
//                  and VMACs or be diconnected i.e. assigned to zero. The
//                  system builder should assign the interrupt connectivity
//                  as specified by the user.
//
// wd_clear         This signal is produced by or-ing all the watchdog clear
//                  signals from timers and is input to io_flops.v where it
//                  check synchronously and if asserted then the system reset
//                  line is activated for one cycle.
//
//===========================================================================--
//

module xaux_regs (clk,
                  rst_a,
                  en,
                  aux_addr,
                  aux_dataw,
                  aux_write,
                  aux_read,
                  h_addr,
                  h_dataw,
                  h_write,
                  h_read,
                  aux_access,
                  core_access,
                  en2b,
                  en3,
                  s1val,
                  s2val,
                  x_s_flag,
                  x_set_sflag,
		  // external or external peripheral IRQs.
	          l_irq_4,
	          l_irq_5,
	          l_irq_6,
	          l_irq_7,
	          l_irq_8,
	          l_irq_9,
	          l_irq_10,
	          l_irq_11,
	          l_irq_12,
	          l_irq_13,
	          l_irq_14,
	          l_irq_15,
	          l_irq_16,
	          l_irq_17,
	          l_irq_18,
	          l_irq_19,
		  // Internal peripherals (e.g. timer)
		  l_irq_3,
                  sr_xhold_host_a,
                  ic_busy,
                  p3lr,
                  p3sr,
                  aux_lv12,
                  aux_hint,
                  aux_lev,
                  uxdrx_reg,  
                  uxreg_hit,  
                  ux_da_am,   
                  ux_dar,     
                  uxivic,     
                  uxhold_host,
                  uxnoaccess, 
   ap_ahv0,
   ap_ahv1,
   ap_ahv2,
   ap_ahv3,
   ap_ahv4,
   ap_ahv5,
   ap_ahv6,
   ap_ahv7,
   ap_ahc0,
   ap_ahc1,
   ap_ahc2,
   ap_ahc3,
   ap_ahc4,
   ap_ahc5,
   ap_ahc6,
   ap_ahc7,
   ap_ahm0,
   ap_ahm1,
   ap_ahm2,
   ap_ahm3,
   ap_ahm4,
   ap_ahm5,
   ap_ahm6,
   ap_ahm7,
                  timer_r,
                  tlimit_r,
                  timer_pirq_r,
                  tcontrol_r,
                  timer_mode_r,
                  timer_clr_r,
                  twatchdog_r,

                  drx_reg,
                  xreg_hit,
                  x_da_am,
                  x_dar,
                  id_arcnum,
                  xnoaccess,
                  xhold_host,
                  xcache_hold_host,
                  dc_disable_r,
                  // extra signals for host interface                  
                  power_toggle,
                  lram_base,
                  // extra signals for host interface                  
                  pc_sel_r,
                  aux_st_mulhi_a,
                  int_vector_base_r,
                  irq,
                  ivic,
                  wd_clear
                  );
   
`include "arcutil_pkg_defines.v" 
`include "arcutil.v"
`include "asmutil.v"
`include "ext_msb.v"
`include "extutil.v"
`include "che_util.v"
`include "xdefs.v"

// Extra include files required for extensions are inserted here.

   input         clk; //  system clock
   input         rst_a; //  system reset
   input         en; //  system go
   
   input  [31:0] aux_addr; 
   input  [31:0] aux_dataw; 
   input         aux_write; 
   input         aux_read; 
   input  [31:0] h_addr; 
   input  [31:0] h_dataw; 
   input         h_write; 
   input         h_read; 
   input         aux_access; 
   input         core_access;
   input         en2b; 
   input         en3; 
   input  [31:0] s1val;
   input  [31:0] s2val;
   input  [1:0]  x_s_flag;
   input         x_set_sflag;
   input         l_irq_4;
   input         l_irq_5;
   input         l_irq_6;
   input         l_irq_7;
   input         l_irq_8;
   input         l_irq_9;
   input         l_irq_10;
   input         l_irq_11;
   input         l_irq_12;
   input         l_irq_13;
   input         l_irq_14;
   input         l_irq_15;
   input         l_irq_16;
   input         l_irq_17;
   input         l_irq_18;
   input         l_irq_19;
   input         l_irq_3;
   input         sr_xhold_host_a;
   input         ic_busy; 
   input         p3lr; 
   input         p3sr; 
   input  [1:0]  aux_lv12; 
   input  [4:0]  aux_hint; 
   input  [31:3] aux_lev; 
   
   input  [31:0] uxdrx_reg;
   input         uxreg_hit;  
   input         ux_da_am;   
   input  [31:0] ux_dar;     
   input         uxivic;     
   input         uxhold_host;
   input         uxnoaccess; 

// <add more signals as appropriate>--
//
//  Signals required for extensions are inserted here. The automatic
//  hierarchy generation system can be used to create the structural
//  HDL to tie all the components together, provided that certain
//  naming and usage rules are followed. Please see the document
//  'Automatic Hierarchy Generator' - $ARCHOME/arc/docs/hiergen.pdf
// 
   input [31:0] ap_ahv0; 
   input [31:0] ap_ahv1; 
   input [31:0] ap_ahv2; 
   input [31:0] ap_ahv3; 
   input [31:0] ap_ahv4; 
   input [31:0] ap_ahv5; 
   input [31:0] ap_ahv6; 
   input [31:0] ap_ahv7; 
   input [31:0] ap_ahc0; 
   input [31:0] ap_ahc1; 
   input [31:0] ap_ahc2; 
   input [31:0] ap_ahc3; 
   input [31:0] ap_ahc4; 
   input [31:0] ap_ahc5; 
   input [31:0] ap_ahc6; 
   input [31:0] ap_ahc7; 
   input [31:0] ap_ahm0; 
   input [31:0] ap_ahm1; 
   input [31:0] ap_ahm2; 
   input [31:0] ap_ahm3; 
   input [31:0] ap_ahm4; 
   input [31:0] ap_ahm5; 
   input [31:0] ap_ahm6; 
   input [31:0] ap_ahm7; 
   input   [TIMER_MSB:0] timer_r; 
   input   [TIMER_MSB:0] tlimit_r;
   input         timer_pirq_r; 
   input         tcontrol_r; 
   input         timer_mode_r; 
   input         timer_clr_r; 
   input         twatchdog_r;

   output [31:0] drx_reg; 
   output        xreg_hit; 
   output        x_da_am; 
   output [31:0] x_dar; 
   output [7:0]  id_arcnum;
   output        xnoaccess; 
   output        xhold_host; 
   output        xcache_hold_host; 
   output        dc_disable_r;

// <add more signals as appropriate>--
//
//  Signals required for extensions are inserted here. The automatic
//  hierarchy generation system can be used to create the structural
//  HDL to tie all the components together, provided that certain
//  naming and usage rules are followed. Please see the document
//  'Automatic Hierarchy Generator' - $ARCHOME/arc/docs/hiergen.pdf
// 
   output        power_toggle;
   output  [EXT_A_MSB:LDST_A_MSB + 3] lram_base; 
   wire    [EXT_A_MSB:LDST_A_MSB + 3] lram_base;
   output        pc_sel_r;
   output        aux_st_mulhi_a;

   output [PC_MSB:`INT_BASE_LSB] int_vector_base_r;
   output [31:3] irq;
   output        ivic; 
   output        wd_clear; 

   reg           power_toggle;
   reg           pc_sel_r;
   wire   [31:0] drx_reg; 
   wire          xreg_hit; 
   wire          x_da_am; 
   wire   [31:0] x_dar; 
   wire   [7:0]  id_arcnum; 
   wire          xnoaccess; 
   wire          xhold_host;
   wire          dc_disable_r;
   wire          wd_clear; 
   wire   [PC_MSB:`INT_BASE_LSB] int_vector_base_r;
   wire          ivic; 
   wire          i_ivic; 
   reg    [PC_MSB:`INT_BASE_LSB]  i_int_vector_base_r;

//  extra signals for LD/ST RAM for load/store accesses
   reg     [EXT_A_MSB-1:LDST_A_MSB + 3] i_ldst_ram_base_addr_r;
   wire    [31:0]                     i_ldst_ram_full_a; 
   wire    [LDST_A_MSB + 2:0]         i_ldst_ram_fill_a; 
   wire          aux_st_mulhi_a;

// =========================== Extension Aux. Reads =========================--
// 
//  The data read extension register carries the value specified by the
//  auxiliary address, aux_addr[31:0], from the basecase ARC when the signal
//  xreg_hit is true. The bus drx_reg[31:0] carries data from single access
//  registers, or the ARC side of dual access registers, but never the host
//  side of dual access registers which are always on x_dar[31:0].
// 
//  auxdc : Aux Register Decode
//  
//  This function provides an invaluable facility of performing the register
//  decode on a 32-bit quantity using the appropriate decode width set by the
//  constant AUXDECSZ. These are to be found in extutil.v.
// 
//  The first 13 address decodes represent the build configuration registers.
//  These registers allow embedded software or host debug software to detect
//  the configuration of ARC hardware. All current v2.1 and v3.0 extensions 
//  are represented. 
// 
//  These registers are always present. The value returned is set to zero if 
//  the extension is not present, if it is present the version number and
//  configuration information is returned.
// 
//  These are just address decodes assigning constants to the data read bus
//  'drx_reg'. The values may be found in 'xdefs.v'.
// 
   assign drx_reg = 
//  Example : auxdc(aux_addr,aux_ext_addr) == 1'b 1 ? ext_aux_data :
// 
// Extension auxiliary reads decodes inserted here
 
    auxdc(aux_addr, aux_ap_amv0) == 1'b1 ?  ap_ahv0 : 
    auxdc(aux_addr, aux_ap_amv1) == 1'b1 ?  ap_ahv1 : 
    auxdc(aux_addr, aux_ap_amv2) == 1'b1 ?  ap_ahv2 : 
    auxdc(aux_addr, aux_ap_amv3) == 1'b1 ?  ap_ahv3 : 
    auxdc(aux_addr, aux_ap_amv4) == 1'b1 ?  ap_ahv4 : 
    auxdc(aux_addr, aux_ap_amv5) == 1'b1 ?  ap_ahv5 : 
    auxdc(aux_addr, aux_ap_amv6) == 1'b1 ?  ap_ahv6 : 
    auxdc(aux_addr, aux_ap_amv7) == 1'b1 ?  ap_ahv7 : 
    auxdc(aux_addr, aux_ap_ac0)  == 1'b1 ?  ap_ahc0 : 
    auxdc(aux_addr, aux_ap_ac1)  == 1'b1 ?  ap_ahc1 : 
    auxdc(aux_addr, aux_ap_ac2)  == 1'b1 ?  ap_ahc2 : 
    auxdc(aux_addr, aux_ap_ac3)  == 1'b1 ?  ap_ahc3 : 
    auxdc(aux_addr, aux_ap_ac4)  == 1'b1 ?  ap_ahc4 : 
    auxdc(aux_addr, aux_ap_ac5)  == 1'b1 ?  ap_ahc5 : 
    auxdc(aux_addr, aux_ap_ac6)  == 1'b1 ?  ap_ahc6 : 
    auxdc(aux_addr, aux_ap_ac7)  == 1'b1 ?  ap_ahc7 : 
    auxdc(aux_addr, aux_ap_amm0) == 1'b1 ?  ap_ahm0 : 
    auxdc(aux_addr, aux_ap_amm1) == 1'b1 ?  ap_ahm1 : 
    auxdc(aux_addr, aux_ap_amm2) == 1'b1 ?  ap_ahm2 : 
    auxdc(aux_addr, aux_ap_amm3) == 1'b1 ?  ap_ahm3 : 
    auxdc(aux_addr, aux_ap_amm4) == 1'b1 ?  ap_ahm4 : 
    auxdc(aux_addr, aux_ap_amm5) == 1'b1 ?  ap_ahm5 : 
    auxdc(aux_addr, aux_ap_amm6) == 1'b1 ?  ap_ahm6 : 
    auxdc(aux_addr, aux_ap_amm7) == 1'b1 ?  ap_ahm7 : 
    auxdc(aux_addr, AUX_LDST_RAM)        == 1'b 1 ? i_ldst_ram_full_a :
    //  Timer 0
    // 
    (auxdc(aux_addr, aux_timer)           == 1'b 1) ? timer_r : 
    (auxdc(aux_addr, aux_tlimit)          == 1'b 1) ? tlimit_r : 
    (auxdc(aux_addr, aux_tcontrol)        == 1'b 1) ?
    {{(DATAWORD_WIDTH - (4)){1'b 0}}, timer_pirq_r, twatchdog_r, timer_mode_r,
     tcontrol_r} : 

    // Interrupt subsystem programming registers

    (auxdc(aux_addr, AUX_IRQ_LV12)        == 1'b 1) ? {{(30){1'b 0}}, aux_lv12} : 
    (auxdc(aux_addr, AUX_IRQ_HINT)        == 1'b 1) ? {{(27){1'b 0}}, aux_hint} : 
    (auxdc(aux_addr, AUX_IRQ_LEV)         == 1'b 1) ? {aux_lev, 3'b 0} :

    // Common configuration registers (dual access)

    (auxdc(aux_addr, AUX_INT_VECTOR_BASE) == 1'b 1) ? {{32-24{1'b0}}, i_int_vector_base_r,
                                                     TEN_ZERO} :
    (auxdc(aux_addr, ARC600_BUILD)        == 1'b 1) ? ARC600_BUILD_VALUE :
    (auxdc(aux_addr, BCR_VERSION_BUILD)   == 1'b 1) ? BCR_VERSION_BUILD_VALUE :
    (auxdc(aux_addr, DATASPACE_BUILD)     == 1'b 1) ? DATASPACE_BUILD_VALUE:
    (auxdc(aux_addr, MEMSUBSYS_BUILD)     == 1'b 1) ? MEMSUBSYS_BUILD_VALUE:
    (auxdc(aux_addr, VECBASE_AC_BUILD)    == 1'b 1) ? VECBASE_AC_BUILD_VALUE :
    (auxdc(aux_addr, PERIPH_BUILD)        == 1'b 1) ? PERIPH_BUILD_VALUE :
    (auxdc(aux_addr, RF_BUILD)            == 1'b 1) ? RF_BUILD_VALUE :
    (auxdc(aux_addr, AA2_BUILD)           == 1'b 1) ? RESERVED_BUILD_VALUE :
    (auxdc(aux_addr, MADI_BUILD)          == 1'b 1) ? MADI_BUILD_VALUE : 
    (auxdc(aux_addr, LDSTRAM_BUILD)       == 1'b 1) ? LDSTRAM_BUILD_VALUE : 
    (auxdc(aux_addr, TIMER_BUILD)         == 1'b 1) ? TIMER_BUILD_VALUE : 
    (auxdc(aux_addr, AP_BUILD)            == 1'b 1) ? AP_BUILD_VALUE : 
    (auxdc(aux_addr, ICCM_BUILD)          == 1'b 1) ? ICCM_BUILD_VALUE : 
    (auxdc(aux_addr, MULTIPLY_BUILD)      == 1'b 1) ? MULTIPLY_BUILD_VALUE : 
    (auxdc(aux_addr, SWAP_BUILD)          == 1'b 1) ? SWAP_BUILD_VALUE : 
    (auxdc(aux_addr, NORM_BUILD)          == 1'b 1) ? NORM_BUILD_VALUE : 
//UNUSEDUNUSED    (auxdc(aux_addr, BARREL_BUILD)        == 1'b 1) ? BARREL_BUILD_VALUE :
//    (auxdc(aux_addr, BARREL_BUILD)        == 1'b 1) ? BARREL_BUILD_VALUE :
(auxdc(aux_addr, BARREL_BUILD) == 1'b1) ? BARREL_BUILD_VALUE :
    ((!(|aux_addr[AUXDECSZ:8])) && ((aux_addr[7:6] == 2'b11) || (aux_addr[7:5] == 3'b011))) ?  UNUSED_BUILD_VALUE : 
    uxdrx_reg; 
// 
//  The extension register hit informs the auxiliary register unit, aux_regs, 
//  the location address, aux_addr[31:0], is a valid extension register
// 
//  The build configuration register decodes are always present.
// 
   assign xreg_hit = 
//  Example : auxdc(aux_addr,aux_ext_addr) == 1'b 1 ? ext_aux_data :
// 
// Extension auxiliary register hits inserted here
    auxdc(aux_addr, aux_ap_amv0) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv1) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv2) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv3) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv4) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv5) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv6) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv7) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac0)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac1)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac2)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac3)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac4)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac5)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac6)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac7)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm0) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm1) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm2) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm3) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm4) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm5) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm6) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm7) == 1'b1 ? 1'b1 :
    auxdc(aux_addr,AUX_LDST_RAM)         == 1'b 1 ? 1'b 1 :
    //  Timer 0
    // 
    (auxdc(aux_addr, aux_timer)           == 1'b 1) ? 1'b 1 : 
    (auxdc(aux_addr, aux_tcontrol)        == 1'b 1) ? 1'b 1 : 
    (auxdc(aux_addr, aux_tlimit)          == 1'b 1) ? 1'b 1 : 

    // Interrupt subsystem programming registers
    (auxdc(aux_addr, AUX_IRQ_LV12)        == 1'b 1) ? 1'b 1 : 
    (auxdc(aux_addr, AUX_IRQ_HINT)        == 1'b 1) ? 1'b 1 : 
    (auxdc(aux_addr, AUX_IRQ_LEV)         == 1'b 1) ? 1'b 1 : 


    // Common configuration registers (dual access)
    (auxdc(aux_addr, AUX_INT_VECTOR_BASE) == 1'b 1) ? 1'b 1 : 
    auxdc(aux_addr, AUX_SYSTEM_BUILD)   == 1'b 1 ? 1'b 1 :
    ((!(|aux_addr[AUXDECSZ:8])) && ((aux_addr[7:6] == 2'b11) || (aux_addr[7:5] == 3'b011))) ? 1'b 1 : 
    uxreg_hit; 
// 
//  The facility for adding extension dual access registers has been provided
//  to facilitate accesses to auxiliary registers whilst the ARC is running.
//  Hence, these registers must be able to handle being accessed siultaneously
//  from the ARC and the host. Source of problems may arise from the case where
//  both the host and the ARC attempt to write to the same dual access auxiliary
//  register. These conflicts must be resolved by the ext. auxiliary registers
//  by design or by stalling the ARC or the host.
//  It must be noted that accesses from the host will appear on both ARC side
//  (drx_reg) and the host side (x_dar) when the ARC is halted (en = '0').
//  This may appear to be a possible conflict as the ARC is halted. When
//  designing the extension the logic which detects and resolves conflicts must
//  account for this.
// 
//  The dual access configuration registers are always present
// 
   assign x_da_am = 
//  Example : auxdc(h_addr,aux_ext_addr2) == 1'b 1 ?  1'b 1 :
// 
// Extension dual access address match decodes inserted here
    auxdc(h_addr, aux_ap_amv0) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv1) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv2) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv3) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv4) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv5) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv6) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv7) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac0)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac1)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac2)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac3)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac4)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac5)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac6)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac7)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm0) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm1) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm2) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm3) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm4) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm5) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm6) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm7) == 1'b1 ? 1'b1 :

    // Interrupt subsystem programming registers - host interface

    (auxdc(h_addr, AUX_IRQ_LV12)        == 1'b 1) ? 1'b 1 : 
    (auxdc(h_addr, AUX_IRQ_HINT)        == 1'b 1) ? 1'b 1 : 
    (auxdc(h_addr, AUX_IRQ_LEV)         == 1'b 1) ? 1'b 1 : 

    // Common configuration registers (dual access)
    (auxdc(h_addr, AUX_INT_VECTOR_BASE) == 1'b 1) ? 1'b 1 : 
    auxdc(h_addr, AUX_SYSTEM_BUILD)   == 1'b 1 ? 1'b 1 :
    ((!(|h_addr[AUXDECSZ:8])) && ((h_addr[7:6] == 2'b11) || (h_addr[7:5] == 3'b011))) ? 1'b 1 : 
    ux_da_am; 
// 
//  The read data from the host side is passed through this interface to the
//  host interface via the ARC auxiliary register unit, aux_regs.v.
// 
//  The dual access configuration registers are always present
// 
   assign x_dar = 

    auxdc(h_addr, aux_ap_amv0) == 1'b1 ?  ap_ahv0 : 
    auxdc(h_addr, aux_ap_amv1) == 1'b1 ?  ap_ahv1 : 
    auxdc(h_addr, aux_ap_amv2) == 1'b1 ?  ap_ahv2 : 
    auxdc(h_addr, aux_ap_amv3) == 1'b1 ?  ap_ahv3 : 
    auxdc(h_addr, aux_ap_amv4) == 1'b1 ?  ap_ahv4 : 
    auxdc(h_addr, aux_ap_amv5) == 1'b1 ?  ap_ahv5 : 
    auxdc(h_addr, aux_ap_amv6) == 1'b1 ?  ap_ahv6 : 
    auxdc(h_addr, aux_ap_amv7) == 1'b1 ?  ap_ahv7 : 
    auxdc(h_addr, aux_ap_ac0)  == 1'b1 ?  ap_ahc0 : 
    auxdc(h_addr, aux_ap_ac1)  == 1'b1 ?  ap_ahc1 : 
    auxdc(h_addr, aux_ap_ac2)  == 1'b1 ?  ap_ahc2 : 
    auxdc(h_addr, aux_ap_ac3)  == 1'b1 ?  ap_ahc3 : 
    auxdc(h_addr, aux_ap_ac4)  == 1'b1 ?  ap_ahc4 : 
    auxdc(h_addr, aux_ap_ac5)  == 1'b1 ?  ap_ahc5 : 
    auxdc(h_addr, aux_ap_ac6)  == 1'b1 ?  ap_ahc6 : 
    auxdc(h_addr, aux_ap_ac7)  == 1'b1 ?  ap_ahc7 : 
    auxdc(h_addr, aux_ap_amm0) == 1'b1 ?  ap_ahm0 : 
    auxdc(h_addr, aux_ap_amm1) == 1'b1 ?  ap_ahm1 : 
    auxdc(h_addr, aux_ap_amm2) == 1'b1 ?  ap_ahm2 : 
    auxdc(h_addr, aux_ap_amm3) == 1'b1 ?  ap_ahm3 : 
    auxdc(h_addr, aux_ap_amm4) == 1'b1 ?  ap_ahm4 : 
    auxdc(h_addr, aux_ap_amm5) == 1'b1 ?  ap_ahm5 : 
    auxdc(h_addr, aux_ap_amm6) == 1'b1 ?  ap_ahm6 : 
    auxdc(h_addr, aux_ap_amm7) == 1'b1 ?  ap_ahm7 : 

    // Interrupt subsystem programming registers - host interface

    (auxdc(h_addr, AUX_IRQ_LV12)        == 1'b 1) ? {{(30){1'b 0}}, aux_lv12} : 
    (auxdc(h_addr, AUX_IRQ_HINT)        == 1'b 1) ? {{(27){1'b 0}}, aux_hint} : 
    (auxdc(h_addr, AUX_IRQ_LEV)         == 1'b 1) ? {aux_lev, 3'b 0} :

    // Common configuration registers (dual access)
        
    (auxdc(h_addr, AUX_INT_VECTOR_BASE) == 1'b 1) ? {{32-24{1'b0}}, i_int_vector_base_r,
                                                   TEN_ZERO} :
    (auxdc(h_addr, ARC600_BUILD)        == 1'b 1) ? ARC600_BUILD_VALUE :
    (auxdc(h_addr, BCR_VERSION_BUILD)   == 1'b 1) ? BCR_VERSION_BUILD_VALUE :
    (auxdc(h_addr, DATASPACE_BUILD)     == 1'b 1) ? DATASPACE_BUILD_VALUE:
    (auxdc(h_addr, MEMSUBSYS_BUILD)     == 1'b 1) ? MEMSUBSYS_BUILD_VALUE:
    (auxdc(h_addr, VECBASE_AC_BUILD)    == 1'b 1) ? VECBASE_AC_BUILD_VALUE :
    (auxdc(h_addr, PERIPH_BUILD)        == 1'b 1) ? PERIPH_BUILD_VALUE : 
    (auxdc(h_addr, RF_BUILD)            == 1'b 1) ? RF_BUILD_VALUE : 
    (auxdc(h_addr, AA2_BUILD)           == 1'b 1) ? RESERVED_BUILD_VALUE :
    (auxdc(h_addr, MADI_BUILD)          == 1'b 1) ? MADI_BUILD_VALUE : 
    (auxdc(h_addr, LDSTRAM_BUILD)       == 1'b 1) ? LDSTRAM_BUILD_VALUE : 
    (auxdc(h_addr, TIMER_BUILD)         == 1'b 1) ? TIMER_BUILD_VALUE : 
    (auxdc(h_addr, AP_BUILD)            == 1'b 1) ? AP_BUILD_VALUE : 
    (auxdc(h_addr, ICCM_BUILD)          == 1'b 1) ? ICCM_BUILD_VALUE :  
    (auxdc(h_addr, MULTIPLY_BUILD)      == 1'b 1) ? MULTIPLY_BUILD_VALUE : 
    (auxdc(h_addr, SWAP_BUILD)          == 1'b 1) ? SWAP_BUILD_VALUE : 
    (auxdc(h_addr, NORM_BUILD)          == 1'b 1) ? NORM_BUILD_VALUE : 
    ((!(|h_addr[AUXDECSZ:8])) && ((h_addr[7:6] == 2'b11) || (h_addr[7:5] == 3'b011))) ?  UNUSED_BUILD_VALUE : 
    ux_dar;

//========================= Int Vector Base Address ========================--
//
// The interrupt vector base address is generated here and is employed for
// handling interrupts and exceptions.
//
//
   always @(posedge clk or posedge rst_a)
   begin : INT_VECT_PROC

   if (rst_a == 1'b 1)

      begin
      i_int_vector_base_r[PC_MSB : `INT_BASE_LSB] <= 
// leda W557 off
      VECBASE_AC_BUILD_VALUE[PC_MSB:`INT_BASE_LSB];
// leda W557 on
      end

   else

      begin
       if ((auxdc(aux_addr, AUX_INT_VECTOR_BASE) == 1'b 1) &
           (aux_write == 1'b 1))
          begin
          i_int_vector_base_r[PC_MSB : `INT_BASE_LSB] <=
          aux_dataw[PC_MSB : `INT_BASE_LSB];
          end
       else if ((auxdc(h_addr, AUX_INT_VECTOR_BASE) == 1'b 1) &
                (h_write == 1'b 1) &
                (aux_access == 1'b 1))
          begin
          i_int_vector_base_r[PC_MSB : `INT_BASE_LSB] <=
          h_dataw[PC_MSB : `INT_BASE_LSB];
          end
      end

   end

   assign int_vector_base_r = i_int_vector_base_r[PC_MSB : `INT_BASE_LSB];

// ========================== Saturate Flag register ========================--
//
// Aux Reg 41.  This register slot is used by the macmode register when XMAC
//              is in the build, or a Stick Saturate flag register when no
//              XMAC is present and the Extended_arith package is.
//   
 
// ======================= Invalidate Instruction Cache =====================--
// 
// 
//  The i-cache cannot be invalidated when ic_busy is true. This will be the
//  case when the cache is clearing its tags, after reset, or is in the process
//  of doing a line load.
// 
//  If the cache cannot be cleared, then the requesting client must be stalled 
//  until the cache is ready.
// 
//  Note: The ivic signal is set to '0' when no cache is selected.
// 
   assign ivic = 
// 
//  Example : ic_busy == 1'b 0 & aux_write == 1'b 1 ? i_ivic :
//
// Instruction invalidate signal inserted here
       ((ic_busy == 1'b 0) & (aux_write == 1'b 1)) ? i_ivic : 
                 uxivic;

// ============================ Ext. Aux. Stalling ==========================--
// 
//  For systems using more than one ARC the identity register has a field,
//  i.e. bits 15 to 8, where a value is    assigned to give each ARC a unique
//  identity. This value is then available to programs running on the ARC
//  through auxiliary register 0x04 (identity register).  
// 
   assign id_arcnum = `ARCNUM; //  0x01 = Only ARC in the system

//  This indicates to the host interface that the extension auxiliary unit
//  rejects the host access when it is true.
//
                
   assign xnoaccess = 
                      uxnoaccess; 

//  The host is stalled when it tries to access a resource which is
//  currently busy. For example, a stall can be generated from the register
//  file when it is being accessed by the ARC or when cache is being 
//  cleared while the host is trying to write to an auxiliary register when
//  the ARC is halted.
//  
//  This signal should be generated by ORing together multiple stall 
//  signals.
//
   assign xhold_host =  
// 
//  Example :   ext_hold_signal |
// 
// Stalling signal to host inserted here
                       sr_xhold_host_a | 
                       uxhold_host;

//  The host is stalled when it tries to access the instruction fetch logic
//  which is currently busy.
//
// This signal should be generated bt ORing together multiple stall signals.
//
   assign xcache_hold_host =
                             1'b 0;
       

// ========================= Interrupt connectivity ==========================--
// 
//  Interrupt connectivity
//  This code maps the interrupt signal output to their sources.
// 
//  1) interrupts connected to external pins
//  2) interrupts connected to peripherals
//  3) interrupts diconnected
// 
//  note1: ext_irq(n), per_irq(n) and dis_irq(n) are mutually exclusive so 
//  that if one of them is true (ie. is equal to " " (space) then the 
//  other two are equal to "--".
// 
//  note 2: The peripheral connectivity (eg. timer(s) or uart(s) should be
//  done before the signals arrive at this module
// 
//  1) if interrupts are connected to external pins

   assign irq[4] = l_irq_4;
   assign irq[5] = l_irq_5;
   assign irq[6] = l_irq_6;
   assign irq[7] = l_irq_7;
   assign irq[8] = l_irq_8;
   assign irq[9] = l_irq_9;
   assign irq[10] = l_irq_10;
   assign irq[11] = l_irq_11;
   assign irq[12] = l_irq_12;
   assign irq[13] = l_irq_13;
   assign irq[14] = l_irq_14;
   assign irq[15] = l_irq_15;
   assign irq[16] = l_irq_16;
   assign irq[17] = l_irq_17;
   assign irq[18] = l_irq_18;
   assign irq[19] = l_irq_19;

//  2) if interrupts are connected to peripherals

   assign irq[3] = l_irq_3;

//  2a) inter-core interrupts


//  3) if interrupts are disconnected

   assign irq[20] = 1'b 0;
   assign irq[21] = 1'b 0;
   assign irq[22] = 1'b 0;
   assign irq[23] = 1'b 0;
   assign irq[24] = 1'b 0;
   assign irq[25] = 1'b 0;
   assign irq[26] = 1'b 0;
   assign irq[27] = 1'b 0;
   assign irq[28] = 1'b 0;
   assign irq[29] = 1'b 0;
   assign irq[30] = 1'b 0;
   assign irq[31] = 1'b 0;

// Watchdog signal to generate a system reset if asserted by either of the
// timers.

   assign wd_clear =

                  timer_clr_r | 
                     1'b 0;

// ====================== Miscellaneous Extensions Logic ====================--
// 
// Miscellaneous extension logic functions are inserted here.
// ======================== Power toggle select logic ========================--
// 
   // Latch bit 0 if a write to the power register is detected.
   // This is a write-only register.
   // It is initialized to '0' 
   // 
   always @(posedge clk or posedge rst_a)
      begin : power_toggle_sync_PROC
      if (rst_a == 1'b 1)
         begin
         power_toggle <= 1'b 0;        
         end
      else
         begin
         if (auxdc(aux_addr, AUX_POWER) == 1'b 1 & aux_write == 1'b 1)
            begin
            power_toggle <= aux_dataw[0];        
            end
         end

      end

// ----------------------------------------------------------------------------
//  Control Register for setting base address of the LD/ST RAM.
//
always @(posedge clk or posedge rst_a)
   begin : ldst_ram_PROC
   if (rst_a == 1'b 1)
      begin
      i_ldst_ram_base_addr_r <= LDST_RAM_BASE_DEFAULT[EXT_A_MSB-1:LDST_A_MSB+3];
      end
   else
      begin
      if (auxdc(aux_addr, AUX_LDST_RAM) == 1'b 1 & aux_write == 1'b 1)
         begin
         i_ldst_ram_base_addr_r <= aux_dataw[EXT_A_MSB-1:LDST_A_MSB + 3];   
         end
      end
   end

assign lram_base  = { LDST_RAM_BASE_DEFAULT[EXT_A_MSB], i_ldst_ram_base_addr_r}; 
assign i_ldst_ram_fill_a = {(LDST_A_MSB+3){1'b 0}}; 
 assign i_ldst_ram_full_a = {
                    {32 - (EXT_A_MSB + 1){1'b 0}},
                    {LDST_RAM_BASE_DEFAULT[EXT_A_MSB], i_ldst_ram_base_addr_r, i_ldst_ram_fill_a}}; 

// ---------------------------------------------------------------------


// Address decode of the IVIC register
//
assign i_ivic = (auxdc(aux_addr, AUX_IVIC) == 1'b1) ?  1'b 1 :
       1'b 0;    


// ========================= JTAG Select Control Logic ======================--
// 
// Latch bit 0 if a write to the JTAG control register is detected.
// This is a write-only register.
// It is initialized to '1' to make Sun comms work ... (ie when used with a
// Sun // port this register must not be changed from a '1'!
// 
always @(posedge clk or posedge rst_a)
   begin : JTAG_SYNC_PROC
   if (rst_a == 1'b 1)
      begin
      pc_sel_r <= 1'b 1;        
      end
   else
      begin
      if ((auxdc(aux_addr, AUX_PCPORT) == 1'b 1) & (aux_write == 1'b 1))
         begin
         pc_sel_r <= aux_dataw[0];        
         end
      end

   end


//  Multiplier result register --
// 
//  Detect an auxiliary register write to the high part of the multiplier result
//  The actual register is located in xalu.v
// 
//  Note that no interlock is provided to prevent aux writes from taking place
//  at the same time as a multiply - This can be easily done in software.
// 

   assign aux_st_mulhi_a = (auxdc(aux_addr, AUX_MULHI) == 1'b 1) &
                           (aux_write == 1'b 1) ?
          1'b 1 : 
          1'b 0;


// ----------------------------------------------------------------------------
//  DC flag
// 
//  The DC flag (dc_disable_r) is always set if there is no data cache in the
//  build. If there is a data cache in the build this flag can be set from
//  a program using LR/SR instructions.
//
   assign dc_disable_r = 
                         1'b 1; 

endmodule // module xaux_regs

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// Host interface with the core.This file multiplexes ARC data flows
// with those from the host, in order to allow host access to the core
// and auxiliary registers.
//
//======================= Inputs to this block =======================--
//
// en3_niv_a        Pipeline stage 3 enable. When this signal is true,
//                  the instruction in stage 3 can pass into stage 4 at
//                  the end of the cycle. When it is false, it will
//                  probably hold up stages one (pcen), two (en2), and
//                  three. This version of this signal is not qualified
//                  with ivalid_aligned.
//
// h_addr[31:0]     From Debugger. This is a 32-bit address (it may be
//                  smaller, but packed with zeroes) from the host which
//                  is used to access registers in the ARC in conjuction
//                  with aux_access and core_access. The width of the
//                  decode applied to this 32-bit quantity is defined by
//                  the AUXDECSZ constant, foundin extutil.v. It is
//                  defined as being a 32-bit bus at this level to 
//                  maintain compatibility with the LR and SR
//                  instructions which can generate a 32-bit value for
//                  the address to be used for auxiliary register
//                  accesses.
//
// h_dataw[31:0]    From Debugger. Data from the host to be stored into
//                  registers in the ARC/extensions.
//
// h_write          From Debugger. When it is true, this signal indicates
//                  that a host write is taking place.
//
// h_read           From Debugger. When it is true, this signal indicates
//                  that a host read is taking place.
//
// aux_access       From mc/host. This signal is used to inform the ARC 
//                  that address supplied on h_addr[31:0] applies to
//                  the auxiliary register set. 
//
// core_access      From mc/host. This signal is used to inform the ARC 
//                  that address supplied on h_addr[31:0] applies to
//                  the core register set. The signals core_access and 
//                  aux_access are provided so that the designer of the 
//                  memory controller can decide how the auxiliary
//                  registers and core registers will appear to the host
//                  processor.
//  
// fs2a[5:0]        From rctl.v. The source 2 register address live
//                  and direct from the stage 2 input latches. It is
//                  muxed with the host address to allow host accesses
//                  to registers when the ARC is stopped, before being
//                  output on s2a[5:0]
//
// h_rr_data[31:0]  Data to the host port from register reads. Also
//                  allows the debugger to read p1iw[] for cache
//                  testing. Does not include any returning load data,
//                  or shortcuts from stage three instructions.
//
// s1val[31:0]      From rctl.v. This is the stage 3 source 1 value
//                  direct from the stage 3 input latches. It is used to
//                  generate the auxiliary register bus address, after
//                  being muxed with host accesses.
//
// s2val[31:0]      From rctl.v. This is the stage 3 source 2 value
//                  direct from the stage 3 input latches. It is used to
//                  generate the auxiliary register write data, after
//                  being muxed with host accesses.
//              
// p3lr             U This signal is generated by rctl. It is produced
//                  from a decode of p3opcode, p3iw(13) (check for LR)
//                  and includes p3iv.
//
// p3sr             U This signal is generated by rctl. It is produced
//                  from a decode of p3opcode, p3iw(25) (check for SR)
//                  and includes p3iv.
//
// aux_datar[31:0]  From aux_regs.v. This is the data provided by the 
//                  auxiliary register set in response to a read. It
//                  does not include data from the pc/status register as
//                  these are handled in a special way. It also goes to
//                  the stage3 alu mux logic as it is used to load core
//                  registers as the result of an LR instruction.
//
// aux_dar[31:0]    From aux_regs.v. This is the data from the
//                  PC/status, semaphore and identity registers which
//                  can be read whilst the ARC is running, and hence
//                  does not go down the aux_datar[31:0] bus.
//
// da_auxam         From aux_regs.v. This signal is true when the
//                  address on h_addr[31:0] matches one of the dual
//                  access auxiliary registers (pc/status, semaphore,
//                  and indentity registers).
//
// p3_docmprel_a    A mispredicted BRcc of BBITx has been taken by the ARC
//                  processor in stage 3. The corrective action will be taken
//                  in stage 4 where the correct PC will be presented at the
//                  instruction fetch interface.
//
// ldvalid          From the LSU. This signal indicates that the LSU
//                  will be doing a register writeback on the nxt cycle,
//                  and that any host accesses must be held off.
//  
// instr_pending_r  This signal is true when an instruction fetch has
//                  been issued, and it has not yet completed. It is not
//                  true directly after a reset before the ARC has
//                  started, as no instruction fetch will have been
//                  issued. It is used to hold off host writes to the
//                  program counter when the ARC is halted, as these
//                  accesses will trigger an instruction fetch.
//
// xnoaccess        U From extensions. Directly ORed onto noaccess. 
//
// xhold_host       U From extensions. Directly ORed onto hold_host.
//
// ck_gated         U This is the gate signal that gates the clocks clk
//                  and ck_phi2 if the ARC is ready to be temporarily
//                  shut down. It is used here to hold off the host
//                  until the ARC is not gated.
//
//====================== Output from this block ======================--
//
// h_datar[31:0]    To Debugger. Data read from ARC/extensions.
//
// noaccess         To Debugger. This signal is used to reject host
//                  accesses which are not allowed when the ARC is
//                  running, ie any core register, and any aux register
//                  except the dual access register (PC, Semaphore, and
//                  identity registers)
//
// hold_host        This signal is used to tell the mc/host that the
//                  register access which it is attempting will not
//                  complete on this cycle, and should be held (by the
//                  mc/host) until the next cycle. This will happen if
//                  the host is attempting to do an access to the core
//                  register set whilst a delayed load is completing, or
//                  if the host is writing the program counter whilst an
//                  instruction fetch is still in progress.
//
// s2a[5:0]         To coreregs.v etc. This is the source1 register
//                  address after the muxer which is used to facilitate
//                  host accesses.
//
// aux_addr[31:0]   To aux_regs.v. This is the auxiliary register bus
//                  address value. Width of decode is set by AUXDECSZ. 
//
// aux_dataw[31:0]  To aux_regs.v. This is the auxiliary register bus 
//                  write data value.
//
// aux_write        To aux_regs.v. This signal indicates that a write
//                  (either from the ARC or host) is being performed to
//                  the auxiliary register specified on aux_addr[31:0].
//
// aux_read         To aux_regs.v. This signal indicates that a read
//                  (either from the ARC or host) is being performed
//                  from the auxiliary register specified on
//                  aux_addr[31:0].
//  
// cr_hostw         To rctl, alu. This indicates that the host will
//                  perform a write to the core registers on the next
//                  cycle, provided that a load writeback does not
//                  bounce it out of the way.
//                   This signal is of a lower priority than ldvalid, so
//                  when both are true, cr_hostw is ignored.
//
// cr_hostr         To sync_regs or regs. This indicates that the host
//                  will perform a read from the core registers on the
//                  next cycle.
//
// h_regadr[5:0]    The register number to be written to by host writes
//                  to the core registers. Used in rctl.v when
//                  cr_hostw is true.
//
// host_rw          This signal is true when an host access occurs, that
//                  is either a write (h_write = '1') or a read
//                  (h_read = '1').
//
// do_inst_step_r   This signal is set when the single step flag (SS)
//                  and the instruction step flag (is) in the debug
//                  register has been written to simultaneously through
//                  the host interface. It indicates that an instruction
//                  step is being performed. When the instruction step
//                  has finished this signal goes low.
//
//====================================================================--
//
module hostif (clk,
               rst_a,
               en,
               fs2a,
               h_rr_data,
               s1val,
               s2val,
               p3lr,
               p3sr,
               aux_datar,
               aux_dar,
               da_auxam,
               en3_niv_a,
               p3_docmprel_a,
	       pcounter_jmp_restart_a,
               ldvalid,
               instr_pending_r,
               do_inst_step_r,
               ck_gated,
               hold_host_intrpt_a,
               hold_host_multic_a,
               host_write_en_n_a,
               xnoaccess,
               xhold_host,
               xcache_hold_host,
               h_addr,
               h_dataw,
               h_write,
               h_read,
               aux_access,
               core_access,

               s2a,
               aux_addr,
               aux_dataw,
               aux_read,
               aux_write,
               cr_hostr,
               cr_hostw,
               h_regadr,
               host_rw,
               h_datar,
               noaccess,
               hold_host);

`include "arcutil_pkg_defines.v"
`include "arcutil.v" 
`include "extutil.v" 

   input          clk;   //  core clock
   input          rst_a; //  system reset
   input          en;    //  system go

//  Signals which connect rctl, aux_regs and
//  core connections to hostif (stage 2)
//
   input   [5:0]  fs2a; 
   input   [31:0] h_rr_data; 

//  core connections to hostif (stage 3)
//
   input   [31:0] s1val; 
   input   [31:0] s2val; 
   input          p3lr; 
   input          p3sr; 

//  hostif connections to auxiliary registers (stage 3)
//
   input   [31:0] aux_datar; 
   input   [31:0] aux_dar; 
   input          da_auxam; 

//  hostif connections to core (stage 3)
//
   input          en3_niv_a; 
   input          p3_docmprel_a;
   input          pcounter_jmp_restart_a;

//  signals to hold off host accesses //
//
   input          ldvalid; 
   input          instr_pending_r; 
   input          do_inst_step_r; 
   input          ck_gated;
   input          hold_host_intrpt_a;
   input          hold_host_multic_a;
   input          host_write_en_n_a;

// extensions signals
//
   input          xnoaccess; 
   input          xhold_host; 
   input          xcache_hold_host; 

// Group Four : Host interface
//
   input   [31:0] h_addr; 
   input   [31:0] h_dataw; 
   input          h_write; 
   input          h_read; 
   input          aux_access; 
   input          core_access; 
 
//  Signals which connect hostif, rctl and auxregs //
//  core connections to hostif (stage 2)
//
   output  [5:0]  s2a; 

//  hostif connections to auxiliary registers (stage 3)
//
   output  [31:0] aux_addr; 
   output  [31:0] aux_dataw; 
   output         aux_read; 
   output         aux_write; 

//  hostif connections to core (stage 3)
//
   output         cr_hostr; 
   output         cr_hostw; 
   output   [5:0] h_regadr; 
   output         host_rw; 

// Group Four : Host interface
//
   output  [31:0] h_datar; 
   output         noaccess; 
   output         hold_host;

   reg            hold_host; 
   wire    [31:0] h_datar; 
   wire           noaccess;
   wire    [5:0]  s2a; 
   wire    [31:0] aux_addr; 
   wire    [31:0] aux_dataw; 
   wire           aux_read; 
   wire           aux_write; 
   wire           cr_hostw; 
   wire           cr_hostr; 
   wire    [5:0]  h_regadr; 
   wire           host_rw;
 
   wire    [31:0] i_h_datar_nxt; 
   reg     [31:0] i_h_datar_r; 
   wire           i_hold_host_brcc_a;
   wire           i_hold_host_ctrl_trans_a;
   wire           i_host_rw_a; 
   wire           i_invalid_access;
   wire           i_pc_hostw_a; 
   wire           i_v_core_access;
   wire           i_v_aux_access;
   wire           i_v_h_read;
   wire           i_v_h_write;

//====================================================================--

   // Invalid Access when trying to read and write at the same time
   // or when trying to access core and aux regs at the same time
   //
   assign i_invalid_access = (h_read & h_write) |
                             (core_access & aux_access);

   // Validate access and r/w signals. Then use the validated versions
   // of this signals in the rest of the logic.
   //
   assign i_v_core_access = core_access & ~i_invalid_access;
   assign i_v_aux_access  = aux_access  & ~i_invalid_access;
   assign i_v_h_write     = h_write     & ~i_invalid_access;
   assign i_v_h_read      = h_read      & ~i_invalid_access;

   // Connections to stage 2:
   //
   // The source 1 bus is used to provide the host with access to the
   // core registers when the ARC is stopped. The lower part of the
   // host address is used to produce the register number.
   //
   assign s2a = (en == 1'b 1) ? fs2a : h_addr[OPERAND_MSB:0]; 

   // Connections to stage 3:
   //
   // The host interface produces the address for the regular auxiliary
   // registers from s1val/s2val when the ARC is running, or from part 
   // of the host address when the ARC is stopped.
   // Host access to the PC and semaphore registers whilst the ARC is 
   // running is acheived by a seperate (direct) data path to the
   // auxiliary register module.
   // 
   // ** Note that aux_read and aux_write include en3 so that only    **
   // ** one set of signals is required for arc and host accesses     **
   //
   assign aux_addr = (en == 1'b 1) ? s2val : 
          h_addr;

   assign aux_dataw = (en == 1'b 1) ? s1val : 
          h_dataw;

   assign aux_read = (en == 1'b 1) ? p3lr & en3_niv_a : 
          i_v_h_read & i_v_aux_access;

   assign aux_write = (en == 1'b 1) ? p3sr & en3_niv_a : 
          i_v_h_write & i_v_aux_access;
 
   // Connections to the memory controller's host interface.
   //
   // Three data paths are muxed together to go out to the host, these
   // being data from the core registers (h_rr_data), data from the
   // auxiliary registers (aux_datar) and data from the semaphore & PC
   // auxiliary registers (aux_dar).
   // 
   assign i_h_datar_nxt = ((da_auxam        == 1'b 1) ||
                           (en              == 1'b 1)) ?
          aux_dar : 
                          (i_v_core_access == 1'b 1) ?
          h_rr_data : 
          aux_datar;

 
   always @(posedge rst_a or posedge clk)
   begin : hdata_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_h_datar_r <= {32{1'b 0}};  
      end
   else
      begin
      i_h_datar_r <= i_h_datar_nxt; 
      end
   end

   assign h_datar = i_h_datar_r;
 
   // The noaccess signal is used to reject host accesses which are not
   // allowed when the ARC is running, ie any core register, and any
   // auxiliary register except the dual access registers (PC,
   // semaphore and identity registers). In addition, the extensions
   // can reject any accesses they object to, using the xnoaccess
   // signal.
   //
   assign i_host_rw_a = i_v_h_read | i_v_h_write; 
   assign host_rw = i_host_rw_a; 
   assign noaccess =(((en               == 1'b 1) &
                      (i_v_core_access  == 1'b 1)) | 
                     ((en               == 1'b 1) &
                      (i_v_aux_access   == 1'b 1) & 
                      (da_auxam         == 1'b 0)) |
                     (xnoaccess        == 1'b 1)) ?
          i_host_rw_a : 
                     (i_invalid_access == 1'b 1) ?
          1'b 1:
          1'b 0;

   //  Decode for host write to the program counter.
   // 
   assign i_pc_hostw_a = (i_v_aux_access == 1'b 1) &&
                         (i_v_h_write    == 1'b 1) &&
                         (en             == 1'b 0) &&
                         ( (auxdc(h_addr, AX_PC_N)       == 1'b 1) ||
                           (auxdc(h_addr, AX_PC32_N)     == 1'b 1) ||
                           (auxdc(h_addr, AX_STATUS32_N) == 1'b 1) ) ?
          1'b 1 :
          1'b 0;

   // The ARC holds the debugger off for 1 cycle when:
   //
   // [1] There is a host write.
   //
   // [2] The host access is to auxiliary Debug register.
   //
   // [3] The halt bit in the Debug register is accessed.
   //
   // [4] A mispredicted BRcc/BBITx has been taken by the ARC processor.
   //
   assign i_hold_host_brcc_a = h_write                   &
                               auxdc(h_addr, AX_DEBUG_N) &
                               h_dataw[DB_HALT_N]        &
                               p3_docmprel_a;

   // The ARC holds the debugger off for 1 cycle when:
   //
   // [1] There is a host write.
   //
   // [2] The host access is to auxiliary Debug register.
   //
   // [3] The halt bit in the Debug register is accessed.
   //
   // [4] A control transfer is going to happen.
   //			       
   assign i_hold_host_ctrl_trans_a = h_write                   &
                                     auxdc(h_addr, AX_DEBUG_N) &
                                     h_dataw[DB_HALT_N]        &
				     pcounter_jmp_restart_a;

   // This signal is set true when the host must be held off for a
   // cycle
   // 
   // [1] The host is writing to a core register whilst a delayed load is
   //     completing, whilst the ARC is halted.
   //
   // [2] The host wants to change the PC (when ARC is halted) and there is
   //     still an instruction fetch pending.
   //
   // [3] The extensions ask for the host to be held.
   //
   // [4] The instruction cache ask for the host to be held.
   //
   // [5] A single instruction step is being executed.
   //
   // [6] The host is halting the processor at the same time corrective
   //     action for a mispredicted compare&branch is being taken. 
   //
   // [7] The host is halting the processor at the same time a multi-cycle
   //     instruction is in progress. 
   //
   // [8] The host is halting the processor at the same time an interrupt
   //     is in progress. 
   //
   // [9] The ARC is gated, until it wakes up.
   //
   always @(en or
            i_v_core_access or 
            i_host_rw_a or 
            ldvalid or
            i_pc_hostw_a or 
            instr_pending_r or
            xhold_host or
            xcache_hold_host or
            ck_gated or 
            do_inst_step_r or
            hold_host_intrpt_a or
            hold_host_multic_a or
            host_write_en_n_a or
            i_hold_host_brcc_a or
	    i_hold_host_ctrl_trans_a)
         
      begin : hold_host_async_PROC
   if (((en                == 1'b 0)   &&
        (i_v_core_access   == 1'b 1)   && 
        (i_host_rw_a       == 1'b 1)   &&
        (ldvalid           == 1'b 1))  || 

       ((i_pc_hostw_a      == 1'b 1)   &&
        (instr_pending_r   == 1'b 1))  || 

       (ck_gated           == 1'b 1)   ||
       (xhold_host         == 1'b 1)   ||
       (xcache_hold_host   == 1'b 1)   ||
       (do_inst_step_r     == 1'b 1)   || 
       (hold_host_intrpt_a == 1'b 1)   ||
       (hold_host_multic_a == 1'b 1)   ||
       (host_write_en_n_a  == 1'b 1)   ||
       (i_hold_host_brcc_a == 1'b 1)   ||
       (i_hold_host_ctrl_trans_a == 1'b 1))

      begin
      hold_host = 1'b 1;   
      end
   else
      begin
      hold_host = 1'b 0;   
      end
   end

//  Generate a signal to indicate that the host will write to the core
//  registers on the next cycle. This signal does not include hold_host
//  as the write would be ignored if a delayed load writeback were to
//  take place. It is never true when the ARC is running.
//
assign cr_hostw = (~en) & i_v_core_access & i_v_h_write; 

//  Generate a signal to indicate that the host will read to the core
//  registers on the next cycle.
//
assign cr_hostr = (~en) & i_v_h_read & i_v_core_access; 

//
//  Extract the register number to be written to from auxiliary address.
//
assign h_regadr = h_addr[OPERAND_MSB:0]; 

endmodule // module hostif
// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module auxiliary(clk_ungated,
                 rst_a,
                 l_irq_4,
                 l_irq_5,
                 l_irq_6,
                 l_irq_7,
                 l_irq_8,
                 l_irq_9,
                 l_irq_10,
                 l_irq_11,
                 l_irq_12,
                 l_irq_13,
                 l_irq_14,
                 l_irq_15,
                 l_irq_16,
                 l_irq_17,
                 l_irq_18,
                 l_irq_19,
                 en_debug_r,
                 clk,
                 en2,
                 p2sleep_inst,
                 en2b,
                 p2b_iv,
                 p2b_opcode,
                 p2b_subopcode,
                 en3,
                 p3iv,
                 p3condtrue,
                 p3setflags,
                 x_idecode3,
                 p3wba,
                 p3lr,
                 p3sr,
                 h_addr,
                 h_dataw,
                 h_write,
                 h_read,
                 aux_access,
                 fs2a,
                 core_access,
                 uxdrx_reg,
                 uxreg_hit,
                 ux_da_am,
                 ux_dar,
                 uxivic,
                 uxhold_host,
                 uxnoaccess,
                 actionpt_pc_brk_a,
                 ldvalid,
                 lpending,
                 debug_if_r,
                 p1int,
                 p2int,
                 p2bint,
                 p3int,
                 x_multic_busy,
                 inst_stepping,
                 instr_pending_r,
                 brk_inst_a,
                 p2b_condtrue,
                 p2b_setflags,
                 en3_niv_a,
                 p3_docmprel_a,
                 p3_flag_instr,
                 p3_sync_instr,
                 p4_disable_r,
                 stop_step,
                 s2val,
                 x_flgen,
                 xsetflags,
                 x_set_sflag,
                 p3ilev1,
                 aux_lv12,
                 aux_hint,
                 aux_lev,
                 ic_busy,
                 ctrl_cpu_start_r,
                 ck_gated,
                 loopstart_r,
                 currentpc_r,
                 pcounter_jmp_restart_a,
                 s1val,
                 alurflags,
                 x_s_flag,
                 xflags,
                 h_rr_data,
                 loopend_r,
                 sr_xhold_host_a,
                 arc_start_a,
                 debug_if_a,
                 actionpt_hit_a,
                 actionpt_status_r,
                 halt,
                 xstep,
                 misaligned_err,
                 ap_ahv0,
                 ap_ahv1,
                 ap_ahv2,
                 ap_ahv3,
                 ap_ahv4,
                 ap_ahv5,
                 ap_ahv6,
                 ap_ahv7,
                 ap_ahc0,
                 ap_ahc1,
                 ap_ahc2,
                 ap_ahc3,
                 ap_ahc4,
                 ap_ahc5,
                 ap_ahc6,
                 ap_ahc7,
                 ap_ahm0,
                 ap_ahm1,
                 ap_ahm2,
                 ap_ahm3,
                 ap_ahm4,
                 ap_ahm5,
                 ap_ahm6,
                 ap_ahm7,
                 en,
                 wd_clear,
                 aluflags_r,
                 aux_addr,
                 aux_dataw,
                 aux_write,
                 aux_read,
                 s2a,
                 actionhalt,
                 cr_hostw,
                 do_inst_step_r,
                 h_pcwr,
                 h_pcwr32,
                 h_regadr,
                 ivic,
                 sleeping,
                 sleeping_r2,
                 irq,
                 int_vector_base_r,
                 e1flag_r,
                 e2flag_r,
                 dc_disable_r,
                 host_rw,
                 step,
                 inst_step,
                 aux_datar,
                 aux_pc32hit,
                 aux_pchit,
                 aux_st_mulhi_a,
                 hold_host,
                 cr_hostr,
                 h_status32,
                 noaccess,
                 en_misaligned,
                 reset_applied_r,
                 power_toggle,
                 lram_base,
                 pc_sel_r,
                 h_datar);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"
`include "asmutil.v"
`include "ext_msb.v"
`include "che_util.v"


input  clk_ungated;
input  rst_a;
input  l_irq_4;
input  l_irq_5;
input  l_irq_6;
input  l_irq_7;
input  l_irq_8;
input  l_irq_9;
input  l_irq_10;
input  l_irq_11;
input  l_irq_12;
input  l_irq_13;
input  l_irq_14;
input  l_irq_15;
input  l_irq_16;
input  l_irq_17;
input  l_irq_18;
input  l_irq_19;
input  en_debug_r;
input  clk;
input  en2;
input  p2sleep_inst;
input  en2b;
input  p2b_iv;
input  [4:0]  p2b_opcode;
input  [5:0]  p2b_subopcode;
input  en3;
input  p3iv;
input  p3condtrue;
input  p3setflags;
input  x_idecode3;
input  [5:0]  p3wba;
input  p3lr;
input  p3sr;
input  [31:0]  h_addr;
input  [31:0]  h_dataw;
input  h_write;
input  h_read;
input  aux_access;
input  [5:0]  fs2a;
input  core_access;
input  [31:0]  uxdrx_reg;
input  uxreg_hit;
input  ux_da_am;
input  [31:0]  ux_dar;
input  uxivic;
input  uxhold_host;
input  uxnoaccess;
input  actionpt_pc_brk_a;
input  ldvalid;
input  lpending;
input  debug_if_r;
input  p1int;
input  p2int;
input  p2bint;
input  p3int;
input  x_multic_busy;
input  inst_stepping;
input  instr_pending_r;
input  brk_inst_a;
input  p2b_condtrue;
input  p2b_setflags;
input  en3_niv_a;
input  p3_docmprel_a;
input  p3_flag_instr;
input  p3_sync_instr;
input  p4_disable_r;
input  stop_step;
input  [31:0]  s2val;
input  x_flgen;
input  xsetflags;
input  x_set_sflag;
input  p3ilev1;
input  [1:0]  aux_lv12;
input  [4:0]  aux_hint;
input  [31:3]  aux_lev;
input  ic_busy;
input  ctrl_cpu_start_r;
input  ck_gated;
input  [PC_MSB:0]  loopstart_r;
input  [PC_MSB:0]  currentpc_r;
input  pcounter_jmp_restart_a;
input  [31:0]  s1val;
input  [3:0]  alurflags;
input  [1:0]  x_s_flag;
input  [3:0]  xflags;
input  [31:0]  h_rr_data;
input  [PC_MSB:0]  loopend_r;
input  sr_xhold_host_a;
input  arc_start_a;
input  debug_if_a;
input  actionpt_hit_a;
input  [NUM_APS-1:0]  actionpt_status_r;
input  halt;
input  xstep;
input  misaligned_err;
input  [31:0]  ap_ahv0;
input  [31:0]  ap_ahv1;
input  [31:0]  ap_ahv2;
input  [31:0]  ap_ahv3;
input  [31:0]  ap_ahv4;
input  [31:0]  ap_ahv5;
input  [31:0]  ap_ahv6;
input  [31:0]  ap_ahv7;
input  [31:0]  ap_ahc0;
input  [31:0]  ap_ahc1;
input  [31:0]  ap_ahc2;
input  [31:0]  ap_ahc3;
input  [31:0]  ap_ahc4;
input  [31:0]  ap_ahc5;
input  [31:0]  ap_ahc6;
input  [31:0]  ap_ahc7;
input  [31:0]  ap_ahm0;
input  [31:0]  ap_ahm1;
input  [31:0]  ap_ahm2;
input  [31:0]  ap_ahm3;
input  [31:0]  ap_ahm4;
input  [31:0]  ap_ahm5;
input  [31:0]  ap_ahm6;
input  [31:0]  ap_ahm7;
output en;
output wd_clear;
output [3:0]  aluflags_r;
output [31:0]  aux_addr;
output [31:0]  aux_dataw;
output aux_write;
output aux_read;
output [5:0]  s2a;
output actionhalt;
output cr_hostw;
output do_inst_step_r;
output h_pcwr;
output h_pcwr32;
output [5:0]  h_regadr;
output ivic;
output sleeping;
output sleeping_r2;
output [31:3]  irq;
output [PC_MSB:`INT_BASE_LSB]  int_vector_base_r;
output e1flag_r;
output e2flag_r;
output dc_disable_r;
output host_rw;
output step;
output inst_step;
output [31:0]  aux_datar;
output aux_pc32hit;
output aux_pchit;
output aux_st_mulhi_a;
output hold_host;
output cr_hostr;
output h_status32;
output noaccess;
output en_misaligned;
output reset_applied_r;
output power_toggle;
output [EXT_A_MSB:LDST_A_MSB+3]  lram_base;
output pc_sel_r;
output [31:0]  h_datar;

wire clk_ungated;
wire rst_a;
wire l_irq_4;
wire l_irq_5;
wire l_irq_6;
wire l_irq_7;
wire l_irq_8;
wire l_irq_9;
wire l_irq_10;
wire l_irq_11;
wire l_irq_12;
wire l_irq_13;
wire l_irq_14;
wire l_irq_15;
wire l_irq_16;
wire l_irq_17;
wire l_irq_18;
wire l_irq_19;
wire en_debug_r;
wire clk;
wire en2;
wire p2sleep_inst;
wire en2b;
wire p2b_iv;
wire  [4:0] p2b_opcode;
wire  [5:0] p2b_subopcode;
wire en3;
wire p3iv;
wire p3condtrue;
wire p3setflags;
wire x_idecode3;
wire  [5:0] p3wba;
wire p3lr;
wire p3sr;
wire  [31:0] h_addr;
wire  [31:0] h_dataw;
wire h_write;
wire h_read;
wire aux_access;
wire  [5:0] fs2a;
wire core_access;
wire  [31:0] uxdrx_reg;
wire uxreg_hit;
wire ux_da_am;
wire  [31:0] ux_dar;
wire uxivic;
wire uxhold_host;
wire uxnoaccess;
wire actionpt_pc_brk_a;
wire ldvalid;
wire lpending;
wire debug_if_r;
wire p1int;
wire p2int;
wire p2bint;
wire p3int;
wire x_multic_busy;
wire inst_stepping;
wire instr_pending_r;
wire brk_inst_a;
wire p2b_condtrue;
wire p2b_setflags;
wire en3_niv_a;
wire p3_docmprel_a;
wire p3_flag_instr;
wire p3_sync_instr;
wire p4_disable_r;
wire stop_step;
wire  [31:0] s2val;
wire x_flgen;
wire xsetflags;
wire x_set_sflag;
wire p3ilev1;
wire  [1:0] aux_lv12;
wire  [4:0] aux_hint;
wire  [31:3] aux_lev;
wire ic_busy;
wire ctrl_cpu_start_r;
wire ck_gated;
wire  [PC_MSB:0] loopstart_r;
wire  [PC_MSB:0] currentpc_r;
wire pcounter_jmp_restart_a;
wire  [31:0] s1val;
wire  [3:0] alurflags;
wire  [1:0] x_s_flag;
wire  [3:0] xflags;
wire  [31:0] h_rr_data;
wire  [PC_MSB:0] loopend_r;
wire sr_xhold_host_a;
wire arc_start_a;
wire debug_if_a;
wire actionpt_hit_a;
wire  [NUM_APS-1:0] actionpt_status_r;
wire halt;
wire xstep;
wire misaligned_err;
wire  [31:0] ap_ahv0;
wire  [31:0] ap_ahv1;
wire  [31:0] ap_ahv2;
wire  [31:0] ap_ahv3;
wire  [31:0] ap_ahv4;
wire  [31:0] ap_ahv5;
wire  [31:0] ap_ahv6;
wire  [31:0] ap_ahv7;
wire  [31:0] ap_ahc0;
wire  [31:0] ap_ahc1;
wire  [31:0] ap_ahc2;
wire  [31:0] ap_ahc3;
wire  [31:0] ap_ahc4;
wire  [31:0] ap_ahc5;
wire  [31:0] ap_ahc6;
wire  [31:0] ap_ahc7;
wire  [31:0] ap_ahm0;
wire  [31:0] ap_ahm1;
wire  [31:0] ap_ahm2;
wire  [31:0] ap_ahm3;
wire  [31:0] ap_ahm4;
wire  [31:0] ap_ahm5;
wire  [31:0] ap_ahm6;
wire  [31:0] ap_ahm7;
wire en;
wire wd_clear;
wire  [3:0] aluflags_r;
wire  [31:0] aux_addr;
wire  [31:0] aux_dataw;
wire aux_write;
wire aux_read;
wire  [5:0] s2a;
wire actionhalt;
wire cr_hostw;
wire do_inst_step_r;
wire h_pcwr;
wire h_pcwr32;
wire  [5:0] h_regadr;
wire ivic;
wire sleeping;
wire sleeping_r2;
wire  [31:3] irq;
wire  [PC_MSB:`INT_BASE_LSB] int_vector_base_r;
wire e1flag_r;
wire e2flag_r;
wire dc_disable_r;
wire host_rw;
wire step;
wire inst_step;
wire  [31:0] aux_datar;
wire aux_pc32hit;
wire aux_pchit;
wire aux_st_mulhi_a;
wire hold_host;
wire cr_hostr;
wire h_status32;
wire noaccess;
wire en_misaligned;
wire reset_applied_r;
wire power_toggle;
wire  [EXT_A_MSB:LDST_A_MSB+3] lram_base;
wire pc_sel_r;
wire  [31:0] h_datar;


// Intermediate signals
wire i_en;
wire  [31:0] i_aux_addr;
wire  [31:0] i_aux_dataw;
wire i_aux_write;
wire i_aux_read;
wire i_do_inst_step_r;
wire  [31:0] i_aux_datar;
wire i_noaccess;
wire i_xcache_hold_host;
wire  [31:0] i_drx_reg;
wire  [7:0] i_id_arcnum;
wire i_xreg_hit;
wire i_x_da_am;
wire  [31:0] i_x_dar;
wire  [31:0] i_aux_dar;
wire i_da_auxam;
wire i_hold_host_intrpt_a;
wire i_hold_host_multic_a;
wire i_host_write_en_n_a;
wire i_l_irq_3;
wire  [TIMER_MSB:0] i_timer_r;
wire  [TIMER_MSB:0] i_tlimit_r;
wire i_timer_pirq_r;
wire i_tcontrol_r;
wire i_timer_mode_r;
wire i_timer_clr_r;
wire i_twatchdog_r;
wire i_xnoaccess;
wire i_xhold_host;


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)
wire  [3:0] u_unconnected_0;


// Instantiation of module aux_regs
aux_regs iaux_regs(
  .clk(clk),
  .rst_a(rst_a),
  .ctrl_cpu_start_r(ctrl_cpu_start_r),
  .arc_start_a(arc_start_a),
  .aux_addr(i_aux_addr),
  .aux_dataw(i_aux_dataw),
  .aux_write(i_aux_write),
  .brk_inst_a(brk_inst_a),
  .stop_step(stop_step),
  .currentpc_r(currentpc_r),
  .en2(en2),
  .fs2a(fs2a),
  .instr_pending_r(instr_pending_r),
  .p2int(p2int),
  .en2b(en2b),
  .p2b_opcode(p2b_opcode),
  .p2b_subopcode(p2b_subopcode),
  .p2b_iv(p2b_iv),
  .p2b_condtrue(p2b_condtrue),
  .p2b_setflags(p2b_setflags),
  .p1int(p1int),
  .p2bint(p2bint),
  .p3iv(p3iv),
  .p3condtrue(p3condtrue),
  .p3_docmprel_a(p3_docmprel_a),
  .p3setflags(p3setflags),
  .p3int(p3int),
  .p3ilev1(p3ilev1),
  .p3wba(p3wba),
  .en3(en3),
  .s2val(s2val),
  .alurflags(alurflags),
  .p3_flag_instr(p3_flag_instr),
  .p3_sync_instr(p3_sync_instr),
  .debug_if_r(debug_if_r),
  .debug_if_a(debug_if_a),
  .lpending(lpending),
  .aux_access(aux_access),
  .inst_stepping(inst_stepping),
  .h_addr(h_addr),
  .h_dataw(h_dataw),
  .h_write(h_write),
  .noaccess(i_noaccess),
  .xcache_hold_host(i_xcache_hold_host),
  .drx_reg(i_drx_reg),
  .id_arcnum(i_id_arcnum),
  .xreg_hit(i_xreg_hit),
  .x_da_am(i_x_da_am),
  .x_dar(i_x_dar),
  .xflags(xflags),
  .x_flgen(x_flgen),
  .x_idecode3(x_idecode3),
  .xsetflags(xsetflags),
  .actionpt_hit_a(actionpt_hit_a),
  .p4_disable_r(p4_disable_r),
  .actionpt_status_r(actionpt_status_r),
  .en_debug_r(en_debug_r),
  .actionpt_pc_brk_a(actionpt_pc_brk_a),
  .p2sleep_inst(p2sleep_inst),
  .halt(halt),
  .xstep(xstep),
  .loopstart_r(loopstart_r),
  .loopend_r(loopend_r),
  .x_multic_busy(x_multic_busy),
  .pcounter_jmp_restart_a(pcounter_jmp_restart_a),
  .misaligned_err(misaligned_err),
  .en_misaligned(en_misaligned),
  .en(i_en),
  .aux_datar(i_aux_datar),
  .aux_dar(i_aux_dar),
  .aux_pchit(aux_pchit),
  .aux_pc32hit(aux_pc32hit),
  .da_auxam(i_da_auxam),
  .do_inst_step_r(i_do_inst_step_r),
  .h_pcwr(h_pcwr),
  .h_pcwr32(h_pcwr32),
  .h_status32(h_status32),
  .aluflags_nxt(u_unconnected_0),
  .aluflags_r(aluflags_r),
  .e1flag_r(e1flag_r),
  .e2flag_r(e2flag_r),
  .actionhalt(actionhalt),
  .hold_host_intrpt_a(i_hold_host_intrpt_a),
  .hold_host_multic_a(i_hold_host_multic_a),
  .host_write_en_n_a(i_host_write_en_n_a),
  .reset_applied_r(reset_applied_r),
  .sleeping_r2(sleeping_r2),
  .sleeping(sleeping),
  .step(step),
  .inst_step(inst_step)
);


// Instantiation of module xaux_regs
xaux_regs ixaux_regs(
  .clk(clk),
  .rst_a(rst_a),
  .en(i_en),
  .aux_addr(i_aux_addr),
  .aux_dataw(i_aux_dataw),
  .aux_write(i_aux_write),
  .aux_read(i_aux_read),
  .h_addr(h_addr),
  .h_dataw(h_dataw),
  .h_write(h_write),
  .h_read(h_read),
  .aux_access(aux_access),
  .core_access(core_access),
  .en2b(en2b),
  .en3(en3),
  .s1val(s1val),
  .s2val(s2val),
  .x_s_flag(x_s_flag),
  .x_set_sflag(x_set_sflag),
  .l_irq_4(l_irq_4),
  .l_irq_5(l_irq_5),
  .l_irq_6(l_irq_6),
  .l_irq_7(l_irq_7),
  .l_irq_8(l_irq_8),
  .l_irq_9(l_irq_9),
  .l_irq_10(l_irq_10),
  .l_irq_11(l_irq_11),
  .l_irq_12(l_irq_12),
  .l_irq_13(l_irq_13),
  .l_irq_14(l_irq_14),
  .l_irq_15(l_irq_15),
  .l_irq_16(l_irq_16),
  .l_irq_17(l_irq_17),
  .l_irq_18(l_irq_18),
  .l_irq_19(l_irq_19),
  .l_irq_3(i_l_irq_3),
  .sr_xhold_host_a(sr_xhold_host_a),
  .ic_busy(ic_busy),
  .p3lr(p3lr),
  .p3sr(p3sr),
  .aux_lv12(aux_lv12),
  .aux_hint(aux_hint),
  .aux_lev(aux_lev),
  .uxdrx_reg(uxdrx_reg),
  .uxreg_hit(uxreg_hit),
  .ux_da_am(ux_da_am),
  .ux_dar(ux_dar),
  .uxivic(uxivic),
  .uxhold_host(uxhold_host),
  .uxnoaccess(uxnoaccess),
  .ap_ahv0(ap_ahv0),
  .ap_ahv1(ap_ahv1),
  .ap_ahv2(ap_ahv2),
  .ap_ahv3(ap_ahv3),
  .ap_ahv4(ap_ahv4),
  .ap_ahv5(ap_ahv5),
  .ap_ahv6(ap_ahv6),
  .ap_ahv7(ap_ahv7),
  .ap_ahc0(ap_ahc0),
  .ap_ahc1(ap_ahc1),
  .ap_ahc2(ap_ahc2),
  .ap_ahc3(ap_ahc3),
  .ap_ahc4(ap_ahc4),
  .ap_ahc5(ap_ahc5),
  .ap_ahc6(ap_ahc6),
  .ap_ahc7(ap_ahc7),
  .ap_ahm0(ap_ahm0),
  .ap_ahm1(ap_ahm1),
  .ap_ahm2(ap_ahm2),
  .ap_ahm3(ap_ahm3),
  .ap_ahm4(ap_ahm4),
  .ap_ahm5(ap_ahm5),
  .ap_ahm6(ap_ahm6),
  .ap_ahm7(ap_ahm7),
  .timer_r(i_timer_r),
  .tlimit_r(i_tlimit_r),
  .timer_pirq_r(i_timer_pirq_r),
  .tcontrol_r(i_tcontrol_r),
  .timer_mode_r(i_timer_mode_r),
  .timer_clr_r(i_timer_clr_r),
  .twatchdog_r(i_twatchdog_r),
  .drx_reg(i_drx_reg),
  .xreg_hit(i_xreg_hit),
  .x_da_am(i_x_da_am),
  .x_dar(i_x_dar),
  .id_arcnum(i_id_arcnum),
  .xnoaccess(i_xnoaccess),
  .xhold_host(i_xhold_host),
  .xcache_hold_host(i_xcache_hold_host),
  .dc_disable_r(dc_disable_r),
  .power_toggle(power_toggle),
  .lram_base(lram_base),
  .pc_sel_r(pc_sel_r),
  .aux_st_mulhi_a(aux_st_mulhi_a),
  .int_vector_base_r(int_vector_base_r),
  .irq(irq),
  .ivic(ivic),
  .wd_clear(wd_clear)
);


// Instantiation of module hostif
hostif ihostif(
  .clk(clk),
  .rst_a(rst_a),
  .en(i_en),
  .fs2a(fs2a),
  .h_rr_data(h_rr_data),
  .s1val(s1val),
  .s2val(s2val),
  .p3lr(p3lr),
  .p3sr(p3sr),
  .aux_datar(i_aux_datar),
  .aux_dar(i_aux_dar),
  .da_auxam(i_da_auxam),
  .en3_niv_a(en3_niv_a),
  .p3_docmprel_a(p3_docmprel_a),
  .pcounter_jmp_restart_a(pcounter_jmp_restart_a),
  .ldvalid(ldvalid),
  .instr_pending_r(instr_pending_r),
  .do_inst_step_r(i_do_inst_step_r),
  .ck_gated(ck_gated),
  .hold_host_intrpt_a(i_hold_host_intrpt_a),
  .hold_host_multic_a(i_hold_host_multic_a),
  .host_write_en_n_a(i_host_write_en_n_a),
  .xnoaccess(i_xnoaccess),
  .xhold_host(i_xhold_host),
  .xcache_hold_host(i_xcache_hold_host),
  .h_addr(h_addr),
  .h_dataw(h_dataw),
  .h_write(h_write),
  .h_read(h_read),
  .aux_access(aux_access),
  .core_access(core_access),
  .s2a(s2a),
  .aux_addr(i_aux_addr),
  .aux_dataw(i_aux_dataw),
  .aux_read(i_aux_read),
  .aux_write(i_aux_write),
  .cr_hostr(cr_hostr),
  .cr_hostw(cr_hostw),
  .h_regadr(h_regadr),
  .host_rw(host_rw),
  .h_datar(h_datar),
  .noaccess(i_noaccess),
  .hold_host(hold_host)
);


// Instantiation of module timer0
timer0 itimer0(
  .clk_ungated(clk_ungated),
  .rst_a(rst_a),
  .en(i_en),
  .aux_write(i_aux_write),
  .aux_addr(i_aux_addr),
  .aux_dataw(i_aux_dataw),
  .timer_r(i_timer_r),
  .tlimit_r(i_tlimit_r),
  .timer_pirq_r(i_timer_pirq_r),
  .tcontrol_r(i_tcontrol_r),
  .timer_mode_r(i_timer_mode_r),
  .l_irq_3(i_l_irq_3),
  .timer_clr_r(i_timer_clr_r),
  .twatchdog_r(i_twatchdog_r)
);


// Output drives
assign en                      = i_en;
assign aux_addr                = i_aux_addr;
assign aux_dataw               = i_aux_dataw;
assign aux_write               = i_aux_write;
assign aux_read                = i_aux_read;
assign do_inst_step_r          = i_do_inst_step_r;
assign aux_datar               = i_aux_datar;
assign noaccess                = i_noaccess;

endmodule


/////////////////////////////////////////////////////////////
//	32x5 Booth Multiplier with sum and carry out      //
/////////////////////////////////////////////////////////////


// Booth bit-pair recoding
// Inputs extended to 6/33-bit to handle unsigned multiply
// Adds one PP for the case of unsigned with MSB=1, total of 3 PP

// Partial products (PP) are extended to 34 bits to accomodate +-2x Booth codes
// Sign extension elimination employed: prefix 111..11 for all PPs, +1 nullifies it for positives (achieved
//   logically-correct arithmetic by inverting the sign bit of the each PP)
// PP0 has a partial sign extension constant, to avoid adding a 10th partial product at its MSB position
//   PP0 sign is not inverted and the next two bits are set to '00' for the constant calculation.
// The constant is as follows:  01010101AB, where A and B are the two bit position immediately after the
//   sign bit of PP0 and they are set as follows:
//   If sign of PP0 is '1' then AB = '01', else AB = '10'
//   This recoding on-the-fly to correct PP0 sign is not a critical path as it executes in parallel with the
//   multi-bit invert and/or shift of the booth select logic




module mult32x5cs (
		res_sum, res_carry,
		dataa, datab, signed_op_a, signed_op_b
		);

parameter AIN = 5;
parameter BIN = 32;

output  [(BIN+AIN-1):0]	res_sum,
			res_carry;
input   [(AIN-1):0]	dataa;
input   [(BIN-1):0]	datab;
input			signed_op_a;   // 1 = signed multiply
input			signed_op_b;

wire    [(AIN-1):0]	a = dataa;
wire    [(BIN):0]	b = signed_op_b ? {datab[(BIN-1)], datab[(BIN-1):0]} : {1'b0, datab[(BIN-1):0]} ;


// wire    [1.5 * (AIN+2) - 1:0] booth_op;
reg     [9:0]		booth_op;   // expand bit pair to three bits (one overlapping bit)
   
// expand to 3 bit overlapping fields

always @ (a or signed_op_a)
begin
        booth_op[2:0]   = {a[ 1: 0],1'b0};
        booth_op[5:3]   =  a[ 3: 1];
        booth_op[8:6]   =  signed_op_a ? {a[4],a[4:3]} : {1'b0,a[4:3]} ; 
end


wire    [5:0] add_one = { booth_sign(booth_op[8:6]),
                          booth_sign(booth_op[5:3]),
                          booth_sign(booth_op[2:0])
			};




// function is used to add a 1 at LSB of all negative partial (Booth bit-pair) multipliers to complete operation (-A = ~A + 1)

function [1:0] booth_sign;
input    [2:0] booth_op;
begin
        casex (booth_op) // synopsys parallel_case
                3'b100 :         booth_sign = 2'b01 ;   // -2
                3'b101, 3'b110 : booth_sign = 2'b01 ;   // -1
                3'b000, 3'b001, 3'b010, 3'b011, 3'b111 :
		                 booth_sign = 2'b00 ;   //  0 or positive
                default :        booth_sign = 2'bx  ;
        endcase
end
endfunction
 



function [(BIN+2):0]    booth_operand;   // one bit added for 2x, one bit for added '1' at MSB+1 for sign extension constant
input    [(BIN):0]      bop;
input    [2:0]          booth_op;

// multiplicand is 25 bits (adds 0 for unsigned), booth_operand is 27 bits
// sign extension elimination, add two bits: invert sign bit at position MSB and append '1' to MSB+1 position
// PP0 does not invert sign, see later details for a 'trick fix'

begin
        casex (booth_op) // synopsys full_case parallel_case
                3'b000:   booth_operand = {2'b11,              {(BIN+1){1'b0}}      };  // +0
                3'b001:   booth_operand = {1'b1 , ~bop[(BIN)],  bop[(BIN):0]        };  // +x
                3'b010:   booth_operand = {1'b1 , ~bop[(BIN)],  bop[(BIN):0]        };  // +x
                3'b011:   booth_operand = {1'b1 , ~bop[(BIN)],  bop[(BIN-1):0], 1'b0};  // +2x

                3'b100:   booth_operand = {1'b1 ,  bop[(BIN)], ~bop[(BIN-1):0], 1'b1};  // -2x
                3'b101:   booth_operand = {1'b1 ,  bop[(BIN)], ~bop[(BIN):0]        };  // -x
                3'b110:   booth_operand = {1'b1 ,  bop[(BIN)], ~bop[(BIN):0]        };  // -x
                3'b111:   booth_operand = {2'b11,              {(BIN+1){1'b0}}      };  // +0
		default : booth_operand = {(BIN+3){1'bx}} ;
        endcase
end
endfunction






/////////////////////////////////////////////////////////////////////////////





// Generation of partial products with "sign extension elimination" prefix:
// Add two bits: invert sign bit at position MSB and append '1' to MSB+1 position

// PP0 must be corrected: standard algorithm requires adding '1' at to PP0 position MSB (sign extension constant 10101011);
//   this would require adding a 10th PP at that bit position and increase critical path.
// Trick fix: PP0 sign is not inverted and only a partial sign extension is appended to it, in the following format:
//        11111..1110[PP0_sgn][PP0...]
// If PP0_sgn is 1 then we need to convert the 0 to 1.
// If PP0_sgn is 0 then we need to add +1 at the next position (i.e. the first 1) to nullify the string of 1's.
// This may seem complex but it ends up being quite simple. Re-calculating the sign extension constant for all 9 PPs gives
//    us a very simple 10101010..101000 (last zero aligns with PP0_sgn). This constant treats all PPs other than PP0 just
//    like the "standard" algorithm, i.e. invert the sign bit and append 1 at the next bit position.
// Since only 00 is appended to the PP0 extension, correcting it as outlined above is simple and basically converts these
// two bits to 10 (PP0_sgn==0) or 01 (PP0_sgn==1). PP0_sgn is pre-calculated, although synthesis may speed it up anyway.
// This is a simple modification which retains the structure of 9 PPs and therefore the first level of the
//   Wallace tree is made of CSA3_to_2 only.
// Timing budget is not increased (same as the "textbook" sign extension elimination algorithm).


// op1_1 is PP0
wire [(BIN+2):0]  op1_1_pre  = booth_operand(b,booth_op[2:0]);   // before correction for PP0

// speed up calculation of the sign rather than wait for the (slow) mux logic
wire              op1_1_sgn  = ((booth_op[2:0] == 3'b0) || (booth_op[2:0] == 3'b111)) ?  1'b0 :
                               add_one[0] ^ b[BIN];              // add_one[0]:  1 = negative code (-x, -2x)
                                                                 // b[32] is the sign bit of multiplicand:  1 = negative

// sign bit extends to 3 bits to perform the modified sign extension algorithm (bits AB replace the "standard" constant)
wire [(BIN+3):0]  op1_1      = {~op1_1_sgn,op1_1_sgn,op1_1_sgn,op1_1_pre[(BIN):0]};




// All other PPs conform to the standard algorithm including +1 for negating previous PP and sign extension elimination constant
// Note that PPs extend beyond the range of the result components, so we can compute overflow


wire [(BIN+4):0]  op1_2  = { booth_operand(b,booth_op[5:3]),   add_one[1:0]         };

// length of booth_operand plus 2 LSB for "add_one" from op_1_2 plus proper shift to place it at the correct (radix-4) bit position
wire [(BIN+6):0]  op1_3  = { booth_operand(b,booth_op[8:6]),   add_one[3:2],    2'b0};

wire [(BIN+6):0]  op1_4  = { add_one[5:4],    4'b0};   // contains +1 for negative op1_3, may contain '1' at bit position 4



/////////////////////////////////////////////////////////////////////////////


/* Wallace Tree, stage 1:  4 PP, 1x CSA42 */


wire [(BIN+7):0] L1T0  =  {    op1_1  &  op1_2  | op1_1  & op1_3  |   op1_2  & op1_3  , 1'b0 } ;   // intermediate carry

wire [(BIN+7):0] op2_1 =       op1_1  ^  op1_2  ^ op1_3  ^ op1_4  ^   L1T0 ;             // sum

wire [(BIN+7):0] op2_2 =  {  ( op1_1  ^  op1_2  ^ op1_3  ^ op1_4  ) & L1T0  |
                            ~( op1_1  ^  op1_2  ^ op1_3  ^ op1_4  ) & op1_4  , 1'b0 } ;  // carry


/* Output */

assign  res_sum   = op2_1[(BIN+AIN-1):0] ;
assign  res_carry = op2_2[(BIN+AIN-1):0] ;


endmodule  // mult32x5cs


// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
// 
// This file contains the logic for:
//       Single-cycle Barrel shifter instructions, Revision info. : $Workfile$  600 Architecture IP Library version 4.9.7, file revision  $Date$
//       Small Score Boarded Multiply Instruction, Revision info. :  600 Architecture IP Library version 4.9.7, file revision  $Date$
//       Normalise Instruction
//       Swap Instruction, Revision info. :  600 Architecture IP Library version 4.9.7, file revision  $Date$
//
//========================== Inputs to this block ==========================--
//
// aluflags_r       ALU Flags. The current state of the ALU flags are
//                  supplied from flags direct from the latches. Thus,
//                  the Z N C V flags can be used with the extension
//                  condition units, but can also be used to suppress flag
//                  setting in extension instructions re-presenting it on the
//                  xflags[3:0] bus. This will have the effect (when flag 
//                  setting is enabled) of latching the current value back
//                  into the latch. 
//
// p3opcode[4:0]    Opcode word. This bus contains the instruction word
//                  which is being executed by stage 3. It must be
//                  qualified by p3iv. The extension instructions take the
//                  upper 16 instruction slots, i.e. 0x10 to 0x1F.
//
// p3iv             L Opcode valid. This signal is used to indicate that the 
//                  opcode in pipeline stage 3 is a valid instruction. The
//                  instruction may not be valid if a junk instruction has
//                  been allowed to come into the pipeline in order to allow
//                  the pipeline to continue running when an instruction 
//                  cannot be fetched by the memory controller, or when an
//                  instruction has been killed.
//                   It should be noted that it is possible for a stall 
//                  condition to occur in stage 2 whilst stage 3 completes.
//                  This will mean that a 'bubble' will be introduced to the
//                  pipeline. State machines should always bear in mind that
//                  if an instruction moves out of stage 3, this does not 
//                  always mean that a new instruction will come into stage 3.
//
// p3c[5:0]         Instruction C field. This bus carries the region of 
//                  the instruction which contains the operand C field. This
//                  is used to encode extra single-operand functions onto
//                  the FLAG instruction opcode.
//
// p3condtrue       This signal is produced from the result of the internal
//                  stage 3 condition code unit or from an extension cc unit
//                  (if implemented). A bit (bit 5) in the instruction selects
//                  between the internal and extension cc unit results. In 
//                  addition, this signal is set true if the instruction is
//                  using short immediate data.
//                    For extensions use it should always be qualified with
//                  an instruction decode and p3iv. 
//  
// s1val[]          Source 1 Data Value. This bus is the source 1 bus  
//                  latched from cr_int, when the instruction in stage 2
//                  passes on to stage 3. It is used as an input to the ALU, 
//                  and for various other purposes outside rctl.
//
// s2val[]          Source 2 Data Value. This bus is the source 2 bus 
//                  latched from cr_int, when the instruction in stage 2
//                  passes on to stage 3.It is used as an input to the ALU,
//                  and for various other purposes outside rctl.
//
// aux_dataw        Auxiliary Write Data. This is the auxiliary register
//                  bus write data value from the host interface. This 
//                  is generated by hostif, either from the host's write  
//                  data bus when the ARC is halted (en = '0') or from 
//                  source 1 from pipeline stage 3, when the ARC is
//                  running. 
//
// x_multic_wben    Multi-cycle extension writeback enable. This signal
//                  is true when the multi-cycle instruction wants to
//                  write-back. It should have been qualified with p3iv,
//                  and p3condtrue and the extension  opcode. If any
//                  other instruction requires a write back at the same
//                  time this signal is true the ARCompact pipeline will
//                  stall and the multi-cycle extension will write back.
//
// x_snglec_wben    Single-cycle extension writeback enable. This signal
//                  is true when the single cycle instruction wants to
//                  write-back. It should have been qualified with p3iv,
//                  and p3condtrue and the extension  opcode. If any
//                  other instruction requires a write back at the same
//                  time this signal is true the ARCompact pipeline will
//                  stall and the multi-cycle extension will write back.
//
// ======================== Output from this block =========================--
//
// xflags           Extension Flags. This bus contains the flag result
//                  (Z, N, C, V) of the extension ALU operations. It is
//                  selected to be latched into the ALU result flags
//                  when x_idecode3, p3iv, p3condtrue are all true.
//                  The flag setting option wouldhave to be requested
//                  as part of the normal instruction encoding or the
//                  xsetflags signal has been forced by xrctl.
//
// xresult          Extension Result. The 32-bit result of an ALU
//                  operation is asserted here. This is selected by the 
//                  ARC when the x_idecode3 is true(in xrctl). This
//                  result is latched into the writeback stage when en3,
//                  p3iv, and p3condtrue signals are true at the end of
//                  the cycle.
//
//==========================================================================--
//

module xalu (clk,
             rst_a,
             
             p3iv,
             aluflags_r,
             p3opcode,
             p3subopcode,
             p3subopcode2_r,
             p3a_field_r,
             p3b_field_r,
             p3c_field_r,
             p3subopcode3_r,
             p3subopcode4_r,
             p3subopcode5_r,
             p3subopcode6_r,
             p3subopcode7_r,
             p3minoropcode,  
             p3condtrue,
             en3,
             ext_s1val,
             ext_s2val,
             s1val,
             s2val,
             aux_dataw,
             x_idecode3,
             x_multic_wben,
             x_snglec_wben, 
             uxsetflags,
             uxresult,
             uxflags,
    
                          barrel_type_r,
             x_p3_brl_decode_16_r,
             x_p3_brl_decode_32_r,
             // Multiply
             p2b_opcode,
             p2b_subopcode,
             p2b_iv,
             en2b,
             aux_st_mulhi_a,
             
             x_p3_norm_decode_r,
             x_p3_snorm_decode_r,
             x_p3_swap_decode_r,
             

                          mulatwork_r,
             lmul_en,
             lmulres_r,
             

             x_s_flag,
             xflags,
             xresult);


// Extra include files required for extensions are inserted here.
`include "arcutil_pkg_defines.v" 
`include "arcutil.v" 
`include "asmutil.v" 
`include "extutil.v" 
`include "xdefs.v" 

   input          clk;
   input          rst_a;

   input          p3iv;
   input   [3:0]  aluflags_r; 
   input   [4:0]  p3opcode; 
   input   [5:0]  p3subopcode; 
   input   [4:0]  p3subopcode2_r; 
   input   [5:0]  p3a_field_r;
   input   [5:0]  p3b_field_r;
   input   [5:0]  p3c_field_r;
   input   [2:0]  p3subopcode3_r; 
   input          p3subopcode4_r; 
   input   [1:0]  p3subopcode5_r; 
   input   [2:0]  p3subopcode6_r; 
   input   [1:0]  p3subopcode7_r; 
   input   [5:0]  p3minoropcode; 
   input          p3condtrue;
   input          en3;

   input   [31:0] ext_s1val; 
   input   [31:0] ext_s2val; 
   input   [31:0] s1val; 
   input   [31:0] s2val; 
   input   [31:0] aux_dataw; 
   input          x_idecode3; 
   input          x_multic_wben; 
   input          x_snglec_wben; 
   input          uxsetflags;
   input   [31:0] uxresult; 
   input   [3:0]  uxflags; 

// Barrel shifter
input   [1:0]  barrel_type_r; 
input          x_p3_brl_decode_16_r; 
input          x_p3_brl_decode_32_r;
 
   input   [4:0]  p2b_opcode;
   input   [5:0]  p2b_subopcode;
   input          p2b_iv;
   input          en2b;
   input          aux_st_mulhi_a;
// Normalise
   input          x_p3_norm_decode_r;
   input          x_p3_snorm_decode_r;
// SWAP
   input          x_p3_swap_decode_r;
//
   output         mulatwork_r;
   output         lmul_en;
   output  [63:0] lmulres_r;
//
   output  [1:0]  x_s_flag;
   output  [3:0]  xflags; 
   output  [31:0] xresult;

//
   wire    [1:0]  x_s_flag;
   wire    [3:0]  xflags; 
   wire    [31:0] xresult; 

// Signal declarations for extensions to be added.
// Barrel Shift signals
reg            i_barrel_c_flag_a; 
reg            i_barrel_c_flag1_a; 
reg            i_barrel_c_flag2_a; 
reg            i_barrel_c_flag3_a; 
reg            i_barrel_c_flag4_a; 
reg            i_barrel_c_flag5_a; 
wire    [ALUFLAG_MSB:0]  i_barrel_flags_a; 
reg     [DATAWORD_MSB:0] i_barrel_result_a; 
reg     [DATAWORD_MSB:0] i_barrel_result1_a; 
reg     [DATAWORD_MSB:0] i_barrel_result2_a; 
reg     [DATAWORD_MSB:0] i_barrel_result3_a; 
reg     [DATAWORD_MSB:0] i_barrel_result4_a; 
reg     [DATAWORD_MSB:0] i_barrel_result5_a; 
wire    [SUBOPCODE2_16_MSB:0] i_brlshift_val_a; 
wire    [1:0]  i_brlshift_type;
wire    [1:0]  i_barrel_type_a;


   reg            lmul_en; 
   wire    [63:0] lmulres_r; 
   reg            mulatwork_r; 
   reg     [63:0] i_multiply_res_r;

//** This specifies how wide our partial multiplier is **
// 
   parameter mul_width  = 4; 
   parameter mul_msb    = (mul_width - 1); 
   parameter mul_lstate = 4'b 1010;
   parameter prod_width = mul_width + DATAWORD_WIDTH; 

   reg     [mul_msb:0] i_mul_state_r; 

   wire    [mul_width:0] i_mul_a; 
   wire    [DATAWORD_MSB:0] i_mul_b; 
   wire    [prod_width - 1:0] i_mul_c; 
   wire    [mul_width + DATAWORD_WIDTH:0] i_mul_product_a; 
   wire    [mul_width + DATAWORD_MSB:0] i_madd_product_a; 
   reg     [mul_width + DATAWORD_MSB:0] i_int_mul_res_r;    
   wire    [mul_width + DATAWORD_WIDTH:0] i_mul_ws;    // intermediate result components from the Wallace Tree
   wire    [mul_width + DATAWORD_WIDTH:0] i_mul_wc;    // intermediate result components from the Wallace Tree

   
   reg            i_mul_signed_r; 
   reg            i_do_signed_r; 
   reg     [DATAWORD_MSB:0] i_m1val_r; 

// Normalise
   wire    [2:0]  i_a_res_a;
   wire    [3:0]  i_b_res_a;
   wire           i_b_sel_a;
   wire    [3:0]  i_c_res_a;
   wire           i_c_sel_a;
   wire    [3:0]  i_d_res_a;
   wire           i_d_sel_a;
   wire           i_n_signbit_a;
   wire    [3:0]  i_normflags_a;
   wire    [DATAWORD_MSB:0] i_normres_a;
   wire           i_nz_a;
   wire    [4:0]  i_res_a;
   wire    [DATAWORD_MSB:0] i_norm_input_a;
   wire           i_norm_n_flag_a;
   // SWAP
   wire    [31:0] i_swap_res_a;
   wire           i_swap_z_a;
   wire           i_swap_n_a;
   wire    [3:0]  i_swap_flags_a;
   

// ================== Functional bit of the instruction ====================--
//
// This section of the file is for the logical description of the ALU
// operation which you are implementing as part of this extension.
// 
// Notes on design of extension instructions:
// 
// Flag Setting : The generation of flags for a particular ALU
// extension should be evaluated in this section. 
// 
//  Functional/Logical Descriptions are inserted here
// ===================== Barrel shifter Extension =====================--
// 


//  Shift value comes directly from the source 2 field --    
//
assign i_brlshift_val_a = ext_s2val[SUBOPCODE2_16_MSB:0];

assign i_barrel_type_a = barrel_type_r;

   
always @(i_brlshift_val_a or ext_s1val or
         i_barrel_type_a 
	 //or i_barrel_c_flag1_a or 
         //i_barrel_c_flag2_a or i_barrel_c_flag3_a or 
         //i_barrel_c_flag4_a or i_barrel_result1_a or 
         //i_barrel_result2_a or i_barrel_result3_a or 
         //i_barrel_result4_a
	 )
   begin : BRLSHIFT_PROC
   case (i_barrel_type_a)
   MULTIBIT_ASL:
      begin

      //  LSL/ASL
      //
      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_result1_a = {ext_s1val[30:0], ONE_ZERO};    
         end
      else
         begin
         i_barrel_result1_a = ext_s1val;  
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_result2_a = {i_barrel_result1_a[29:0], TWO_ZERO};    
         end
      else
         begin
         i_barrel_result2_a = i_barrel_result1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_result3_a = {i_barrel_result2_a[27:0], FOUR_ZERO};   
         end
      else
         begin
         i_barrel_result3_a = i_barrel_result2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_result4_a = {i_barrel_result3_a[23:0], EIGHT_ZERO};  
         end
      else
         begin
         i_barrel_result4_a = i_barrel_result3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_result5_a = {i_barrel_result4_a[15:0], SIXTEEN_ZERO};    
         end
      else
         begin
         i_barrel_result5_a = i_barrel_result4_a;  
         end

      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_c_flag1_a = ext_s1val[DATAWORD_MSB];    
         end
      else
         begin
         i_barrel_c_flag1_a = 1'b 0;   
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_c_flag2_a = i_barrel_result1_a[30];  
         end
      else
         begin
         i_barrel_c_flag2_a = i_barrel_c_flag1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_c_flag3_a = i_barrel_result2_a[28];  
         end
      else
         begin
         i_barrel_c_flag3_a = i_barrel_c_flag2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_c_flag4_a = i_barrel_result3_a[24];  
         end
      else
         begin
         i_barrel_c_flag4_a = i_barrel_c_flag3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_c_flag5_a = i_barrel_result4_a[16];  
         end
      else
         begin
         i_barrel_c_flag5_a = i_barrel_c_flag4_a;  
         end

      end
   MULTIBIT_LSR:
      begin
      //  LSR
      //  
      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_result1_a = {ONE_ZERO, ext_s1val[DATAWORD_MSB:1]};  
         end
      else
         begin
         i_barrel_result1_a = ext_s1val;  
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_result2_a = {TWO_ZERO, i_barrel_result1_a[DATAWORD_MSB:2]};  
         end
      else
         begin
         i_barrel_result2_a = i_barrel_result1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_result3_a = {FOUR_ZERO, i_barrel_result2_a[DATAWORD_MSB:4]}; 
         end
      else
         begin
         i_barrel_result3_a = i_barrel_result2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_result4_a = {EIGHT_ZERO, i_barrel_result3_a[DATAWORD_MSB:8]};    
         end
      else
         begin
         i_barrel_result4_a = i_barrel_result3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_result5_a = {SIXTEEN_ZERO, i_barrel_result4_a[DATAWORD_MSB:16]}; 
         end
      else
         begin
         i_barrel_result5_a = i_barrel_result4_a;  
         end

      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_c_flag1_a = ext_s1val[0];   
         end
      else
         begin
         i_barrel_c_flag1_a = 1'b 0;   
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_c_flag2_a = i_barrel_result1_a[1];   
         end
      else
         begin
         i_barrel_c_flag2_a = i_barrel_c_flag1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_c_flag3_a = i_barrel_result2_a[3];   
         end
      else
         begin
         i_barrel_c_flag3_a = i_barrel_c_flag2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_c_flag4_a = i_barrel_result3_a[7];   
         end
      else
         begin
         i_barrel_c_flag4_a = i_barrel_c_flag3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_c_flag5_a = i_barrel_result4_a[15];  
         end
      else
         begin
         i_barrel_c_flag5_a = i_barrel_c_flag4_a;  
         end

      end
   MULTIBIT_ASR:
      begin
      //  ASR
      // 
      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_result1_a = {ext_s1val[DATAWORD_MSB],
                                ext_s1val[DATAWORD_MSB:1]};    
         end
      else
         begin
         i_barrel_result1_a = ext_s1val;  
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_result2_a = {{(2){i_barrel_result1_a[DATAWORD_MSB]}},
                                i_barrel_result1_a[DATAWORD_MSB:2]};
         end
      else
         begin
         i_barrel_result2_a = i_barrel_result1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_result3_a = {{(4){i_barrel_result2_a[DATAWORD_MSB]}},
                                i_barrel_result2_a[DATAWORD_MSB:4]};    
         end
      else
         begin
         i_barrel_result3_a = i_barrel_result2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_result4_a = {{(8){i_barrel_result3_a[DATAWORD_MSB]}},
                                i_barrel_result3_a[DATAWORD_MSB:8]};    
         end
      else
         begin
         i_barrel_result4_a = i_barrel_result3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_result5_a = {{(16){i_barrel_result4_a[DATAWORD_MSB]}},
                                i_barrel_result4_a[DATAWORD_MSB:16]};   
         end
      else
         begin
         i_barrel_result5_a = i_barrel_result4_a;  
         end

      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_c_flag1_a = ext_s1val[0];   
         end
      else
         begin
         i_barrel_c_flag1_a = 1'b 0;   
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_c_flag2_a = i_barrel_result1_a[1];   
         end
      else
         begin
         i_barrel_c_flag2_a = i_barrel_c_flag1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_c_flag3_a = i_barrel_result2_a[3];   
         end
      else
         begin
         i_barrel_c_flag3_a = i_barrel_c_flag2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_c_flag4_a = i_barrel_result3_a[7];   
         end
      else
         begin
         i_barrel_c_flag4_a = i_barrel_c_flag3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_c_flag5_a = i_barrel_result4_a[15];  
         end
      else
         begin
         i_barrel_c_flag5_a = i_barrel_c_flag4_a;  
         end

      end
   MULTIBIT_ROR:
      begin
      //  ROR
      // 
      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_result1_a = {ext_s1val[0],
                                ext_s1val[DATAWORD_MSB:1]};    
         end
      else
         begin
         i_barrel_result1_a = ext_s1val;  
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_result2_a = {i_barrel_result1_a[1:0],
                                i_barrel_result1_a[DATAWORD_MSB:2]};
         end
      else
         begin
         i_barrel_result2_a = i_barrel_result1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_result3_a = {i_barrel_result2_a[3:0],
                                i_barrel_result2_a[DATAWORD_MSB:4]};    
         end
      else
         begin
         i_barrel_result3_a = i_barrel_result2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_result4_a = {i_barrel_result3_a[7:0],
                                i_barrel_result3_a[DATAWORD_MSB:8]};    
         end
      else
         begin
         i_barrel_result4_a = i_barrel_result3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_result5_a = {i_barrel_result4_a[15:0],
                                i_barrel_result4_a[DATAWORD_MSB:16]};   
         end
      else
         begin
         i_barrel_result5_a = i_barrel_result4_a;  
         end

      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_c_flag1_a = ext_s1val[0];   
         end
      else
         begin
         i_barrel_c_flag1_a = 1'b 0;   
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_c_flag2_a = i_barrel_result1_a[1];   
         end
      else
         begin
         i_barrel_c_flag2_a = i_barrel_c_flag1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_c_flag3_a = i_barrel_result2_a[3];   
         end
      else
         begin
         i_barrel_c_flag3_a = i_barrel_c_flag2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_c_flag4_a = i_barrel_result3_a[7];   
         end
      else
         begin
         i_barrel_c_flag4_a = i_barrel_c_flag3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_c_flag5_a = i_barrel_result4_a[15];  
         end
      else
         begin
         i_barrel_c_flag5_a = i_barrel_c_flag4_a;  
         end

        end
   default:
      ;
   endcase
   end // block: brlshift_proc

   
   always @(i_barrel_result5_a or i_barrel_c_flag5_a)
         begin
                
       i_barrel_result_a  = i_barrel_result5_a;
       i_barrel_c_flag_a  = i_barrel_c_flag5_a;

         end
   
   
   
 
   //  Barrel shift result flags. 
   //
   assign i_barrel_flags_a[A_N_N] = i_barrel_result_a[DATAWORD_MSB];
    
   assign i_barrel_flags_a[A_Z_N] = (i_barrel_result_a == THIRTY_TWO_ZERO) ?
          1'b 1 : 
          1'b 0;
   
   assign i_barrel_flags_a[A_C_N] = i_barrel_c_flag_a;
   
   assign i_barrel_flags_a[A_V_N] = aluflags_r[A_V_N]; 

   
   
// =========================================================================--

//========================== Multi-cycle multiplier =========================--
//
// This section implements a unsigned multiply using a technique which
// operates on a small number of bits at once.
//
// The unused portion of the result register is used to store the multiplier,
// whilst the i_m1val_r register is used to hold the multiplicand.
//
// The first cycle (when the mul instruction is in p3) is used to load the
// bottom half of the result register with the multiplier.
//
// States :                                                    mulatwork_r
//
// 0    idle                                                        0
// 1    load mulres(31:0) with multiplier. Evaluate cc              1
// 2    first partial result generated                              1
// ..
// (32/mul_width)       cycle before final multiply will take place
// (32/mul_width)+1     final multiply
// (32/mul_width)+2     final partial result ready for addition.
//

always @(posedge clk or posedge rst_a)
   begin : MULFSM_PROC
   if (rst_a == 1'b 1)
      begin
      i_mul_state_r <= 4'b 0000;        
      mulatwork_r <= 1'b 0;        
      i_do_signed_r <= 1'b 0;        
      i_mul_signed_r <= 1'b 0;        
      lmul_en <= 1'b 0;        

      end
   else
      // Set up sign bit for last multiply
      //
      begin
      if ((i_mul_state_r == 4'b 1000) & (i_do_signed_r == 1'b 1))
         begin
         i_mul_signed_r <= i_multiply_res_r[mul_width + mul_width - 1];        
         end
      else
         begin
         i_mul_signed_r <= 1'b 0;        
         end

      case (i_mul_state_r)

      // If there's a mul a-coming round the mountain, (i.e. in p2)
      // then move out if the idle state, setting the 'signed' flag
      // accordingly.
      // 
      4'b 0000:
         begin
         if ((p2b_iv == 1'b1) & (en2b == 1'b1))
            begin
            if ((p2b_opcode == OP_FMT2) & (p2b_subopcode == MO_MULU64))
               begin
               i_mul_state_r <= 4'b 0001;
               mulatwork_r <= 1'b 1;
               i_do_signed_r <= 1'b 0;
               end
            else if (((p2b_opcode == OP_FMT2) & (p2b_subopcode == MO_MUL64)) | 
                     ((p2b_opcode == OP_16_ALU_GEN)                        &
                      (p2b_subopcode[SUBOPCODE2_16_MSB:0] == SO16_MUL64)))
               begin
               i_mul_state_r <= 4'b 0001;
               mulatwork_r <= 1'b 1;
               i_do_signed_r <= 1'b 1;
               end
            end

         lmul_en <= 1'b 0;
         end

      // First multiplier state - load the result register, and evaluate 
      // the condition codes.
      //
      // If the cc is false, fall back into the idle state. 
      // 
      4'b 0001:
         begin
         if ((p3condtrue & p3iv) == 1'b1)
            begin
            i_mul_state_r <= 4'b 0010;        
            end
         else
            begin
            i_mul_state_r <= 4'b 0000;        
            mulatwork_r <= 1'b 0;        
            end
         lmul_en <= 1'b 0;
         end

      // If it's the last state, then go back to the idle state
      // 
      mul_lstate:
         begin
         i_mul_state_r <= 4'b 0000;        
         mulatwork_r <= 1'b 0;        
         lmul_en <= 1'b 1;
         end

      // The rest of the multiplier states.
      // 
      default:
         begin
         i_mul_state_r <= i_mul_state_r + 4'b 0001;        
         lmul_en <= 1'b 0;        

         end
      endcase
      end

   end

//  The multiplier input is always the bottom mul_width bits of lmulres_r
// 
assign i_mul_a = {i_mul_signed_r, i_multiply_res_r[mul_width - 1:0]}; 

//  The multiplier always gets i_m1val_r on the multiplicand input --
// 
assign i_mul_b = i_m1val_r; 

//  The madd adder input always gets the top 32 bits of the product register.
// 
assign i_mul_c = (i_do_signed_r == 1'b 0) ?
      {{(prod_width - (DATAWORD_WIDTH)){1'b 0}}, i_multiply_res_r[63:32]} : 
      {{(prod_width - (DATAWORD_WIDTH)){i_multiply_res_r[63]}},
       i_multiply_res_r[63:DATAWORD_WIDTH]}; 
       


   mult32x5cs u_mul32x5(
                    .res_sum(i_mul_ws),
                    .res_carry(i_mul_wc),
                    .dataa(i_mul_a),
                    .datab(i_mul_b),
                    .signed_op_a(i_do_signed_r),
                    .signed_op_b(i_do_signed_r)
                   );
   
   assign i_mul_product_a = i_mul_ws + i_mul_wc;   // full-adder

// Latch the multiply result.
// 
always @(posedge clk or posedge rst_a)
   begin : INTERMEDIATE_PROC
   if (rst_a == 1'b 1)
      begin
      i_int_mul_res_r <= {(mul_width + DATAWORD_WIDTH){1'b 0}};        
      end
   else
      begin
      i_int_mul_res_r <= i_mul_product_a[mul_width + DATAWORD_MSB:0];        
      end
   end

// Adder
// 
assign i_madd_product_a = i_int_mul_res_r + i_mul_c; 


// It's a 64-bit wide latch. 
// 
// Data either comes from the multiplier, or from an auxiliary register
// write to the high part of the register.
// 
always @(posedge clk or posedge rst_a)
   begin : MRES_LATCH_PROC
   if (rst_a == 1'b 1)
      begin
      i_multiply_res_r <= {(SIXTY_FOUR){1'b 0}};        
      i_m1val_r <= {(DATAWORD_WIDTH){1'b 0}};        

      end
   else
      // Load multiplier high result from auxiliary register write.
      // 
      begin

      if (aux_st_mulhi_a == 1'b 1)
         begin
         i_multiply_res_r <= {aux_dataw, i_multiply_res_r[DATAWORD_MSB:0]};        

         end
      else
         begin
         case (i_mul_state_r)

         // We are going to use the 'others' case to specify a shift, so we
         // need to separately specify the retain-the-value case.
         // 
         4'b 0000:
            begin
            i_multiply_res_r <= i_multiply_res_r;        
            end

         // If we are going to do the multiply, then preload result register
         // with 00000000 & ext_s2val.
         // We also load i_m1val_r from s1val_lowpower at this stage.
         // 
         4'b 0001:
            begin
            if ((p3condtrue & p3iv) == 1'b1)
               begin
               i_multiply_res_r <= {{(DATAWORD_WIDTH){1'b0}}, ext_s2val};
               end

            i_m1val_r <= ext_s1val;
            end

         // After the first multiply has taken place, the multiply result is
         // junk, but we still want to shift the multiplicand down.
         // 
         4'b 0010:
            begin
            i_multiply_res_r <= {{(DATAWORD_WIDTH + mul_width){1'b 0}},
                                 i_multiply_res_r[DATAWORD_MSB:mul_width]};        
            end

         // If we are in the process of multiplying, accept the adder result,
         // and shift the whole lot right by mul_width bits.
         // 
         // The multiplicand is shifted right in order to make space for the 
         // result of the add operation.
         // 
         default:
            begin
            i_multiply_res_r <= {i_madd_product_a,
                                 i_multiply_res_r[DATAWORD_MSB:mul_width]};        
            end

         endcase
         end

      end

   end


assign lmulres_r = i_multiply_res_r; 


   //=========================== Normalise function ==========================--
   //
   // I am assuming that if s2val_lowpower[30] == ~sign bit then no shift 
   // has to take place, and if s2val_lowpower[29] == ~sign bit that there
   // has to be a shift of 1, etc.
   //
   assign i_norm_input_a = (x_p3_snorm_decode_r == 1'b1) ? 
                           {ext_s2val[WORD_MSB:0],{WORD_WIDTH{1'b0}}} :
                           ext_s2val;

   assign i_n_signbit_a = (~i_norm_input_a[DATAWORD_MSB]);

   // top two bits 00 --
   //
   assign i_d_res_a = (i_norm_input_a[30] == i_n_signbit_a) ? 4'b1000 : 
                      (i_norm_input_a[29] == i_n_signbit_a) ? 4'b1001 : 
                      (i_norm_input_a[28] == i_n_signbit_a) ? 4'b1010 : 
                      (i_norm_input_a[27] == i_n_signbit_a) ? 4'b1011 :
                      (i_norm_input_a[26] == i_n_signbit_a) ? 4'b1100 : 
                      (i_norm_input_a[25] == i_n_signbit_a) ? 4'b1101 :
                      (i_norm_input_a[24] == i_n_signbit_a) ? 4'b1110 :
                      (i_norm_input_a[23] == i_n_signbit_a) ? 4'b1111 : 4'b0xxx;

 
   // top two bits 01 --
   //
   assign i_c_res_a = (i_norm_input_a[22] == i_n_signbit_a) ? 4'b1000 : 
                      (i_norm_input_a[21] == i_n_signbit_a) ? 4'b1001 : 
                      (i_norm_input_a[20] == i_n_signbit_a) ? 4'b1010 :
                      (i_norm_input_a[19] == i_n_signbit_a) ? 4'b1011 : 
                      (i_norm_input_a[18] == i_n_signbit_a) ? 4'b1100 :
                      (i_norm_input_a[17] == i_n_signbit_a) ? 4'b1101 :
                      (i_norm_input_a[16] == i_n_signbit_a) ? 4'b1110 :
                      (i_norm_input_a[15] == i_n_signbit_a) ? 4'b1111 : 4'b0xxx;
 
   // top two bits 10 --
   //
   assign i_b_res_a = (i_norm_input_a[14] == i_n_signbit_a) ? 4'b1000 :
                      (i_norm_input_a[13] == i_n_signbit_a) ? 4'b1001 :
                      (i_norm_input_a[12] == i_n_signbit_a) ? 4'b1010 :
                      (i_norm_input_a[11] == i_n_signbit_a) ? 4'b1011 : 
                      (i_norm_input_a[10] == i_n_signbit_a) ? 4'b1100 : 
                      (i_norm_input_a[9]  == i_n_signbit_a) ? 4'b1101 :
                      (i_norm_input_a[8]  == i_n_signbit_a) ? 4'b1110 : 
                      (i_norm_input_a[7]  == i_n_signbit_a) ? 4'b1111 : 4'b0xxx; 

   // top two bits 11 --
   //
   assign i_a_res_a = (i_norm_input_a[6] == i_n_signbit_a) ? 3'b000 : 
                      (i_norm_input_a[5] == i_n_signbit_a) ? 3'b001 : 
                      (i_norm_input_a[4] == i_n_signbit_a) ? 3'b010 : 
                      (i_norm_input_a[3] == i_n_signbit_a) ? 3'b011 : 
                      (i_norm_input_a[2] == i_n_signbit_a) ? 3'b100 : 
                      (i_norm_input_a[1] == i_n_signbit_a) ? 3'b101 :
                      (i_norm_input_a[0] == i_n_signbit_a) ? 3'b110 : 3'b111; 
                             
   // choose which result to select --
   //
   assign i_d_sel_a = i_d_res_a[3]; 
   assign i_c_sel_a = i_c_res_a[3]; 
   assign i_b_sel_a = i_b_res_a[3]; 

   // select the result --
   //
   assign i_res_a = (i_d_sel_a == 1'b1) ? {2'b00, i_d_res_a[2:0]} :
                    (i_c_sel_a == 1'b1) ? {2'b01, i_c_res_a[2:0]} :
                    (i_b_sel_a == 1'b1) ? {2'b10, i_b_res_a[2:0]} :
                    {x_p3_norm_decode_r, // Using the decode here
                     1'b1,               // allows the production
                     i_a_res_a};         // of 0x1f for norm 0x0 and
                                         // 0x0f for normw 0x0

   assign i_nz_a = (i_norm_input_a == THIRTY_TWO_ZERO) ? 1'b1 : 1'b0;

   assign i_normres_a = {TWENTYSEVEN_ZERO, i_res_a};

   assign i_norm_n_flag_a = i_norm_input_a[DATAWORD_MSB];

   assign i_normflags_a = {i_nz_a, i_norm_n_flag_a, aluflags_r[A_C_N],
                           aluflags_r[A_V_N]};

// ===========================================================================--


// ============================ Swap function =============================--
// 
//  Swaps upper and lower 16 bits of the source 1 value.
// 
  assign i_swap_res_a = {ext_s2val[15:0], ext_s2val[31:16]};

  //  Generate flag values
  //  Only Z and N are set. C and V remain unchanged.
  // 
  assign i_swap_z_a = (i_swap_res_a == {(THIRTY_TWO){1'b0}}) ?
                      1'b1 :
                      1'b0;

  assign i_swap_n_a = i_swap_res_a[DATAWORD_MSB];

  assign i_swap_flags_a = {i_swap_z_a,
                           i_swap_n_a,
                           aluflags_r[A_C_N],
                           aluflags_r[A_V_N]};


// =========================================================================--

// ========================= ALU result selection ==========================--
// 
// Note that only the normalise and barrel shift results are present
// here, since the multiply result never gets onto the ALU result bus.
// 
// For single operand extensions the result is switched to i_sopres when
// there is a match with the C-field in the instruction longword at
// stage 3, i.e. p3c. There is the possibility that instructions that
// are not single operands will also be selected. This is trapped since 
// i_sopres is only forwarded to the extension result multiplexer when
// p3c is equal to the denotation for single operand instruction. 
// 
// The 32-bit result of an ALU operation is selected based on the
// instruction in stage 3, i.e. p3i. This is selected by the ARC when
// the x_idecode3 is true, and (in xrctl.v). This result is latched
// into the writeback stage when en3, p3iv, and p3condtrue signals are
// true at the end of the cycle.
//
// As the result from the final ALU multiplexer has to be fed back to
// the operand fetch stage through the shortcut mechanism, this signal
// is likely to be part of the critical path, so this should be borne in
// mind when designing extensions.
//  
// Multic-Cycle results take priority over single cycle extensions, so
// must use a priority encoder.  All single cycle extensions are or'd 
// together, so must return '0' when they are not enabled in stage3, 
// and must be the lowest priority.

   assign xresult = 
  
//
//Result for Extension instructions decodes are inserted here.

                     x_multic_wben ? uxresult :

                 (i_barrel_result_a &
                  ({(DATAWORD_WIDTH){(x_p3_brl_decode_32_r | 
                                     x_p3_brl_decode_16_r)}})) |
                    (i_normres_a & ({32{(x_p3_norm_decode_r      |
                                        x_p3_snorm_decode_r)}})) |
                 (i_swap_res_a & ({(DATAWORD_WIDTH){x_p3_swap_decode_r}})) |
                     uxresult;

// This bus contains the flag result (Z, N, C, V) of the extension ALU
// operations. It is selected to be latched into the ALU result flags
// when x_idecode3, p3iv, p3condtrue are all true. The flag setting
// option would have to be requested as part of the normal instruction
// encoding or the xsetflags signal has been forced by xrctl.
//
// If the D field of an extension instruction is being used in a
// non-standard way, indicated by the setting of xshimm signal, then
// the flags are not set, unless xsetflags is used to force flag
// setting.
//
// If the extension ALU wants to supress flag setting, then the latched
// ALU flag result from aluflags_r[3:0] can be placed on xflags[3:0]. 
//
   assign xflags =
// For Example :
//              p3opcode == OP_FMT3 & p3subopcode == another_ext ?
//              extension_flags :
//              p3opcode == OP_FMT3 & p3subopcode == yet_another_ext ?
//              i_sopflags :    
//   
// Flags for extension instructions decodes are inserted here.

                    uxsetflags ? uxflags :

                (i_barrel_flags_a & 
                 ({(ALUFLAG_WIDTH){x_p3_brl_decode_32_r}})) |
                   (i_normflags_a & ({4{(x_p3_norm_decode_r      |
                                        x_p3_snorm_decode_r)}})) |
                (i_swap_flags_a & ({(ALUFLAG_WIDTH){x_p3_swap_decode_r}})) |
                    uxflags;


//This signal is used to in conjuction with the x_sets_sflag signal to set the
//Saturate flag in the extension AUX. reg. 41
   assign x_s_flag =
// For Example :
//              p3opcode == OP_FMT3 & p3subopcode == another_ext ?
//              extension_s_flag :
// Saturate Flag for extension instructions decodes are inserted here.
                      2'b 00;

endmodule // module xalu

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2008 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// Small, slow implementation of the adder, functionally compatible
// with and Kogge-stone parallel prefix adders. This is for A601.
//

module adder (A,
              B,
              Cin,

              Sum,
              Zout,
              Nout,
              Cout,
              Vout);
   
input    [31:0] A; 
input    [31:0] B; 
input    Cin; 

output   [31:0] Sum; 
output   Zout; 
output   Nout; 
output   Cout; 
output   Vout; 

//wire    [31:0] Sum_ncin; 
reg     [31:0] Sum; 
reg      Cout; 
wire     Zout; 
wire     Nout; 
wire     Vout; 

// -------------------------------------------
// ---------- 32bit Slow adder ---------------
// -------------------------------------------
//assign Sum_ncin = A + B ; // synopsys label add32_1

always @(A or B or Cin)
begin : add32_2_PROC
    /* synopsys resource a2:
       map_to_module = "DW01_add",
       implementation = "rpl",
       ops = "add32_2";
    */
      {Cout, Sum} = A + B + Cin ; // synopsys label add32_2
end


assign Nout = Sum[31]; 
assign Zout = (Sum == 32'h0);
assign Vout = (B[31] & A[31] & ~Sum[31]) | (~B[31] & ~A[31] & Sum[31]);

endmodule // module adder

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains logic that allows the processor to perform
// all ALU operations and LD/ST accesses.
//
//=========================== Inputs to this block ===========================--
//
// clk                          System Clock
// 
// rst_a                        System Reset (Active high)
//
// aluflags_r       [3:0]       Architectual aritmetic flags ZNCV.
//                              The flags are updated at the end of stgae 3.
//
// e1flag_ r                    Interrupt mask level 1 bit.
//
// e2flag_r                     Interrupt mask Level 2 bit
//
// aux_datar        [31:0]      Auxiliary read data. This is the data that has
//                              been read from an auxiliary mapped register. 
//
// aux_pc32hit                  Auxiliary register access is to 32-bit PC
//                              register. Qualify with p3lr and route
//                              constructed link register as below.    
//
// aux_pchit                    Auxiliary register access is to 32-bit PC
//                              register. Qualify with p3lr and route
//                              constructed link register as below.
//
// cr_hostw                     The host data is routed to the output for writes
//                              to core registers.         
//
// drd              [31:0]      Returning load data from load store unit.
//
// h_dataw          [31:0]      Host data write data.  The host will place data
//                              on this bus that will be written to register in
//                              the machine.
//
// ldvalid_wb                   Returning load write-back. The load store unit
//                              has signaled that a returning load will write
//                              the data on drd[31:0] at the end of the cycle.
//
// p3_alu_absiv                 Indicates that an ABS instruction is in stage 3.
//
// p3_alu_arithiv               Indicates that an ALU instruction is in stage 3.
//
// p3_alu_flagiv                Indicates that a flag setting ALU instruction is
//                              in stage 3.
//
// p3_alu_logiciv               Indicates that a logic instruction is in stage
//                              3.
//
// p3_alu_minmaxiv              Indicates that a MIN/MAX instruction is in stage
//                              3.
//
// p3_alu_op [1:0]              Describes which ALU operation is in stage 3.
//
// p3_alu_snglopiv              Indicates that a single operand instruction is
//                              in stage 3.
//
// p3_bit_op_sel [1:0]          Indicates to the ALU which operation to complete
//                              for the compare&branch operations       
//
//
// p3awb_field_r    [1:0]       Indicates the write-back mode of the LD/ST
//                              instruction in stage 3.
//
// p3dolink                     This signal is true when a JLcc or BLcc
//                              instruction has been taken, indicating that the
//                              link register needs to be stored. It is used by
//                              ALU to switch the program counter value which
//                              has been passed down the pipeline onto the
//                              p3result bus. If this signal is to be used to
//                              give a fully qualified indication that a J/BLcc
//                              is in stage 3, it must be qualified with p3iv
//                              to take account of pipeline tearing between
//                              stages 2b and 3 which could cause the
//                              instruction in stage 3 to be repeated.              
//
// p3int                        From int_unit. This signal indicates that an
//                              interrupt jump instruction (fantasy instruction)
//                              is currently in stage 2. This signal has a
//                              number of consequences throughout the system,
//                              causing the interrupt vector (int_vec) to be put
//                              into the PC, and causing the old PC to be placed
//                              into the pipeline in order to be stored into the
//                              appropriate interrupt link register.
//                              Note that p3int and p3iv are mutually exclusive.
//
// p3lr                         This signal is used by hostif. It is produced
//                              from a decode of p3opcode, p3iw(13) (check for
//                              LR) and includes p3iv. Also used in extension
//                              logic for sepArate decoding of auxiliary
//                              accesses from host and ARC 600.            
//
// p3_max_instr                 Indicates that the instruction in stage 3 is a
//                              maximum.
//
// p3_min_instr                 Indicates that the instruction in stage 3 is a
//                              minimum.
//
// p3wb_en                      Stage 4 pipeline latch control. Controls
//                              transition of the data on the p3result[31:0]
//                              bus, and the corresponding register address from
//                              stage 3 to stage 4. As these buses carry data
//                              not only from instructions but from delayed load
//                              writebacks and host writes, they must be
//                              controlled separately from the instruction in
//                              stage 3. This is because if the instruction in
//                              stage 3 does not need to write a value back into
//                              a register, and a delayed load writeback is
//                              about to happen, the instruction is allowed to
//                              complete (i.e. set flags) whilst the data from
//                              the load is clocked into stage 4. If however the
//                              instruction in stage 3 DOES need to writeback to
//                              the register file when a delayed load or
//                              multicycle writeback is about to happen, then
//                              the instruction in stage 3 must be held up and
//                              not allowed to change the processor state,
//                              whilst the data from the delayed load is clocked
//                              into stage 4 from stage 3.
//                              *** Note that p3wb_en can be true even when the
//                              processor is halted, as delayed load writebacks
//                              and host writes use this signal in order to
//                              access the core registers. ***          
//
// s1val            [31:0]      Normal source 1 register.  This register is
//                              loaded with the operand data for basecase
//                              operations.  The value only changes when a valid
//                              basecase instruction is in stage 2b.
//
// s2val             [31:0]     Normal source 2 register.  This register is
//                              loaded with the operand data for basecase
//                              operations.  The value only changes when a valid
//                              basecase instruction is in stage 2b.
//
// x_multic_wben                From xrctl. Multi-cycle extension writeback
//                              enable. This signal is true when the multi-cycle
//                              instruction wants to write-back. It should have
//                              been qualified with p3iv, and p3condtrue and the
//                              extension  opcode. If any other instruction
//                              requires a write back at the same time this
//                              signal is true the ARC 600 pipeline will stall
//                              and the multi-cycle extension will write back.    
//
// xresult          [31:0]      Extension Result. The 32-bit result of an ALU
//                              operation is asserted here. 
//
// x_snglec_wben                Single-cycle extension writeback enable. This
//                              signal is true when the single cycle instruction
//                              wants to write-back. It should have been
//                              qualified with p3iv, and p3condtrue and the
//                              extension  opcode. If any other instruction
//                              requires a write back at the same time this
//                              signal is true the ARCompact pipeline will stall
//                              and the multi-cycle extension will write back.    
//
// s2val_inverted_r             This signal when set indicates that the value in
//                              the s2val register has been inverted for the
//                              current operation.
//
//========================== Output from this block ==========================--
//
// alurflags       [3:0]        New stage 3 ALU flags. Generated in this stage
//                              by the current instruction. At the end of the
//                              cycle this data will be latched into the
//                              aluflags_r register.
//
// br_flags_a      [3:0]        The flags generated by a compar&branch type
//                              instruction.
//
// mc_addr         [31:0]       The memory address to be sent to the load-store
//                              unit.
//
// p3res_sc        [31:0]       Stage 3 result for short-cutting back to stage
//                              2b
//
// p3result        [31:0]       Stage 3 result for writing back to register file
//
// p3result_nld    [31:0]       As above excluding the returning load path.
//
// wbdata          [31:0]       Stage 4 write data.
//
//============================================================================--
//
module bigalu (clk,
               rst_a,
               aluflags_r,
               e1flag_r,
               e2flag_r,
               aux_datar,
               aux_pc32hit,
               aux_pchit,
               cr_hostw,
               drd,
               h_dataw,
               ldvalid_wb,
               p3_alu_absiv,
               p3_alu_arithiv,
               p3_alu_logiciv,
               p3_alu_op,
               p3_alu_snglopiv,
               p3_shiftin_sel_r,
               p3_bit_op_sel,
               p3_sop_op_r,
               p3awb_field_r,
               p3dolink,
               p3int,
               p3lr,
               p3_min_instr,
               p3_max_instr,
               p3wb_en,
               s1val,
               s2val,
               x_multic_wben,
               xresult,
               x_snglec_wben,
               s2val_inverted_r,

               alurflags,
               br_flags_a,
               mc_addr,
               p3res_sc,
               p3result,
               p3result_nld,
               wbdata);

`include "arcutil_pkg_defines.v" 
`include "arcutil.v" 
`include "extutil.v" 

   input                          clk; 
   input                          rst_a; 
   input  [3:0]                   aluflags_r; 
   input                          e1flag_r; 
   input                          e2flag_r;
   input  [31:0]                  aux_datar; 
   input                          aux_pc32hit;
   input                          aux_pchit; 
   input                          cr_hostw; 
   input  [31:0]                  drd; 
   input  [31:0]                  h_dataw; 
   input                          ldvalid_wb; 
   input                          p3_alu_absiv;
   input                          p3_alu_arithiv;
   input                          p3_alu_logiciv;
   input  [1:0]                   p3_alu_op;
   input                          p3_alu_snglopiv;
   input  [1:0]                   p3_shiftin_sel_r;
   input  [1:0]                   p3_bit_op_sel;
   input  [2:0]                   p3_sop_op_r;
   input  [1:0]                   p3awb_field_r;
   input                          p3dolink; 
   input                          p3int; 
   input                          p3lr; 
   input                          p3_min_instr; 
   input                          p3_max_instr; 
   input                          p3wb_en; 
   input  [31:0]                  s1val; 
   input  [31:0]                  s2val; 
   input                          x_multic_wben; 
   input  [31:0]                  xresult; 
   input                          x_snglec_wben;
   input                          s2val_inverted_r; 

   output [3:0]                   alurflags; 
   output [3:0]                   br_flags_a; 
   output [31:0]                  mc_addr; 
   output [31:0]                  p3res_sc; 
   output [31:0]                  p3result; 
   output [31:0]                  p3result_nld; 
   output [31:0]                  wbdata; 

   wire [3:0]                     alurflags; 
   wire [31:0]                    p3res_sc;
   wire [31:0]                    p3result;
   wire [31:0]                    p3result_nld;
   wire [31:0]                    mc_addr; 
   wire [31:0]                    wbdata; 
   wire [3:0]                     br_flags_a; 

   reg                            i_adder_cin_a; 
   wire                           i_adder_neg_a; 
   wire                           i_adder_ovf_a; 
   wire                           i_adder_carry_a; 
   wire                           i_adder_cout_a; 
   wire   [DATAWORD_MSB:0]        i_adder_result_a; 
   wire   [DATAWORD_MSB:0]        i_adder_result_ncin_a; 
   wire                           i_adder_zero_a; 
   wire                           i_alu_c_flag_r; 
   wire                           i_alu_v_flag_r; 
   wire   [1:0]                   i_arith_c_flag_sel_a; 
   wire                           i_br_carry_a; 
   wire   [3:0]                   i_br_flags_a; 
   wire                           i_br_negative_a; 
   wire                           i_br_overflow_a; 
   wire                           i_br_zero_a; 
   wire                           i_do_pc32_a; 
   wire                           i_do_statreg_a; 
   wire   [1:0]                   i_flag_sel_a; 
   wire                           i_logic_zero_a; 
   reg    [DATAWORD_MSB:0]        i_logicres_a; 
   wire                           i_logicres_msb_a; 
   reg                            i_o_carry_a; 
   reg                            i_o_negative_a; 
   reg                            i_o_overflow_a; 
   reg                            i_o_zero_a; 
   wire                           i_p3_min_max_decode_a; 
   wire   [DATAWORD_MSB:0]        i_p3result_nld_a; 
   wire   [DATAWORD_MSB:0]        i_res_a; 
   reg                            i_s2_gt_s1_a; 
   reg                            i_s2_lt_s1_a; 
   reg    [DATAWORD_MSB:0]        i_s2val_logic_a; 
   reg    [DATAWORD_MSB:0]        i_s2val_mask_a; 
   wire                           i_s2val_msb_r; 
   reg    [DATAWORD_MSB:0]        i_s2val_one_bit_a; 
   reg                            i_shftin_a; 
   wire                           i_sngleopres_msb_a; 
   reg    [DATAWORD_MSB:0]        i_snglopres_a; 
   reg                            i_sop_carry_a; 
   reg                            i_sop_ovf_a; 
   wire                           i_sop_zero_a; 
   wire   [1:0]                   i_src_msbs_a; 
    wire   [DATAWORD_MSB:0]        i_statreg_a; 
   wire                           i_use_arith_a; 
   wire                           i_use_aux_a; 
   wire                           i_use_ext_a; 
   wire                           i_use_logic_a; 
   wire                           i_use_s1val_a; 
   wire                           i_use_s2val_a; 
   wire                           i_use_sop_a; 
   wire   [DATAWORD_MSB:0]        i_wbdata_nxt; 
   reg    [DATAWORD_MSB:0]        i_wbdata_r;
   wire                           i_min_max_c_flag_a;

  //Flag signal assignements
  //
  assign i_alu_c_flag_r = aluflags_r[A_C_N]; 
  assign i_alu_v_flag_r = aluflags_r[A_V_N]; 

//------------------------------------------------------------------------------
// Carry in bit.
//------------------------------------------------------------------------------
//
   // The carry in bit selection can be done here because the adder architecture
   // has been selected to allow the carry in to be non-timing critical 
   //  
   always @(i_alu_c_flag_r or p3_alu_absiv or p3_alu_op or s2val_inverted_r)
    begin : carry_bit_async_PROC
            case (p3_alu_op)
              
              // 
              //  s1 + (not s2 + 1) - i_carry
              // 
              SUBOP_ADC:
                begin
                   i_adder_cin_a = i_alu_c_flag_r;   //  s1 + s2 + i_carry
                end
              
              //  s1 + (not s2 + 1)
              // 
              SUBOP_SBC:
                begin
                   i_adder_cin_a = ~i_alu_c_flag_r;   
                end
              
              //  s1 + s2 (add, ldo, ldr, st)
              // 
              SUBOP_SUB:
                begin
                   i_adder_cin_a = 1'b 1;   
                end
              
              default:
                begin
                   if (p3_alu_absiv == 1'b 1)
                     begin
                        i_adder_cin_a = s2val_inverted_r;   
                     end
                   else
                     begin
                        i_adder_cin_a = 1'b 0;   
                     end
                end
            endcase
    end 

//------------------------------------------------------------------------------
// 32-bit Kogge-Stone Adder.
//------------------------------------------------------------------------------
// 
   adder U_adder (.A(s1val),
          .B(s2val),
          .Cin(i_adder_cin_a),
          .Sum(i_adder_result_a),
          .Zout(i_adder_zero_a),
          .Nout(i_adder_neg_a),
          .Cout(i_adder_cout_a),
          .Vout(i_adder_ovf_a));


   // The carry/borrow result. Inverted when a SUB .
   //
   assign i_adder_carry_a = i_adder_cout_a ^ s2val_inverted_r;


//---------------------------- Single Bit Operand ------------------------------
//
  // This logic is used to generate results for the BBITn,BTST,BSET,BXOR
  // instructions
  
   always @(s2val)
     begin : s2val_1bit_async_PROC
        case (s2val[4:0])
          5'b 00000 : i_s2val_one_bit_a = 32'b 00000000000000000000000000000001;   
          5'b 00001 : i_s2val_one_bit_a = 32'b 00000000000000000000000000000010;   
          5'b 00010 : i_s2val_one_bit_a = 32'b 00000000000000000000000000000100;
          5'b 00011 : i_s2val_one_bit_a = 32'b 00000000000000000000000000001000;
          5'b 00100 : i_s2val_one_bit_a = 32'b 00000000000000000000000000010000;
          5'b 00101 : i_s2val_one_bit_a = 32'b 00000000000000000000000000100000;
          5'b 00110 : i_s2val_one_bit_a = 32'b 00000000000000000000000001000000;
          5'b 00111 : i_s2val_one_bit_a = 32'b 00000000000000000000000010000000;
          5'b 01000 : i_s2val_one_bit_a = 32'b 00000000000000000000000100000000;
          5'b 01001 : i_s2val_one_bit_a = 32'b 00000000000000000000001000000000;
          5'b 01010 : i_s2val_one_bit_a = 32'b 00000000000000000000010000000000;
          5'b 01011 : i_s2val_one_bit_a = 32'b 00000000000000000000100000000000;
          5'b 01100 : i_s2val_one_bit_a = 32'b 00000000000000000001000000000000;
          5'b 01101 : i_s2val_one_bit_a = 32'b 00000000000000000010000000000000;
          5'b 01110 : i_s2val_one_bit_a = 32'b 00000000000000000100000000000000;
          5'b 01111 : i_s2val_one_bit_a = 32'b 00000000000000001000000000000000;
          5'b 10000 : i_s2val_one_bit_a = 32'b 00000000000000010000000000000000;
          5'b 10001 : i_s2val_one_bit_a = 32'b 00000000000000100000000000000000;
          5'b 10010 : i_s2val_one_bit_a = 32'b 00000000000001000000000000000000;
          5'b 10011 : i_s2val_one_bit_a = 32'b 00000000000010000000000000000000;
          5'b 10100 : i_s2val_one_bit_a = 32'b 00000000000100000000000000000000;
          5'b 10101 : i_s2val_one_bit_a = 32'b 00000000001000000000000000000000;
          5'b 10110 : i_s2val_one_bit_a = 32'b 00000000010000000000000000000000;
          5'b 10111 : i_s2val_one_bit_a = 32'b 00000000100000000000000000000000;
          5'b 11000 : i_s2val_one_bit_a = 32'b 00000001000000000000000000000000;
          5'b 11001 : i_s2val_one_bit_a = 32'b 00000010000000000000000000000000;
          5'b 11010 : i_s2val_one_bit_a = 32'b 00000100000000000000000000000000;
          5'b 11011 : i_s2val_one_bit_a = 32'b 00001000000000000000000000000000;
          5'b 11100 : i_s2val_one_bit_a = 32'b 00010000000000000000000000000000;
          5'b 11101 : i_s2val_one_bit_a = 32'b 00100000000000000000000000000000;
          5'b 11110 : i_s2val_one_bit_a = 32'b 01000000000000000000000000000000;
          default   : i_s2val_one_bit_a = 32'b 10000000000000000000000000000000;
        endcase
     end 

//-------------------------------- Mask Operand --------------------------------
// 
   always @(s2val)
     begin  :  s2val_mask_async_PROC
        case (s2val[4:0])
          5'b 00000 : i_s2val_mask_a = 32'b 00000000000000000000000000000001;
          5'b 00001 : i_s2val_mask_a = 32'b 00000000000000000000000000000011;
          5'b 00010 : i_s2val_mask_a = 32'b 00000000000000000000000000000111;
          5'b 00011 : i_s2val_mask_a = 32'b 00000000000000000000000000001111;
          5'b 00100 : i_s2val_mask_a = 32'b 00000000000000000000000000011111;
          5'b 00101 : i_s2val_mask_a = 32'b 00000000000000000000000000111111;
          5'b 00110 : i_s2val_mask_a = 32'b 00000000000000000000000001111111;
          5'b 00111 : i_s2val_mask_a = 32'b 00000000000000000000000011111111;
          5'b 01000 : i_s2val_mask_a = 32'b 00000000000000000000000111111111;
          5'b 01001 : i_s2val_mask_a = 32'b 00000000000000000000001111111111;
          5'b 01010 : i_s2val_mask_a = 32'b 00000000000000000000011111111111;
          5'b 01011 : i_s2val_mask_a = 32'b 00000000000000000000111111111111;
          5'b 01100 : i_s2val_mask_a = 32'b 00000000000000000001111111111111;
          5'b 01101 : i_s2val_mask_a = 32'b 00000000000000000011111111111111;
          5'b 01110 : i_s2val_mask_a = 32'b 00000000000000000111111111111111;
          5'b 01111 : i_s2val_mask_a = 32'b 00000000000000001111111111111111;
          5'b 10000 : i_s2val_mask_a = 32'b 00000000000000011111111111111111;
          5'b 10001 : i_s2val_mask_a = 32'b 00000000000000111111111111111111;
          5'b 10010 : i_s2val_mask_a = 32'b 00000000000001111111111111111111;
          5'b 10011 : i_s2val_mask_a = 32'b 00000000000011111111111111111111;
          5'b 10100 : i_s2val_mask_a = 32'b 00000000000111111111111111111111;
          5'b 10101 : i_s2val_mask_a = 32'b 00000000001111111111111111111111;
          5'b 10110 : i_s2val_mask_a = 32'b 00000000011111111111111111111111;
          5'b 10111 : i_s2val_mask_a = 32'b 00000000111111111111111111111111;
          5'b 11000 : i_s2val_mask_a = 32'b 00000001111111111111111111111111;
          5'b 11001 : i_s2val_mask_a = 32'b 00000011111111111111111111111111;
          5'b 11010 : i_s2val_mask_a = 32'b 00000111111111111111111111111111;
          5'b 11011 : i_s2val_mask_a = 32'b 00001111111111111111111111111111;
          5'b 11100 : i_s2val_mask_a = 32'b 00011111111111111111111111111111;
          5'b 11101 : i_s2val_mask_a = 32'b 00111111111111111111111111111111;
          5'b 11110 : i_s2val_mask_a = 32'b 01111111111111111111111111111111;
          default   : i_s2val_mask_a = 32'b 11111111111111111111111111111111;
        endcase
     end 

//----------------------------- Logic Operand Mux ------------------------------
// 
   // The following mux select between the input used to generate many logic
   // results. The results from above are used for the bit type instructions.
   // Other boolean logic instructions will use their actual operand data.
   //
   always @(i_s2val_mask_a or i_s2val_one_bit_a or p3_bit_op_sel or s2val)
     begin : s2val_p3sel_async_PROC
        case (p3_bit_op_sel)
          2'b 00  : i_s2val_logic_a = s2val;
          2'b 01  : i_s2val_logic_a = i_s2val_one_bit_a;
          default : i_s2val_logic_a = i_s2val_mask_a;
        endcase
     end 
   

//------------------------------ Logic Functions -------------------------------
// 
   // Select between the results of the various results that can be synthesised.
   //
   always @(i_s2val_logic_a or p3_alu_op or s1val)
     begin  : logic_res_async_PROC
        case (p3_alu_op)
          OP_AND  : i_logicres_a = s1val &  i_s2val_logic_a;
          OP_OR   : i_logicres_a = s1val |  i_s2val_logic_a;
          OP_XOR  : i_logicres_a = s1val ^  i_s2val_logic_a;
          default : i_logicres_a = s1val & ~i_s2val_logic_a;
        endcase
     end 

   assign i_logicres_msb_a = i_logicres_a[DATAWORD_MSB]; 

//------------------------- Single Operand Functions ---------------------------
// 
   assign i_s2val_msb_r = s2val[DATAWORD_MSB]; 

   // Select the correct data to be shifted in to form final result
   //
   always @(i_s2val_msb_r or i_alu_c_flag_r or p3_shiftin_sel_r or s2val)
     begin  :  shift_sel_async_PROC
        case (p3_shiftin_sel_r)
          2'b 01 : i_shftin_a = i_s2val_msb_r;
          2'b 10 : i_shftin_a = s2val[0];
          2'b 11 : i_shftin_a = i_alu_c_flag_r;
          default : i_shftin_a = 1'b 0;
        endcase
     end 
   
 
   // The signal operand shift and extend operations
   //
   always @(i_alu_c_flag_r or 
            i_alu_v_flag_r or 
            i_s2val_msb_r or 
            i_shftin_a or
            p3_sop_op_r or 
            s2val)
     begin : snglop_res_async_PROC

        i_sop_carry_a = i_alu_c_flag_r;   
        i_sop_ovf_a = i_alu_v_flag_r;   

        case (p3_sop_op_r)
          OP_RIGHT_SHIFT:
            begin
               i_snglopres_a = {i_shftin_a, s2val[DATAWORD_MSB:1]};   
               i_sop_carry_a = s2val[0];   
            end
          OP_LEFT_SHIFT:
            begin
               i_snglopres_a = {s2val[DATAWORD_MSB - 1:0], i_shftin_a};   
               i_sop_carry_a = i_s2val_msb_r;   
               i_sop_ovf_a = i_s2val_msb_r ^ s2val[DATAWORD_MSB - 1];   
            end
          OP_SEXB:  i_snglopres_a = {{(24){s2val[7]}}, s2val[7:0]};   
          OP_SEXW:i_snglopres_a = {{(16){s2val[15]}}, s2val[15:0]};   
          OP_EXTB:i_snglopres_a = {{(24){1'b 0}}, s2val[7:0]};   
          OP_EXTW:i_snglopres_a = {{(16){1'b 0}}, s2val[15:0]};   
          default:i_snglopres_a = ~s2val;   
        endcase
     end 

   assign i_sngleopres_msb_a = i_snglopres_a[DATAWORD_MSB]; 
 
   // Min/Max instruction result generation
   //  
   assign i_src_msbs_a = {s1val[DATAWORD_MSB], s2val[DATAWORD_MSB]}; 

   always @(i_adder_cout_a or i_adder_zero_a or i_src_msbs_a)
     begin : min_max_async_PROC
        case (i_src_msbs_a)
          2'b 01,
          2'b 10:
            begin
               i_s2_lt_s1_a = i_adder_cout_a & ~i_adder_zero_a;   
               i_s2_gt_s1_a = ~i_adder_cout_a;   
            end
          2'b 11:
            begin
               i_s2_lt_s1_a = 1'b 0;   
               i_s2_gt_s1_a = i_adder_cout_a;   
            end
          default:
            begin
               i_s2_lt_s1_a = ~i_adder_cout_a;   
               i_s2_gt_s1_a = 1'b 0;   
            end
        endcase
     end
   
//--------------------------- Resolve Flag Results -----------------------------
// 
   // Zero flag generation for logic type results.
   //   
   assign i_logic_zero_a = (i_logicres_a == 32'h 00000000) ? 1'b 1 :  1'b 0; 

   // Zero flag gneration of single operand instrucion.
   //                           
   assign i_sop_zero_a = (i_snglopres_a == 32'h 00000000) ? 1'b 1 :  1'b 0;


   // Individual flags for BRcc instructions.
   //
   // Zero flag
   //
   assign i_br_zero_a = (
                         // Adder used for BRcc
                         (i_adder_zero_a & p3_alu_arithiv)
                         |
                         // Logic used for BBITn
                         (i_logic_zero_a & p3_alu_logiciv));
 

   // Negative flag
   //
   assign i_br_negative_a = i_adder_neg_a; 

   // Carry flag
   //
   assign i_br_carry_a = i_adder_cout_a; 

   // Overflow flag
   //
   assign i_br_overflow_a = i_adder_ovf_a; 

   // Separate flags bus for BRcc instructions due to critical path
   // implications from this logic.
   // 
   assign i_br_flags_a = {i_br_zero_a, 
              i_br_negative_a, 
              i_br_carry_a,
              i_br_overflow_a}; 

   // The flag results for both the 16/32-bit instructions are selected.
   // based upon upon whether they are arithmetic, logical or barrel
   // shifts.
   // 
   assign i_p3_min_max_decode_a = (p3_min_instr | p3_max_instr); 

   assign i_flag_sel_a = {p3_alu_logiciv, (p3_alu_arithiv |
                                           i_p3_min_max_decode_a)}; 

   assign i_arith_c_flag_sel_a = {i_p3_min_max_decode_a,
                                  p3_alu_absiv};

   always @(i_adder_neg_a or i_adder_ovf_a or i_adder_carry_a or
            i_adder_zero_a or i_alu_c_flag_r or i_alu_v_flag_r or 
            i_arith_c_flag_sel_a or i_flag_sel_a or i_logic_zero_a or 
            i_logicres_msb_a or i_sngleopres_msb_a or i_sop_carry_a or 
            i_sop_ovf_a or i_sop_zero_a or
            s2val_inverted_r or i_min_max_c_flag_a)
     begin : dt_flags_async_PROC

        case (i_flag_sel_a)

          2'b 10:
            begin

               //  zero flag
               i_o_zero_a = i_logic_zero_a;   

               //  negative flag
               i_o_negative_a = i_logicres_msb_a;   

               //  carry flag : unchanged.
               i_o_carry_a = i_alu_c_flag_r;   

               //  overflow flag
               i_o_overflow_a = i_alu_v_flag_r;   
            end
          2'b 01:
            begin
               //  zero flag
               i_o_zero_a = i_adder_zero_a;   

               //  negative flag
               i_o_negative_a = i_adder_neg_a;   

               //  carry flag
               //
               case (i_arith_c_flag_sel_a)
                 2'b 10:
                   begin
                      i_o_carry_a = i_min_max_c_flag_a;   
                   end
                 2'b 01:
                   begin
                      i_o_carry_a = s2val_inverted_r;   
                   end
                 default:
                   begin
                      i_o_carry_a = i_adder_carry_a;   
                   end
               endcase 
               
               //  overflow flag
               i_o_overflow_a = i_adder_ovf_a;
            end

          default:
            begin
               //  zero flag
               i_o_zero_a = i_sop_zero_a;   

               //  negative flag
               i_o_negative_a = i_sngleopres_msb_a;   

               //  carry flag
               i_o_carry_a = i_sop_carry_a;   

               //  overflow flag
               i_o_overflow_a = i_sop_ovf_a;   
            end
        endcase
     end
   
   // Prelatched flags for all cases other than BRcc instructions. 
   // 
   assign alurflags = {i_o_zero_a, i_o_negative_a,
                       i_o_carry_a, i_o_overflow_a}; 

//----------------------------- Multiplex results ------------------------------
// 
   // Construction of the status register for int or blcc or aux_pchit, 
   // Note H isn't used. RCTL puts currentpc or nextpc on lower part of
   // s1val.
   // 
   assign i_statreg_a = {aluflags_r[A_Z_N], aluflags_r[A_N_N],
                         aluflags_r[A_C_N], aluflags_r[A_V_N], 
                         e2flag_r, e1flag_r, 1'b 0, 1'b 0, 
                         s1val[PC_MSB_A4:PC_LSB_A4]}; 

   //  Select status register.
   // 
   assign i_do_statreg_a = (aux_pchit & p3lr & ~i_use_ext_a); 

   // Select PC32 register.
   // 
   assign i_do_pc32_a = ((p3int | p3dolink | aux_pc32hit & p3lr) & 
                          ~i_use_ext_a); 

   // Use external result when on the extension writeback signal is true else
   // the ALU results are multiplexed instead. Note that XT_ALUOP and
   // xy_multic_op is a constant in extutil to disable this part of the
   // multiplexer if there are no external instructions.
   //
   assign i_use_ext_a = ((x_snglec_wben & XT_ALUOP)
                         | 
                         (x_multic_wben & XT_MULTIC_OP)); 

   // Arithmetic result - this is to be selected when an arithmetic instruction
   // is being executed, but not when p3lr is set, or if i_use_ext_a is true.
   // 
   assign i_use_arith_a = (p3_alu_arithiv & ~(i_use_ext_a |
                          p3_max_instr |
                          p3_min_instr)); 
   
   assign i_use_logic_a = (p3_alu_logiciv & ~i_use_ext_a); 
   
   assign i_use_sop_a = (p3_alu_snglopiv & ~i_use_ext_a); 
   
   assign i_use_aux_a = (p3lr & ~(i_do_statreg_a | 
                                 i_do_pc32_a | 
                                 i_use_ext_a)); 

   
   // This signal selects source 1 operand for a Min/Max operation when it is
   // smaller/greater than source 2 respectively.
   //
   assign i_use_s1val_a = (i_do_pc32_a                  |
                          (p3_max_instr                & 
                           i_s2_lt_s1_a                | 
                           p3_min_instr                & 
                           i_s2_gt_s1_a)               &
                           (~i_use_ext_a)); 

   // This signal selects source 2 operand for a Min/Max operation when it is
   // smaller/greater than source 1 respectively.
   // 
   assign i_min_max_c_flag_a = ((p3_max_instr  &
                                 (i_s2_gt_s1_a |
                                  i_adder_zero_a)) | 
                                (p3_min_instr &
                                 (i_s2_lt_s1_a |
                                  i_adder_zero_a)) );

   assign i_use_s2val_a      = (i_min_max_c_flag_a & ~i_use_ext_a);

//---------------------------- Lower Level Version -----------------------------
// 
   // This section builds an AND-OR multiplexer, for the ALU result since all of
   // the below conditions are mutually exclusive. 
   // 
   assign i_res_a = (aux_datar & {(DATAWORD_WIDTH){i_use_aux_a}} | 
                      
                     i_adder_result_a & {(DATAWORD_WIDTH){i_use_arith_a}} | 
                      
                     i_logicres_a & {(DATAWORD_WIDTH){i_use_logic_a}} | 
                     
                     i_snglopres_a & {(DATAWORD_WIDTH){i_use_sop_a}} | 
                     
                     s1val & {(DATAWORD_WIDTH){i_use_s1val_a}} | 
                     
                     ~s2val & {(DATAWORD_WIDTH){i_use_s2val_a}} | 
                     
                     i_statreg_a & {(DATAWORD_WIDTH){i_do_statreg_a}} | 
                     
                     xresult & {(DATAWORD_WIDTH){i_use_ext_a}}); 

//-------------------------------- LD/ST Adder ---------------------------------
// 
   // The result of the adder for use by the memory controller, The results of
   // adds for load/store operations still go to p3result for address
   // writeback.
   // 
   assign mc_addr = (p3awb_field_r == LDST_PRE_WB) ?  s1val : 
           i_adder_result_a;

   assign i_p3result_nld_a = (h_dataw & {(DATAWORD_WIDTH){cr_hostw}} |
                              
                              i_res_a & {(DATAWORD_WIDTH){~cr_hostw}}); 

   // Latch the stage 3 result to stage 4 for writeback. 
   // 
   assign i_wbdata_nxt = (drd & {(DATAWORD_WIDTH){(ldvalid_wb)}} | 
                          
                          h_dataw & {(DATAWORD_WIDTH){(cr_hostw & ~ldvalid_wb)}}             |
                          
                          i_res_a & {(DATAWORD_WIDTH){~(ldvalid_wb          |
                                                        cr_hostw)}});
   
   always @(posedge rst_a or posedge clk)
     begin : p4data_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_wbdata_r <= {(DATAWORD_WIDTH){1'b 0}};   
          end
        else
          begin
             if (p3wb_en == 1'b 1)
               begin
                  i_wbdata_r <= i_wbdata_nxt;   
               end
          end
     end

//----------------------------------- Output -----------------------------------
// 
   assign br_flags_a = i_br_flags_a; 
   assign p3result = i_wbdata_nxt; 
   assign p3result_nld = i_p3result_nld_a; 
   assign p3res_sc = i_res_a; 
   assign wbdata = i_wbdata_r; 

endmodule // module bigalu
// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module alu(rst_a,
           clk,
           en2b,
           p2b_iv,
           p2b_opcode,
           p2b_subopcode,
           en3,
           p3iv,
           p3opcode,
           p3subopcode,
           p3subopcode2_r,
           p3a_field_r,
           p3b_field_r,
           p3c_field_r,
           p3condtrue,
           x_idecode3,
           p3wb_en,
           p3lr,
           aluflags_r,
           ext_s1val,
           ext_s2val,
           aux_dataw,
           h_dataw,
           uxsetflags,
           uxresult,
           uxflags,
           cr_hostw,
           p3int,
           x_multic_wben,
           x_snglec_wben,
           ldvalid_wb,
           p3_alu_absiv,
           p3_alu_arithiv,
           p3_alu_logiciv,
           p3_alu_op,
           p3_alu_snglopiv,
           p3_bit_op_sel,
           p3_max_instr,
           p3_min_instr,
           p3_shiftin_sel_r,
           p3_sop_op_r,
           p3awb_field_r,
           p3dolink,
           p3minoropcode,
           p3subopcode3_r,
           p3subopcode4_r,
           p3subopcode5_r,
           p3subopcode6_r,
           p3subopcode7_r,
           s2val,
           barrel_type_r,
           x_p3_brl_decode_16_r,
           x_p3_brl_decode_32_r,
           x_p3_norm_decode_r,
           x_p3_snorm_decode_r,
           x_p3_swap_decode_r,
           e1flag_r,
           e2flag_r,
           aux_datar,
           aux_pc32hit,
           aux_pchit,
           drd,
           s1val,
           s2val_inverted_r,
           aux_st_mulhi_a,
           wbdata,
           br_flags_a,
           mulatwork_r,
           alurflags,
           mc_addr,
           p3res_sc,
           p3result,
           lmulres_r,
           x_s_flag,
           xflags);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "asmutil.v"
`include "xdefs.v"


input  rst_a;
input  clk;
input  en2b;
input  p2b_iv;
input  [4:0]  p2b_opcode;
input  [5:0]  p2b_subopcode;
input  en3;
input  p3iv;
input  [4:0]  p3opcode;
input  [5:0]  p3subopcode;
input  [4:0]  p3subopcode2_r;
input  [5:0]  p3a_field_r;
input  [5:0]  p3b_field_r;
input  [5:0]  p3c_field_r;
input  p3condtrue;
input  x_idecode3;
input  p3wb_en;
input  p3lr;
input  [3:0]  aluflags_r;
input  [31:0]  ext_s1val;
input  [31:0]  ext_s2val;
input  [31:0]  aux_dataw;
input  [31:0]  h_dataw;
input  uxsetflags;
input  [31:0]  uxresult;
input  [3:0]  uxflags;
input  cr_hostw;
input  p3int;
input  x_multic_wben;
input  x_snglec_wben;
input  ldvalid_wb;
input  p3_alu_absiv;
input  p3_alu_arithiv;
input  p3_alu_logiciv;
input  [1:0]  p3_alu_op;
input  p3_alu_snglopiv;
input  [1:0]  p3_bit_op_sel;
input  p3_max_instr;
input  p3_min_instr;
input  [1:0]  p3_shiftin_sel_r;
input  [2:0]  p3_sop_op_r;
input  [1:0]  p3awb_field_r;
input  p3dolink;
input  [5:0]  p3minoropcode;
input  [2:0]  p3subopcode3_r;
input  p3subopcode4_r;
input  [1:0]  p3subopcode5_r;
input  [2:0]  p3subopcode6_r;
input  [1:0]  p3subopcode7_r;
input  [31:0]  s2val;
input  [1:0]  barrel_type_r;
input  x_p3_brl_decode_16_r;
input  x_p3_brl_decode_32_r;
input  x_p3_norm_decode_r;
input  x_p3_snorm_decode_r;
input  x_p3_swap_decode_r;
input  e1flag_r;
input  e2flag_r;
input  [31:0]  aux_datar;
input  aux_pc32hit;
input  aux_pchit;
input  [31:0]  drd;
input  [31:0]  s1val;
input  s2val_inverted_r;
input  aux_st_mulhi_a;
output [31:0]  wbdata;
output [3:0]  br_flags_a;
output mulatwork_r;
output [3:0]  alurflags;
output [31:0]  mc_addr;
output [31:0]  p3res_sc;
output [31:0]  p3result;
output [63:0]  lmulres_r;
output [1:0]  x_s_flag;
output [3:0]  xflags;

wire rst_a;
wire clk;
wire en2b;
wire p2b_iv;
wire  [4:0] p2b_opcode;
wire  [5:0] p2b_subopcode;
wire en3;
wire p3iv;
wire  [4:0] p3opcode;
wire  [5:0] p3subopcode;
wire  [4:0] p3subopcode2_r;
wire  [5:0] p3a_field_r;
wire  [5:0] p3b_field_r;
wire  [5:0] p3c_field_r;
wire p3condtrue;
wire x_idecode3;
wire p3wb_en;
wire p3lr;
wire  [3:0] aluflags_r;
wire  [31:0] ext_s1val;
wire  [31:0] ext_s2val;
wire  [31:0] aux_dataw;
wire  [31:0] h_dataw;
wire uxsetflags;
wire  [31:0] uxresult;
wire  [3:0] uxflags;
wire cr_hostw;
wire p3int;
wire x_multic_wben;
wire x_snglec_wben;
wire ldvalid_wb;
wire p3_alu_absiv;
wire p3_alu_arithiv;
wire p3_alu_logiciv;
wire  [1:0] p3_alu_op;
wire p3_alu_snglopiv;
wire  [1:0] p3_bit_op_sel;
wire p3_max_instr;
wire p3_min_instr;
wire  [1:0] p3_shiftin_sel_r;
wire  [2:0] p3_sop_op_r;
wire  [1:0] p3awb_field_r;
wire p3dolink;
wire  [5:0] p3minoropcode;
wire  [2:0] p3subopcode3_r;
wire p3subopcode4_r;
wire  [1:0] p3subopcode5_r;
wire  [2:0] p3subopcode6_r;
wire  [1:0] p3subopcode7_r;
wire  [31:0] s2val;
wire  [1:0] barrel_type_r;
wire x_p3_brl_decode_16_r;
wire x_p3_brl_decode_32_r;
wire x_p3_norm_decode_r;
wire x_p3_snorm_decode_r;
wire x_p3_swap_decode_r;
wire e1flag_r;
wire e2flag_r;
wire  [31:0] aux_datar;
wire aux_pc32hit;
wire aux_pchit;
wire  [31:0] drd;
wire  [31:0] s1val;
wire s2val_inverted_r;
wire aux_st_mulhi_a;
wire  [31:0] wbdata;
wire  [3:0] br_flags_a;
wire mulatwork_r;
wire  [3:0] alurflags;
wire  [31:0] mc_addr;
wire  [31:0] p3res_sc;
wire  [31:0] p3result;
wire  [63:0] lmulres_r;
wire  [1:0] x_s_flag;
wire  [3:0] xflags;


// Intermediate signals
wire  [31:0] i_xresult;


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)
wire  [31:0] u_unconnected_0;
wire u_unconnected_1;


// Instantiation of module bigalu
bigalu ibigalu(
  .clk(clk),
  .rst_a(rst_a),
  .aluflags_r(aluflags_r),
  .e1flag_r(e1flag_r),
  .e2flag_r(e2flag_r),
  .aux_datar(aux_datar),
  .aux_pc32hit(aux_pc32hit),
  .aux_pchit(aux_pchit),
  .cr_hostw(cr_hostw),
  .drd(drd),
  .h_dataw(h_dataw),
  .ldvalid_wb(ldvalid_wb),
  .p3_alu_absiv(p3_alu_absiv),
  .p3_alu_arithiv(p3_alu_arithiv),
  .p3_alu_logiciv(p3_alu_logiciv),
  .p3_alu_op(p3_alu_op),
  .p3_alu_snglopiv(p3_alu_snglopiv),
  .p3_shiftin_sel_r(p3_shiftin_sel_r),
  .p3_bit_op_sel(p3_bit_op_sel),
  .p3_sop_op_r(p3_sop_op_r),
  .p3awb_field_r(p3awb_field_r),
  .p3dolink(p3dolink),
  .p3int(p3int),
  .p3lr(p3lr),
  .p3_min_instr(p3_min_instr),
  .p3_max_instr(p3_max_instr),
  .p3wb_en(p3wb_en),
  .s1val(s1val),
  .s2val(s2val),
  .x_multic_wben(x_multic_wben),
  .xresult(i_xresult),
  .x_snglec_wben(x_snglec_wben),
  .s2val_inverted_r(s2val_inverted_r),
  .alurflags(alurflags),
  .br_flags_a(br_flags_a),
  .mc_addr(mc_addr),
  .p3res_sc(p3res_sc),
  .p3result(p3result),
  .p3result_nld(u_unconnected_0),
  .wbdata(wbdata)
);


// Instantiation of module xalu
xalu ixalu(
  .clk(clk),
  .rst_a(rst_a),
  .p3iv(p3iv),
  .aluflags_r(aluflags_r),
  .p3opcode(p3opcode),
  .p3subopcode(p3subopcode),
  .p3subopcode2_r(p3subopcode2_r),
  .p3a_field_r(p3a_field_r),
  .p3b_field_r(p3b_field_r),
  .p3c_field_r(p3c_field_r),
  .p3subopcode3_r(p3subopcode3_r),
  .p3subopcode4_r(p3subopcode4_r),
  .p3subopcode5_r(p3subopcode5_r),
  .p3subopcode6_r(p3subopcode6_r),
  .p3subopcode7_r(p3subopcode7_r),
  .p3minoropcode(p3minoropcode),
  .p3condtrue(p3condtrue),
  .en3(en3),
  .ext_s1val(ext_s1val),
  .ext_s2val(ext_s2val),
  .s1val(s1val),
  .s2val(s2val),
  .aux_dataw(aux_dataw),
  .x_idecode3(x_idecode3),
  .x_multic_wben(x_multic_wben),
  .x_snglec_wben(x_snglec_wben),
  .uxsetflags(uxsetflags),
  .uxresult(uxresult),
  .uxflags(uxflags),
  .barrel_type_r(barrel_type_r),
  .x_p3_brl_decode_16_r(x_p3_brl_decode_16_r),
  .x_p3_brl_decode_32_r(x_p3_brl_decode_32_r),
  .p2b_opcode(p2b_opcode),
  .p2b_subopcode(p2b_subopcode),
  .p2b_iv(p2b_iv),
  .en2b(en2b),
  .aux_st_mulhi_a(aux_st_mulhi_a),
  .x_p3_norm_decode_r(x_p3_norm_decode_r),
  .x_p3_snorm_decode_r(x_p3_snorm_decode_r),
  .x_p3_swap_decode_r(x_p3_swap_decode_r),
  .mulatwork_r(mulatwork_r),
  .lmul_en(u_unconnected_1),
  .lmulres_r(lmulres_r),
  .x_s_flag(x_s_flag),
  .xflags(xflags),
  .xresult(i_xresult)
);


// Output drives

endmodule


// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2001-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// Instruction Aligner. Aligns and formats 16 and 32-bit instructions.
// 
// ======================= Inputs to this block =======================--
// 
//  clk         Global Clock.
//   
//  RST_A       Global Reset (active high).
// 
//  p1iw[31:0]  The instruction word supplied by the memory
//              controller. It is considered to be valid when the
//              ivalid signal is true.
// 
//  ivalid      Qualifying signal for p1iw[31:0]. When it is low,
//              this indicates that the m/c has not been able to
//              fetch the requested opcode, and that the program
//              counter should not be incremented. The pipeline
//              might be stalled, depending upon whether the
//              instruction in stage 2 needs to look at the
//              instruction in stage 1.
//              When it is true, the instruction is clocked into 
//              pipeline stage 2 provided that the pipeline is able
//              to move on.
// 
//  en1         Stage 2 pipeline latch control. True when an
//              instruction is being latched into pipeline stage 2.
//              This signal will be low when ivalid_aligned = 0,
//              preventing junk instructions from being clocked into
//              the pipeline. Also means that interrupts do not
//              enter the pipe until a valid instruction is
//              available in stage 1.
// 
//  en2         Pipeline stage 2 enable. When this signal is true,
//              the instruction in stage 2 can pass into stage 3 at
//              the end of the cycle. When it is false, it will hold
//              up stage 2 and stage 1 (pcen).
// 
//  p2b_dojcc   True when a jump is going to happen.
//              Relates to the instruction in p2. Includes p2iv.
// 
//  p2_dorel    True when a relative branch (not jump) is going to
//              happen. Relates to the instruction in p2. Includes
//              p2iv.
//
//  p4_docmprel True when a relative compare branch (not jump) is going
//              to happen. Relates to the instruction in p2. Includes
//              p2iv.
// 
//  h_pcwr      True when the host writes to the PC register
// 
//  h_pcwr32    True when the host writes to the PC32 register
// 
//  h_status32  True when the host writes to the Status32 register
// 
//  loopend_hit_a
//              From to cr_int. This signal is set true when
//              pc_plus_len points to the loop end address. It is
//              used in conjuction with a number of other signals to
//              decrement the loop counter.
// 
//  misaligned_target
//              True when the current PC is word aligned
// 
//  do_inst_step_r
//              This signal is set when the single step flag (SS)
//              and the instruction step flag (IS) in the debug
//              register has been written to simultaneously through
//              the host interface. It indicates that an instruction
//              step is being performed. When the instruction step
//              has finished this signal goes low.
// 
//  ivic        Indicates that all values in the cache are to be 
//              invalidated. (it stands for InValidate Instruction
//              Cache). It is anticipated that this signal will be 
//              generated from a decode of an SR instruction.
//              Note that due to the pipelined nature of the ARC, up 
//              to three instructions could be issued following the 
//              SR which generates the ivic signal. Cache
//              invalidates must be supressed when a line is being
//              loaded from memory. This is done at the auxiliary
//              register which generates ivic.
// 
//  p2int       This signal indicates that an interrupt jump
//              instruction (fantasy instruction) is currently in
//              stage 2. This signal has a number of consequences
//              throughout the system, causing the interrupt vector
//              (int_vec) to be put into the PC, and causing the old
//              PC to be placed into the pipeline in order to be
//              stored into the appropriate interrupt link register.
//              Note that p2int and p2iv are mutually exclusive.
// 
//  pcen_niv    Version of pcen excluding ivalid_aligned decode.
// 
//  ifetch_aligned
//              This signal, from rctl in the ARC, indicates to
//              the cache controller that a new instruction is
//              required, and should be fetched from memory from
//              the address which will be clocked into
//              currentpc[25:2] at the end of the cycle. It
//              is also true for one cycle when the processor has
//              been started following a reset, in order to get the
//              ball rolling.
//               An instruction fetch will also be issued if the
//              host changes the program counter when the ARC is
//              halted, provided it is not directly after a reset.
//               The ifetch signal will never be set true whilst
//              the memory controller is in the process of doing an
//              instruction fetch, so it may be used by the memory
//              controller as an acknowledgement of instruction
//              receipt.
// 
//  p2limm      This signal indicates that the instruction in stage 2
//              is using a 32-Bit limm.  When this signal is true the
//              instruction word in stage 1 is limm data.
// 
// ====================== Output from this block ======================--
// 
//  p1inst_16   This signal is true when the instrucion forwarded is a
//              16-bit type.
// 
//  aligner_do_pc_plus_8
//             This signal is true when an instruction stream consists of
//             word aligned 32-bit instructions. As can be seen at time T
//             the 16-bit instruction at address n is presented (the high
//             part of the next longword is stored in the buffer). At T+1
//             the current PC is n+2. The data requested (at time T) and
//             returned from memory at time T+1 is the longword at
//             n+4 (and therefore the half word at n+6 is buffered).  To
//             be able to present the complete 32-bit instruction at n+6
//             the memory address must be set to n+8, which is the
//             longword aligned version of PC+8 ( (n+2)+8 =
//             (n+10)&&0xfffffffc = n+8).
//             This process will continue until a 16-bit instruction or
//             a jcc/brcc/bcc instruction is encountered.
// 
// 
//             --------------------------------
//             |              |               |
//        n    |    16-bit    |    32-bit_a0  |
//             |              |               |
//             --------------------------------
//             |              |               |
//        n+4  |   32-bit_b0  |    32-bit_a1  |
//             |              |               |
//             --------------------------------
//             |              |               |
//        n+8  |   32-bit_b1  |    32-bit_a2  |
//             |              |               |
//             --------------------------------
//             |              |               |
//        n+12 |   32-bit_b2  |    xxxxxxx    |
//             |              |               |
//             --------------------------------
// 
// 
//  aligner_pc_enable
//             This signal is true when the instruction aligner needs
//             fetch the longword from the pc+4 address to be able to
//             reconstruction a word aligned 32-bit instruction or
//             limm. if a jcc/brcc/bcc as a word aligned target which is
//             also a 32-bit instruction the aligner is unable to
//             present the instruction immediatly.  The aligner must
//             stall stage 1 (this is done by forcing ivalid_aligned to
//             false) and request the n+4 longword.  When the n+4
//             longword is returned the aligner can construct the
//             complete instruction from the buffered high word at
//             address n+2 and the low word at address n+4.
// 
//             --------------------------------
//             |              |               |
//        n    |    xxxxxx    |    32-bit_a0  |
//             |              |               |
//             --------------------------------
//             |              |               |
//        n+4  |   32-bit_b0  |    xxxxxxxxx  |
//             |              |               |
//             --------------------------------
//
//  ivalid_aligned
// 
//            This signal is true when the ivalid signal from the ifetch
//            interface is true except when the aligner need to get the
//            next longword to be able to reconstruct the current
//            instruction. See explanation of aligner_pc_enable.
// 
// 
//  p1iw_aligned_a
// 
//           This bus contains the current instruction word and is
//           qualified with ivalid_aligned.
// 
//  p1_limm_data
//
//           This is the unlatched 32-bit long immediate data value which
//           contains a long immediate dataword to be switched onto one
//           of the source operand buses.
//
// ----------------------------------------------------------------------
// 
// 
module inst_align (clk,
                   rst_a,
                   p4_docmprel,
                   p2b_dojcc,
                   p2_dorel,
                   p2_dopred,
                   do_loop_a,
                   do_inst_step_r,
                   en1,
                   en2,
                   en2b,
                   h_pcwr,
                   h_pcwr32,
                   h_status32,
                   ifetch_aligned,
                   ivalid,
                   ivic,
                   kill_tagged_p1,
                   misaligned_target,
                   p1iw,
                   pcounter_jmp_restart_r,
                   p2int,
                   p2limm,
                   pcen_niv,

                   ifetch,
                   ivalid_aligned,
                   p1inst_16,
                   p1iw_aligned_a,
                   aligner_do_pc_plus_8,
                   aligner_pc_enable);

`include "arcutil_pkg_defines.v" 
`include "arcutil.v"

input   clk; 
input   rst_a; 
input   p4_docmprel; 
input   p2b_dojcc; 
input   p2_dorel; 
input   p2_dopred;
input   do_loop_a;  
input   do_inst_step_r; 
input   en1; 
input   en2; 
input   en2b; 
input   h_pcwr; 
input   h_pcwr32; 
input   h_status32; 
input   ifetch_aligned; 
input   ivalid; 
input   ivic;
input   kill_tagged_p1; 
input   misaligned_target; 
input   [31:0] p1iw; 
input   pcounter_jmp_restart_r; 
input   p2int; 
input   p2limm; 
input   pcen_niv; 

output  ifetch; 
output  ivalid_aligned; 
output  p1inst_16; 
output  [DATAWORD_MSB:0] p1iw_aligned_a; 
output  aligner_do_pc_plus_8; 
output  aligner_pc_enable;

 
wire    ifetch; 
wire    ivalid_aligned; 
wire    p1inst_16; 
wire    [DATAWORD_MSB:0] p1iw_aligned_a; 
wire    aligner_do_pc_plus_8; 
wire    aligner_pc_enable; 

// --------------------------------------------------------------------
// Internal Signals
// --------------------------------------------------------------------
//

wire    [3:0] i_aligner_mux_ctrl_a; 
wire    i_buffer_invalid_a; 
wire    [16:0] i_buffer_nxt; 
reg     [16:0] i_buffer_r; 
wire    i_buffer_valid_a; 
reg     i_buffer_valid_r; 
reg     i_aligner_do_pc_plus_8_a; 
wire    i_gen_new_ifetch_a; 
wire    i_ifetch_a; 
reg     i_inst_is_16_bit_a; 
wire    i_instword_1_is_16_bit_a; 
wire    i_instword_2_is_16_bit_a; 
wire    i_ivalid_a; 
reg     [DATAWORD_MSB:0] i_p1iw_a; 
reg     [DATAWORD_MSB:0] i_p1iw_aligned_a;


//  rtl
// --------------------------------------------------------------------
// Endianness support
// --------------------------------------------------------------------

always @(p1iw)
   begin : endian_async_PROC

      // Little-endian swaps the 16-bit words in an instruction long-word
      i_p1iw_a = {p1iw[15:0], p1iw[DATAWORD_MSB:16]};  
   end
   
// --------------------------------------------------------------------
// Signal Assignments
// --------------------------------------------------------------------

// Is the first word a 16-bit instruction?
// All the 16-bit instructions reside in major opcode slots 0x0C to
// 0x1F. The 5-bit opcode sits at bit positions 31 downto 27.
//
assign i_instword_1_is_16_bit_a = i_p1iw_a[31] | (i_p1iw_a[30] & i_p1iw_a[29]);
// Is the second word a 16-Bit instruction?
// All the 16-bit instructions reside in major opcode slots 0x0C to
// 0x1F. The 5-bit opcode sits at bit positions 15 downto 11.
//
assign i_instword_2_is_16_bit_a = i_p1iw_a[15] | (i_p1iw_a[14] & i_p1iw_a[13]); 

// This signal informs the core that the instruction is of 16-bit type
//
assign p1inst_16 = i_inst_is_16_bit_a;
 
// I-cache interface control signals
//
assign ifetch = i_ifetch_a; 
assign ivalid_aligned = i_ivalid_a; 

// When the aligner is processing a stream of word aligned
// 32-bit instructions the aligner requires that the cache/memory
// returns the longword address directly after the current PC
//
assign aligner_do_pc_plus_8 = i_aligner_do_pc_plus_8_a;
 
//  Stage 1 instruction word
//
assign p1iw_aligned_a = i_p1iw_aligned_a;

// ---------------------------------------------------------------------
//  ALIGNER MUX Control
// ---------------------------------------------------------------------
//  All signals below are mutally exclusive
//
// Instruction longword has a 16-bit instruction in it's first word
// location.
//
assign i_aligner_mux_ctrl_a[0] = ((misaligned_target        == 1'b 0) &
                                  (i_instword_1_is_16_bit_a == 1'b 1) & 
                                  (p2limm                   == 1'b 0)) ?
       1'b 1 : 
       1'b 0;

// The buffer contains a 16-bit instruction and the pc is word aligned.
//
assign i_aligner_mux_ctrl_a[1] = ((misaligned_target == 1'b 1) &
                                  (i_buffer_valid_r  == 1'b 1) & 
                                  (i_buffer_r[16]    == 1'b 1) &
                                  (p2limm            == 1'b 0)) ? 1'b 1 : 
       1'b 0;
 
// The buffer contains half a longword (instruction or limm).
//
assign i_aligner_mux_ctrl_a[2] = ((misaligned_target == 1'b 1) &
                                  (i_buffer_valid_r  == 1'b 1) & 
                                  ((i_buffer_r[16]   == 1'b 0) |
                                   (p2limm           == 1'b 1))) ? 1'b 1 : 
       1'b 0;
 
// instruction longword has a 16-bit instruction in it's second word
// location.
//
assign i_aligner_mux_ctrl_a[3] =((misaligned_target        == 1'b 1) &
                                 (i_buffer_valid_r         == 1'b 0) & 
                                 (i_instword_2_is_16_bit_a == 1'b 1)) ?
       1'b 1 : 
       1'b 0; 

// The logic below detects when the aligner is required to fetch the
// second part of a longword which is located at the next longword
// address.
//
// The original ARC5 design did the following in the case of a
// misaligned Non-linear 32-bit access:
//
// When the initial request for the instruction is made, the buffer is
// invalidated since the instruction fetch is non-linear (a jump/branch
// or pc write etc).
// 
// When the first part of the instruction is supplied by the cache
// system, and the core is ready to accept it, the following condition 
// will be true:
//
// misaligned_target        = '1'  - last instruction fetch was
//                                    misaligned
// i_buffer_valid_r         = '0'  - no stored instruction parts
// i_instword_2_is_16_bit_a = '0'  - cache has the first part of a
//                                   32-bit op
// ivalid                   = '1'  - cache is supplying a valid
//                                   instruction
// pcen_niv            = '1'  - the core is running and ready to
//                                   accept the instruction
//
// Under these circumstances, the logic does the following:
//    a. it forces the ivalid signal low to supress the 32-bit
//       instruction 
//    b. it clocks the first part of the instruction into the buffer
//    c. it asks the cache system for the next instruction word
//
// The effect of including pcen_niv is that the second part of the
// instruction is only fetched once the core is ready to accept it.
// In an ideal world, the aligner would detect that the next part of the 
// instruction is required, and go off and get it without any reference
// to the core. This will firstly be more intuitive, and secondly will 
// allow the pcen_niv signal to be removed from the logic.
//
// Another change instituted in this file is to ensure that the buffer
// is allowed to update during an ifetch when the core is halted.
//
// Other changes are required in cr_int to ensure that the correct
// program counter is presented. The signal pcen_niv is also used 
// there to select the program counter value. Changes are required to
// ensure that the right PC value is selected when the core is halted
// and the PC is updated.
// 
assign i_gen_new_ifetch_a = ((misaligned_target        == 1'b 1) &
                             (kill_tagged_p1           == 1'b 0) &
                             (i_buffer_valid_r         == 1'b 0) & 
                             ((i_instword_2_is_16_bit_a == 1'b 0) |
                              (p2limm                   == 1'b 1)) &
                             (ivalid                   == 1'b 1)) ? 1'b 1 : 
       1'b 0;

// The signal going to cr_int (aligner_pc_enable) is used only when
// ivalid = '1' to qualify the PC update. Hence we can produce a version
// here which does not include ivalid, since it will be included later.
//
assign aligner_pc_enable = ((misaligned_target        == 1'b 1) &
                            (kill_tagged_p1           == 1'b 0) &
                            (i_buffer_valid_r         == 1'b 0) & 
                            ((i_instword_2_is_16_bit_a == 1'b 0) |
                             (p2limm                   == 1'b 1))) ? 1'b 1 : 
       1'b 0; 

// The above situation has been indentifed and now the aligner acts upon
// it by generating a new ifetch to the ifetch interface. The entire
// instruction will not be valid until both parts have been fetched.
//
assign i_ifetch_a = (i_gen_new_ifetch_a == 1'b 1) ? 1'b 1 : 
       ifetch_aligned;

assign i_ivalid_a = (i_gen_new_ifetch_a == 1'b 1) ? 1'b 0 : 
       ivalid; 

// ---------------------------------------------------------------------
//  Aligner Mux
// ---------------------------------------------------------------------
always @(i_aligner_mux_ctrl_a or i_buffer_r or i_p1iw_a)
   begin : aligner_async_PROC
   case (i_aligner_mux_ctrl_a)
   4'b 0001:
      begin
      // 16-bit instruction type
      i_inst_is_16_bit_a = 1'b 1;

      i_aligner_do_pc_plus_8_a = 1'b 0;
    
      //  16-bit instruction word
      i_p1iw_aligned_a = {i_p1iw_a[31:16],
                           //  Flag bit 
                           1'b 0,
                           //  B field MSBs
                           2'b 00, i_p1iw_a[26], 
                           //  C field
                           2'b 00, i_p1iw_a[23], i_p1iw_a[23:21],
                           // Padding;
                           6'b 000000};

      end

   4'b 0010:
      begin
      // 16-bit instruction type
      i_inst_is_16_bit_a = 1'b 1;

      i_aligner_do_pc_plus_8_a = 1'b 0;

      //  16-bit instruction word
      i_p1iw_aligned_a = {i_buffer_r[15:0],
                           //  Flag bit 
                           1'b 0,
                           //  B field MSBs
                           2'b 00, i_buffer_r[10], 
                           //  C field
                           2'b 00, i_buffer_r[7], i_buffer_r[7:5],
                           // Padding;
                           6'b 000000};

      end

   4'b 0100:
      begin
      // 32-bit instruction type        
      i_inst_is_16_bit_a = 1'b 0;

      i_aligner_do_pc_plus_8_a = 1'b 1;

      i_p1iw_aligned_a = {i_buffer_r[15:0], i_p1iw_a[31:16]};  

      end

   4'b 1000:
      begin
      // 16-bit instruction type
      i_inst_is_16_bit_a = 1'b 1;

      i_aligner_do_pc_plus_8_a = 1'b 0;
    
      //  16-bit instruction word
      i_p1iw_aligned_a = {i_p1iw_a[15:0],
                           // Flag bit 
                           1'b 0,
                           //  B field MSBs
                           2'b 00, i_p1iw_a[10], 
                           //  C field
                           2'b 00, i_p1iw_a[7], i_p1iw_a[7:5],
                           // Padding;
                           6'b 000000};
      end
   default:
      begin
      // 32-bit instruction type     
      i_inst_is_16_bit_a = 1'b 0;

      i_aligner_do_pc_plus_8_a = 1'b 0;

      i_p1iw_aligned_a = i_p1iw_a;

      end
   endcase
   end

// ---------------------------------------------------------------------
//  Buffer has valid data
// ---------------------------------------------------------------------
// Buffer valid does not indicate if the buffer contains a valid 16-bit
// instruction or half of a valid 32-bit instruction simply because this
// kind of information is not know until stage 2
//
// Buffer valid indicates that buffer contains something that can be
// used to construct a valid instruction word in stage 1.
//
// This is true when :- the longword from the cache is valid
// 
// The original signal for A5 looked like this:
//
//assign i_buffer_valid_a = ivalid &
//                          //  16-bit instruction in first part of
//                          // longword
//                          ((~misaligned_target &
//                            i_instword_1_is_16_bit_a |
//                          //  the pc value is word aligned
//                            misaligned_target) & 
//                          //  the current instruction will move into
//                          // stage2
//                         (en1 | i_gen_new_ifetch_a |
//                            do_inst_step_r)) &
//                          //  the pc is allowed to advance
//                          pcen_niv;
//
// However, to allow the buffer to update as soon as the data is 
// available from the cache (even when the core is halted), the
// qualifying signal pcen_niv has been removed from the
// i_gen_new_ifetch_a mode.
//
assign i_buffer_valid_a = ivalid &
                          (~kill_tagged_p1) &
                          // 16-bit instruction in first part of
                          // longword.
                          (((~misaligned_target) &
                            i_instword_1_is_16_bit_a |
                          // The pc value is word aligned.
                            misaligned_target) & 
                          // The current instruction will move into 
                          // stage 2..
                          (((en1 | do_inst_step_r) &
                          // The pc is allowed to advance.
                            pcen_niv) |
                          i_gen_new_ifetch_a));

// The buffer is no long valid if :-
assign i_buffer_invalid_a = (
                            //  A bra has occured in stage 2.
                            ((p2_dorel | p2_dopred) & en2 |
                            //  A jmp has occured in stage 2B.
                             (p2b_dojcc & en2b) |
                            //  Branch and compare in stage 4 has occured.
                             p4_docmprel | 
                            // An interrupt has occured in stage 2 and
                            // the buffer contents will not be needed as
                            // the interrupt will jump in stage 2.
                             (p2int & en2)) & 
                            // The above conditions need qualifing with
                            // ivalid because they don't actually happen
                            // in the current cycle if valid is not true
                            // (which indicates the cache can accept
                            // another ifetch).
                            (pcen_niv & ivalid) |
                            (pcounter_jmp_restart_r & ivalid) |
                            // The cache has been invalidated. 
                            ivic | 
                            // A write to the pc via the host. 
                            (h_pcwr | h_pcwr32) |
                            // The buffer contents are still need when the
                            // host restarts by clearing the halt bit.
                            (h_status32 & (~misaligned_target)) | 
                            // The buffer contents have been used.
                            i_buffer_r[16] & (~p2limm) &
                            // The current longword is an aligned 32-bit
                            // instruction or a limm.
                            misaligned_target & ifetch_aligned & en1 |
                            ((~i_instword_1_is_16_bit_a) | p2limm) & 
                            ~misaligned_target |
                            // Looping back during a zero overhead loop.
                            (do_loop_a & en1)); 

always @(posedge clk or posedge rst_a)
   begin : buffer_valid_sync_PROC
   if (rst_a == 1'b 1)
      begin
      //  asynchronous reset (active high)
      i_buffer_valid_r <= 1'b 0;    
      end
   else
      begin
      //  rising clock edge
      //
      // Buffer valid does not indicate if the buffer contains a valid
      // 16-bit instruction or half of a valid 32-bit instruction
      // simply because this kind of information is not know until stage
      //  2.
      // Buffer valid indicates that buffer contains something that can
      // be used to contruct a valid instruction word in stage 1.
      if (i_buffer_invalid_a == 1'b 1)
        begin
                   i_buffer_valid_r <= 1'b 0; 
        end
          else if (i_buffer_valid_a == 1'b 1)
        begin
           i_buffer_valid_r <= 1'b 1; 
        end

      end
   end

// ---------------------------------------------------------------------
// Instruction Word buffer
// ---------------------------------------------------------------------
//  The buffer is updated when either the instruction word from the
//  I-cache is valid and the instruction is allowed to advance or if
//  the target is wordaligned an is a 32-bit instruction.
//
assign i_buffer_nxt = ((i_buffer_valid_a == 1'b 1) &
                       (i_ifetch_a == 1'b 1)) ?
       //  Get a new buffer value when the aligner really
       //  needs one.
       //
       {i_instword_2_is_16_bit_a, 
        i_p1iw_a[15:0]} : 
       i_buffer_r;
 
always @(posedge clk or posedge rst_a)
   begin : instr_word_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_buffer_r <= {(SEVENTEEN){1'b 0}};    
      end
   else
      begin
      i_buffer_r <= i_buffer_nxt;   
      end
   end

// ---------------------------------------------------------------------
// THE END........
// ---------------------------------------------------------------------

endmodule // module inst_align

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file is an empty extension core register block.
//       Small Score Boarded Multiply Instruction, Revision info. :  600 Architecture IP Library version 4.9.7, file revision  $Date$
// 
//
//========================== Inputs to this block =========================--
//
//
// s1a[5:0]         U Source 1 register address from stage 2 of the pipeline.
//                  This is the B field from the instruction word, sent from 
//                  the rctl via hostif.v.
//
// s2a[5:0]         L Source 2 register address from stage 2 of the pipeline.
//                  This is the C field from the instruction word, sent from
//                  rctl.v. 
//
// wba[5:0]         L Write Back Address. This is the address of the register
//                  to be loaded with wbdata[31:0] at the end of the cycle if
//                  wben is high. This is used to for all register writebacks
//                  whether from the LSU, ALU, or the host.
//
// wbdata[]         L Write Back Data. This is the data from the writeback 
//                  stage which is to be written into the register file, into
//                  the address specified by wba[5:0] at the end of the cycle
//                  when wben is true. 
//
// wben             L Write Back Enable. This signal is the enable signal 
//                  which determines whether the data on wbdata[] is written
//                  into the register file at stage 4. This occurs at the end
//                  of the cycle. Note that stage 4 (writeback) is never held
//                  up, so when wben is true on a particular cycle a writeback
//                  must take place regardless of anything else.
//                  This produced in stage 3 and takes into account delayed
//                  load writebacks, cancelled instructions, and instructions
//                  which are not to be executed due to the CC result being
//                  false, amongst other things.
//
//======================== Outputs from this block ========================--
// 
// x1data[]         U Extension Source 1 Data. This is the source 1 data for
//                  alternatives not supported by coreregs and the extension
//                  registers have been enabled in extutil.v. It is
//                  forwarded to cr_int, if a match is found for address
//                  s1a[5:0].
//
// x2data_2_pc[31:0]
//                  U Extension Source 1 Data for program counter.
//                  Normally this will be identical to x1data[31:0]. It was
//                  required to prevent the slow write-through data from
//                  being used for Jcc [Rn] or JLcc [Rn]. Hence when such
//                  an extension exists, the x1data[] bus gets the stored
//                  register value or the writethrough data, but this
//                  signal only gets the stored register data, and a stall
//                  is generated if a writethrough would otherwise be
//                  required.
//
// x2data[]         U Extension Source 2 Data. This is the source 2 data for
//                  alternatives not supported by coreregs and the extension
//                  registers have been enabled in extutil.v. It is
//                  forwarded to cr_int, if a match is found for address
//                  s2a[5:0].
// 
//==========================================================================--
//
module xcoreregs (clk,
                  rst_a,
                  p2minoropcode,  
                  p2opcode,
                  p2subopcode,
                  p2subopcode3_r,
                  p2subopcode4_r,
                  p2subopcode5_r,
                  p2subopcode6_r,
                  p2subopcode7_r,
                  lmulres_r,
                  s1a,
                  s2a,
                  wba,
                  wbdata,
                  wben,
                  ux2data_2_pc,
                  ux1data,
                  ux2data,

                  x2data_2_pc,
                  x1data,
                  x2data);

`include "arcutil_pkg_defines.v" 
`include "arcutil.v"         
`include "extutil.v"         
`include "xdefs.v"       
// Extra include files required for extensions are inserted here.

   input          clk;  //  system clock
   input          rst_a; //  system reset
   input   [5:0]  p2minoropcode; 
   input   [4:0]  p2opcode; 
   input   [5:0]  p2subopcode; 
   input   [2:0]  p2subopcode3_r; 
   input          p2subopcode4_r; 
   input   [1:0]  p2subopcode5_r; 
   input   [2:0]  p2subopcode6_r; 
   input   [1:0]  p2subopcode7_r; 
//      <add extra signals as appropriate>
//
//  Signals required for extensions are inserted here. The automatic
//  hierarchy generation system can be used to create the structural
//  HDL to tie all the components together, provided that certain
//  naming and usage rules are followed. Please see the document
//  'Automatic Hierarchy Generator' - $ARCHOME/arc/docs/hiergen.pdf
// 

   input   [63:0] lmulres_r; 
   input   [5:0]  s1a; 
   input   [5:0]  s2a; 
   input   [5:0]  wba; 
   input   [31:0] wbdata; 
   input          wben;
   input   [31:0] ux2data_2_pc;
   input   [31:0] ux1data;
   input   [31:0] ux2data;
   
//      <add extra signals as appropriate>
//
//  Signals required for extensions are inserted here. The automatic
//  hierarchy generation system can be used to create the structural
//  HDL to tie all the components together, provided that certain
//  naming and usage rules are followed. Please see the document
//  'Automatic Hierarchy Generator' - $ARCHOME/arc/docs/hiergen.pdf
// 
   output  [31:0] x2data_2_pc; 
   output  [31:0] x1data; 
   output  [31:0] x2data; 

   reg     [31:0] x2data_2_pc;
   reg     [31:0] x1data; 
   reg     [31:0] x2data; 

// Signal declarations for extensions to be added.


// =========================== Ext. Register Logic ==========================--
// 
//  This section of the file is for adding core register extensions to which 
//  you can write to or for some other purpose.
// 
//  For Example, an extension core register, i.e. ext_write_register, at
//  address 56 (more usually defined in xdefs.v with a meaningful name),
//  would be written to in the following manner.
// 
// always @(posedge clk_debug or posedge rst_a)
//    begin : clocked_PROC
//    if (rst_a == 1'b 1)
//       begin
//       ext_write_register <= 1'b 0;   
//       end
// 
//    else
//       begin
// 
//       //  Write can only take place when the enable is true.
//       // 
//       if (wben == 1'b 0 & wba == 6'b 111000)
//          begin
//          ext_write_register <= wbdata;   
//          end
//       end
//    end
//
// Miscellaneous extension logic functions are inserted here.

// ===================  Core register result selection ===================--
// 
// The data from the extension core registers is selected using a
// multiplexer which uses the s1a (s2a) field as the index. Hence, a
// matching address for either of address busses will set the appropriate
// value on the x1data (or x2data) bus.
// 
// The x1data/x2data values are passed to the ALU (stage 3) via the cr_int.v 
// module. 
// 
// An example which has an extension core register address
// "one_ext_core_addr" linked to a value generated by the ALU would
// necessitate a declaration of the signal in the PORT description, i.e. 
// alu_register_value. This would normally be a 32-bit wide bus, though any 
// bus width can be defined as long as only 32-bits are passed to
// x1data/x2data.
// 
//
// Core register result selection for extension source 1 field which is used
// for any jump indirect through a register.
//
// e.g Jcc  [Rn]    where cc is a condition code
//     JLcc [Rn]    instructions with .f are included
//                  all delay slot modes are included 
//
// Normally, this signal should get the exact same data as x1data. The only
// exception to this rule would be where the extensions designer has found
// that a problem exists with late-arriving data on x1data which may cause
// a static timing path such as:
//
//  (some logic) -> x1data -> next_pc -> icache RAM
//
// x1data goes to two places:
//
//  1. Through the reg read multiplexers to the flip-flop at the end of the
//     stage. (shorter path)
//
//  2. To the jump instruction (the only instruction to use register data at
//     stage 2). The jump-through-a-register path essentially adds more
//     levels of muxing in order to create the next_pc signal - which then
//     typically goes onto a RAM cell which is likely to have a larger setup
//     time than a regular flip-flop. (longer path)
// 
// The x2data_2_pc signal gives the extension designer the opportunity to
// supply the late-arriving register data onto the x1data signal, and to
// supply different data onto x2data_2_pc - typically this would be a
// latched copy of the late arriving data with shorter static timing path.
//
// A stall would have to be generated to hold the Jump until the x1data
// register bus contains the correct value. This stall would typically
// detect that a jump indirect (Jcc [Rn]) was using an affected extensions
// core register (where x1data and x2data_2_pc signal differ).
//
// If you are unsure, make x2data_2_pc the same as x1data under all
// conditions, and everything will be fine - this is the normal case!
//
always @(s2a or ux2data_2_pc
         or lmulres_r
        )
   begin : x2data_2_pc_async_PROC
   case (s2a) 

//
//  Example : one_ext_core_addr: x2data_2_pc = alu_register_value;
//
//Extension core register address decodes inserted here
   RMLO:  x2data_2_pc = lmulres_r[31:0];        
   rmmid: x2data_2_pc = lmulres_r[47:16];        
   RMHI:  x2data_2_pc = lmulres_r[63:32];        

   default:
      begin
      x2data_2_pc = ux2data_2_pc;  
      end
   endcase
   end

    
// Core register result selection for extension source 1 field
//
always @(s1a or ux1data
         or lmulres_r
        )
   begin : x1data_async_PROC
   case (s1a) 

//
//  Example : one_ext_core_addr: x1data = alu_register_value;
//
//Extension core register address decodes inserted here
   RMLO:
      begin
      x1data = lmulres_r[31:0];        
      end
   rmmid:
      begin
      x1data = lmulres_r[47:16];        
      end
   RMHI:
      begin
      x1data = lmulres_r[63:32];        
      end
   default:
      begin
      x1data = ux1data;    
      end
   endcase
   end

//Core register result selection for extension source 2 field
//
always @(s2a or ux2data
         or lmulres_r
        )
   begin : x2data_async_PROC
   case (s2a) 

//
//  Example : one_ext_core_addr: x2data = alu_register_value;
//
//Extension core register address decodes inserted here
   RMLO:
      begin
      x2data = lmulres_r[31:0];        
      end
   rmmid:
      begin
      x2data = lmulres_r[47:16];        
      end
   RMHI:
      begin
      x2data = lmulres_r[63:32];        
      end
   default:
      begin
      x2data = ux2data;    
      end
   endcase
   end


endmodule // module xcoreregs

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This module is a 3-port memory (2 read ports/1 write port)
// implemented using flip-flops. It is used as the core register
// file. This module can be used both for synthesis and simulation.
// It can be replaced with a vendor specific RAM.
//
// In the ARChitect configuration tool you can select different 
// implementations of the core register file. Depending on the
// selected type of core register this module is used differently:
// 
//  [1] If a 3 port flip-flop implementation is selected then this
//      module is synthesised.
// 
//  [2] If a 3 port RAM cell implementation is selected then this
//      module is not synthesised. Instead the zero-area RAM model 
//      (with the same name as this module, i.e. regfile_3p) in 
//      arc_rams.db is used.
// 
// This module is only used for 3-port core register files. It is 
// always used as a simulation model independently of whether a 3
// port flip-flop implementation or a RAM cell has been selected.
//
//
module regfile_3p (clk,
                   address_a,
                   address_b,
                   address_w,
                   wr_data,
                   we,
                   ck_en_w,
                   ck_en_a,
                   ck_en_b,

                   rd_data_a,
                   rd_data_b);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "asmutil.v"
`include "extutil.v"

input   clk; 
input   [4:0] address_a; 
input   [4:0] address_b; 
input   [4:0] address_w; 
input   [31:0] wr_data; 
input   we; 
input   ck_en_w; 
input   ck_en_a; 
input   ck_en_b; 

output  [31:0] rd_data_a; 
output  [31:0] rd_data_b;

reg     [31:0] rd_data_a; 
reg     [31:0] rd_data_b; 

reg     [31:0] regfile_mem_0_r; 
reg     [31:0] regfile_mem_1_r; 
reg     [31:0] regfile_mem_2_r; 
reg     [31:0] regfile_mem_3_r; 
reg     [31:0] regfile_mem_10_r; 
reg     [31:0] regfile_mem_11_r; 
reg     [31:0] regfile_mem_12_r; 
reg     [31:0] regfile_mem_13_r; 
reg     [31:0] regfile_mem_14_r; 
reg     [31:0] regfile_mem_15_r; 
reg     [31:0] regfile_mem_26_r; 
reg     [31:0] regfile_mem_27_r; 
reg     [31:0] regfile_mem_28_r; 
reg     [31:0] regfile_mem_29_r; 
reg     [31:0] regfile_mem_30_r; 
reg     [31:0] regfile_mem_31_r; 
reg     regfile_init; 
reg     [4:0] address_a_r; 
reg     [4:0] address_b_r; 

//synopsys translate_off

initial 
   begin
   regfile_init = `true;    
   end
   
//synopsys translate_on

always @(posedge clk)
   begin : reg_3p_sync_PROC

//synopsys translate_off

   if (regfile_init)
      begin

      //  If the switch is set, initialise the RAM to bits = 0.
      //  This will cut down on 'X' warnings.
      // 
         regfile_mem_0_r <= {32{1'b 0}};  
         regfile_mem_1_r <= {32{1'b 0}};  
         regfile_mem_2_r <= {32{1'b 0}};  
         regfile_mem_3_r <= {32{1'b 0}};  
         regfile_mem_10_r <= {32{1'b 0}};  
         regfile_mem_11_r <= {32{1'b 0}};  
         regfile_mem_12_r <= {32{1'b 0}};  
         regfile_mem_13_r <= {32{1'b 0}};  
         regfile_mem_14_r <= {32{1'b 0}};  
         regfile_mem_15_r <= {32{1'b 0}};  
         regfile_mem_26_r <= {32{1'b 0}};  
         regfile_mem_27_r <= {32{1'b 0}};  
         regfile_mem_28_r <= {32{1'b 0}};  
         regfile_mem_29_r <= {32{1'b 0}};  
         regfile_mem_30_r <= {32{1'b 0}};  
         regfile_mem_31_r <= {32{1'b 0}};  

      regfile_init = `false;    
      end

//synopsys translate_on

   //  Synchronous RAM model
   // 
        // Latch the addresses and enables from stage 1:
        if (ck_en_a == REGFILE_CK_EN_ACTIVE)
        begin
            address_a_r <= address_a; 
        end
        
        if (ck_en_b == REGFILE_CK_EN_ACTIVE)
        begin
            address_b_r <= address_b; 
        end
      
      //  Check that the write and address signals are valid on the clock edge
      // 
//synopsys translate_off
      if (! ( chk_bit(we)))
          begin
          $write("error: ");
          $write("3p RAM we = X at simulation time");
          $write("%b", time2str_f($time));
          $write("ns");
          $display();
          $display("Time: ", $time);
          end

      if (! ( chk_vec_4_0(address_a)))
          begin
          $write("warning: ");
          $write("3p RAM address_a = X at simulation time");
          $write("%b", time2str_f($time));
          $write("ns");
          $display();
          $display("Time: ", $time);
          end

      if (! ( chk_vec_4_0(address_b)))
          begin
          $write("warning: ");
          $write("3p RAM address_b = X at simulation time");
          $write("%b", time2str_f($time));
          $write("ns");
          $display();
          $display("Time: ", $time);
          end

      if (! ( chk_vec_4_0(address_w)))
          begin
          $write("warning: ");
          $write("3p RAM address_w = X at simulation time");
          $write("%b", time2str_f($time));
          $write("ns");
          $display();
          $display("Time: ", $time);
          end
//synopsys translate_on

      //  Write Port
      // 
      if (ck_en_w == REGFILE_CK_EN_ACTIVE)
         begin

         //  Store data into memory and write through to the output
         //   
         if (we == REGFILE_WR_ACTIVE)
            begin
               case (address_w)
                   5'b00000:  regfile_mem_0_r <= wr_data[31:0];
                   5'b00001:  regfile_mem_1_r <= wr_data[31:0];
                   5'b00010:  regfile_mem_2_r <= wr_data[31:0];
                   5'b00011:  regfile_mem_3_r <= wr_data[31:0];
                   5'b01010:  regfile_mem_10_r <= wr_data[31:0];
                   5'b01011:  regfile_mem_11_r <= wr_data[31:0];
                   5'b01100:  regfile_mem_12_r <= wr_data[31:0];
                   5'b01101:  regfile_mem_13_r <= wr_data[31:0];
                   5'b01110:  regfile_mem_14_r <= wr_data[31:0];
                   5'b01111:  regfile_mem_15_r <= wr_data[31:0];
                   5'b11010:  regfile_mem_26_r <= wr_data[31:0];
                   5'b11011:  regfile_mem_27_r <= wr_data[31:0];
                   5'b11100:  regfile_mem_28_r <= wr_data[31:0];
                   5'b11101:  regfile_mem_29_r <= wr_data[31:0];
                   5'b11110:  regfile_mem_30_r <= wr_data[31:0];
                   5'b11111:  regfile_mem_31_r <= wr_data[31:0];
                endcase

            //  Check written data is valid
            // 

//synopsys translate_off

            if (! (chk_vec_31_0(wr_data)))
                begin
                $write("error: ");
                $write("3p RAM wr_data = X at simulation time");
                $write("%b", time2str_f($time));
                $write("ns");
                $display();
                $display("Time: ", $time);
                end

//synopsys translate_on

            end  // if (we == REGFILE_WR_ACTIVE)
       end  // if (ck_en_w)
   end   // always block


// Read Port A

always @(address_a_r
or regfile_mem_0_r or regfile_mem_1_r or regfile_mem_2_r or regfile_mem_3_r
or regfile_mem_10_r or regfile_mem_11_r or regfile_mem_12_r or regfile_mem_13_r
or regfile_mem_14_r or regfile_mem_15_r
or regfile_mem_26_r or regfile_mem_27_r
or regfile_mem_28_r or regfile_mem_29_r or regfile_mem_30_r or regfile_mem_31_r)
begin : read_porta_async_PROC

         case (address_a_r)
             5'b00000:  rd_data_a = regfile_mem_0_r;
             5'b00001:  rd_data_a = regfile_mem_1_r;
             5'b00010:  rd_data_a = regfile_mem_2_r;
             5'b00011:  rd_data_a = regfile_mem_3_r;
             5'b01010:  rd_data_a = regfile_mem_10_r;
             5'b01011:  rd_data_a = regfile_mem_11_r;
             5'b01100:  rd_data_a = regfile_mem_12_r;
             5'b01101:  rd_data_a = regfile_mem_13_r;
             5'b01110:  rd_data_a = regfile_mem_14_r;
             5'b01111:  rd_data_a = regfile_mem_15_r;
             5'b11010:  rd_data_a = regfile_mem_26_r;
             5'b11011:  rd_data_a = regfile_mem_27_r;
             5'b11100:  rd_data_a = regfile_mem_28_r;
             5'b11101:  rd_data_a = regfile_mem_29_r;
             5'b11110:  rd_data_a = regfile_mem_30_r;
             5'b11111:  rd_data_a = regfile_mem_31_r;
             default:   rd_data_a = 32'h00000000;
         endcase
end

// Read Port B

always @(address_b_r
or regfile_mem_0_r or regfile_mem_1_r or regfile_mem_2_r or regfile_mem_3_r
or regfile_mem_10_r or regfile_mem_11_r or regfile_mem_12_r or regfile_mem_13_r
or regfile_mem_14_r or regfile_mem_15_r
or regfile_mem_26_r or regfile_mem_27_r
or regfile_mem_28_r or regfile_mem_29_r or regfile_mem_30_r or regfile_mem_31_r)
begin : read_portb_async_PROC

         case (address_b_r)
             5'b00000:  rd_data_b = regfile_mem_0_r;
             5'b00001:  rd_data_b = regfile_mem_1_r;
             5'b00010:  rd_data_b = regfile_mem_2_r;
             5'b00011:  rd_data_b = regfile_mem_3_r;
             5'b01010:  rd_data_b = regfile_mem_10_r;
             5'b01011:  rd_data_b = regfile_mem_11_r;
             5'b01100:  rd_data_b = regfile_mem_12_r;
             5'b01101:  rd_data_b = regfile_mem_13_r;
             5'b01110:  rd_data_b = regfile_mem_14_r;
             5'b01111:  rd_data_b = regfile_mem_15_r;
             5'b11010:  rd_data_b = regfile_mem_26_r;
             5'b11011:  rd_data_b = regfile_mem_27_r;
             5'b11100:  rd_data_b = regfile_mem_28_r;
             5'b11101:  rd_data_b = regfile_mem_29_r;
             5'b11110:  rd_data_b = regfile_mem_30_r;
             5'b11111:  rd_data_b = regfile_mem_31_r;
             default:   rd_data_b = 32'h00000000;
         endcase
end

endmodule 

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This wrap file contains the core register memory. The memory is 
// implemented as either a RAM or as flip-flops depending on the 
// selected ARChitect configuration (for more info read the comments in
// conjunction with the memory instantiation at the end of this file).
//                
// The instantiated memory is a synchronous 32x32 three-port RAM, with
// writethrough. On the rising (active) clock edge, the three 
// addresses, write data and the write control signal are latched in. 
// Data appears on the outputs some time later. Write-through reads 
// have longer access times.
//
//======================= Inputs to this block =======================--
// 
//  clk              Rising-edge master clock.
// 
//  ck_en_a          Clock enable - Port A
//  ck_en_b          Clock enable - Port B
//  ck_en_w          Clock enable - Write Port
//  s3p_we           Active-high write enable
//  s3p_aw[4:0]      Write address
//  s3p_ara[4:0]     Read address - Port A
//  s3p_arb[4:0]     Read address - Port B
//  wbdata[31:0]     Write data in
//
//====================== Output from this block ======================--
//
//  s3p_qa[31:0]     Read data    - Port A
//  s3p_qb[31:0]     Read data    - Port B
//
//====================================================================--
//

module regfile_3p_wrap (clk,
                        s3p_aw,
                        s3p_ara,
                        s3p_arb,
                        wbdata,
                        s3p_we,
                        ck_en_w,
                        ck_en_a,
                        ck_en_b,

                        s3p_qa,
                        s3p_qb);

`include "arcutil.v"

input   clk; 
input   [4:0] s3p_aw; 
input   [4:0] s3p_ara; 
input   [4:0] s3p_arb; 
input   [31:0] wbdata; 
input   s3p_we; 
input   ck_en_w; 
input   ck_en_a; 
input   ck_en_b; 

output  [31:0] s3p_qa; 
output  [31:0] s3p_qb; 

wire    [31:0] s3p_qa; 
wire    [31:0] s3p_qb; 

wire    [4:0] i_address_a; 
wire    [4:0] i_address_b; 
wire    [4:0] i_address_w; 

wire    [31:0] i_wr_data; 
wire    [31:0] i_rd_data_a; 
wire    [31:0] i_rd_data_b; 

`ifdef FAKE_RAMS
`else
wire        [4:0] i_raddr_a;
wire        [4:0] i_raddr_b;
wire        [4:0] i_raddr_w;
reg        i_zero_a;
reg        i_zero_b;
`endif

`ifdef FAKE_RAMS
`else
// Store top bit of translated address
// - used to provide zero result for non-existent registers
// 
always @(posedge clk)
 begin : zero_proc
   i_zero_a <= i_raddr_a[4];
   i_zero_b <= i_raddr_b[4];
 end

// For FPGA builds, to avoid conflicts, avoid having the RD and WR addresses being the same.
assign i_raddr_a = rf_addr(s3p_ara);
assign i_raddr_b = rf_addr(s3p_arb);
assign i_raddr_w = rf_addr(s3p_aw);
assign i_address_a = (i_raddr_a[3:0] == i_raddr_w[3:0] && s3p_we == 1'b1) ? (i_raddr_w[3:0] + 1'b1) : i_raddr_a[3:0];
assign i_address_b = (i_raddr_b[3:0] == i_raddr_w[3:0] && s3p_we == 1'b1) ? (i_raddr_w[3:0] + 1'b1) : i_raddr_b[3:0];
assign i_address_w = i_raddr_w[3:0];
`endif

assign i_wr_data = wbdata; 

`ifdef FAKE_RAMS
assign s3p_qa = i_rd_data_a; 
assign s3p_qb = i_rd_data_b; 
`else
assign s3p_qa      = i_zero_a == 1'b1 ? 32'h00000000 : i_rd_data_a; 
assign s3p_qb      = i_zero_b == 1'b1 ? 32'h00000000 : i_rd_data_b; 
`endif

//  Memory instantiation
// 
//  This is memory is implemented using flip-flops. It can be used 
//  both for synthesis and simulation. It can be replaced with a 
//  vendor specific RAM.
// 
//  In the ARChitect configuration tool you can select different 
//  implementations of the core register file. Depending on the 
//  selected type of core register this instantiated memory is used 
//  differently:
// 
//   [1] If a 3 port flip-flop implementation is selected then this
//       module is synthesised.
// 
//   [2] If a 3 port RAM cell implementation is selected then this
//       module is not synthesised. Instead the zero-area RAM model 
//       (with the same name as this module, i.e. regfile_3p) in 
//       arc_rams.db is used.
// 
//  This module is only used for 3-port core register files. It is 
//  always used as a simulation model independently of whether a 
//  3 port flip-flop implementation or a RAM cell has been selected.
// 
//  Note that if a 3 port RAM cell has been selected the RAM model
//  used will have:
// 
//       * No capacitance
//       * Infinite drive capacity
// 
//   ..and writethrough is not modelled in the Synopsys timing model.
// 
//  and hence timings should be taken with a pinch of salt.
// 
//  The clock enables signals turns off the RAM ports when not in use
//  to save power. Depending on technology this may cause time delays
//  on the critical path. If this is the case and this is not 
//  acceptable, just don't connect these signal to the instantiation
//  of the real RAM.
// 
//  If the clock enables and write enables of the vendor RAM are not 
//  active low as they are for for this model, do not insert an 
//  inverter! Instead change the related constants in extutil.v.
//


regfile_3p U_regfile_3p (
          .clk(clk),
          .address_a(s3p_ara),
          .address_b(s3p_arb),
          .address_w(s3p_aw),
          .wr_data(i_wr_data),
          .we(s3p_we),
          .ck_en_w(ck_en_w),
          .ck_en_a(ck_en_a),
          .ck_en_b(ck_en_b),

          .rd_data_a(i_rd_data_a),
          .rd_data_b(i_rd_data_b));


endmodule

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains logic that decrements a 32-bit value by one.
//
module dec32 (a,
              q);

`include "arcutil_pkg_defines.v"
`include "arcutil.v" 

input   [LOOPCNT_MSB:0] a; 
output  [LOOPCNT_MSB:0] q; 
wire    [LOOPCNT_MSB:0] q; 

assign q = a - 1; 

endmodule // module dec32

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1998-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains logic that allows the processor to perform a zero
// overhead loop.
//
//======================= Inputs to this block =======================--
//
// clk              Global Clock.
//  
// rst_a            Global Reset (active high).
//
//
// loopcount_hit_a  From cr_int. Set true when a register write to the
//                  loopcount register is required. Decoded from wba
//                  and wben, and hence takes into account delayed load
//                  writes and host writes.
//
// loopend_hit_a    From cr_int. This signal is set true when
//                  i_pc_plus_inst_len points to the loop end address.
//                  It is used in conjuction with a number of other
//                  signals to decrement the loop counter.
//
// p2int            This signal indicates that an interrupt jump
//                  instruction (fantasy instruction) is currently in
//                  stage 2. This signal has a number of consequences
//                  throughout the system, causing the interrupt vector
//                  (int_vec[31:1]) to be put into the PC, and causing
//                  the old PC to be placed into the pipeline in order
//                  to be stored into the appropriate interrupt link
//                  register.
//                  Note that p2int and p2iv are mutually exclusive.
//                  Used here to prevent the loopcounter from being
//                  updated if a loop-end instruction is interrupted.
//                  (Note that pcen is true when p2int = '1', in order
//                  to load the interrupt vector).
//
// p2killnext_a     True when the instruction in stage 2 is a branch
//                  /jump type operation which will kill the following
//                  delay slot instruction. The following operation will
//                  be marked invalid when it is passed from stage 1
//                  into stage 2.
//
// pcen_niv      ** Version of pcen without ivalid_aligned decode
//                  Comment for pcen:
//                  U Program counter enable. When this signal is true,
//                  the PC will change at the end of the cycle,
//                  indicating that the memory controller needs to do
//                  perform a fetch on the next cycle using the address
//                  which will appear on currentpc[], which is supplied
//                  from aux_regs.
//                  This signal is affected by interrupt logic and all
//                  the other pipeline stage enables.
//                  It is used here to ensure that the loopcount
//                  register is only decremented when the pc can be
//                  updated, hence taking stalls into account.
//
//====================== Output from this block ======================--
//
// loopcount_r      This is the 32-bit value, zero-extended from
//                  loopcount_msb. It is put onto the source register
//                  buses by coreregs at the appropriate times.
//
//====================================================================--
//
module loopcnt (clk, 
                rst_a, 
                aux_addr, 
                aux_dataw, 
                aux_write, 
                currentpc_r,
                en1, 
                en2, 
                kill_p1_nlp_a, 
                loopcount_hit_a, 
                p1int, 
                p2_lp_instr, 
                p2_target, 
                p2condtrue, 
                p2int, 
                p2iv, 
                p3result, 
                pc_is_linear_r, 
                pcen, 
                pcounter_jmp_restart_r, 

                loop_int_holdoff_a, 
                do_loop_a, 
                loop_kill_p1_a, 
                loopcount_r, 
                loopend_hit_a, 
                loopend_r,
                loopstart_r);

`include "arcutil_pkg_defines.v"
`include "arcutil.v" 
`include "extutil.v"

   input                     clk; 
   input                     rst_a; 
   input [31:0]              aux_addr; 
   input [31:0]              aux_dataw; 
   input                     aux_write; 
   input [PC_MSB:0]          currentpc_r; 
   input                     en1; 
   input                     en2; 
   input                     kill_p1_nlp_a; 
   input                     loopcount_hit_a; 
   input                     p1int; 
   input                     p2_lp_instr; 
   input [PC_MSB:0]          p2_target;
   input                     p2condtrue; 
   input                     p2int; 
   input                     p2iv; 
   input [31:0]              p3result; 
   input                     pc_is_linear_r; 
   input                     pcen; 
   input                     pcounter_jmp_restart_r; 

   output                    loop_int_holdoff_a; 
   output                    do_loop_a; 
   output                    loop_kill_p1_a; 
   output [LOOPCNT_MSB:0]    loopcount_r; 
   output                    loopend_hit_a; 
   output [PC_MSB:0]         loopend_r; 
   output [PC_MSB:0]         loopstart_r; 

   wire                      do_loop_a;
   wire                      loop_int_holdoff_a;
   wire                      loop_kill_p1_a;
   wire                      loopend_hit_a;
   wire [LOOPCNT_MSB:0]      loopcount_r;
   wire [PC_MSB:0]           loopend_r;
   wire [PC_MSB:0]           loopstart_r;
   
   
   reg [LOOPCNT_MSB:0]       i_lp_cnt_r; 
   reg [PC_MSB:0]     i_lp_end_r; 
   reg [PC_MSB:0]     i_lp_start_r;
   
   wire                      i_cpc_eq_lp_end_a; 
   wire                      i_cpc_eq_lpend_minus2_a; 
   wire                      i_cpc_eq_lpend_minus4_a; 
   wire                      i_do_loop_a; 
   wire                      i_last_lp_instr_32_nxt; 
   reg                       i_last_lp_instr_32_r; 
   wire                      i_ld_lp_end_a; 
   wire                      i_ld_lpstart_a; 
   wire                      i_lp_cnt_dec_a; 
   wire                      i_lp_cnt_ne_one_a; 
   wire                      i_lp_cnt_ne_zero_a; 
   wire                      i_lp_end_hit_a; 
   wire                      i_lp_instr_a; 
   wire                      i_lp_over_run_action_a; 
   wire                      i_lp_over_run_detect_a; 
   wire [LOOPCNT_MSB:0]      i_lp_cnt_minus_1_a; 
   wire [LOOPCNT_MSB:0]      i_lp_cnt_nxt; 
   wire [PC_MSB:0]         i_lp_end_minus_2_a; 
   wire [PC_MSB:0]         i_lp_end_minus_4_a; 
   wire [LOOPCNT_MSB:0]      i_one_a; 
   wire [LOOPCNT_MSB:0]      i_zero_a; 
   wire [PC_MSB:0]    i_lp_end_nxt; 
   wire [PC_MSB:0]    i_lp_start_nxt; 
   wire [PC_MSB:0]    i_lp_end_decr_2_a;   
   wire [PC_MSB:0]    i_lp_end_decr_4_a;   

      
//------------------------------------------------------------------------------
// Loop end  detection
//------------------------------------------------------------------------------

   // Case 1 : The last instruction in the loop is a 32-bit type
   //
   // First time around the loop the "i_lp_over_run_detect_a" will trigger  
   //
   // On the second and all subsquent interations when the PC is equal to
   // lpend-4 the loop will trigger.
   //
   // Case 2 : The last instruction in loop is 16-bit type
   //
   // The "i_last_lp_instr_32_r" will never be set in this case because
   // the "i_cpc_eq_lpend_minus2_a" signal will be true before the
   // "i_lp_over_run_detect_a" is triggered.
   
   assign i_lp_end_hit_a = (((i_cpc_eq_lpend_minus2_a == 1'b1) & 
                              (i_last_lp_instr_32_r == 1'b0)) 
                              | 
                             ((i_cpc_eq_lpend_minus4_a == 1'b1) & 
                              (i_last_lp_instr_32_r == 1'b1)) 
                              | 
                             (i_lp_over_run_detect_a == 1'b1)) ? 1'b1 : 1'b0;


   // The following logic is used to detect the end of loop when the last
   // instruction is a 32-bit type. This is used when both word aligned and
   // longword aligned loops are used.
   // On the first interation of the loop the loopend is hit using the
   // "i_cpc_eq_lp_end_a" signal.  However this section of code will be hit
   // again when the loop has finished, to prevent the loop from triggering
   // the "i_lp_cnt_ne_zero_a" is included because on the last interation the
   // loopcount will be zero. We also need to make sure that the pc has arived
   // at the loopend linearly. The "pc_is_linear_r" signal is cleared on all
   // host writes to the PC and control instrucution to prevent this from
   // happening.
   //
   assign  i_cpc_eq_lp_end_a = (currentpc_r[PC_MSB:PC_LSB] == i_lp_end_r) ?
           1'b1 : 
           1'b0 ; 
      
   // There is a loop over run when :
   //
   // [1] The end of the loop is detected in stage 2.
   //
   // [2] The loop count value is not zero.
   //
   // [3] The program counter has moved lineraly from it's last address to the
   //     courrent address.  This signal is also cleared when a host access has
   //     modified the program counter
   //
   assign  i_lp_over_run_detect_a = (i_cpc_eq_lp_end_a &
                                     i_lp_cnt_ne_zero_a & 
                                     pc_is_linear_r);
   
   // An action is taken when a loop over run is detected when :
   //
   // [1] There is a loop over run.
   //
   // [2] The loop count value is not zero.
   //
   // [3] The instruction in stage 2 is not an interrupt.
   //
   // [4] There is no control transfer instruction to be resolved when the
   //     instruction cache cannot accept another fetch request.
   //
   assign  i_lp_over_run_action_a = (i_lp_over_run_detect_a &
                                     i_lp_cnt_ne_one_a &
                                    (~p2int) &
                                    (~pcounter_jmp_restart_r)) ;
 
 

   assign i_last_lp_instr_32_nxt = ((i_lp_instr_a | i_ld_lp_end_a) ==
                                       1'b1) ?
          1'b0 : 
                                      ((i_lp_over_run_action_a & en1) ==
                                       1'b1) ?
          1'b1 : 
          i_last_lp_instr_32_r ;
   
   always @(posedge clk or posedge rst_a)
   begin : lst_instr_32_sync_PROC
      if (rst_a == 1'b1)
         i_last_lp_instr_32_r <= 1'b0 ; 
      else
         i_last_lp_instr_32_r <= i_last_lp_instr_32_nxt ; 
   end 

   
   // Do a loop iteration when we have reached the end, if the count
   // value is not one. 
   //
   // [1] The end of the loop is detected.
   //
   // [2] The instruction in stage 1 is not killed (does not include loop
   //     overrun kill).
   //
   // [3] There are no interrupts in stage 1 or 2.
   //
   // [4] The loop count value is not equal to one.
   //
   assign i_do_loop_a = i_lp_end_hit_a         & 
                       (~kill_p1_nlp_a)          & 
                       (~(p1int | p2int))        &
                       (~pcounter_jmp_restart_r) & 
                        i_lp_cnt_ne_one_a ; 

//------------------------------------------------------------------------------
//  LOOP COUNT
//------------------------------------------------------------------------------

   // The loop is decremented when:
   //
   // [1] The end of the loop is detected.
   //
   // [2] The loop is not to be killed in stage 1 due to loop over-run.
   //
   // [3] There are no interrupts in stage 1 or 2.
   //
   // [4] There is no control transfer instruction to be resolved when the
   //     instruction cache cannot accept another fetch request.
   //
   // [5] The program counter is enabled.
   //
   assign i_lp_cnt_dec_a = (i_lp_end_hit_a         & 
                           (~kill_p1_nlp_a)          & 
                           (~(p1int | p2int))        & 
                           (~pcounter_jmp_restart_r) & 
                            pcen) ;
 
   // Generate value to be latched into the loop counter at the end of
   // the cycle.
   //
   // Note that if the lpcnt register is being written at the same
   // time as a loop is trying to decrement the counter, then the
   // register write will win, and the decremented counter value will be
   // ignored.
   //
   assign i_lp_cnt_nxt = (loopcount_hit_a == 1'b1) ? p3result : 
                                 (i_lp_cnt_dec_a ==  1'b1) ? i_lp_cnt_minus_1_a : 
          i_lp_cnt_r ; 

   // Latch the next value into the loop counter.
   //
   always @(posedge clk or posedge rst_a)
   begin : loopcnt_sync_PROC
      if (rst_a == 1'b1)
         i_lp_cnt_r <= {(THIRTY_TWO){1'b0}} ; 
      else
         i_lp_cnt_r <= i_lp_cnt_nxt ; 
   end 

   // Set lpcnt_eq_one true when the result is equal to one.
   //
   assign i_one_a = {{(THIRTY_ONE){1'b0}}, 1'b 1} ;
   
   assign i_lp_cnt_ne_one_a = (i_lp_cnt_r != i_one_a) ? 1'b1 : 1'b0 ;
 
   assign i_zero_a = {(THIRTY_TWO){1'b0}} ; 

   assign i_lp_cnt_ne_zero_a = (i_lp_cnt_r != i_zero_a) ? 1'b1 : 1'b0 ;
   
//=============================== Decrementer ================================--
//
   // Generate the decremented lpcnt value.
   //
   // 
   dec32 U_dec32 (.a (i_lp_cnt_r),
                  .q (i_lp_cnt_minus_1_a));
   
   // When a loop instruction is in stage 2 and the condition is true,
   // and stage 2 is being allowed to complete, the loopstart_r and
   // loopend_r registers are loaded.
   //
   assign i_lp_instr_a = (p2_lp_instr & p2condtrue & p2iv & en2) ;
   
   // The loopstart_r & loopend_r registers can alos be loaded by the ARC
   // (SR) or by the host.
   //   
   assign i_ld_lpstart_a = auxdc(aux_addr, AX_LSTART_N) & aux_write ;
   
   assign i_ld_lp_end_a = auxdc(aux_addr, AX_LEND_N) & aux_write ;
   
   // The loop start value comes either from currentpc_r (the instruction 
   // immmediately following the loop instruction) or via the auxiliary
   // register bus from either the SR instruction or from the host.
   // The loop end value comes either from target[31:1] (the destination
   // of the branch implied within the loop instruction, or from the
   // auxiliary register bus as for loopstart_r
   //
   // ** Note that for loopstart_r & loopend_r the address is taken from
   //    31:0 of the auxiliary  write data, in the same way as the PC is
   //    loaded by the host and by the Jcc instruction **
   //
   assign i_lp_start_nxt = (i_lp_instr_a == 1'b1) ? 
                                                    currentpc_r[PC_MSB:PC_LSB] :
                           (i_ld_lpstart_a == 1'b1) ? 
                            aux_dataw[PC_MSB:PC_LSB] :
          i_lp_start_r ;
   
   assign i_lp_end_nxt = (i_lp_instr_a == 1'b1) ? 
                                                   p2_target[PC_MSB:PC_LSB] :
                         (i_ld_lp_end_a == 1'b1) ? aux_dataw[PC_MSB:PC_LSB] : 
          i_lp_end_r ; 

   // The actual registers themselves --
   //
   always @(posedge clk or posedge rst_a)
   begin : loop_addr_sync_PROC
      if (rst_a == 1'b1)
      begin
         i_lp_start_r <= `THIRTY_ONE_ZEROS ; 
         i_lp_end_r   <= `THIRTY_ONE_ZEROS ; 
      end
      else
      begin
         i_lp_start_r <= i_lp_start_nxt ; 
         i_lp_end_r   <= i_lp_end_nxt ; 
      end 
   end // block: loop_addr_sync_PROC
   
   // Decrementers  
   assign i_lp_end_decr_2_a  = i_lp_end_r - `LOOPWORD_ONE;
   assign i_lp_end_decr_4_a  = i_lp_end_r - `LOOPWORD_TWO;
   assign i_lp_end_minus_2_a = {i_lp_end_decr_2_a, 1'b0} ;
   assign i_lp_end_minus_4_a = {i_lp_end_decr_4_a, 1'b0} ;

   assign i_cpc_eq_lpend_minus2_a = (currentpc_r == i_lp_end_minus_2_a) ?
          1'b 1 :
          1'b 0 ;
 
   assign i_cpc_eq_lpend_minus4_a = (currentpc_r == i_lp_end_minus_4_a) ?
          1'b 1 : 
          1'b 0 ;
   
   
   //============================ Output Drives =============================--
   //
   assign do_loop_a = i_do_loop_a ; 
   assign loop_kill_p1_a = i_lp_over_run_action_a;
   assign loopcount_r = i_lp_cnt_r ; 
   assign loopend_hit_a = i_lp_end_hit_a ; 
   assign loopend_r = {i_lp_end_r, `ONE_ZERO} ; 
   assign loopstart_r = {i_lp_start_r, `ONE_ZERO} ; 
   assign loop_int_holdoff_a = i_lp_over_run_action_a ;
   
endmodule
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains logic for core register internals block. This
// module handles the selection of values to be placed onto the source
// 1 and source 2 datapaths at stage 2. It also includes register
// shortcut datapaths. Shortcut control logic is contained in the rctl
// block.
// 
//=========================== Inputs to this block ===========================--
//
// clk                               System Clock
// 
// rst_a                             System Reset (Active high)
//
// currentpc_r      [PC_MSB:0]       This is the latched value of the PC which
//                                   is currently being used by stage 1 to fetch
//                                   the next instruction. 
//
// drd              [31:0]           Returning load data from the memory system.
//
// en2b                              Pipeline stage 2B enable. When this signal
//                                   is true, the instruction in stage 2b can
//                                   pass into stage 3 at the end of the cycle.
//                                   When it is false, it will hold up stage 2B
//                                   as well as stage 2 and stage 1 (pcen).                
//
// last_pc_plus_len [PC_MSB:0]       This bus contains the registered (in to
//                                   stage2b) value of the program counter plus
//                                   the length of the current instruction.
//
// loopcount_r      [LOOPCNT_MSB:0]  The loop count register.
//
// mstore2b                          This signal indicates to the actionpoint
//                                   mechanism when selected there is a valid
//                                   store instruction in stage 2b. It is
//                                   produced from decode of p2b_opcode,
//                                   p2b_subopcode and the p2b_iv signal.             
//
// p2_iw_r          [INSTR_UBND:0]   Stage 2 instruction word.    
//
// p2_s1val_tmp_r   [DATAWORD_MSB:0] This bus is used in cr_int. This signal is
//                                   used to early generate some of the values
//                                   to be placed on the source 1 in the next.
//                                   stage. This has been done for static timing
//                                   reasons.
//
//
// p2b_abs_op       [1:0]            Indicates that the instruction in stage 2B
//                                   is an ABS.
//
// p2b_arithiv                       Indicates that the ALU operation in stage
//                                   2B will be an arithmetic operation (as
//                                   opposed to logical, say)          
//
// p2b_blcc_a                        True when stage 2B contains a valid branch
//                                   & link instruction.
//
// p2b_delay_slot                    Stage 2B instruction has a delay slot. This
//                                   signal is set true when the instruction in
//                                   stage 2B uses a delay slot.  This signal
//                                   does not have an information about the
//                                   delay slot instruction itself.       
//
// p2b_iv                            Stage 2B instruction valid. This signal is
//                                   set true when the current instruction is
//                                   valid, i.e. not killed and actual
//                                   instruction data              
//
// p2b_jlcc_a                        Stage 2B contains a jump & link or branch &
//                                   link instructionn.
//
// p2b_limm                          Stage 2B contains an instruction that uses
//                                   long immediate data.             
//
// p2b_lr                            Stage 2B has a valid LR instruction in it.               
//
// p2b_neg_op                        Indicates that the instruction in stage 2B
//                                   is an NEG.           
//
// p2b_not_op                        Indicates that the instruction in stage 2B
//                                   is an logical NOT operation.
//
// p2b_pc_r         [PC_MSB:0]       The program counter value for the
//                                   instruction in stage 2B.
//
// p2b_shift_by_one_a                Used by shifting arith instructions (e.g.
//                                   ADD1) and by shifting LD/ST instructions
//                                   (e.g. LD.AS).
//                                
// p2b_shift_by_two_a                Used by shifting arith instructions (e.g.
//                                   ADD1) and by shifting LD/ST instructions
//                                   (e.g. LD.AS).
//                                
// p2b_shift_by_three_a              Used by shifting arith instructions (e.g.
//                                   ADD1) and by shifting LD/ST instructions
//                                   (e.g. LD.AS).
//                                
// p2b_shift_by_zero_a               Used by shifting arith instructions (e.g.
//                                   ADD1) and by shifting LD/ST instructions
//                                   (e.g. LD.AS).
//
// p2b_shimm_data  [12:0]            This bus carries the short immediate data
//                                   encoded on the instruction word. It is used
//                                   by coreregs when one of the source (s1a/
//                                   fs2a) registers being referenced is one of.
//                                   the short immediate registers It always
//                                   provides the region of the instruction
//                                   where the short immediate data would be
//                                   found, regardless of whether short
//                                   immediate data is being used.
//                             
// p2b_shimm_s1_a                    Operand 1 requires the short immediate data
//                                   carried in p2b_shimm_data
//                             
// p2b_shimm_s2_a                    Operand 2 requires the short immediate data
//                                   carried in p2b_shimm_data
//
// p2bint                            From int_unit. This signal indicates that
//                                   an interrupt jump instruction (fantasy
//                                   instruction) is currently in stage 2B. This
//                                   signal has a number of consequences
//                                   throughout the system, causing the
//                                   interrupt vector (int_vec) to be put into
//                                   the PC, and causing the old PC to be placed
//                                   into the pipeline in order to be stored
//                                   into the appropriate interrupt link
//                                   register.
//                                   Note that p2bint and p2b_iv are mutually
//                                   exclusive.
//
// p3res_sc         [31:0]           Equivalent to p3result but excluding the
//                                   returning load (drd) component.
//
// qd_a             [31:0]           Register file output 1.  This is the
//                                   contents of register specified in source 1
//                                   register field.
//
// qd_b             [31:0]           Register file output 2.  This is the
//                                   contents of register specified in source 2
//                                   register field.
//
// s1a              [5:0]            Source 1 register address. This is the B
//                                   field from the instruction word, sent to
//                                   the core registers and the LSU. 
// 
// s1en                              This signal is used to indicate that the
//                                   instruction in pipeline stage 2 will use
//                                   the data from the register specified by 
//                                   s1a[5:0]. This signal includes p2iv as
//                                   part of its decode.
//
// s2a              [5:0]            Source 2 register address. This is the C
//                                   field from the instruction word. This field
//                                   is also used by the host to read values
//                                   from the registers. 
//
// s2en                              This signal is used to indicate that the
//                                   instruction in pipeline stage 2 will use
//                                   the data from the register specified by 
//                                   s2a[5:0]. This signal includes p2iv as part
//                                   of its decode.               
//
//
// sc_load1                          This signal is set true when data from a
//                                   returning load is required to be shortcut
//                                   onto the stage 2B source 1 result bus. If
//                                   the 4-port register file is implemented,
//                                   the data used for the shortcut comes direct
//                                   from the memory system, this requiring an
//                                   additional input into the shortcut
//                                   multiplexer. Extension core registers can
//                                   have shortcutting banned if x_p2nosc1 is
//                                   set true at the appropriate time. Includes
//                                   both p2b_iv and p3iv.
//                                  
// sc_load2                          This signal is set true when data from a
//                                   returning load is required to be shortcut
//                                   onto the stage 2B source 2B result bus. If
//                                   the 4-port register file is implemented,
//                                   the data used for the shortcut comes direct
//                                   from the memory system, this requiring an
//                                   additional input into the shortcut muxer
//                                   Extension core registers can have
//                                   shortcutting banned if x_p2nosc2 is set
//                                   true at the appropriate time. Includes both
//                                   p2b_iv and p3iv.
//
// sc_reg1                           This signal is produced by the pipeline
//                                   control unit rctl, and is set true when an
//                                   instruction in stage 3 is going to generate
//                                   a write to the register being read by
//                                   source 1 of the instruction in stage 2B.
//                                   This is a source 1 shortcut. It is used by
//                                   the core register module to switch the
//                                   stage 3 result bus onto the stage 2B source 
//                                   1 result. Extension core registers can have
//                                   shortcutting banned if x_p2nosc1 is set
//                                   true at the appropriate time. Includes both
//                                   p2b_iv and p3iv.
//                                  
// sc_reg2                           This signal is produced by the pipeline
//                                   control unit rctl, and is set true when an
//                                   instruction in stage 3 is going to generate
//                                   a write to the register being read by
//                                   source 2B of the instruction in stage 2B.
//                                   This is a source 1 shortcut. It is used by
//                                   the core register module to switch the
//                                   stage 3 result bus onto the stage 2B source
//                                   2 result. Extension core registers can have
//                                   shortcutting banned if x_p2nosc2 is set
//                                   true at the appropriate time. Includes both
//                                   p2b_iv and p3iv.
//                                  
// wba [5:0]                         This bus carries the address of the
//                                   register to which the data on wbdata[31:0]
//                                   is to be written at the end of the cycle if
//                                   wben is true. It is produced during stage 3
//                                   and takes account of delayed load register
//                                   writeback (taking a value from the LSU),
//                                   LD/ST address writeback  (address from the 
//                                   B or C field), and normal ALU operation
//                                   destination addresses (instruction A
//                                   field).
//                                  
// wben                              This signal is the enable signal which
//                                   determines whether the data on wbdata[31:0] 
//                                   is written into the register file at stage
//                                   4. It is produced in stage 3 and takes into 
//                                   account delayed load writebacks, cancelled
//                                   instructions, and instructions which are
//                                   not to be executed due to the cc result
//                                   being false, amongst other things.                 
//
// x1data             [31:0]         Extension Source 1 Data. This is the source
//                                   1 data for alternatives not supported by
//                                   coreregs and the extension registers have
//                                   been enabled in extutil. It is forwarded
//                                   to cr_int, if a match is found for address
//                                   s1a[5:0].
//
// x2data              [31:0]        Extension Source 2 Data. This is the source
//                                   2 data for alternatives not supported by
//                                   coreregs and the extension registers have
//                                   been enabled in extutil. It is forwarded to
//                                   cr_int, if a match is found for address
//                                   s2a[5:0].
//
// x_idecode2b                       From xrctl. This signal will be true when
//                                   the extension logic detects an extension
//                                   instruction in stage 2B and is produced
//                                   from p2b_opcode[4:0] and the sub-opcodes.          
//
//========================== Output from this block ==========================--
//
// dwr               [31:0]           Data value to be stored to memory. It is
//                                    latched stval from the ARC interface. The
//                                    value is latched when en2b = '1' ie. the
//                                    pipeline is not stalled.
//
// ext_s1val         [31:0]           Extension source 1 register.  This
//                                    register is loaded with the operand data
//                                    for extensions.  The value only changes
//                                    when a valid extension instruction is in
//                                    stage 2b.
//
// ext_s2val         [31:0]           Extension source 2 register.  This
//                                    register is loaded with the operand data
//                                    for extensions.  The value only changes
//                                    when a valid extension instruction is in
//                                    stage 2b.
//
// h_rr_data         [31:0]           Data to the host port from register reads.
//                                    Also allows the debugger to read
//                                    p1iw_aligned_a[] for cache testing. Does
//                                    not include any returning load data, or
//                                    shortcuts from stage three instructions.
//
// r_wben                             Indicates that a write is to take place on
//                                    this cycle using the address on wba[] and
//                                    the data supplied on wbdata[]. It is
//                                    slightly different from the master
//                                    writeback enable signal, wben, since it
//                                    only applies to register file (r0-r31)
//                                    writes.             
//
// s1bus             [31:0]           This is the source1 bus which contains
//                                    register data, immediates, etc and short-
//                                    cut info. A pre-latch version of s1val in
//                                    fact.
//
// s1val             [31:0]           Normal source 1 register. This register
//                                    is loaded with the operand data for
//                                    basecase operations. The value only
//                                    changes when a valid basecase instruction
//                                    is in stage 2b.
//
// s2bus             [31:0]           Next normal 2 source register value.
//
// s2val             [31:0]           Normal source 2 register.  This
//                                    register is loaded with the operand data
//                                    for basecase operations.  The value only
//                                    changes when a valid basecase instruction
//                                    is in stage 2b.
//
// s2val_inverted_r                   This signal when set indicates that the
//                                    value in the s2val register has been
//                                    inverted for the current operation.
//
// stval             [31:0]           Data value to be stored to memory.
// 
//============================================================================--
//

module cr_int ( clk,             // system clock
                rst_a,           // system reset
                currentpc_r,
                drd,
                en2b,
                loopcount_r,
                mstore2b,
                last_pc_plus_len,
                p2_iw_r,
                p2b_pc_r,
                p2_s1val_tmp_r,
                p2b_abs_op,
                p2b_alu_op,
                p2b_arithiv,
                p2b_delay_slot,
                p2b_iv,
                p2b_jlcc_a,
                p2b_blcc_a,
                p2b_limm,
                p2b_lr,
                p2b_neg_op,
                p2b_not_op,
                p2b_shift_by_one_a,
                p2b_shift_by_three_a,
                p2b_shift_by_two_a,
                p2b_shift_by_zero_a,
                p2b_shimm_data,
                p2b_shimm_s1_a,
                p2b_shimm_s2_a,
                p2bint,
                p3res_sc,
                qd_a,
                qd_b,
                s1a,
                s1en,
                s2a,
                s2en,
                sc_load1,
                sc_load2,
                sc_reg1,
                sc_reg2,
                wba,
                wben,
                x1data,
                x2data,
                x_idecode2b,

                dwr,
                ext_s1val,
                ext_s2val,
                h_rr_data,
                r_wben,
                s1bus,
                s1val,
                s2bus,
                s2val,
                s2val_inverted_r,
                stval
                );

`include "arcutil_pkg_defines.v"
`include "arcutil.v"

   input                     clk;                     //  system clock
   input                     rst_a;                   //  system reset
   input  [PC_MSB:0]         currentpc_r; 
   input  [31:0]             drd; 
   input                     en2b; 
   input  [LOOPCNT_MSB:0]    loopcount_r; 
   input                     mstore2b; 
   input  [PC_MSB:0]         last_pc_plus_len; 
   input  [INSTR_UBND:0]     p2_iw_r; 
   input  [PC_MSB:0]         p2b_pc_r; 
   input  [DATAWORD_MSB:0]   p2_s1val_tmp_r; 
   input                     p2b_abs_op; 
   input  [1:0]              p2b_alu_op; 
   input                     p2b_arithiv; 
   input                     p2b_delay_slot; 
   input                     p2b_iv; 
   input                     p2b_jlcc_a; 
   input                     p2b_blcc_a; 
   input                     p2b_limm; 
   input                     p2b_lr; 
   input                     p2b_neg_op; 
   input                     p2b_not_op; 
   input                     p2b_shift_by_one_a; 
   input                     p2b_shift_by_three_a; 
   input                     p2b_shift_by_two_a; 
   input                     p2b_shift_by_zero_a; 
   input  [12:0]             p2b_shimm_data; 
   input                     p2b_shimm_s1_a; 
   input                     p2b_shimm_s2_a; 
   input                     p2bint; 
   input  [31:0]             p3res_sc; 
   input  [31:0]             qd_a; 
   input  [31:0]             qd_b; 
   input  [5:0]              s1a; 
   input                     s1en; 
   input  [5:0]              s2a; 
   input                     s2en; 
   input                     sc_load1; 
   input                     sc_load2; 
   input                     sc_reg1; 
   input                     sc_reg2; 
   input  [5:0]              wba; 
   input                     wben; 
   input  [31:0]             x1data; 
   input  [31:0]             x2data; 
   input                     x_idecode2b; 
   
   output [31:0]             dwr; 
   output [31:0]             ext_s1val; 
   output [31:0]             ext_s2val; 
   output [31:0]             h_rr_data; 
   output                    r_wben; 
   output [31:0]             s1bus; 
   output [31:0]             s1val; 
   output [31:0]             s2bus; 
   output [31:0]             s2val; 
   output                    s2val_inverted_r; 
   output [31:0]             stval; 

   wire   [31:0]             dwr; 
   wire   [31:0]             ext_s1val; 
   wire   [31:0]             ext_s2val; 
   wire   [31:0]             h_rr_data; 
   wire                      r_wben; 
   wire   [31:0]             s1bus; 
   wire   [31:0]             s1val; 
   wire   [31:0]             s2bus; 
   wire   [31:0]             s2val; 
   wire                      s2val_inverted_r; 
   wire   [31:0]             stval; 

//------------------------------------------------------------------------------
//  Local signals
//------------------------------------------------------------------------------

   wire                      i_basecase_reg1_en_a; 
   wire                      i_basecase_reg2_en_a; 
   reg   [DATAWORD_MSB:0]    i_ext_s1val_r; 
   reg   [DATAWORD_MSB:0]    i_ext_s2val_r; 
   wire                      i_extension_reg_en_a; 
   reg   [DATAWORD_MSB:0]    i_h_rr_data_a; 
   wire                      i_invert_s2val_a; 
   wire  [DATAWORD_MSB:0]    i_limm_data_r; 
   wire                      i_p2b_blcc_dslot_a; 
   wire                      i_p2b_blcc_no_dslot_a; 
   wire                      i_p2b_jlcc_dslot_a; 
   wire                      i_s1_sel_core_reg_a; 
   wire                      i_s1_sel_currentpc_a; 
   wire                      i_s1_sel_drd_a; 
   wire                      i_s1_sel_no_reg_a; 
   wire                      i_s1_sel_p2b_pc_s1val_a; 
   wire                      i_s1_sel_rlcnt_a; 
   wire                      i_s1_sel_rlimm_a; 
   wire                      i_s1_sel_sc_res_a; 
   wire                      i_s1_sel_shimm_a; 
   wire                      i_s1_sel_xdata_a; 
   wire  [DATAWORD_MSB:0]    i_s1val_nxt; 
   reg   [DATAWORD_MSB:0]    i_s1val_r; 
   wire                      i_s2_sel_core_reg_a; 
   wire                      i_s2_sel_drd_a; 
   wire                      i_s2_sel_eq_currentpc_a; 
   wire                      i_s2_sel_eq_rlcnt_a; 
   wire                      i_s2_sel_eq_rlimm_a; 
   wire                      i_s2_sel_no_reg_a; 
   wire                      i_s2_sel_sc_res_a; 
   wire                      i_s2_sel_shimm_a; 
   wire                      i_s2_sel_xdata_a; 
   wire  [DATAWORD_MSB:0]    i_s2_shift1_a; 
   wire  [DATAWORD_MSB:0]    i_s2_shift2_a; 
   wire  [DATAWORD_MSB:0]    i_s2_shift3_a; 
   reg                       i_s2val_inverted_r; 
   wire  [DATAWORD_MSB:0]    i_s2val_nxt; 
   reg   [DATAWORD_MSB:0]    i_s2val_r; 
   wire  [DATAWORD_MSB:0]    i_s2val_shift_a; 
   wire  [DATAWORD_MSB:0]    i_s2val_tmp; 
   wire  [DATAWORD_MSB:0]    i_shimm_sext_a; 
   wire                      i_st_sel_core_reg_a; 
   wire                      i_st_sel_drd_a; 
   wire                      i_st_sel_eq_currentpc_a; 
   wire                      i_st_sel_eq_rlcnt_a; 
   wire                      i_st_sel_eq_rlimm_a; 
   wire                      i_st_sel_no_reg_a; 
   wire                      i_st_sel_sc_res_a; 
   wire                      i_st_sel_xdata_a; 
   wire  [DATAWORD_MSB:0]    i_stval_nxt; 
   reg   [DATAWORD_MSB:0]    i_stval_r; 


//------------------------------------------------------------------------------
// Stage 2 Long/Short Immediates
//------------------------------------------------------------------------------
//
   // Long immediate data is latched into the stage 2 instruction word register
   // ready for use by the stage 2b source operand muxer.
   //
   assign i_limm_data_r = p2_iw_r; 

 
   // Sign-extend the short immediate data to 32 bits
   //
   assign i_shimm_sext_a = {{(DATAWORD_MSB - SHIMM_MSB)
                             {p2b_shimm_data[SHIMM_MSB]}},
                            p2b_shimm_data[SHIMM_MSB:0]};

//------------------------------------------------------------------------------
// Source 1 value
//------------------------------------------------------------------------------
//
// Mux together the various sources for source 1 operand.
//

   // Use the current PC (stage 1) for the return address for a jump & link
   // This value will be placed into the blink register.
   //
   assign i_p2b_jlcc_dslot_a  = (p2b_jlcc_a & (p2b_delay_slot | p2b_limm)); 
   
   // Use the address of the instruction that is stage 1 as the return address
   // for a branch with delay slot.  Currrent PC cannot be used as the branch
   // has already modified it to be the branch target. This value will be placed
   // into the blink register.
   //
   assign i_p2b_blcc_dslot_a  = (p2b_blcc_a & p2b_delay_slot); 

   // Use the PC of the instruction in stage 2 if a JLcc or Blcc is in stage 2b
   // and they have no delay slot or limm data. This value will be placed into
   // the BLINK register.
   //
   assign i_p2b_blcc_no_dslot_a  = ((p2b_blcc_a | p2b_jlcc_a) &
                                   (~p2b_delay_slot)           &
                                   (~p2b_limm)); 

   // Decode source 1 register address checking for r63 (current PC)
   //
   assign i_s1_sel_currentpc_a  = ((s1a == RCURRENTPC) & (s1en == 1'b1)) ?
          1'b1 :
          1'b0;

   // Select the results generated in the previous stage.
   //
   assign i_s1_sel_p2b_pc_s1val_a = (p2b_abs_op            |
                                     p2b_neg_op            |
                                     p2b_not_op            |
                                     i_p2b_blcc_no_dslot_a |
                                     i_s1_sel_currentpc_a  |
                                     p2bint                |
                                     p2b_lr) & ~(sc_load1 | sc_reg1);

   // Decode the source 1 address, checking for r62 (long immediate data).
   //
   assign i_s1_sel_rlimm_a  = ((s1a == RLIMM) & 
                               (s1en == 1'b1) & 
                               (i_s1_sel_no_reg_a == 1'b1))? 1'b1 : 1'b0; 
   
   // Decode the source 1 address, checking for r60 (loop count).
   //
   assign i_s1_sel_rlcnt_a  = ((s1a == RLCNT)&
                               (s1en == 1'b1)&
                               (i_s1_sel_no_reg_a == 1'b1))? 1'b1 : 1'b0;

   // Select the output of the register file.
   //
   assign i_s1_sel_core_reg_a  = ((~s1a[OPERAND_MSB])  & 
                                  (~p2b_shimm_s1_a)    & 
                                  s1en               & 
                                  i_s1_sel_no_reg_a);

   // This signal is used to enable various cones of logic so that they are only
   // asserted if the current instruction is on that uses the source 1 register
   // field or uses short immediate data
   //
   assign i_s1_sel_no_reg_a  = ~(i_s1_sel_drd_a          |
                                 p2b_jlcc_a              |
                                 p2b_blcc_a              |
                                 i_s1_sel_p2b_pc_s1val_a |
                                 i_s1_sel_sc_res_a);

   // Select short cut from a load.
   //
   assign i_s1_sel_drd_a  = sc_load1; 

   // Select short cut from a ALU.
   //
   assign i_s1_sel_sc_res_a = ((~sc_load1) & (~p2bint) & sc_reg1); 

   // Select short immediate value.
   //
   assign i_s1_sel_shimm_a = (p2b_shimm_s1_a & i_s1_sel_no_reg_a); 

   // Select extension core register value.
   //
   assign i_s1_sel_xdata_a = ~(i_s1_sel_drd_a          |
                               i_s1_sel_p2b_pc_s1val_a |
                               i_p2b_jlcc_dslot_a      |
                               i_s1_sel_sc_res_a       |
                               i_s1_sel_core_reg_a     |
                               i_s1_sel_rlimm_a        |
                               i_s1_sel_rlcnt_a        |
                               i_s1_sel_shimm_a) & s1en; 
   

   // Merge all results ready for registering into stage 3.
   //
   assign i_s1val_nxt =((drd         & {(THIRTY_TWO){i_s1_sel_drd_a}})      |
                    
                        (p3res_sc    & {(THIRTY_TWO){i_s1_sel_sc_res_a}})   |
                    
                        (currentpc_r & {(THIRTY_TWO){i_p2b_jlcc_dslot_a}})  |
                    
                   (last_pc_plus_len & {(THIRTY_TWO){i_p2b_blcc_dslot_a}})  |
                    
                   (p2_s1val_tmp_r & {(THIRTY_TWO){i_s1_sel_p2b_pc_s1val_a}}) |
                    
                   (i_shimm_sext_a & {(THIRTY_TWO){i_s1_sel_shimm_a}})        |
                    
                   (qd_a             & {(THIRTY_TWO){i_s1_sel_core_reg_a}})   |
                    
                   (loopcount_r      & {(THIRTY_TWO){i_s1_sel_rlcnt_a}})      |
                    
                          (i_limm_data_r & {(THIRTY_TWO){i_s1_sel_rlimm_a}}) |
                    
                          (x1data        & {(THIRTY_TWO){i_s1_sel_xdata_a}}));

//------------------------------------------------------------------------------
// Store value.  
//------------------------------------------------------------------------------   
//
// This the dataword to be stored to memory via a ST instruction

   assign i_st_sel_no_reg_a = ~(i_st_sel_drd_a | i_st_sel_sc_res_a); 

   // Decode source 2 address field, checking for r63 (program counter).
   //
   assign i_st_sel_eq_currentpc_a = ((s2a == RCURRENTPC) &
                                     (s2en == 1'b1)      &
                                     (i_st_sel_no_reg_a == 1'b1))? 1'b1 : 1'b0;

   // Decode source 2 register addres for r62 (long immediate data limm)
   //   
   assign i_st_sel_eq_rlimm_a  = ((s2a == RLIMM) &
                                  (s2en == 1'b1) &
                                  (i_st_sel_no_reg_a == 1'b1))? 1'b1 : 1'b0; 

   // Decode source 2 register addres for r60 (loop count)
   //   
   assign i_st_sel_eq_rlcnt_a = ((s2a == RLCNT) &
                                 (s2en == 1'b1) &
                                 (i_st_sel_no_reg_a == 1'b1))? 1'b1 : 1'b0;
   
   // Decode for detecting basecase register read.
   //
   assign i_st_sel_core_reg_a  = (~s2a[OPERAND_MSB] &
                                 s2en & i_st_sel_no_reg_a);

   // Decode short-cut from load returns
   //
   assign i_st_sel_drd_a  = sc_load2; 

   // Decodec Shortcut from ALU
   //
   assign i_st_sel_sc_res_a  = (sc_reg2 & ~sc_load2); 

   // Decode for extension core register values.
   //
   assign i_st_sel_xdata_a  = (~(i_st_sel_drd_a          |
                                i_st_sel_sc_res_a        |
                                i_st_sel_core_reg_a      |
                                i_st_sel_eq_currentpc_a  |
                                i_st_sel_eq_rlimm_a      |
                                i_st_sel_eq_rlcnt_a)) & s2en; 
   
   // Merge all values for the Store value
   //
   assign i_stval_nxt = ((drd           & {(THIRTY_TWO){i_st_sel_drd_a}})      |
                    
                         (p3res_sc      & {(THIRTY_TWO){i_st_sel_sc_res_a}})   |
                    
                         (qd_b          & {(THIRTY_TWO){i_st_sel_core_reg_a}}) |
                    
                         (loopcount_r   & {(THIRTY_TWO){i_st_sel_eq_rlcnt_a}}) |
                    
                         (i_limm_data_r & {(THIRTY_TWO){i_st_sel_eq_rlimm_a}}) |
                    
                         (p2b_pc_r  & {(THIRTY_TWO){i_st_sel_eq_currentpc_a}}) |
                    
                         (x2data        & {(THIRTY_TWO){i_st_sel_xdata_a}}));

//------------------------------------------------------------------------------
// Source 2 value
//------------------------------------------------------------------------------

   // This signal enables various logic cones to allow them to be asserted only
   // when the current instruction is using the source 2 register field and not
   // short immediated data or a short-cut from a returning load is occuring.
   //
   assign i_s2_sel_no_reg_a  = ~(p2b_shimm_s2_a    |
                                 i_s2_sel_sc_res_a |
                                 i_s2_sel_drd_a); 

   
   // Decode source 2 address field checking for r63 (current program counter)
   //
   assign i_s2_sel_eq_currentpc_a = ((s2a == RCURRENTPC)
                            & (s2en == 1'b1)
                            & (i_s2_sel_no_reg_a == 1'b1))? 1'b1 : 1'b0;

   // Decode source 2 address field checking for r62 (Limm)
   //
   assign i_s2_sel_eq_rlimm_a = ((s2a == RLIMM)
                         & (s2en == 1'b1)
                         & (i_s2_sel_no_reg_a == 1'b1))? 1'b1 : 1'b0;

   // Decode source 2 address field checking for r60 (Loop count)
   //
   assign i_s2_sel_eq_rlcnt_a = ((s2a == RLCNT)
                         & (s2en == 1'b 1)
                         & (i_s2_sel_no_reg_a == 1'b1))? 1'b1 : 1'b0;

   // Decode core basecase core register reads
   //    
   assign i_s2_sel_core_reg_a  = ( (~s2a[OPERAND_MSB]) &
                                 s2en              &
                                 i_s2_sel_no_reg_a );

   // Decode for short immediate data.
   //
   assign i_s2_sel_shimm_a  = ((~(i_s2_sel_sc_res_a | i_s2_sel_drd_a)) &
                              p2b_shimm_s2_a); 

   // Short cut on returning load
   //
   assign i_s2_sel_drd_a  = (sc_load2 & (~mstore2b)); 

   // Shortcut on ALU operation.
   //  
   assign i_s2_sel_sc_res_a = (sc_reg2 & (~(mstore2b | sc_load2))); 

   // Select extension register read value.
   //
   assign i_s2_sel_xdata_a  = (~(i_s2_sel_drd_a         |
                                i_s2_sel_sc_res_a       |
                                i_s2_sel_shimm_a        |
                                i_s2_sel_core_reg_a     |
                                i_s2_sel_eq_currentpc_a |
                                i_s2_sel_eq_rlimm_a     |
                                i_s2_sel_eq_rlcnt_a)) & s2en;
 

   // Merge all data values together. This is only a temperary value, source 2
   // still requires shifting and invertion.
   //                                    
   assign i_s2val_tmp = ((drd          & {(THIRTY_TWO){i_s2_sel_drd_a}})      |

                         (p3res_sc     & {(THIRTY_TWO){i_s2_sel_sc_res_a}})   |

                         (i_shimm_sext_a & {(THIRTY_TWO){i_s2_sel_shimm_a}})  |

                         (qd_b          & {(THIRTY_TWO){i_s2_sel_core_reg_a}}) |

                         (loopcount_r   & {(THIRTY_TWO){i_s2_sel_eq_rlcnt_a}}) |

                         (i_limm_data_r & {(THIRTY_TWO){i_s2_sel_eq_rlimm_a}}) |

                         (p2b_pc_r & {(THIRTY_TWO){i_s2_sel_eq_currentpc_a}}) |

                         (x2data   & {(THIRTY_TWO){i_s2_sel_xdata_a}}));




//------------------------------------------------------------------------------
// Shift Source 2 value
//------------------------------------------------------------------------------
//   
   assign i_s2_shift1_a    = {i_s2val_tmp[DATAWORD_MSB_1:0], ONE_ZERO}; 

   assign i_s2_shift2_a    = {i_s2val_tmp[DATAWORD_MSB_2:0], TWO_ZERO}; 

   assign i_s2_shift3_a    = {i_s2val_tmp[DATAWORD_MSB_3:0], THREE_ZERO}; 

   // The add1/add2/add3/sub1/sub2/sub3 instructions are supported below for
   // both 32/16 bit instructions.
   // 
   assign i_s2val_shift_a = ((i_s2val_tmp & {(THIRTY_TWO){p2b_shift_by_zero_a}})
                        |
                        (i_s2_shift1_a & {(THIRTY_TWO){p2b_shift_by_one_a}})
                        |
                        (i_s2_shift2_a & {(THIRTY_TWO){p2b_shift_by_two_a}})
                        |
                        (i_s2_shift3_a & {(THIRTY_TWO){p2b_shift_by_three_a}}));
                        
//------------------------------------------------------------------------------
// Invert source 2 value
//------------------------------------------------------------------------------
//
   // Invert source 2 when doing a subtract operation
   //                     
   assign i_invert_s2val_a =   ((p2b_alu_op[1] & p2b_arithiv) |
                                (i_s2val_tmp[DATAWORD_MSB] & p2b_abs_op)); 

   assign i_s2val_nxt  = i_s2val_shift_a ^ {(DATAWORD_WIDTH){i_invert_s2val_a}};


//------------------------------------------------------------------------------
// The Register File Connections
//------------------------------------------------------------------------------
//
   // Only enable writes to the register file when the address points to one of
   // the registers r0-r31.
   //
   assign r_wben = (wben & (~wba[OPERAND_MSB]));

//------------------------------------------------------------------------------
// Data gating signals to save power. 
//------------------------------------------------------------------------------
//
   // Only the relevent set of registers is enabled to prevent unnecassary
   // switching of logic. There is a large adder in the bascase alu that will
   // use an ammount of power.
   //
   // The source 1 operand register is only enabled if the current instruction
   // is a valid basecase instruction or an interrupt.
   //
   assign i_basecase_reg1_en_a = (en2b & ((p2b_iv & (~x_idecode2b))
                                 | 
                                 p2bint)); 
  
   // The source 2 operand register is only enabled if the current instruction
   // is a valid basecase instruction.
   //
   assign i_basecase_reg2_en_a = (en2b & p2b_iv & (~x_idecode2b)); 

   // The extension operand register is only enabled if the current instruction
   // is a valid extension instruction.
   //
   assign i_extension_reg_en_a = (en2b & p2b_iv & x_idecode2b); 

//------------------------------------------------------------------------------
//  Stage 2 Result Registers
//------------------------------------------------------------------------------
                        
   always @(posedge clk or posedge rst_a)
    begin : stage_2b_sync_PROC
      if (rst_a == 1'b 1)
        begin
          i_stval_r          <= {(DATAWORD_WIDTH){1'b 0}};
          i_s1val_r          <= {(DATAWORD_WIDTH){1'b 0}};
          i_s2val_r          <= {(DATAWORD_WIDTH){1'b 0}};
          i_ext_s2val_r      <= {(DATAWORD_WIDTH){1'b 0}};
          i_ext_s1val_r      <= {(DATAWORD_WIDTH){1'b 0}};
          i_s2val_inverted_r <= 1'b 0;   
        end
      else
        begin

          if ((en2b & p2b_iv) == 1'b1)
            begin

              // dwr latch
              i_stval_r <= i_stval_nxt;   

            end

          if (i_basecase_reg1_en_a == 1'b1)
            begin

              // Basecase s1val 
              i_s1val_r <= i_s1val_nxt;   

            end

          if (i_basecase_reg2_en_a == 1'b1)
            begin

              // Basecase s2val
              i_s2val_r <= i_s2val_nxt;   

              i_s2val_inverted_r <= i_invert_s2val_a;   

            end
          
          if (i_extension_reg_en_a == 1'b1)
            begin

              // Extensions s1val 
              i_ext_s1val_r <= i_s1val_nxt;   

              // Extensions s2val 
              i_ext_s2val_r <= i_s2val_tmp;   

            end

        end
    end


   //  This bus carries the register file read data to the host
   //  interface.
   // 
   //  There will be a functional difference to the extent that if the 
   //  processor is halted without the pipeline being flushed, and there
   //  is an instruction stopped at stage 3, then the value which is 
   //  ready to be written to the register file will not be returned to
   //  the debugger, but the value actually stored in the register file
   //  will be used instead.
   // 
   //  Note that the ability to read from p1iw_aligned_a has been retained
   //  so that it is possible to explicity determine the value being
   //  presented from the instruction cache.
   // 
   always @(currentpc_r
            or loopcount_r 
            or i_limm_data_r 
            or qd_b 
            or s2a
            or x2data)
    begin : host_access_async_PROC
      case (s2a)
        
        //  For the contents of the register file.
        r0,  r1,  r2,  r3,  r4,  r5,  r6,  r7,
        r8,  r9,  r10, r11, r12, r13, r14, r15,
        r16, r17, r18, r19, r20, r21, r22, r23,
        r24, r25, r26, r27, r28, r29, r30, r31:
         begin
            i_h_rr_data_a = qd_b;   
         end

        //  For the contents of the loopcount register.
        RLCNT:
         begin
            i_h_rr_data_a = loopcount_r;   
         end

        //  For long immediate data.
        RLIMM:
         begin
            i_h_rr_data_a = i_limm_data_r;   
         end

        //  For the instruction currently in stage 2.
        RCURRENTPC:
         begin
            i_h_rr_data_a = {currentpc_r[PC_MSB:PC_LSB + 1], TWO_ZERO};   
         end

        //  For extensions.
        default:
         begin
            i_h_rr_data_a = x2data;   
         end
      endcase
    end

//------------------------------------------------------------------------------
// Output Drives
//------------------------------------------------------------------------------
//
// Drive outputs from internal signals

   assign dwr              = i_stval_r; 
   assign ext_s1val        = i_ext_s1val_r; 
   assign ext_s2val        = i_ext_s2val_r; 
   assign h_rr_data        = i_h_rr_data_a; 
   assign s1bus            = i_s1val_nxt; 
   assign s1val            = i_s1val_r; 
   assign s2bus            = i_s2val_nxt; 
   assign s2val            = i_s2val_r; 
   assign s2val_inverted_r = i_s2val_inverted_r; 
   assign stval            = i_stval_nxt; 

endmodule // module cr_int

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// Wrapper for Synchronous register file.
//
module sync_regs (clk,
                  rst_a,
                  en,
                  core_access,
                  hold_host,
                  en2,
                  fs2a,
                  p2_s1a,
                  p2_s2a,
                  s1a,
                  h_addr,
                  h_read,
                  wben,
                  wbdata,
                  wba,
                  regadr,
                  ldvalid,
                  s3p_qa,
                  s3p_qb,
                  p2iv,
                  cr_hostr,
                  test_mode,
                  sr_xhold_host_a,
                  ldv_r0r31,
                  qd_a,
                  qd_b,
                  s3p_aw,
                  s3p_ara,
                  s3p_arb,
                  s3p_we,
                  ck_en_w,
                  ck_en_w2,
                  ck_en_a,
                  ck_en_b);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"

input   clk; 
input   rst_a; 

//  Signals for register reads
//
input   en; 
input   core_access; 
input   hold_host; 
input   en2; 
input   [5:0] fs2a; 
input   [5:0] p2_s1a; 
input   [5:0] p2_s2a; 
input   [5:0] s1a; 
input   [31:0] h_addr; 
input   h_read; 

//  Write data in
//
input   wben; 
input   [31:0] wbdata; 
input   [5:0] wba; 

//  Second (direct load) write port connections
//
//  Note that drd and regadr also go direct to the RAM.
//
input   [5:0]  regadr; 
input   ldvalid;

//  Connections to the core register file
//
input   [31:0] s3p_qa; 
input   [31:0] s3p_qb; 

//  Generation of the enable signals for the core register 
//  file.
//
input   p2iv; 
input   cr_hostr; 
input   test_mode; 

//  Signals for register reads
//
output  sr_xhold_host_a; 

//  Second (direct load) write port connections
//
output  ldv_r0r31; 

//  Read data out
//
output  [31:0] qd_a; 
output  [31:0] qd_b; 

//  Connections to the core register file
//
output  [4:0] s3p_aw; 
output  [4:0] s3p_ara; 
output  [4:0] s3p_arb; 
output  s3p_we; 

//  Generation of the enable signals for the core register 
//  file.
//
output  ck_en_w; 
output  ck_en_w2; 
output  ck_en_a; 
output  ck_en_b; 

wire    sr_xhold_host_a; 
wire    ldv_r0r31; 
wire    [31:0] qd_a; 
wire    [31:0] qd_b; 
wire    [4:0] s3p_aw; 
wire    [4:0] s3p_ara; 
wire    [4:0] s3p_arb; 
wire    s3p_we; 
wire    ck_en_w; 
wire    ck_en_w2; 
wire    ck_en_a; 
wire    ck_en_b; 

wire    [CORE_REG_MSB:0] i_aw_a; 
reg     i_hold_host_r; 
wire    i_ldvalid_r0r31_a; 
wire    [CORE_REG_MSB:0] i_rega_a; 
wire    [CORE_REG_MSB:0] i_regb_a; 
wire    i_sr_xhold_host_a; 
wire    i_we_a; 
reg     i_p5_we_r;
reg     [DATAWORD_MSB:0] i_p5_wbdata_r;
reg     [5:0] i_p5_wba_r;


   //  Generate Read addresses
   // 
   //  Read A address - Register read. The address comes direct from the
   //  instruction word which is being supplied by the cache.
   // 
   assign i_rega_a = (en2 == 1'b 1) ?
          p2_s1a[CORE_REG_MSB:0] : 
          s1a[CORE_REG_MSB:0]; 


   //  Read B address - Register reads plus HOST port accesses.
   //  Address comes from the instruction word being supplied by the cache,
   //  if the ARC is running, otherwise from the host address.
   // 
   //  We need to generate a cycle delay for host reads from the core 
   //  registers, since the data will not be ready until the end of the 
   //  cycle after the host address value first became true.
   //  
   //  Once we know that the Host read is going to complete successfully,
   //  we can remove the host address, and allow the RAM to re-fetch the
   //  values it had when the ARC was halted.
   // 
   assign i_regb_a = (en2         == 1'b 1) ?
          p2_s2a[CORE_REG_MSB:0] : 
                     ((hold_host   == 1'b 1) &&
                      (h_read      == 1'b 1) &&
                      (core_access == 1'b 1) &&
                      (en          == 1'b 0)) ?
          h_addr[CORE_REG_MSB:0] : 
          fs2a[CORE_REG_MSB:0]; 

   //  Generate Write signals
   // 
   //  Write address
   // 
   assign i_aw_a = wba[CORE_REG_MSB:0]; 

   //  Write enable : true when a register is being written, and the 
   //  address is in the lower half of the register space.
   // 
   assign i_we_a = ((wben             == 1'b 1) && 
                    (rf_reg(wba)      == 1'b 1)) ?
          REGFILE_WR_ACTIVE : 
          (~REGFILE_WR_ACTIVE); 

   //  Clock enable for the write port controlled by the write enable above.
   //  It is enabled during writes or when the ARC is in test mode.
   // 
   //  This turns off the RAM port when not in use to save power. Depending
   //  on technology this may cause time delays on the critical path. If
   //  this the case and this is not acceptable, just don't connect this
   //  signal to the RAM. If the flip-flop implementation of the core 
   //  register file is used then this signal is not used.
   //
   assign ck_en_w = (wben             == 1'b 1) &&
                    (rf_reg(wba)      == 1'b 1) || 
                    (test_mode        == 1'b 1) ?
          REGFILE_CK_EN_ACTIVE : 
          (~REGFILE_CK_EN_ACTIVE); 

   //  Host access.
   //   Generate a holdup signal when the host reads from the register file
   // 
   //   The nature of synchronous RAMs, and the lack of a pre-latch h_addr
   //   signal mean that host reads from the ARC register file will take 
   //   two cycles in this version.
   // 
   //  So, we stall if:
   //       The ARC is halted
   //       The host is attempting a core register read
   //       The previous cycle's host access was OK (not stalled)
   // 
   //  Hence when we generate a stall, or if one is generated somewhere else,
   //  the stall will go away after one cycle.
   // 
   assign i_sr_xhold_host_a = ((en            == 1'b 0) &&
                               (h_read        == 1'b 1) &&
                               (core_access   == 1'b 1) &&
                               (i_hold_host_r == 1'b 0)) ?
          1'b 1 : 
          1'b 0; 

   assign sr_xhold_host_a = i_sr_xhold_host_a; 

   // Keep a copy of the value of hold_host from the last cycle
   // Also, latch the write-enable signal.
   // 
   always @(posedge clk or posedge rst_a)
   begin : ff_sync_PROC
      if (rst_a == 1'b 1)
         begin
            i_hold_host_r <= 1'b 0; 
            i_p5_wbdata_r <= 32'b 0;    
            i_p5_wba_r    <= 6'b 0;    
            i_p5_we_r     <= 1'b 0;    
         end
      else
         begin
            i_hold_host_r <= hold_host;
                         
            if (i_we_a == REGFILE_WR_ACTIVE)
               begin
                  i_p5_wbdata_r <= wbdata;    
                  i_p5_wba_r    <= wba;
               end

            i_p5_we_r     <= i_we_a; 
         end
   end

//----------------------------------------------------------------------- 
//
// Generate write signal for direct load of r0-r31 data.
// 
// This signal controls the writing of drd[31:0] into the 4-port
// register file at the address specified by the bottom five bits of
// regadr.
// 
// The pipeline control system additionally has to deal with
// shortcutting of this data, and know not to generate stalls for these
// loads under normal circumstances.
// 
//
   assign i_ldvalid_r0r31_a = ((ldvalid             == 1'b 1) &&
                               (rf_reg(regadr)      == 1'b 1)) ?
          REGFILE_WR_ACTIVE : 
          (~REGFILE_WR_ACTIVE); 

   assign ldv_r0r31 = i_ldvalid_r0r31_a; 

// Clock enable for the write port controlled by the write enable above.
// It is enabled during writes or when the ARC is in test mode.
// (this signal is only used with the 4-port register file).
// 
// This turns off the RAM port when not in use to save power. Depending
// on technology this may cause time delays on the critical path. If
// this the case and this is not acceptable, just don't connect this
// signal to the RAM. If the flip-flop implementation of the core 
// register file is used then this signal is not used.
//
   assign ck_en_w2 = (((ldvalid           == 1'b 1) &&
                     (rf_reg(regadr)      == 1'b 1)) ||

                     (test_mode == 1'b 1)) ?

          REGFILE_CK_EN_ACTIVE : 
          (~REGFILE_CK_EN_ACTIVE); 

//----------------------------------------------------------------------- 
// 
// Some implementations require that we provide a write-through path,
// if the timing does not allow write-through inside the RAM.
//  
// Hence we switch the write data onto the outputs if
//
//      [1] A write is taking place,
//      OR
//      [2] The register being written to is also being read.
// 

   //  Multiplex the normal results with the writethrough result.
   // 
   assign qd_a = (i_we_a           == REGFILE_WR_ACTIVE) &&
                 (s1a              == wba) ?
          wbdata :
                 (i_p5_we_r        == REGFILE_WR_ACTIVE) &&
                 (s1a              == i_p5_wba_r) ?
          i_p5_wbdata_r :
          s3p_qa; 


   //  Multiplex the normal results with the writethrough result.
   // 
   assign qd_b = (i_we_a           == REGFILE_WR_ACTIVE) &&
                 (fs2a             == wba) ?
          wbdata : 
                 (i_p5_we_r        == REGFILE_WR_ACTIVE) &&
                 (fs2a             == i_p5_wba_r) ?
          i_p5_wbdata_r :
          s3p_qb; 

   //  Clock enables for the read ports.
   // 
   //  This turns off the RAM port when not in use to save power. Depending
   //  on technology this may cause time delays on the critical path. If this
   //  is the case and this is not acceptable, just don't connect these
   //  signals to the register file. If the flip-flop implementation of the 
   //  core register file is used then these signals are not used.
   // 
   //  The read ports of the RAM will be active on the next clock cycle if:
   // 
   //    1. a valid instruction is in pipe stage 1 and the ARC isn't stalled.
   //    2. the host will perform a read on the next clock cycle (this only
   //       applies to port A).
   //    3. a write is performed to the register file during the present
   //       clock cycle. This is to ensure that the outputs of the read ports
   //       will be updated with the latest content of the address it is
   //       reading.
   //    4. the ARC is in test mode (test_mode = '1')
   //
   assign ck_en_a = (p2iv             == 1'b 1) &&
                    (en2              == 1'b 1) ||
                    (i_we_a           == REGFILE_WR_ACTIVE) ||
                    (i_p5_we_r        == REGFILE_WR_ACTIVE) ||
                    (test_mode == 1'b 1) ?
          REGFILE_CK_EN_ACTIVE : 
          (~REGFILE_CK_EN_ACTIVE); 

   assign ck_en_b = (p2iv             == 1'b 1) &&
                    (en2              == 1'b 1) || 
                    (cr_hostr         == 1'b 1) ||
                    (i_we_a           == REGFILE_WR_ACTIVE) ||
                    (i_p5_we_r        == REGFILE_WR_ACTIVE) ||
                    (test_mode        == 1'b 1) ?
          REGFILE_CK_EN_ACTIVE : 
          (~REGFILE_CK_EN_ACTIVE); 


//----------------------------------------------------------------------- 

   //  Outputs to the 4-port RAM
   // 
   assign s3p_aw  = i_aw_a; 
   assign s3p_ara = i_rega_a; 
   assign s3p_arb = i_regb_a; 
   assign s3p_we  = i_we_a; 

endmodule // module sync_regs

// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module coreregs(en,
                rst_a,
                test_mode,
                clk,
                s1en,
                s2en,
                en2,
                mstore2b,
                p2iv,
                en2b,
                p2b_iv,
                aux_addr,
                aux_dataw,
                aux_write,
                h_addr,
                h_read,
                s1a,
                s2a,
                fs2a,
                wba,
                wbdata,
                wben,
                core_access,
                sc_reg1,
                sc_reg2,
                ldvalid,
                p1int,
                p2int,
                p2bint,
                pcounter_jmp_restart_r,
                regadr,
                x_idecode2b,
                en1,
                pcen,
                p2_iw_r,
                p2_lp_instr,
                p2_s1a,
                p2_s2a,
                p2condtrue,
                p2b_abs_op,
                p2b_alu_op,
                p2b_arithiv,
                p2b_blcc_a,
                p2b_delay_slot,
                p2b_jlcc_a,
                p2b_limm,
                p2b_lr,
                p2b_neg_op,
                p2b_not_op,
                p2b_shift_by_one_a,
                p2b_shift_by_three_a,
                p2b_shift_by_two_a,
                p2b_shift_by_zero_a,
                p2b_shimm_data,
                p2b_shimm_s1_a,
                p2b_shimm_s2_a,
                sc_load1,
                sc_load2,
                loopcount_hit_a,
                kill_p1_nlp_a,
                currentpc_r,
                pc_is_linear_r,
                last_pc_plus_len,
                p2b_pc_r,
                p2_target,
                p2_s1val_tmp_r,
                drd,
                p3res_sc,
                p3result,
                x1data,
                x2data,
                hold_host,
                cr_hostr,
                s1bus,
                s2bus,
                ext_s1val,
                ext_s2val,
                loop_kill_p1_a,
                loop_int_holdoff_a,
                loopend_hit_a,
                s2val,
                loopstart_r,
                do_loop_a,
                qd_b,
                s1val,
                s2val_inverted_r,
                dwr,
                h_rr_data,
                loopend_r,
                sr_xhold_host_a);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"


input  en;
input  rst_a;
input  test_mode;
input  clk;
input  s1en;
input  s2en;
input  en2;
input  mstore2b;
input  p2iv;
input  en2b;
input  p2b_iv;
input  [31:0]  aux_addr;
input  [31:0]  aux_dataw;
input  aux_write;
input  [31:0]  h_addr;
input  h_read;
input  [5:0]  s1a;
input  [5:0]  s2a;
input  [5:0]  fs2a;
input  [5:0]  wba;
input  [31:0]  wbdata;
input  wben;
input  core_access;
input  sc_reg1;
input  sc_reg2;
input  ldvalid;
input  p1int;
input  p2int;
input  p2bint;
input  pcounter_jmp_restart_r;
input  [5:0]  regadr;
input  x_idecode2b;
input  en1;
input  pcen;
input  [INSTR_UBND:0]  p2_iw_r;
input  p2_lp_instr;
input  [5:0]  p2_s1a;
input  [5:0]  p2_s2a;
input  p2condtrue;
input  p2b_abs_op;
input  [1:0]  p2b_alu_op;
input  p2b_arithiv;
input  p2b_blcc_a;
input  p2b_delay_slot;
input  p2b_jlcc_a;
input  p2b_limm;
input  p2b_lr;
input  p2b_neg_op;
input  p2b_not_op;
input  p2b_shift_by_one_a;
input  p2b_shift_by_three_a;
input  p2b_shift_by_two_a;
input  p2b_shift_by_zero_a;
input  [12:0]  p2b_shimm_data;
input  p2b_shimm_s1_a;
input  p2b_shimm_s2_a;
input  sc_load1;
input  sc_load2;
input  loopcount_hit_a;
input  kill_p1_nlp_a;
input  [PC_MSB:0]  currentpc_r;
input  pc_is_linear_r;
input  [PC_MSB:0]  last_pc_plus_len;
input  [PC_MSB:0]  p2b_pc_r;
input  [PC_MSB:0]  p2_target;
input  [DATAWORD_MSB:0]  p2_s1val_tmp_r;
input  [31:0]  drd;
input  [31:0]  p3res_sc;
input  [31:0]  p3result;
input  [31:0]  x1data;
input  [31:0]  x2data;
input  hold_host;
input  cr_hostr;
output [31:0]  s1bus;
output [31:0]  s2bus;
output [31:0]  ext_s1val;
output [31:0]  ext_s2val;
output loop_kill_p1_a;
output loop_int_holdoff_a;
output loopend_hit_a;
output [31:0]  s2val;
output [PC_MSB:0]  loopstart_r;
output do_loop_a;
output [31:0]  qd_b;
output [31:0]  s1val;
output s2val_inverted_r;
output [31:0]  dwr;
output [31:0]  h_rr_data;
output [PC_MSB:0]  loopend_r;
output sr_xhold_host_a;

wire en;
wire rst_a;
wire test_mode;
wire clk;
wire s1en;
wire s2en;
wire en2;
wire mstore2b;
wire p2iv;
wire en2b;
wire p2b_iv;
wire  [31:0] aux_addr;
wire  [31:0] aux_dataw;
wire aux_write;
wire  [31:0] h_addr;
wire h_read;
wire  [5:0] s1a;
wire  [5:0] s2a;
wire  [5:0] fs2a;
wire  [5:0] wba;
wire  [31:0] wbdata;
wire wben;
wire core_access;
wire sc_reg1;
wire sc_reg2;
wire ldvalid;
wire p1int;
wire p2int;
wire p2bint;
wire pcounter_jmp_restart_r;
wire  [5:0] regadr;
wire x_idecode2b;
wire en1;
wire pcen;
wire  [INSTR_UBND:0] p2_iw_r;
wire p2_lp_instr;
wire  [5:0] p2_s1a;
wire  [5:0] p2_s2a;
wire p2condtrue;
wire p2b_abs_op;
wire  [1:0] p2b_alu_op;
wire p2b_arithiv;
wire p2b_blcc_a;
wire p2b_delay_slot;
wire p2b_jlcc_a;
wire p2b_limm;
wire p2b_lr;
wire p2b_neg_op;
wire p2b_not_op;
wire p2b_shift_by_one_a;
wire p2b_shift_by_three_a;
wire p2b_shift_by_two_a;
wire p2b_shift_by_zero_a;
wire  [12:0] p2b_shimm_data;
wire p2b_shimm_s1_a;
wire p2b_shimm_s2_a;
wire sc_load1;
wire sc_load2;
wire loopcount_hit_a;
wire kill_p1_nlp_a;
wire  [PC_MSB:0] currentpc_r;
wire pc_is_linear_r;
wire  [PC_MSB:0] last_pc_plus_len;
wire  [PC_MSB:0] p2b_pc_r;
wire  [PC_MSB:0] p2_target;
wire  [DATAWORD_MSB:0] p2_s1val_tmp_r;
wire  [31:0] drd;
wire  [31:0] p3res_sc;
wire  [31:0] p3result;
wire  [31:0] x1data;
wire  [31:0] x2data;
wire hold_host;
wire cr_hostr;
wire  [31:0] s1bus;
wire  [31:0] s2bus;
wire  [31:0] ext_s1val;
wire  [31:0] ext_s2val;
wire loop_kill_p1_a;
wire loop_int_holdoff_a;
wire loopend_hit_a;
wire  [31:0] s2val;
wire  [PC_MSB:0] loopstart_r;
wire do_loop_a;
wire  [31:0] qd_b;
wire  [31:0] s1val;
wire s2val_inverted_r;
wire  [31:0] dwr;
wire  [31:0] h_rr_data;
wire  [PC_MSB:0] loopend_r;
wire sr_xhold_host_a;


// Intermediate signals
wire  [31:0] i_qd_b;
wire  [LOOPCNT_MSB:0] i_loopcount_r;
wire  [31:0] i_qd_a;
wire  [31:0] i_s3p_qa;
wire  [31:0] i_s3p_qb;
wire  [4:0] i_s3p_aw;
wire  [4:0] i_s3p_ara;
wire  [4:0] i_s3p_arb;
wire i_s3p_we;
wire i_ck_en_w;
wire i_ck_en_a;
wire i_ck_en_b;


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)
wire u_unconnected_0;
wire  [31:0] u_unconnected_1;
wire u_unconnected_2;
wire u_unconnected_3;


// Instantiation of module cr_int
cr_int icr_int(
  .clk(clk),
  .rst_a(rst_a),
  .currentpc_r(currentpc_r),
  .drd(drd),
  .en2b(en2b),
  .loopcount_r(i_loopcount_r),
  .mstore2b(mstore2b),
  .last_pc_plus_len(last_pc_plus_len),
  .p2_iw_r(p2_iw_r),
  .p2b_pc_r(p2b_pc_r),
  .p2_s1val_tmp_r(p2_s1val_tmp_r),
  .p2b_abs_op(p2b_abs_op),
  .p2b_alu_op(p2b_alu_op),
  .p2b_arithiv(p2b_arithiv),
  .p2b_delay_slot(p2b_delay_slot),
  .p2b_iv(p2b_iv),
  .p2b_jlcc_a(p2b_jlcc_a),
  .p2b_blcc_a(p2b_blcc_a),
  .p2b_limm(p2b_limm),
  .p2b_lr(p2b_lr),
  .p2b_neg_op(p2b_neg_op),
  .p2b_not_op(p2b_not_op),
  .p2b_shift_by_one_a(p2b_shift_by_one_a),
  .p2b_shift_by_three_a(p2b_shift_by_three_a),
  .p2b_shift_by_two_a(p2b_shift_by_two_a),
  .p2b_shift_by_zero_a(p2b_shift_by_zero_a),
  .p2b_shimm_data(p2b_shimm_data),
  .p2b_shimm_s1_a(p2b_shimm_s1_a),
  .p2b_shimm_s2_a(p2b_shimm_s2_a),
  .p2bint(p2bint),
  .p3res_sc(p3res_sc),
  .qd_a(i_qd_a),
  .qd_b(i_qd_b),
  .s1a(s1a),
  .s1en(s1en),
  .s2a(s2a),
  .s2en(s2en),
  .sc_load1(sc_load1),
  .sc_load2(sc_load2),
  .sc_reg1(sc_reg1),
  .sc_reg2(sc_reg2),
  .wba(wba),
  .wben(wben),
  .x1data(x1data),
  .x2data(x2data),
  .x_idecode2b(x_idecode2b),
  .dwr(dwr),
  .ext_s1val(ext_s1val),
  .ext_s2val(ext_s2val),
  .h_rr_data(h_rr_data),
  .r_wben(u_unconnected_0),
  .s1bus(s1bus),
  .s1val(s1val),
  .s2bus(s2bus),
  .s2val(s2val),
  .s2val_inverted_r(s2val_inverted_r),
  .stval(u_unconnected_1)
);


// Instantiation of module loopcnt
loopcnt iloopcnt(
  .clk(clk),
  .rst_a(rst_a),
  .aux_addr(aux_addr),
  .aux_dataw(aux_dataw),
  .aux_write(aux_write),
  .currentpc_r(currentpc_r),
  .en1(en1),
  .en2(en2),
  .kill_p1_nlp_a(kill_p1_nlp_a),
  .loopcount_hit_a(loopcount_hit_a),
  .p1int(p1int),
  .p2_lp_instr(p2_lp_instr),
  .p2_target(p2_target),
  .p2condtrue(p2condtrue),
  .p2int(p2int),
  .p2iv(p2iv),
  .p3result(p3result),
  .pc_is_linear_r(pc_is_linear_r),
  .pcen(pcen),
  .pcounter_jmp_restart_r(pcounter_jmp_restart_r),
  .loop_int_holdoff_a(loop_int_holdoff_a),
  .do_loop_a(do_loop_a),
  .loop_kill_p1_a(loop_kill_p1_a),
  .loopcount_r(i_loopcount_r),
  .loopend_hit_a(loopend_hit_a),
  .loopend_r(loopend_r),
  .loopstart_r(loopstart_r)
);


// Instantiation of module sync_regs
sync_regs isync_regs(
  .clk(clk),
  .rst_a(rst_a),
  .en(en),
  .core_access(core_access),
  .hold_host(hold_host),
  .en2(en2),
  .fs2a(fs2a),
  .p2_s1a(p2_s1a),
  .p2_s2a(p2_s2a),
  .s1a(s1a),
  .h_addr(h_addr),
  .h_read(h_read),
  .wben(wben),
  .wbdata(wbdata),
  .wba(wba),
  .regadr(regadr),
  .ldvalid(ldvalid),
  .s3p_qa(i_s3p_qa),
  .s3p_qb(i_s3p_qb),
  .p2iv(p2iv),
  .cr_hostr(cr_hostr),
  .test_mode(test_mode),
  .sr_xhold_host_a(sr_xhold_host_a),
  .ldv_r0r31(u_unconnected_2),
  .qd_a(i_qd_a),
  .qd_b(i_qd_b),
  .s3p_aw(i_s3p_aw),
  .s3p_ara(i_s3p_ara),
  .s3p_arb(i_s3p_arb),
  .s3p_we(i_s3p_we),
  .ck_en_w(i_ck_en_w),
  .ck_en_w2(u_unconnected_3),
  .ck_en_a(i_ck_en_a),
  .ck_en_b(i_ck_en_b)
);


// Instantiation of module regfile_3p_wrap
regfile_3p_wrap iregfile_3p_wrap(
  .clk(clk),
  .s3p_aw(i_s3p_aw),
  .s3p_ara(i_s3p_ara),
  .s3p_arb(i_s3p_arb),
  .wbdata(wbdata),
  .s3p_we(i_s3p_we),
  .ck_en_w(i_ck_en_w),
  .ck_en_a(i_ck_en_a),
  .ck_en_b(i_ck_en_b),
  .s3p_qa(i_s3p_qa),
  .s3p_qb(i_s3p_qb)
);


// Output drives
assign qd_b                    = i_qd_b;

endmodule


// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2001-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This modules controls access to the ICCM RAM. It arbitrates between
// the following three interfaces (mentioned in priority order): 
//  
//       1. ICCM RAM Direct Memory Interface (ICCM RAM DMI)
//       2. Data Memory Pipeline (DMP) interface
//       3. Instruction fetch interface.
// 
// 
// ===================== Inputs to this module =======================--
//
// clk_ungated      Core ungated clock. Ungated clock  is used so
//                  that if a DMI request comes in when the clock is
//                  asleep, the request is still handled.
//
// rst_a            Global asynchronous reset signal.
//
// test_mode        Global production test mode signal.
//
// ivic             Invalidate Instruction Cache (IVIC) signal. When set
//                  the instruction fetch state machine in this module
//                  returns to the idle state, where the ivalid signal
//                  is set to 0. The reason for doing this is to force 
//                  ivalid to 0 by the time the ifetch generated by the 
//                  ivic arrives. If ivalid would not be low when this 
//                  ifetch comes then the instruction fetch interface 
//                  would go into an illegal state, because the earliest 
//                  the first ivalid can arrive is on the cycle after the
//                  first ifetch.
//
//                  Unlike the intruction cache the data in the ICCM RAM 
//                  remains valid after an ivic has been performed.
//
// code_ram_rdata   Read data from the ICCM RAM.
//
// ifetch           Instruction request signal from the processor.
//
// next_pc          Address of the next instruction to be fetched.
//
// dmp_dwr          The load write data bus is connected to the DMP
//                  sub-modules, the peripherals and the ICCM RAM. Write
//                  data can come from either the ARC pipeline or the
//                  debug interface, depending on which module requests
//                  to write to memory.
//
// dmp_en3          Pipeline stage 3 enable signal is connected to the
//                  DMP sub-modules, the peripherals and the ICCM RAM.
//                  This signal is controlled by either the ARC
//                  pipeline or the debug access unit. When set
//                  a DMP sub-module, the ICCM RAM or a peripheral will
//                  service the load/store request.
//
// dmp_addr         The load/store address is connected to the DMP
//                  sub-modules, the peripherals and the ICCM RAM. This
//                  address can come from either the ARC pipeline or
//                  the debug interface, depending on which module
//                  requests access to memory.
//
// dmp_mload        The load instruction indicator. When it is set
//                  either the ARC or the debug interface wish to load
//                  data from an address in the LD/ST memory space.
//
// dmp_mstore       The store instruction indicator. When it is set
//                  either the ARC or the debug interface wish to store
//                  data to an address in the LD/ST memory space.
//
// dmp_size         The size of transfer signal is connected to the
//                  DMP-submodules, the peripherals and the ICCM RAM.
//                  This is always cleared in debug mode. In ARC access
//                  mode, it is controlled by the ARC pipeline.
//
// dmp_sex          The sign extend signal is connected to the
//                  DMP-submodules, the peripherals and the ICCM RAM.
//                  It is always cleared in debug mode. In ARC access
//                  mode it is controlled from the ARC pipeline.
//
// hold_loc         This is a hold signal for the ICCM RAM and the
//                  LD/ST RAM. If any of these RAM's are trying to
//                  return a load on the same cycle that hold_loc
//                  is set then the load return should be reissued on
//                  the next cycle.
//
// is_code_ram      This is set when the address (dmp_addr) is within
//                  the ICCM RAM address range.
//
// code_dmi_req     The DMI request to ICCM RAM. When set the direct
//                  memory interface (DMI) has immediate access
//                  to the ICCM RAM. Other ICCM RAM interfaces
//                  (instruction fetch and data memory pipeline) are
//                  held off as they have lower priority. During one
//                  access several reads and writes can be performed.
//                  The DMI access ends when this signal is again set
//                  low.
//
// code_dmi_addr    The address for the ICCM RAM Direct Memory
//                  Interface.
//
// code_dmi_wdata   The write data for the ICCM RAM Direct Memory
//                  Interface.
//
// code_dmi_wr      The write enable for the ICCM RAM Direct Memory
//                  Interface. Set means write and clear means read.
//
// code_dmi_be      The byte enables on the ICCM RAM Direct Memory
//                  Interface. There are four enables, one for each 
//                  byte.
//
// ================ outputs from this module =====================--
//
// p1iw             The instruction word supplied by the ICCM RAM to the
//                  pipeline stage 1 of the processor. It is valid when
//                  ivalid is true.
//
// ivalid           The valid signal for p1iw.
//
// code_drd         The load data return bus from the ICCM RAM.
//
// code_ldvalid_r   Indicates that the ICCM RAM wishes to perform a
//                  writeback on the next cycle.This signal is set when
//                  code_drd contains valid data.
//
// code_dmi_rdata   Read data to the ICCM RAM Direct Memory Interface.
//                  byte lane. The byte enable bus is little endian.
//
module iccm_control (
   clk_ungated,
   rst_a,
   ck_disable,
   test_mode,
   ivic,
   code_ram_rdata,
   ifetch,
   next_pc,
   dmp_dwr,
   dmp_en3,
   dmp_addr,
   dmp_mload,
   dmp_mstore,
   dmp_size,
   dmp_sex,
   hold_loc,
   is_code_ram,
   code_dmi_req,
   code_dmi_addr,
   code_dmi_wdata,
   code_dmi_wr,
   code_dmi_be,

   code_ram_addr,
   code_ram_wdata,
   code_ram_wr,
   code_ram_be,
   code_ram_ck_en,
   p1iw,
   ivalid,
   code_drd,
   code_ldvalid_r,
   code_dmi_rdata,
   code_stall_ldst,
   ic_busy);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"

input                       clk_ungated;
input                       rst_a; 
input                       ck_disable;
input                       test_mode; 
input                       ivic;

// ICCM RAM interface
//
input   [31:0]              code_ram_rdata; 

//  Instruction fetch interface
// 
input                       ifetch;
input   [PC_MSB:0]          next_pc; 

//  Data Memory Pipeline (DMP) interface
// 
input   [31:0]              dmp_dwr; 
input                       dmp_en3; 
input   [31:0]              dmp_addr; 
input                       dmp_mload; 
input                       dmp_mstore; 
input   [1:0]               dmp_size; 
input                       dmp_sex; 
input                       hold_loc; 
input                       is_code_ram; 
input                       code_dmi_req; 

//  ICCM RAM Direct Memory Interface (ICCM RAM DMI)
// 
input   [31:0]              code_dmi_addr; 
input   [31:0]              code_dmi_wdata; 
input                       code_dmi_wr; 
input   [3:0]               code_dmi_be; 

// ICCM RAM interface
//
output  [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] code_ram_addr; 
output  [31:0]              code_ram_wdata; 
output                      code_ram_wr; 
output  [3:0]               code_ram_be; 
output                      code_ram_ck_en; 

//  Instruction fetch interface
// 
output  [31:0]              p1iw; 
output                      ivalid; 

//  Data Memory Pipeline (DMP) interface
// 
output  [31:0]              code_drd; 
output                      code_ldvalid_r;

//  ICCM RAM Direct Memory Interface (ICCM RAM DMI)
// 
output  [31:0]              code_dmi_rdata; 

//  Instruction cache busy signal (tied low)
// 
output                      ic_busy; 

output                      code_stall_ldst;

wire    [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] code_ram_addr; 
wire    [31:0]              code_ram_wdata; 
wire                        code_ram_wr; 
wire    [3:0]               code_ram_be; 
wire                        code_ram_ck_en; 

wire    [31:0]              p1iw; 
wire                        ivalid; 
wire    [31:0]              code_drd; 
wire                        code_ldvalid_r; 
wire    [31:0]              code_dmi_rdata;
wire                        ic_busy; 

reg     [31:0]              i_p1iw_last_r; 
reg     [3:0]               i_dmp_be_a; 
wire    [31:0]              i_long_a; 
wire    [15:0]              i_word; 
wire    [7:0]               i_byte; 
wire    [31:0]              i_sxtl; 
wire    [31:0]              i_extl; 
wire                        i_iccm_busy_nxt; 
reg                         i_iccm_busy_r; 
wire    [31:0]              i_iccm_drd_nxt; 
reg     [31:0]              i_iccm_drd_r; 
reg     [1:0]               i_iccm_state_r; 
wire                        i_code_dmp_req_a; 
reg                         i_dmp_sex_r; 
reg     [1:0]               i_dmp_size_r; 
reg     [1:0]               i_dmp_addr_lsb_r; 
reg                         i_ld_rtn_again_r; 
reg                         i_code_ldvalid_r;
reg     [1:0]               i_dmp_shift_a;
   

//  The instruction cache busy signal is always tied low
//  because a ICCM RAM cannot coexist with an instruction
//  cache.
// 
assign ic_busy = 1'b 0; 

assign code_stall_ldst = 1'b 0;

// =========================================================
// 
//  ICCM RAM interface
// 
// =========================================================
//  ICCM RAM address
// 
assign code_ram_addr = (code_dmi_req == 1'b 1) ?
       code_dmi_addr[2+CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:2] : 
                       (i_code_dmp_req_a == 1'b 1) ?
       dmp_addr[2+CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:2] :

    next_pc[2+CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:2]; 

 // Endian aware write-data shifting:
   always @(dmp_addr)   
   begin : wdshift_calc_async_PROC

  // Little-endian: shift = long-word byte-offset
   i_dmp_shift_a = dmp_addr[1:0];
   end 

//  ICCM RAM write data
// 
assign code_ram_wdata = (code_dmi_req == 1'b 1) ?
       code_dmi_wdata : 
                        (i_dmp_shift_a == BYTE1) ?
       {dmp_dwr[23:0], dmp_dwr[31:24]} : 
                        (i_dmp_shift_a == BYTE2) ?
       {dmp_dwr[15:0], dmp_dwr[31:16]} : 
                        (i_dmp_shift_a == BYTE3) ?
       {dmp_dwr[7:0], dmp_dwr[31:8]} : 
       dmp_dwr; 

//  ICCM RAM write enable
// 
assign code_ram_wr = (((code_dmi_req == 1'b 1) & 
                       (code_dmi_wr == 1'b 1)) | 

                      ((dmp_mstore == 1'b 1) & 
                       (dmp_en3 == 1'b 1) & 
                       (is_code_ram == 1'b 1))) ?
       CODE_WR_ACTIVE : 
       CODE_RE_ACTIVE; 

//  ICCM RAM byte enable
// 
assign code_ram_be = (code_dmi_req == 1'b 1) ? code_dmi_be : 

                     (i_code_dmp_req_a == 1'b 1) ? i_dmp_be_a : 

               4'b 1111; 

//  ICCM RAM clock enable
// 
//  The ICCM RAM is enabled when:
// 
//     [1] During production test mode
//     [2] When there is a request on the DMI interface
//     [3] When there is a request on the DMP interface
//     [4] When there is a request on the ifetch interface
//     [5] The cycle after a DMI or DMP access in order to
//         update the read data.
// 
assign code_ram_ck_en = (test_mode      == 1'b 1) | 
                        (code_dmi_req   == 1'b 1) | 
                        (i_code_dmp_req_a == 1'b 1) | 
                        (ifetch == 1'b 1 & ck_disable == 1'b0) | 
                        (i_iccm_busy_r == 1'b 1) ? CODE_CK_EN_ACTIVE :

       ~CODE_CK_EN_ACTIVE; 

//  The ICCM RAM needs to be enabled one cycle after a DMP or 
//  DMI access, in order to update read data.
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : iccm_busy_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_iccm_busy_r <= 1'b 0;    
      end
   else
      begin
      i_iccm_busy_r <= i_iccm_busy_nxt;   
      end
   end

// =========================================================
// 
//  DMI interface
// 
// =========================================================

//  Read data 
// 
assign code_dmi_rdata = code_ram_rdata; 

// =========================================================
// 
//  DMP interface
// 
// =========================================================

//  Generation of the DMP request signal
// 
assign i_code_dmp_req_a = 

                 (((dmp_mload == 1'b 1) | (dmp_mstore == 1'b 1)) & 
                  (dmp_en3 == 1'b 1) & 
                  (is_code_ram == 1'b 1)) ? 1'b 1 : 
           1'b 0; 

//  Generation of the DMP byte enables
// 
always @(dmp_addr or dmp_size)
   begin : dmp_be_async_PROC

   case (dmp_size)

   //  Byte mask
   //
   LDST_BYTE:
      begin

      case (dmp_addr[1:0])
      BYTE0:
         begin
         i_dmp_be_a = BYTE0_MASK;
         end
      BYTE1:
         begin
         i_dmp_be_a = BYTE1_MASK;    
         end
      BYTE2:
         begin
         i_dmp_be_a = BYTE2_MASK;    
         end
      default:
         begin
         i_dmp_be_a = BYTE3_MASK;    
         end
      endcase
      end

   //  Word mask
   // 
   LDST_WORD:
      begin
      if (dmp_addr[1] == 1'b 0)
         begin
         i_dmp_be_a = WORD0_MASK;    
         end
      else
         begin
         i_dmp_be_a = WORD1_MASK;    
         end
      end

   //  Longword mask
   // 
   default:
      begin
      i_dmp_be_a = LONG_MASK;    
      end
   endcase
   end

//  Store DMP request data needed for the return data
// 
//  Part of the DMP's request is stored to allow return 
//  data to be processed on the next cycle. This is 
//  necessary in order to remember which byte lanes were
//  requested and whether return data needs to be sign 
//  extended.
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : dmp_req_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_dmp_size_r     <= {(TWO){1'b 0}};   
      i_dmp_addr_lsb_r <= {(TWO){1'b 0}};   
      i_dmp_sex_r      <= 1'b 0;    
      end
   else
      begin
      if ((dmp_mload == 1'b 1) & 
          (dmp_en3 == 1'b 1) & 
          (is_code_ram == 1'b 1))
         begin
         i_dmp_size_r     <= dmp_size;  
         i_dmp_addr_lsb_r <= dmp_addr[1:0]; 
         i_dmp_sex_r      <= dmp_sex;   
         end
      end
   end

//  Generation of DMP return data
//  
//  Requested byte lanes are sent back on the DMP 
//  interface. Return data (code_drd) always start
//  at bit 0 even if only the second, third or fourth 
//  byte lane was requested. Also, return data is 
//  extended or sign extended depending on the signal 
//  dmp_sex.
// 
assign i_long_a = code_ram_rdata; 

assign i_word = (i_dmp_addr_lsb_r[1] == 1'b 1) ? i_long_a[31:16] : 
    i_long_a[15:0]; 

assign i_byte = (i_dmp_addr_lsb_r[0] == 1'b 1) ? i_word[15:8] :
    i_word[7:0]; 

assign i_sxtl = (i_dmp_size_r == LDST_LWORD) ? i_long_a : 

                (i_dmp_size_r == LDST_BYTE) ? {{(TWENTY_FOUR){i_byte[7]}}, i_byte}:

            {{(SIXTEEN){i_word[15]}}, i_word}; 

assign i_extl = (i_dmp_size_r == LDST_LWORD) ? i_long_a : 

                (i_dmp_size_r == LDST_BYTE) ? {{(TWENTY_FOUR){1'b 0}}, i_byte} : 

            {{(SIXTEEN){1'b 0}}, i_word}; 

// Select whether to sign extended.
//
assign i_iccm_drd_nxt = (i_dmp_sex_r == 1'b 1) ? i_sxtl : 
       i_extl; 

//  If there is a returning load from the ICCM RAM on
//  the DMP interface that has been held back (hold_loc=1),
//  store the data so that it can be returned during
//  the next cycle.
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : iccm_drd_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_iccm_drd_r <= {(THIRTY_TWO){1'b 0}};    
      i_ld_rtn_again_r <= 1'b 0;    
      end
   else
      begin
      i_ld_rtn_again_r <= hold_loc & i_code_ldvalid_r;

      if ( (hold_loc         == 1'b 1) & 
           (i_code_ldvalid_r == 1'b 1) &
           (i_ld_rtn_again_r == 1'b 0) )
         begin
         i_iccm_drd_r <= i_iccm_drd_nxt;  
         end
      end
   end

//  Return data on the DMP interface
// 
//  If the return data did not manage to return on the 
//  previous cycle then return this stored data. Otherwise, 
//  return data directly from ICCM RAM output.
// 
assign code_drd = (i_ld_rtn_again_r == 1'b 1) ? i_iccm_drd_r : 
       i_iccm_drd_nxt; 

//  Generate a valid signal for the returning load.
// 
//  The valid signal is set if there was a DMP request that
//  was serviced on the previous cycle or if the load was 
//  not allowed to return and a new attempt is needed.
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : code_ldvalid_PROC
   if (rst_a == 1'b 1)
      begin
      i_code_ldvalid_r <= 1'b 0;    
      end
   else
      begin
      if (((dmp_mload == 1'b 1) & 
           (dmp_en3 == 1'b 1) & 
           (is_code_ram == 1'b 1)) | 

         ((hold_loc == 1'b 1) & 
          (i_code_ldvalid_r == 1'b 1)))
         begin
         i_code_ldvalid_r <= 1'b 1; 
         end
      else
         begin
         i_code_ldvalid_r <= 1'b 0; 
         end
      end
   end

assign code_ldvalid_r = i_code_ldvalid_r; 

// =========================================================
// 
//  Instruction fetch interface
// 
// =========================================================

//  The ICCM RAM is busy (as seen by the instruction fetch 
//  interface) when a request is issued on either the DMI or
//  the DMP interface.
// 
assign i_iccm_busy_nxt = code_dmi_req | 
                         i_code_dmp_req_a; 

//  Finite state machine
// 
//  Based entirely on the example in the aim ifetch section
//  Plus, added read capability. KS
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : iccm_fsm_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_iccm_state_r <= `ICCM_IDLE;   
      end
   else
      begin
      case (i_iccm_state_r)

         //Idle state - before any ifetches have been received.
         //
         `ICCM_IDLE:
            begin

            // If an Invalidate Instruction Cache (IVIC) signal is
            // received then remain in the idle state.
            //
            if (ivic == 1'b 1)

                i_iccm_state_r <= `ICCM_IDLE;

            else if (ifetch == 1'b 1)
               begin
               //  Move to active state if we receive an ifetch 
               //  and it can be accomodated. Move to wait state if
               //  we receive an ifetch and it cannot be accomodated.
               // 
               if (i_iccm_busy_nxt == 1'b 1)
                  begin
                  i_iccm_state_r <= `ICCM_STALL;  
                  end
               else
                  begin
                  i_iccm_state_r <= `ICCM_ACTIVE; 
                  end
               end
            else
               //  If not, stay where we are.
               // 
               begin
               i_iccm_state_r <= `ICCM_IDLE;  
               end
            end

         //  Ifetch Active state - an ifetch is underway this cycle!
         // 
         `ICCM_ACTIVE:
            begin

            // If an Invalidate Instruction Cache (IVIC) signal is
            // received then go to the idle state.
            //
            if (ivic == 1'b 1)

                i_iccm_state_r <= `ICCM_IDLE;

            //  Move to hold state if we do not receive another 
            //  ifetch and we will not have a RAM access on the next 
            //  cycle.
            // 
            else if (ifetch == 1'b 0 & i_iccm_busy_nxt == 1'b 1)
               begin
               i_iccm_state_r <= `ICCM_HOLD;  
               end

            //  Move to wait state if we do receive another ifetch
            //  which cannot be accomodated on this cycle.
            //
            else if (ifetch == 1'b 1 & i_iccm_busy_nxt == 1'b 1)
               begin
               i_iccm_state_r <= `ICCM_STALL; 
               end

            //  Otherwise, stay where we are if we will have access
            //  to the RAM on the next cycle.
            //
            else
               begin
               i_iccm_state_r <= `ICCM_ACTIVE;    
               end
            end

         //  Maintain the last correctly fetched instruction word.
         //
         `ICCM_HOLD:
            begin

            // If an Invalidate Instruction Cache (IVIC) signal is
            // received then go to the idle state.
            //
            if (ivic == 1'b 1)

                i_iccm_state_r <= `ICCM_IDLE;

            //  If the RAM will be available to us on the next cycle
            //  then return to the 'active ifetch state'
            // 
            else if (i_iccm_busy_nxt == 1'b 0)
               begin
               i_iccm_state_r <= `ICCM_ACTIVE;    
               end

            //  Move to wait state if we do receive another ifetch
            //  which cannot be accomodated on this cycle.
            // 
            else if (ifetch == 1'b 1 & i_iccm_busy_nxt == 1'b 1)
               begin
               i_iccm_state_r <= `ICCM_STALL; 
               end

            //  Remain in hold state if we do not receive another 
            //  ifetch and we will not have RAM access on the next 
            //  cycle.
            // 
            else
               begin
               i_iccm_state_r <= `ICCM_HOLD;  
               end
            end

            //  A collision has occured between the ifetch access and 
            //  some other type of access to the RAM. We tell the ARC 
            //  that no instruction is available, and wait until we have
            //  access again before we can fetch the instruction.
            // 

         `ICCM_STALL:
            begin

            // If an Invalidate Instruction Cache (IVIC) signal is
            // received then go to the idle state.
            //
            if (ivic == 1'b 1)

                i_iccm_state_r <= `ICCM_IDLE;

            //  If the RAM will be available to us on the next cycle,
            //  then return to the 'active ifetch state'.
            // 
            else if (i_iccm_busy_nxt == 1'b 0)
               begin
               i_iccm_state_r <= `ICCM_ACTIVE;    
               end
            else
               begin
               i_iccm_state_r <= `ICCM_STALL; 
               end
            end
         default: i_iccm_state_r <= `ICCM_IDLE;
      endcase
      end
   end

//  Hold the last instruction word when we are in the 'hold' state.
// 
assign p1iw = (i_iccm_state_r == `ICCM_HOLD) ?
       i_p1iw_last_r :
       code_ram_rdata; 

//  An instruction will only be available when we are in the 'active'
//  or 'instruction hold' states.
// 
assign ivalid = ( (i_iccm_state_r == `ICCM_ACTIVE)
                | (i_iccm_state_r == `ICCM_HOLD) 
                ) ? 1'b 1 : 
    1'b 0; 

//  Storage of last instruction fetched
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : hold_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_p1iw_last_r <= {(THIRTY_TWO){1'b 0}}; 
      end
   else
      //  Whenever the RAM actively supplies an instruction word,
      //  store it in case it is required on the next cycle
      // 
      begin
      if (i_iccm_state_r == `ICCM_ACTIVE)
         begin
         i_p1iw_last_r <= code_ram_rdata;   
         end
      end
   end

endmodule 
// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module if_sys(clk_ungated,
              code_ram_rdata,
              rst_a,
              test_mode,
              ck_disable,
              ivic,
              dmp_mload,
              dmp_mstore,
              next_pc,
              ifetch,
              dmp_dwr,
              dmp_en3,
              dmp_addr,
              dmp_size,
              dmp_sex,
              hold_loc,
              is_code_ram,
              code_dmi_req,
              code_dmi_addr,
              code_dmi_wdata,
              code_dmi_wr,
              code_dmi_be,
              code_ram_addr,
              code_ram_wdata,
              code_ram_wr,
              code_ram_be,
              code_ram_ck_en,
              code_stall_ldst,
              ic_busy,
              ivalid,
              p1iw,
              code_drd,
              code_ldvalid_r,
              code_dmi_rdata);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"


input  clk_ungated;
input  [31:0]  code_ram_rdata;
input  rst_a;
input  test_mode;
input  ck_disable;
input  ivic;
input  dmp_mload;
input  dmp_mstore;
input  [PC_MSB:0]  next_pc;
input  ifetch;
input  [31:0]  dmp_dwr;
input  dmp_en3;
input  [31:0]  dmp_addr;
input  [1:0]  dmp_size;
input  dmp_sex;
input  hold_loc;
input  is_code_ram;
input  code_dmi_req;
input  [31:0]  code_dmi_addr;
input  [31:0]  code_dmi_wdata;
input  code_dmi_wr;
input  [3:0]  code_dmi_be;
output [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0]  code_ram_addr;
output [31:0]  code_ram_wdata;
output code_ram_wr;
output [3:0]  code_ram_be;
output code_ram_ck_en;
output code_stall_ldst;
output ic_busy;
output ivalid;
output [31:0]  p1iw;
output [31:0]  code_drd;
output code_ldvalid_r;
output [31:0]  code_dmi_rdata;

wire clk_ungated;
wire  [31:0] code_ram_rdata;
wire rst_a;
wire test_mode;
wire ck_disable;
wire ivic;
wire dmp_mload;
wire dmp_mstore;
wire  [PC_MSB:0] next_pc;
wire ifetch;
wire  [31:0] dmp_dwr;
wire dmp_en3;
wire  [31:0] dmp_addr;
wire  [1:0] dmp_size;
wire dmp_sex;
wire hold_loc;
wire is_code_ram;
wire code_dmi_req;
wire  [31:0] code_dmi_addr;
wire  [31:0] code_dmi_wdata;
wire code_dmi_wr;
wire  [3:0] code_dmi_be;
wire  [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] code_ram_addr;
wire  [31:0] code_ram_wdata;
wire code_ram_wr;
wire  [3:0] code_ram_be;
wire code_ram_ck_en;
wire code_stall_ldst;
wire ic_busy;
wire ivalid;
wire  [31:0] p1iw;
wire  [31:0] code_drd;
wire code_ldvalid_r;
wire  [31:0] code_dmi_rdata;


// Intermediate signals


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)


// Instantiation of module iccm_control
iccm_control iiccm_control(
  .clk_ungated(clk_ungated),
  .rst_a(rst_a),
  .ck_disable(ck_disable),
  .test_mode(test_mode),
  .ivic(ivic),
  .code_ram_rdata(code_ram_rdata),
  .ifetch(ifetch),
  .next_pc(next_pc),
  .dmp_dwr(dmp_dwr),
  .dmp_en3(dmp_en3),
  .dmp_addr(dmp_addr),
  .dmp_mload(dmp_mload),
  .dmp_mstore(dmp_mstore),
  .dmp_size(dmp_size),
  .dmp_sex(dmp_sex),
  .hold_loc(hold_loc),
  .is_code_ram(is_code_ram),
  .code_dmi_req(code_dmi_req),
  .code_dmi_addr(code_dmi_addr),
  .code_dmi_wdata(code_dmi_wdata),
  .code_dmi_wr(code_dmi_wr),
  .code_dmi_be(code_dmi_be),
  .code_ram_addr(code_ram_addr),
  .code_ram_wdata(code_ram_wdata),
  .code_ram_wr(code_ram_wr),
  .code_ram_be(code_ram_be),
  .code_ram_ck_en(code_ram_ck_en),
  .p1iw(p1iw),
  .ivalid(ivalid),
  .code_drd(code_drd),
  .code_ldvalid_r(code_ldvalid_r),
  .code_dmi_rdata(code_dmi_rdata),
  .code_stall_ldst(code_stall_ldst),
  .ic_busy(ic_busy)
);


// Output drives

endmodule


// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module registers(clk_ungated,
                 code_ram_rdata,
                 en,
                 rst_a,
                 test_mode,
                 ck_disable,
                 clk,
                 s1en,
                 s2en,
                 en2,
                 mstore2b,
                 p2opcode,
                 p2subopcode,
                 p2iv,
                 en2b,
                 p2b_iv,
                 aux_addr,
                 aux_dataw,
                 aux_write,
                 h_addr,
                 h_read,
                 s1a,
                 s2a,
                 fs2a,
                 wba,
                 wbdata,
                 wben,
                 core_access,
                 sc_reg1,
                 sc_reg2,
                 ux2data_2_pc,
                 ux1data,
                 ux2data,
                 do_inst_step_r,
                 h_pcwr,
                 h_pcwr32,
                 ivic,
                 ldvalid,
                 dmp_mload,
                 dmp_mstore,
                 p1int,
                 p2int,
                 p2bint,
                 pcounter_jmp_restart_r,
                 regadr,
                 x_idecode2b,
                 en1,
                 ifetch_aligned,
                 pcen,
                 pcen_niv,
                 p2_dopred,
                 p2_dorel,
                 p2_iw_r,
                 p2_lp_instr,
                 p2_s1a,
                 p2_s2a,
                 p2condtrue,
                 p2limm,
                 p2minoropcode,
                 p2subopcode3_r,
                 p2subopcode4_r,
                 p2subopcode5_r,
                 p2subopcode6_r,
                 p2subopcode7_r,
                 p2b_abs_op,
                 p2b_alu_op,
                 p2b_arithiv,
                 p2b_blcc_a,
                 p2b_delay_slot,
                 p2b_dojcc,
                 p2b_jlcc_a,
                 p2b_limm,
                 p2b_lr,
                 p2b_neg_op,
                 p2b_not_op,
                 p2b_shift_by_one_a,
                 p2b_shift_by_three_a,
                 p2b_shift_by_two_a,
                 p2b_shift_by_zero_a,
                 p2b_shimm_data,
                 p2b_shimm_s1_a,
                 p2b_shimm_s2_a,
                 sc_load1,
                 sc_load2,
                 p4_docmprel,
                 loopcount_hit_a,
                 kill_p1_nlp_a,
                 kill_tagged_p1,
                 currentpc_r,
                 misaligned_target,
                 pc_is_linear_r,
                 next_pc,
                 last_pc_plus_len,
                 p2b_pc_r,
                 p2_target,
                 p2_s1val_tmp_r,
                 drd,
                 p3res_sc,
                 p3result,
                 lmulres_r,
                 hold_host,
                 cr_hostr,
                 h_status32,
                 dmp_dwr,
                 dmp_en3,
                 dmp_addr,
                 dmp_size,
                 dmp_sex,
                 hold_loc,
                 is_code_ram,
                 code_dmi_req,
                 code_dmi_addr,
                 code_dmi_wdata,
                 code_dmi_wr,
                 code_dmi_be,
                 code_ram_addr,
                 code_ram_wdata,
                 code_ram_wr,
                 code_ram_be,
                 code_ram_ck_en,
                 s1bus,
                 s2bus,
                 ext_s1val,
                 ext_s2val,
                 ivalid_aligned,
                 loop_kill_p1_a,
                 loop_int_holdoff_a,
                 loopend_hit_a,
                 p1iw_aligned_a,
                 code_stall_ldst,
                 s2val,
                 ic_busy,
                 aligner_do_pc_plus_8,
                 aligner_pc_enable,
                 ivalid,
                 loopstart_r,
                 p1inst_16,
                 do_loop_a,
                 qd_b,
                 x2data_2_pc,
                 s1val,
                 s2val_inverted_r,
                 dwr,
                 h_rr_data,
                 loopend_r,
                 sr_xhold_host_a,
                 p1iw,
                 code_drd,
                 code_ldvalid_r,
                 code_dmi_rdata);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"


input  clk_ungated;
input  [31:0]  code_ram_rdata;
input  en;
input  rst_a;
input  test_mode;
input  ck_disable;
input  clk;
input  s1en;
input  s2en;
input  en2;
input  mstore2b;
input  [4:0]  p2opcode;
input  [5:0]  p2subopcode;
input  p2iv;
input  en2b;
input  p2b_iv;
input  [31:0]  aux_addr;
input  [31:0]  aux_dataw;
input  aux_write;
input  [31:0]  h_addr;
input  h_read;
input  [5:0]  s1a;
input  [5:0]  s2a;
input  [5:0]  fs2a;
input  [5:0]  wba;
input  [31:0]  wbdata;
input  wben;
input  core_access;
input  sc_reg1;
input  sc_reg2;
input  [31:0]  ux2data_2_pc;
input  [31:0]  ux1data;
input  [31:0]  ux2data;
input  do_inst_step_r;
input  h_pcwr;
input  h_pcwr32;
input  ivic;
input  ldvalid;
input  dmp_mload;
input  dmp_mstore;
input  p1int;
input  p2int;
input  p2bint;
input  pcounter_jmp_restart_r;
input  [5:0]  regadr;
input  x_idecode2b;
input  en1;
input  ifetch_aligned;
input  pcen;
input  pcen_niv;
input  p2_dopred;
input  p2_dorel;
input  [INSTR_UBND:0]  p2_iw_r;
input  p2_lp_instr;
input  [5:0]  p2_s1a;
input  [5:0]  p2_s2a;
input  p2condtrue;
input  p2limm;
input  [5:0]  p2minoropcode;
input  [2:0]  p2subopcode3_r;
input  p2subopcode4_r;
input  [1:0]  p2subopcode5_r;
input  [2:0]  p2subopcode6_r;
input  [1:0]  p2subopcode7_r;
input  p2b_abs_op;
input  [1:0]  p2b_alu_op;
input  p2b_arithiv;
input  p2b_blcc_a;
input  p2b_delay_slot;
input  p2b_dojcc;
input  p2b_jlcc_a;
input  p2b_limm;
input  p2b_lr;
input  p2b_neg_op;
input  p2b_not_op;
input  p2b_shift_by_one_a;
input  p2b_shift_by_three_a;
input  p2b_shift_by_two_a;
input  p2b_shift_by_zero_a;
input  [12:0]  p2b_shimm_data;
input  p2b_shimm_s1_a;
input  p2b_shimm_s2_a;
input  sc_load1;
input  sc_load2;
input  p4_docmprel;
input  loopcount_hit_a;
input  kill_p1_nlp_a;
input  kill_tagged_p1;
input  [PC_MSB:0]  currentpc_r;
input  misaligned_target;
input  pc_is_linear_r;
input  [PC_MSB:0]  next_pc;
input  [PC_MSB:0]  last_pc_plus_len;
input  [PC_MSB:0]  p2b_pc_r;
input  [PC_MSB:0]  p2_target;
input  [DATAWORD_MSB:0]  p2_s1val_tmp_r;
input  [31:0]  drd;
input  [31:0]  p3res_sc;
input  [31:0]  p3result;
input  [63:0]  lmulres_r;
input  hold_host;
input  cr_hostr;
input  h_status32;
input  [31:0]  dmp_dwr;
input  dmp_en3;
input  [31:0]  dmp_addr;
input  [1:0]  dmp_size;
input  dmp_sex;
input  hold_loc;
input  is_code_ram;
input  code_dmi_req;
input  [31:0]  code_dmi_addr;
input  [31:0]  code_dmi_wdata;
input  code_dmi_wr;
input  [3:0]  code_dmi_be;
output [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0]  code_ram_addr;
output [31:0]  code_ram_wdata;
output code_ram_wr;
output [3:0]  code_ram_be;
output code_ram_ck_en;
output [31:0]  s1bus;
output [31:0]  s2bus;
output [31:0]  ext_s1val;
output [31:0]  ext_s2val;
output ivalid_aligned;
output loop_kill_p1_a;
output loop_int_holdoff_a;
output loopend_hit_a;
output [DATAWORD_MSB:0]  p1iw_aligned_a;
output code_stall_ldst;
output [31:0]  s2val;
output ic_busy;
output aligner_do_pc_plus_8;
output aligner_pc_enable;
output ivalid;
output [PC_MSB:0]  loopstart_r;
output p1inst_16;
output do_loop_a;
output [31:0]  qd_b;
output [31:0]  x2data_2_pc;
output [31:0]  s1val;
output s2val_inverted_r;
output [31:0]  dwr;
output [31:0]  h_rr_data;
output [PC_MSB:0]  loopend_r;
output sr_xhold_host_a;
output [31:0]  p1iw;
output [31:0]  code_drd;
output code_ldvalid_r;
output [31:0]  code_dmi_rdata;

wire clk_ungated;
wire  [31:0] code_ram_rdata;
wire en;
wire rst_a;
wire test_mode;
wire ck_disable;
wire clk;
wire s1en;
wire s2en;
wire en2;
wire mstore2b;
wire  [4:0] p2opcode;
wire  [5:0] p2subopcode;
wire p2iv;
wire en2b;
wire p2b_iv;
wire  [31:0] aux_addr;
wire  [31:0] aux_dataw;
wire aux_write;
wire  [31:0] h_addr;
wire h_read;
wire  [5:0] s1a;
wire  [5:0] s2a;
wire  [5:0] fs2a;
wire  [5:0] wba;
wire  [31:0] wbdata;
wire wben;
wire core_access;
wire sc_reg1;
wire sc_reg2;
wire  [31:0] ux2data_2_pc;
wire  [31:0] ux1data;
wire  [31:0] ux2data;
wire do_inst_step_r;
wire h_pcwr;
wire h_pcwr32;
wire ivic;
wire ldvalid;
wire dmp_mload;
wire dmp_mstore;
wire p1int;
wire p2int;
wire p2bint;
wire pcounter_jmp_restart_r;
wire  [5:0] regadr;
wire x_idecode2b;
wire en1;
wire ifetch_aligned;
wire pcen;
wire pcen_niv;
wire p2_dopred;
wire p2_dorel;
wire  [INSTR_UBND:0] p2_iw_r;
wire p2_lp_instr;
wire  [5:0] p2_s1a;
wire  [5:0] p2_s2a;
wire p2condtrue;
wire p2limm;
wire  [5:0] p2minoropcode;
wire  [2:0] p2subopcode3_r;
wire p2subopcode4_r;
wire  [1:0] p2subopcode5_r;
wire  [2:0] p2subopcode6_r;
wire  [1:0] p2subopcode7_r;
wire p2b_abs_op;
wire  [1:0] p2b_alu_op;
wire p2b_arithiv;
wire p2b_blcc_a;
wire p2b_delay_slot;
wire p2b_dojcc;
wire p2b_jlcc_a;
wire p2b_limm;
wire p2b_lr;
wire p2b_neg_op;
wire p2b_not_op;
wire p2b_shift_by_one_a;
wire p2b_shift_by_three_a;
wire p2b_shift_by_two_a;
wire p2b_shift_by_zero_a;
wire  [12:0] p2b_shimm_data;
wire p2b_shimm_s1_a;
wire p2b_shimm_s2_a;
wire sc_load1;
wire sc_load2;
wire p4_docmprel;
wire loopcount_hit_a;
wire kill_p1_nlp_a;
wire kill_tagged_p1;
wire  [PC_MSB:0] currentpc_r;
wire misaligned_target;
wire pc_is_linear_r;
wire  [PC_MSB:0] next_pc;
wire  [PC_MSB:0] last_pc_plus_len;
wire  [PC_MSB:0] p2b_pc_r;
wire  [PC_MSB:0] p2_target;
wire  [DATAWORD_MSB:0] p2_s1val_tmp_r;
wire  [31:0] drd;
wire  [31:0] p3res_sc;
wire  [31:0] p3result;
wire  [63:0] lmulres_r;
wire hold_host;
wire cr_hostr;
wire h_status32;
wire  [31:0] dmp_dwr;
wire dmp_en3;
wire  [31:0] dmp_addr;
wire  [1:0] dmp_size;
wire dmp_sex;
wire hold_loc;
wire is_code_ram;
wire code_dmi_req;
wire  [31:0] code_dmi_addr;
wire  [31:0] code_dmi_wdata;
wire code_dmi_wr;
wire  [3:0] code_dmi_be;
wire  [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] code_ram_addr;
wire  [31:0] code_ram_wdata;
wire code_ram_wr;
wire  [3:0] code_ram_be;
wire code_ram_ck_en;
wire  [31:0] s1bus;
wire  [31:0] s2bus;
wire  [31:0] ext_s1val;
wire  [31:0] ext_s2val;
wire ivalid_aligned;
wire loop_kill_p1_a;
wire loop_int_holdoff_a;
wire loopend_hit_a;
wire  [DATAWORD_MSB:0] p1iw_aligned_a;
wire code_stall_ldst;
wire  [31:0] s2val;
wire ic_busy;
wire aligner_do_pc_plus_8;
wire aligner_pc_enable;
wire ivalid;
wire  [PC_MSB:0] loopstart_r;
wire p1inst_16;
wire do_loop_a;
wire  [31:0] qd_b;
wire  [31:0] x2data_2_pc;
wire  [31:0] s1val;
wire s2val_inverted_r;
wire  [31:0] dwr;
wire  [31:0] h_rr_data;
wire  [PC_MSB:0] loopend_r;
wire sr_xhold_host_a;
wire  [31:0] p1iw;
wire  [31:0] code_drd;
wire code_ldvalid_r;
wire  [31:0] code_dmi_rdata;


// Intermediate signals
wire i_ivalid;
wire i_do_loop_a;
wire  [31:0] i_p1iw;
wire  [31:0] i_x1data;
wire  [31:0] i_x2data;
wire i_ifetch;


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)


// Instantiation of module coreregs
coreregs icoreregs(
  .en(en),
  .rst_a(rst_a),
  .test_mode(test_mode),
  .clk(clk),
  .s1en(s1en),
  .s2en(s2en),
  .en2(en2),
  .mstore2b(mstore2b),
  .p2iv(p2iv),
  .en2b(en2b),
  .p2b_iv(p2b_iv),
  .aux_addr(aux_addr),
  .aux_dataw(aux_dataw),
  .aux_write(aux_write),
  .h_addr(h_addr),
  .h_read(h_read),
  .s1a(s1a),
  .s2a(s2a),
  .fs2a(fs2a),
  .wba(wba),
  .wbdata(wbdata),
  .wben(wben),
  .core_access(core_access),
  .sc_reg1(sc_reg1),
  .sc_reg2(sc_reg2),
  .ldvalid(ldvalid),
  .p1int(p1int),
  .p2int(p2int),
  .p2bint(p2bint),
  .pcounter_jmp_restart_r(pcounter_jmp_restart_r),
  .regadr(regadr),
  .x_idecode2b(x_idecode2b),
  .en1(en1),
  .pcen(pcen),
  .p2_iw_r(p2_iw_r),
  .p2_lp_instr(p2_lp_instr),
  .p2_s1a(p2_s1a),
  .p2_s2a(p2_s2a),
  .p2condtrue(p2condtrue),
  .p2b_abs_op(p2b_abs_op),
  .p2b_alu_op(p2b_alu_op),
  .p2b_arithiv(p2b_arithiv),
  .p2b_blcc_a(p2b_blcc_a),
  .p2b_delay_slot(p2b_delay_slot),
  .p2b_jlcc_a(p2b_jlcc_a),
  .p2b_limm(p2b_limm),
  .p2b_lr(p2b_lr),
  .p2b_neg_op(p2b_neg_op),
  .p2b_not_op(p2b_not_op),
  .p2b_shift_by_one_a(p2b_shift_by_one_a),
  .p2b_shift_by_three_a(p2b_shift_by_three_a),
  .p2b_shift_by_two_a(p2b_shift_by_two_a),
  .p2b_shift_by_zero_a(p2b_shift_by_zero_a),
  .p2b_shimm_data(p2b_shimm_data),
  .p2b_shimm_s1_a(p2b_shimm_s1_a),
  .p2b_shimm_s2_a(p2b_shimm_s2_a),
  .sc_load1(sc_load1),
  .sc_load2(sc_load2),
  .loopcount_hit_a(loopcount_hit_a),
  .kill_p1_nlp_a(kill_p1_nlp_a),
  .currentpc_r(currentpc_r),
  .pc_is_linear_r(pc_is_linear_r),
  .last_pc_plus_len(last_pc_plus_len),
  .p2b_pc_r(p2b_pc_r),
  .p2_target(p2_target),
  .p2_s1val_tmp_r(p2_s1val_tmp_r),
  .drd(drd),
  .p3res_sc(p3res_sc),
  .p3result(p3result),
  .x1data(i_x1data),
  .x2data(i_x2data),
  .hold_host(hold_host),
  .cr_hostr(cr_hostr),
  .s1bus(s1bus),
  .s2bus(s2bus),
  .ext_s1val(ext_s1val),
  .ext_s2val(ext_s2val),
  .loop_kill_p1_a(loop_kill_p1_a),
  .loop_int_holdoff_a(loop_int_holdoff_a),
  .loopend_hit_a(loopend_hit_a),
  .s2val(s2val),
  .loopstart_r(loopstart_r),
  .do_loop_a(i_do_loop_a),
  .qd_b(qd_b),
  .s1val(s1val),
  .s2val_inverted_r(s2val_inverted_r),
  .dwr(dwr),
  .h_rr_data(h_rr_data),
  .loopend_r(loopend_r),
  .sr_xhold_host_a(sr_xhold_host_a)
);


// Instantiation of module xcoreregs
xcoreregs ixcoreregs(
  .clk(clk),
  .rst_a(rst_a),
  .p2minoropcode(p2minoropcode),
  .p2opcode(p2opcode),
  .p2subopcode(p2subopcode),
  .p2subopcode3_r(p2subopcode3_r),
  .p2subopcode4_r(p2subopcode4_r),
  .p2subopcode5_r(p2subopcode5_r),
  .p2subopcode6_r(p2subopcode6_r),
  .p2subopcode7_r(p2subopcode7_r),
  .lmulres_r(lmulres_r),
  .s1a(s1a),
  .s2a(s2a),
  .wba(wba),
  .wbdata(wbdata),
  .wben(wben),
  .ux2data_2_pc(ux2data_2_pc),
  .ux1data(ux1data),
  .ux2data(ux2data),
  .x2data_2_pc(x2data_2_pc),
  .x1data(i_x1data),
  .x2data(i_x2data)
);


// Instantiation of module inst_align
inst_align iinst_align(
  .clk(clk),
  .rst_a(rst_a),
  .p4_docmprel(p4_docmprel),
  .p2b_dojcc(p2b_dojcc),
  .p2_dorel(p2_dorel),
  .p2_dopred(p2_dopred),
  .do_loop_a(i_do_loop_a),
  .do_inst_step_r(do_inst_step_r),
  .en1(en1),
  .en2(en2),
  .en2b(en2b),
  .h_pcwr(h_pcwr),
  .h_pcwr32(h_pcwr32),
  .h_status32(h_status32),
  .ifetch_aligned(ifetch_aligned),
  .ivalid(i_ivalid),
  .ivic(ivic),
  .kill_tagged_p1(kill_tagged_p1),
  .misaligned_target(misaligned_target),
  .p1iw(i_p1iw),
  .pcounter_jmp_restart_r(pcounter_jmp_restart_r),
  .p2int(p2int),
  .p2limm(p2limm),
  .pcen_niv(pcen_niv),
  .ifetch(i_ifetch),
  .ivalid_aligned(ivalid_aligned),
  .p1inst_16(p1inst_16),
  .p1iw_aligned_a(p1iw_aligned_a),
  .aligner_do_pc_plus_8(aligner_do_pc_plus_8),
  .aligner_pc_enable(aligner_pc_enable)
);


// Instantiation of module if_sys
if_sys iif_sys(
  .clk_ungated(clk_ungated),
  .code_ram_rdata(code_ram_rdata),
  .rst_a(rst_a),
  .test_mode(test_mode),
  .ck_disable(ck_disable),
  .ivic(ivic),
  .dmp_mload(dmp_mload),
  .dmp_mstore(dmp_mstore),
  .next_pc(next_pc),
  .ifetch(i_ifetch),
  .dmp_dwr(dmp_dwr),
  .dmp_en3(dmp_en3),
  .dmp_addr(dmp_addr),
  .dmp_size(dmp_size),
  .dmp_sex(dmp_sex),
  .hold_loc(hold_loc),
  .is_code_ram(is_code_ram),
  .code_dmi_req(code_dmi_req),
  .code_dmi_addr(code_dmi_addr),
  .code_dmi_wdata(code_dmi_wdata),
  .code_dmi_wr(code_dmi_wr),
  .code_dmi_be(code_dmi_be),
  .code_ram_addr(code_ram_addr),
  .code_ram_wdata(code_ram_wdata),
  .code_ram_wr(code_ram_wr),
  .code_ram_be(code_ram_be),
  .code_ram_ck_en(code_ram_ck_en),
  .code_stall_ldst(code_stall_ldst),
  .ic_busy(ic_busy),
  .ivalid(i_ivalid),
  .p1iw(i_p1iw),
  .code_drd(code_drd),
  .code_ldvalid_r(code_ldvalid_r),
  .code_dmi_rdata(code_dmi_rdata)
);


// Output drives
assign ivalid                  = i_ivalid;
assign do_loop_a               = i_do_loop_a;
assign p1iw                    = i_p1iw;

endmodule


// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains logic for Program counter generation logic.
// This file does not include the flags - these are combined at
// the level above in order to produce the full 32-bit word seen
// by the ARC600 & the host.
//
//=========================== Inputs to this block ===========================--
//
// clk                             Core Clock
// 
// rst_a                           System Reset (Active high)
//
// aligner_do_pc_plus_8            This signal is true when an instruction
//                                 stream consists of word aligned 32-bit
//                                 instructions. As can be seen at time T the
//                                 16-bit instruction at address n is presented
//                                 (the high part of the next longword is stored
//                                 in the buffer). At T+1 the current PC is n+2.
//                                 The data requested (at time T) and returned
//                                 from memory at time T+1 is the longword at
//                                 n+4 (and therefore the half word at n+6 is
//                                 buffered).  To be able to present the
//                                 complete 32-bit instruction at n+6 the memory
//                                 address must be set to n+8, which is the
//                                 longword aligned version of PC+8 ( (n+2)+8 =
//                                 (n+10)&&0xfffffffc = n+8). This process will
//                                 continue until a 16-bit instruction or a jcc
//                                 /brcc/bcc instruction is encountered.
//                               
//                               
//                                         ////////////////////////////////
//                                         |              |               |
//                                    n    |    16-bit    |    32-bit_a0  |
//                                         |              |               |
//                                         ////////////////////////////////
//                                         |              |               |
//                                    n+4  |   32-bit_b0  |    32-bit_a1  |
//                                         |              |               |
//                                         ////////////////////////////////
//                                         |              |               |
//                                    n+8  |   32-bit_b1  |    32-bit_a2  |
//                                         |              |               |
//                                         ////////////////////////////////
//                                         |              |               |
//                                    n+12 |   32-bit_b2  |    xxxxxxx    |
//                                         |              |               |
//                                         ////////////////////////////////
//                               
//                               
// aligner_pc_enable                This signal is true when the instruction
//                                  aligner needs to fetch the longword from the
//                                  pc+4 address to be able to reconstruct a
//                                  word aligned 32-bit instruction or limm. if
//                                  a jcc/brcc/bcc as a word aligned target
//                                  which is also a 32-bit instruction the
//                                  aligner is unable to present the instruction
//                                  immediatly.  The aligner must stall stage 1
//                                  (this is done by forcing ivalid_aligned to
//                                  false) and request the n+4 longword. When
//                                  the n+4 longword is returned the aligner can
//                                  construct the complete instruction from the
//                                  buffered high word at address n+2 and the
//                                  low word at address n+4.
//                               
//                                       ////////////////////////////////
//                                       |              |               |
//                                  n    |    xxxxxx    |    32-bit_a0  |
//                                       |              |               |
//                                       ////////////////////////////////
//                                       |              |               |
//                                  n+4  |   32-bit_b0  |    xxxxxxxxx  |
//                                       |              |               |
//                                       ////////////////////////////////
//                               
// awake_a                          This signal allows the PC signal sent to
//                                  the cache to be synchronized with the
//                                  internally stored PC when re-awakening from
//                                  reset or a cache invalidate.
//                                 
// en2                              Pipeline stage 2 enable. When this signal is
//                                  true, the instruction in stage 2 can pass
//                                  into stage 2B at the end of the cycle. When
//                                  it is false, it will hold up stage 2 and
//                                  stage 1 (pcen).
//                                 
// en2b                             Pipeline stage 2B enable. When this signal
//                                  is true, the instruction in stage 2b can
//                                  pass into stage 3 at the end of the cycle.
//                                  When it is false, it will hold up stage 2B,
//                                  stage 2 and stage 1 (pcen).
//                                 
// en3                              Pipeline stage 3 enable. When this signal is
//                                  true, the instruction in stage 3 can pass
//                                  into stage 4 at the end of the cycle. When
//                                  it is false, it will probably hold upstage
//                                  1, 2 and 2b (pcen, en2), along with stage 3.
//                                 
// h_dataw [31:0]                   Host Write Data. Data to be written from the
//                                  host.
//                                 
// h_pcwr                           From aux_regs. This signal is set true when
//                                  the host is attempting to write to the pc/
//                                  status register, and the machine is stopped.
//                                  It is used to trigger an instruction fetch
//                                  when the PC is written when the machine is
//                                  stopped. This is necessary to ensure the
//                                  correct instruction is executed when the
//                                  machine is restarted. It is also used to
//                                  latch the new PC value.
//                                 
// h_pcwr32                         From aux_regs. This signal is set true when
//                                  the host is attempting to write to the
//                                  32-bit pc register, and the machine is
//                                  stopped. It is used to trigger an
//                                  instruction fetch when the PC is written
//                                  when the machine is stopped. This is
//                                  necessary to ensure the correct instruction
//                                  is executed when the machine is restarted.
//                                 
// int_vec  [PC_MSB:0]              This is the interrupt vector supplied to the 
//                                  program counter. Each interrupt line has a
//                                  different vector associated with it. It is
//                                  latched into the PC at the end of the cycle
//                                  when p2int is true.
//                                 
// ivalid                           Qualifying signal for p1iw[31:0]. When it is
//                                  low, this indicates that the m/c has not
//                                  been able to fetch the requested opcode, and
//                                  that the program counter should not be
//                                  incremented. The pipeline might be stalled,
//                                  depending upon whether the instruction in
//                                  stage 2 needs to look at the instruction in
//                                  stage 1. When it is true, the instruction is
//                                  clocked into pipeline stage 2 provided that
//                                  the pipeline is able to move on.
//                                  
// ivalid_aligned                   This signal is true when the ivalid signal
//                                  from the ifetch interface is true except
//                                  when the aligner need to get the next
//                                  longword to be able to reconstruct the
//                                  current instruction. See explanation of
//                                  aligner_pc_enable.
//                                 
// 
// loopstart_r [PC_MSB:0]           Zero delay loop start address.
//                                 
// p1inst_16                        This signal is true when the instrucion
//                                  forwarded is a 16-bit type.
//                                 
// p2_jblcc_a                       True when stage 2 contains a valid jump&link
//                                  or branch & link instruction
//                                 
// p2_abs_neg_a                     Stage 2 abs and negs instruction decode
//                                 
// p2_brcc_instr_a                  Stage 2 compare&branch instruction decode.
//                                 
// p2_dorel                         True when a relative branch (not jump) is
//                                  going to happen. Relates to the instruction
//                                  in stage 2. Includes p2iv.
//                                 
// p2_iw_r [INSTR_UBND:0]           Stage 2 instruction word. 
//                                 
// p2_not_a                         True when stage 2 has decoded a NOT
//                                  instruction.
//                                 
// p2_s1a [5:0]                     Stage 2 source 1 register address field.
//                                 
// p2_s1en                          Stage 2 source 1 register address field
//                                  enable.
//                                 
// p2b_dojcc                        True when a jump is going to happen.
//                                  Relates to the instruction in stage 2b.
//                                  Includes p2b_iv.
//       
// p2b_shimm_data [12:0]            This bus carries the short immediate data
//                                  encoded on the instruction word. It is used
//                                  by coreregs when one of the source (s1a/
//                                  fs2a) registers being referenced is one of
//                                  the short immediate registers.It always
//                                  provides the region of the instruction where
//                                  the short immediate data would be found,
//                                  regardless of whether short immediate data
//                                  is being used.
//                                 
// p2b_shimm_s1_a                   operand 1 requires the short immediate data
//                                  carried in p2b_shimm_data
//                                 
// p2delay_slot                     Stage 2 instruction has a delay slot. This
//                                  signal is set true when the instruction in
//                                  stage 2 uses a delay slot.  This signal does
//                                  not have an information about the delay slot
//                                  instruction itself.
//                                 
// p2int                            From int_unit. This signal indicates that an
//                                  interrupt jump instruction (fantasy
//                                  instruction) is currently in stage 2. This
//                                  signal has a number of consequences
//                                  throughout the system, causing the interrupt
//                                  vector (int_vec) to be put into the PC, and
//                                  causing the old PC to be placed into the
//                                  pipeline in order to be stored into the
//                                  appropriate interrupt link register.
//                                  Note that p2int and p2iv are mutually
//                                  exclusive.
//                                 
// p2limm                           Indicates that the instruction in stage 2
//                                  will use long immediate data.
//                                 
// p2lr                             This is true when p2opcode = oldo, and 
//                                  p2iw(13) = '1', which indicates that the
//                                  instruction is the auxiliary register load
//                                  instruction LR, not a memory load LD
//                                  instruction. This signal is used by coreregs
//                                  to switch the currentpc_r bus onto the
//                                  source2 bus (which is then passed through
//                                  the same logic as the interrupt link
//                                  register) in order to get the correct value
//                                  of PC when it is read by an LR instruction.
//                                  Does not include p2iv.
//                                 
// p2offset [targz:0]               This is the 24-bit relative address from the
//                                  instruction in stage 2. It is sign-extended
//                                  and added to the stage 2 program counter
//                                  when a branch is to take place.
//                                 
// p4_docmprel                      Stage 4 control transfer is in progress
//                                  during the cycle.
//                                 
// pcen                             Program counter enable. When this signal is
//                                  true, the PC will change at the end of the
//                                  cycle, indicating that the memory controller
//                                  needs to do a fetch on the next cycle using
//                                  the address which will appear on currentpc,
//                                  which is supplied from aux_regs.
//                                  This signal is affected by interrupt logic
//                                  and all the other pipeline stage enables
//                                 
// pcen_niv                         Same as above but with the ivalid_aligned
//                                  qualification
//                                 
// fs2a[5:0]                        from rctl. The source 2 register address
//                                  live and direct from the stage 2B latches.
//                                  It is muxed with the host address to allow
//                                  host accesses to registers when the ARC 600
//                                  is stopped, before being output on s1a[5:0].
//                                 
// p2_dopred                        Stage 2 changed PC to PC+branch offset due
//                                  to compare & branch prediction.
// p2_dopred_nds                    Same as above except on true when the
//                                  compare&branch has a no delay slot.
//                                 
// do_loop_a                        From loopcnt. This signals that a ZD loop
//                                  loopback will happen when en1 is true.
//                                 
// p2b_dopred_ds                    Stage 2b contains a compare&branch that has
//                                  been predicited taken. The branch also has a
//                                  delay slot.
//
// step                             From debug. Do a single step on the next cycle, if
//                                  the ARC is stopped.
//
// inst_step                        When this signal is set at the same time as the step
//                                  signal is set a single instruction step occurs. Only
//                                  one instruction is fetched and allowed to complete.
//
//========================== Output from this block ==========================--
//
// currentpc_nxt  [PC_MSB:PC_LSB]   This bus containts the next program counter
//                                  value to be written to the architectual
//                                  program counter register.
//                                 
// currentpc_r  [PC_MSB:0]          This bus is the current value of the
//                                  architectual program counter register.
//                                 
// misaligned_target                This signal is true when bit 1 of the
//                                  program counter register is set. It
//                                  signifies that the the current address is
//                                  a word address.
//                                 
// pc_is_linear_r                   This signal is only true when the program
//                                  counter has moved lineraly from it's last
//                                  address to the courrent address.  This
//                                  signal is also cleared when a host access
//                                  has modified the program counter.
//                                 
// next_pc  [PC_MSB:0]              This is the next address the machine
//                                  requires from the instruction cache system
//                                 
// running_pc  [PC_MSB:0]           This is the next program counter when the
//                                  machine is in free running mode.  This
//                                  signal is used by the multi-way instruction
//                                  cache to save power. This is achieved by not
//                                  enabling the tag or data rams if the same
//                                  cache line is being accessed.
//                                 
// last_pc_plus_len  [PC_MSB:0]     This bus contains the registered (in to
//                                  stage 2B) value of the program counter plus
//                                  the length of the current instruction.
//                                 
// p2_pc_r  [PC_MSB:0]              The program counter value for the
//                                  instruction in stage 2.
//                                 
// p2b_pc_r   [PC_MSB:0]            The program counter value for the
//                                  instruction in stage 2b.
//                                 
// p2_target  [PC_MSB:0]            This is the target address for the
//                                  branch/loop instruction in stage2.
//                                 
// p2_s1val_tmp_r  [PC_MSB:0]       This bus is used in cr_int. This signal is
//                                  used to early generate some of the values to
//                                  be placed on the source 1 in the next stage.
//                                  This has been done for static timing reasons.
//                                 
// pcounter_jmp_restart_r           This signal is true when a delayed control
//                                  transfer is pending.  If a control transfer
//                                  is resolved and the Instruction cache system
//                                  is busy fetching i.e. there is no
//                                  instruction in stage 1 ivalid_aligned = '0'
//                                  then the cache cannot accept any more
//                                  fetches.  This is reconised and this bit is
//                                  set, when the cache becomes free the machine
//                                  will do the program counter update.
//
//============================================================================--
//
module pcounter  (clk,
              rst_a,
              aligner_do_pc_plus_8,
              aligner_pc_enable,
              awake_a,
              en2,
              en2b,
              en3,
              h_dataw,
              h_pcwr,
              h_pcwr32,
              int_vec,
              ivalid,
              ivalid_aligned,
              loopstart_r,
              p1inst_16,
              p2_jblcc_a,
              p2_abs_neg_a,
              p2_brcc_instr_a,
              p2_dorel,
              p2_iw_r,
              p2_not_a,
              p2_s1a,
              p2_s1en,
              p2b_dojcc,
              p2b_shimm_data,
              p2b_shimm_s2_a,
              p2delay_slot,
              p2int,
              p2limm,
              p2lr,
              p2offset,
              p4_docmprel,
              pcen,
              pcen_niv,
              fs2a,
              p2_dopred,
              p2_dopred_nds,
              p2b_dopred_ds,
              do_loop_a,
              qd_b,
              x2data_2_pc,
	      step,
	      inst_step, 

              currentpc_nxt,
              currentpc_r,
              misaligned_target,
              pc_is_linear_r,
              next_pc,
              running_pc,
              last_pc_plus_len,
              p2_pc_r,
              p2b_pc_r,
              p2_target,
              p2_s1val_tmp_r,
              pcounter_jmp_restart_r,
              pcounter_jmp_restart_a);
   
`include "arcutil_pkg_defines.v" 
`include "arcutil.v" 
`include "extutil.v" 

   input                  clk; //  core clock
   input                  rst_a; //  system reset
   input                  aligner_do_pc_plus_8; 
   input                  aligner_pc_enable; 
   input                  awake_a; 
   input                  en2; 
   input                  en2b; 
   input                  en3; 
   input [31:0]           h_dataw; 
   input                  h_pcwr; 
   input                  h_pcwr32; 
   input [PC_MSB:0]       int_vec; 
   input                  ivalid; 
   input                  ivalid_aligned; 
   input [PC_MSB:0]       loopstart_r; 
   input                  p1inst_16; 
   input                  p2_jblcc_a; 
   input                  p2_abs_neg_a; 
   input                  p2_brcc_instr_a; 
   input                  p2_dorel; 
   input [INSTR_UBND:0]   p2_iw_r; 
   input                  p2_not_a; 
   input [5:0]            p2_s1a; 
   input                  p2_s1en; 
   input                  p2b_dojcc; 
   input [12:0]           p2b_shimm_data; 
   input                  p2b_shimm_s2_a; 
   input                  p2delay_slot; 
   input                  p2int; 
   input                  p2limm; 
   input                  p2lr; 
   input [TARGSZ:0]       p2offset; 
   input                  p4_docmprel; 
   input                  pcen; 
   input                  pcen_niv; 
   input [5:0]            fs2a; 
   input                  p2_dopred; 
   input                  p2_dopred_nds; 
   input                  p2b_dopred_ds;
   input                  do_loop_a; 
   input [31:0]           qd_b;
   input [31:0]           x2data_2_pc; 
   input                  step;
   input                  inst_step;

   output [PC_MSB:PC_LSB]  currentpc_nxt; 
   output [PC_MSB:0]       currentpc_r; 
   output                  misaligned_target; 
   output                  pc_is_linear_r;
   output [PC_MSB:0]       next_pc; 
   output [PC_MSB:0]       running_pc; 
   output [PC_MSB:0]       last_pc_plus_len; 
   output [PC_MSB:0]       p2_pc_r; 
   output [PC_MSB:0]       p2b_pc_r; 
   output [PC_MSB:0]       p2_target; 
   output [DATAWORD_MSB:0] p2_s1val_tmp_r; 
   output                  pcounter_jmp_restart_r; 
   output                  pcounter_jmp_restart_a; 
   wire   [PC_MSB:PC_LSB]  currentpc_nxt; 
   wire   [PC_MSB:0]       currentpc_r; 
   wire                    misaligned_target; 
   wire                    pc_is_linear_r;
   wire   [PC_MSB:0]       next_pc; 
   wire   [PC_MSB:0]       running_pc; 
   wire   [PC_MSB:0]       last_pc_plus_len; 
   wire   [PC_MSB:0]       p2_pc_r; 
   wire   [PC_MSB:0]       p2b_pc_r; 
   wire   [PC_MSB:0]       p2_target; 
   wire   [DATAWORD_MSB:0] p2_s1val_tmp_r; 
   wire                    pcounter_jmp_restart_r; 
   wire                    pcounter_jmp_restart_a; 
   wire   [2:0]            i_bottom_bits_plus_1_a; 
   wire   [2:0]            i_bottom_bits_plus_2_a; 
   wire   [PC_MSB:PC_LSB]  i_core_pc_a; 
   wire   [PC_MSB:PC_LSB]  i_ctrl_trfer_pc_a; 
   wire                    i_ctrl_trfer_pc_flg_a;
   wire                    i_ctrl_trfer_pc_flg_nlp_a; 
   wire [PC_MSB:PC_LSB]    i_currentpc_nxt; 
   reg  [PC_MSB:PC_LSB]    i_currentpc_r; 
   wire [PC_MSB:PC_LSB + 1] i_currentpc_to_cache_nxt; 
   reg  [PC_MSB:PC_LSB + 1] i_currentpc_to_cache_r; 
   reg                     i_do_restart_r; 
   reg                     i_do_restart_nxt;
   wire   [PC_MSB:PC_LSB]  i_hwrite_a; 
   wire                    i_jcc_s2a_eq_core_reg_a; 
   wire                    i_jcc_s2a_eq_limm_a; 
   wire                    i_jcc_s2a_eq_pc_a; 
   wire                    i_jcc_s2a_eq_xcore_reg_a; 
   wire                    i_misalign_target_a; 
   wire   [PC_MSB:3]       i_no_ripple_val_a; 
   wire                    i_p2_ctrl_trfer_a; 
   wire   [PC_MSB:PC_LSB]  i_p2_ctrl_trfer_pc_a; 
   wire                    i_p2_do_rel_a; 
   reg    [PC_MSB:PC_LSB]  i_p2_pc_r; 
   wire   [PC_MSB:PC_LSB]  i_p2_pc_tmp; 
   reg    [PC_MSB:LONGWORD_LSB] i_p2b_pc_r; 
   wire                    i_p2b_ctrl_trfer_a; 
   wire   [PC_MSB:PC_LSB]  i_p2b_ctrl_trfer_pc_a; 
   wire   [DATAWORD_MSB:0] i_p2_s1val_tmp_nxt; 
   reg    [DATAWORD_MSB:0] i_p2_s1val_tmp_r; 
   reg    [PC_MSB:PC_LSB]  i_p3_target_buffer_r; 
   reg    [PC_MSB:PC_LSB]  i_p4_target_buffer_r; 
   wire   [PC_MSB:PC_LSB]  i_pc_or_hwrite_a; 
   wire   [PC_MSB:PC_LSB]  i_pc_plus_2_a; 
   wire   [PC_MSB:PC_LSB]  i_pc_plus_4_a; 
   wire   [PC_MSB:PC_LSB]  i_pc_plus_8_a; 
   wire   [PC_MSB:PC_LSB]  i_pc_plus_inst_length_a; 
   reg    [PC_MSB:PC_LSB]  i_last_pc_plus_len_r;   
   wire                    i_pcounter_pcen_a; 
   wire                    i_pcounter_pcen_n_a; 
   reg                     i_pc_is_linear_r; 
   reg    [PC_MSB:PC_LSB]  i_restart_addr_r; 
   wire   [PC_MSB:3]       i_ripple_val_a; 
   reg    [PC_MSB:PC_LSB]  i_running_a; 
   wire   [2:0]            i_running_sel_a; 
   wire                    i_s1_sel_currentpc_a; 
   wire                    i_s1_sel_pc_a; 
   wire   [PC_MSB:PC_LSB]  i_sext_p2offset_a; 
   wire   [DATAWORD_MSB:0] i_shimm_sext_a; 
   wire   [PC_MSB:PC_LSB]  i_stopped_a; 
   wire   [PC_MSB:PC_LSB]  i_stopped_path1_a; 
   wire   [PC_MSB:PC_LSB]  i_stopped_path2_a; 
   wire   [PC_MSB:PC_LSB]  i_target_buffer_nxt; 
   wire   [PC_MSB:PC_LSB + 1]  i_target_buffer_tmp; 
   wire                    i_aligner_pc_en_iv_a; 
   wire                    i_aligner_pc_en_iv_n_a; 
   wire                    i_s1_sel_target_addr_a; 
   wire                    i_s1_sel_p2_pc_a; 
 
//------------------------------------------------------------------------------
// Stage 2 source 1 early generate.
//------------------------------------------------------------------------------
//
// This signal is used to ease the timing on the generation of source 1 operand
// value in the next stage.  Rather that having to mux in all the signals and
// values below in the next stage they are done here, registered and muxed in as
// one in the next stage.
//
   // Decode of the stage 2 source 1 register address field.  This signal is
   // true when the current stage 2 source 1 address field is r63 or current PC.
   //
   assign i_s1_sel_currentpc_a = ((p2_s1a == RCURRENTPC) & (p2_s1en == 1'b 1)) ?
          1'b 1 : 
          1'b 0; 


   // Decode used to select the program counter of the instruction in stage 2 on
   // to the bus.
   //
   assign i_s1_sel_pc_a = (p2lr          | 
                           p2_dopred_nds | 
                           p2_jblcc_a &
                           (~p2delay_slot) & 
                           (~p2limm)); 

   // Decode for the target address for the branch/loop insturtcion
   // 
   assign i_s1_sel_target_addr_a = ((~p2_dopred) & p2_brcc_instr_a); 

   // Select the current architectual program counter.
   //   
   assign i_s1_sel_p2_pc_a = (p2int | i_s1_sel_currentpc_a); 
   

   // When reading from r63 the result should be longword aligned
   //
   assign i_p2_pc_tmp = ({i_p2_pc_r[PC_MSB:LONGWORD_LSB],
                         (i_p2_pc_r[PC_LSB] & 
                         (~i_s1_sel_currentpc_a))});
   
   // Mux all results together.
   //   
   assign i_p2_s1val_tmp_nxt = (({i_p2_pc_tmp, ONE_ZERO})         &
                                ({(PC_SIZE){i_s1_sel_p2_pc_a}})       |
                        
                                ({i_target_buffer_nxt, ONE_ZERO}) &
                                ({(PC_SIZE){i_s1_sel_target_addr_a}}) |
                        
                                ({i_currentpc_r, ONE_ZERO})       &
                                ({(PC_SIZE){i_s1_sel_pc_a}})          |
                        
                                THIRTY_TWO_ONES                 &
                                ({(PC_SIZE){p2_not_a}})               |
                        
                                THIRTY_TWO_ZERO                 &
                                ({(PC_SIZE){p2_abs_neg_a}})); 
  
   // Add the offset to the last PC_value+instruction_length to get the branch
   // target address.
   //
   // Adding the offset to the current program counter value has certain
   // related to loops - breakpoints (branches) cannot be placed in the last
   // instruction position in a loop, for example. In addition, branches cannot
   // be executed as the delay slot of another branch - this is not such a big
   // problem however.
   //
   // Sign extend value from branch.
   //
   assign    i_sext_p2offset_a = {{(PC_MSB - TARGSZ){p2offset[TARGSZ]}}, p2offset};

//------------------------------------------------------------------------------
// Target Adder
//------------------------------------------------------------------------------
//
   // Instatiation of adder for target address calculation
   //
   assign     i_target_buffer_tmp = i_sext_p2offset_a[PC_MSB:LONGWORD_LSB] + (i_p2_pc_r[PC_MSB:LONGWORD_LSB]);


   assign  i_target_buffer_nxt = {i_target_buffer_tmp,
                                  i_sext_p2offset_a[PC_LSB]};


   // Address and data storage registers
   //
   always @(posedge clk or posedge rst_a)
    begin : p2_pc_PROC
      if (rst_a == 1'b 1)
        begin
          i_p2_pc_r            <= {(PC_MSB - PC_LSB + 1){1'b 0}};   
          i_p2b_pc_r           <= {(PC_MSB - LONGWORD_LSB + 1){1'b 0}};   
          i_p2_s1val_tmp_r     <= {(DATAWORD_WIDTH){1'b 0}};   
          i_p3_target_buffer_r <= {(PC_MSB - PC_LSB + 1){1'b 0}};   
          i_p4_target_buffer_r <= {(PC_MSB - PC_LSB + 1){1'b 0}};   
          i_last_pc_plus_len_r <= {(PC_MSB - PC_LSB + 1){1'b 0}};   
        end
      else
        begin
          //  Update the previous PC value when we update the current PC
          //  value.
          // 
          if (pcen == 1'b 1)
            begin
              i_p2_pc_r            <= i_currentpc_r[PC_MSB:PC_LSB];   
              i_last_pc_plus_len_r <= i_pc_plus_inst_length_a;   
            end

          if (en2 == 1'b 1)
            begin
              i_p2_s1val_tmp_r <= i_p2_s1val_tmp_nxt;

              // Move the program counter value for the instruction entering
              // stage 2b along with it.
              //
              i_p2b_pc_r <= i_p2_pc_r[PC_MSB:LONGWORD_LSB];   
            end

          // The processor will wait for it's delay slot so we can get it the
          // correct address of the instruction after the delay slot. (because
          // it knows the length of the delay slot).
          //
          if (en2b == 1'b 1)
            begin
              if (p2b_dopred_ds == 1'b 1)
               begin
                  i_p3_target_buffer_r <= i_last_pc_plus_len_r;   
               end
              else
               begin
                  i_p3_target_buffer_r <= i_p2_s1val_tmp_r[PC_MSB:PC_LSB];   
               end
            end
          if (en3 == 1'b 1)
            begin
              i_p4_target_buffer_r <= i_p3_target_buffer_r;   
            end
        end
    end 
   

//------------------------------------------------------------------------------
//  Current PC + 2/4/8
//------------------------------------------------------------------------------
//
   // The purpose of the following logic is to allow pc+2,pc+4,pc+8 to
   // be generated every cycle.
   // 
   assign i_no_ripple_val_a = i_currentpc_r[PC_MSB:3]; 

   //  29-bit half-adder
   //
   assign i_ripple_val_a = i_currentpc_r[PC_MSB:3] + 1'b 1; 

   //  Three bit half-adder
   //
   assign i_bottom_bits_plus_1_a = {ONE_ZERO, i_currentpc_r[2:PC_LSB]} + 1'b 1; 

   //  Three-bit half-adder
   //
   assign i_bottom_bits_plus_2_a = i_bottom_bits_plus_1_a + 1'b 1; 

   //  29-bit mux
   //
   assign i_pc_plus_2_a[PC_MSB:3] = (i_bottom_bits_plus_1_a[2] == 1'b 0) ?
          i_no_ripple_val_a : 
          i_ripple_val_a; 

   assign i_pc_plus_2_a[2:PC_LSB] = i_bottom_bits_plus_1_a[PC_LSB:0]; 

   //  29-bit mux
   //
   assign i_pc_plus_4_a[PC_MSB:3] = (i_bottom_bits_plus_2_a[2] == 1'b 0) ?
          i_no_ripple_val_a : 
          i_ripple_val_a;
   
//------------------------------------------------------------------------------
// PC plus 4
//------------------------------------------------------------------------------

   assign i_pc_plus_4_a[2:PC_LSB] = i_bottom_bits_plus_2_a[PC_LSB:0]; 
 
//------------------------------------------------------------------------------
// PC plus 8
//------------------------------------------------------------------------------
 
   assign i_pc_plus_8_a = {i_ripple_val_a, i_currentpc_r[2:PC_LSB]};

//------------------------------------------------------------------------------
// Current program counter plus the instruction length
//------------------------------------------------------------------------------
//   
   assign i_pc_plus_inst_length_a = (p1inst_16 == 1'b 1) ? i_pc_plus_2_a : 
          i_pc_plus_4_a; 

//------------------------------------------------------------------------------
//  Stage 2 Program counter values
//------------------------------------------------------------------------------
//
   assign i_p2_do_rel_a = (p2_dorel | p2_dopred);
   
   assign i_p2_ctrl_trfer_a = (p2int | i_p2_do_rel_a); 

   // AND-OR mux
   //
   assign i_p2_ctrl_trfer_pc_a = (int_vec[PC_MSB:PC_LSB] &
                                  ({(PC_MSB){p2int}}) 
                                                           | 
                                  i_target_buffer_nxt    &
                                  ({(PC_MSB){i_p2_do_rel_a}})); 

//------------------------------------------------------------------------------
// Stage 2B Program counter values
//------------------------------------------------------------------------------
//
   // Sign-extend the short immediate data to 32 bits
   //
   assign i_shimm_sext_a = {{(NINETEEN){p2b_shimm_data[SHIMM_MSB]}}, 
                            p2b_shimm_data[SHIMM_MSB:0]}; 

   assign i_jcc_s2a_eq_limm_a = ((fs2a == RLIMM) & (~p2b_shimm_s2_a)) ? 1'b 1 : 
          1'b 0; 

   assign i_jcc_s2a_eq_core_reg_a = ((~fs2a[OPERAND_MSB]) & (~p2b_shimm_s2_a)); 

   assign i_jcc_s2a_eq_pc_a = ((fs2a == RCURRENTPC) & (~p2b_shimm_s2_a)) ? 1'b 1 : 
          1'b 0; 

   assign i_jcc_s2a_eq_xcore_reg_a = (~(i_jcc_s2a_eq_core_reg_a | 
                                       p2b_shimm_s2_a          | 
                                       i_jcc_s2a_eq_limm_a     | 
                                       i_jcc_s2a_eq_pc_a)); 

   assign i_p2b_ctrl_trfer_a = p2b_dojcc; 

   // Stage 2b jumps can reference both registers and short/long immediate data.
   //  
   assign i_p2b_ctrl_trfer_pc_a = (i_shimm_sext_a[PC_MSB:PC_LSB] &
                                   ({(PC_MSB){p2b_shimm_s2_a}})          | 
                           
                                   qd_b[PC_MSB:PC_LSB]           &
                                   ({(PC_MSB){i_jcc_s2a_eq_core_reg_a}}) | 
                           
                                   p2_iw_r[PC_MSB:PC_LSB]        &
                                   ({(PC_MSB){i_jcc_s2a_eq_limm_a}})     | 
                           
                                   i_p2_pc_r                     &
                                   ({(PC_MSB){i_jcc_s2a_eq_pc_a}})       | 
                           
                                   x2data_2_pc[PC_MSB:PC_LSB]    &
                                   ({(PC_MSB){i_jcc_s2a_eq_xcore_reg_a}})); 


//------------------------------------------------------------------------------
// Control transfer request
//------------------------------------------------------------------------------
//
   // This signal is true when a control transfer is in the pipeline (except
   // zero-delay loops).
   //
   assign i_ctrl_trfer_pc_flg_nlp_a = (i_do_restart_r           | 
                                       i_p2b_ctrl_trfer_a       | 
                                       i_p2_ctrl_trfer_a        |
                                       p4_docmprel);

   // This signal includes the zero delay loops.
   //
   assign i_ctrl_trfer_pc_flg_a = (i_ctrl_trfer_pc_flg_nlp_a |
                                   do_loop_a);
   

//------------------------------------------------------------------------------
// Select control transfer next program counter value.
//------------------------------------------------------------------------------
//
   // Select the highest priority (i.e. the control transfer futherest down the
   // pipeline) control transfer.
   //
   // The priorites are as follows:
   //
   // (1) Compare & branch
   // (2) Jumps
   // (3) Branches and Interrupts
   // (4) delayed control transfer
   // (5) Zero delay loops
   //  
   // This priority encoder is coded in this way for static timing reasons.
   //
   assign i_ctrl_trfer_pc_a = ((i_p2_ctrl_trfer_a == 1'b 1) & 
                               ((i_p2b_ctrl_trfer_a | p4_docmprel) == 1'b 0)) ?
        i_p2_ctrl_trfer_pc_a : 
                              (p4_docmprel == 1'b 1) ? 
        i_p4_target_buffer_r : 
                              (i_p2b_ctrl_trfer_a == 1'b 1) ? 
        i_p2b_ctrl_trfer_pc_a : 
                              (i_do_restart_r == 1'b 1) ? 
        i_restart_addr_r : 
        // Loops are detected in stage 1
        //
        loopstart_r[PC_MSB:PC_LSB]; 

//------------------------------------------------------------------------------
// Select the correct PC
//------------------------------------------------------------------------------
//
   // If a control transfer is present then select it's PC else move the PC on
   // linearsly.
   //
   assign i_core_pc_a = (i_ctrl_trfer_pc_flg_a == 1'b 1) ? i_ctrl_trfer_pc_a : 
          i_pc_plus_inst_length_a; 


//------------------------------------------------------------------------------
// Host write logic
//------------------------------------------------------------------------------
// Program counter cannot be written to by the host when ARC600 is running. The
// enable signal pcen cannot be true when ARC is halted.
// 
   // Break instruction decode included here since it is typically a critical
   // path from the cache data RAM.
   //
   assign i_hwrite_a = (h_pcwr == 1'b 1) ?
          {SIX_ZERO, h_dataw[OLD_PC_MSB:0], ONE_ZERO} : 
          h_dataw[PC_MSB:PC_LSB]; 

   assign i_pc_or_hwrite_a = ((h_pcwr | h_pcwr32) == 1'b 1) ?  i_hwrite_a : 
          i_currentpc_r[PC_MSB:PC_LSB]; 

//------------------------------------------------------------------------------
// Select host or core PC
//------------------------------------------------------------------------------
//
   // This is the PC of the instruction in stage one rather than the address
   // presented to the instruction fetch interface since some aligning is
   // performed before the instruction is received.
   //
   assign i_currentpc_nxt = (i_pcounter_pcen_a == 1'b 1) ? 
          i_core_pc_a : 
          i_pc_or_hwrite_a; 

//------------------------------------------------------------------------------
// program counter registers
//------------------------------------------------------------------------------
//
   always @(posedge clk or posedge rst_a)
    begin : pc_reg_sync_PROC
      if (rst_a == 1'b 1)
        begin
          
          // The latches which make up the PC are defined below. The reset
          // vector (`IVECTOR0) is automatically loaded into the register when rst_a
          // is true.
          //
          i_currentpc_r          <= `IVECTOR0_PC;   
          i_currentpc_to_cache_r <= `IVECTOR0_PC1;   
          i_pc_is_linear_r       <= 1'b 0;   
        end
      else
        begin

          if ((h_pcwr | h_pcwr32) == 1'b 1)
            begin
              i_pc_is_linear_r <= 1'b 0;
            end
          else
            if (pcen == 1'b 1 | (step & inst_step))
             begin
               i_pc_is_linear_r <= (~i_ctrl_trfer_pc_flg_nlp_a);   
             end

          i_currentpc_r <= i_currentpc_nxt;   
          i_currentpc_to_cache_r <= i_currentpc_to_cache_nxt;   
        end
    end

   //  The current PC of a word aligned instruction.
   //  

   assign i_misalign_target_a = 
   
   
   i_currentpc_r[PC_LSB];

//------------------------------------------------------------------------------
// Delayed control transfer logic
//------------------------------------------------------------------------------
//
// To allow control transfer instructions to move freely down the pipeline
// without the need to stall them in their resolution stage whilst the cache
// becomes free this logic is required.  The logic detects when both a control
// transfer (except loops) and the cache is busy (ivalid_aligned = '0').  The
// address for the control transfer is stored for use when the cache becomes
// free.  When it does the address is fetched and the machine continues in
// normal running mode.
//

always @( pcen or i_p2b_ctrl_trfer_a or en2b or i_p2_ctrl_trfer_a or en2
          or p4_docmprel or ivalid_aligned or i_do_restart_r )
  begin
    if( pcen == 1'b1 )
      i_do_restart_nxt = 1'b0;
    else if(((i_p2b_ctrl_trfer_a & en2b | 
               i_p2_ctrl_trfer_a & en2 | 
               p4_docmprel) == 1'b 1) & (ivalid_aligned == 1'b 0))
      i_do_restart_nxt = 1'b1;
    else
      i_do_restart_nxt = i_do_restart_r;
  end

always @( posedge clk or posedge rst_a )
  begin
    if( rst_a == 1'b1 )  i_do_restart_r <= 1'b0;
    else                 i_do_restart_r <= i_do_restart_nxt;      
  end

   always @(posedge clk or posedge rst_a)
    begin : restart_PROC
      if (rst_a == 1'b 1)
        begin
          i_restart_addr_r <= {(PC_MSB - PC_LSB + 1){1'b 0}};   
        end
      else
        begin
          if ((((i_p2b_ctrl_trfer_a & en2b) | 
             (i_p2_ctrl_trfer_a & en2) | 
             p4_docmprel) == 1'b 1) & (ivalid_aligned == 1'b 0) &
              (pcen == 1'b0))
            begin
              i_restart_addr_r <= i_ctrl_trfer_pc_a;   
            end
        end
    end

//------------------------------------------------------------------------------
// PC value to cache system Revised PC Muxer
//------------------------------------------------------------------------------
//
// This Muxer has been entirely rewritten based on an analysis of which program
// counter values are required under which circumstances. After this analysis,
// optimizations have been applied to balance the mux logic to reduce the
// critical paths related to signals from the incoming instruction (i.e.
// p1inst_16, BRK decode, p1iw_aligned_a etc). Signals from the p2limm decode
// are also fairly late arriving it seems.
// 
// I$ invalidate
//
// When the instruction cache is invalidated, the 16-bit instruction buffer in
// the aligner block is cleared.
// 
// As a consequence, a new instruction fetch is issued from the core to restart
// instruction fetching at the current program counter. This is required since
// any ifetch which was issued simultaneously with the ivic would be ignored by
// the instruction cache.
//
// The PC-value-to-cache signal is resynchronized to the architectural PC on
// reset and on restart after ivic, using the awake_a signal. 
// 
// The first ifetch that is actually used is the first one AFTER the ivic. When
// the processor is running this will be on the cycle immediately after ivic,
// but when it is halted, the first ifetch will be when the processor is
// restarted.
//
   assign i_aligner_pc_en_iv_a = (aligner_pc_enable & ivalid); 
  
   assign i_aligner_pc_en_iv_n_a = ((~aligner_pc_enable) | (~ivalid)); 

   assign i_stopped_a = (i_stopped_path1_a &
                         ({(PC_MSB){i_aligner_pc_en_iv_a}}) |
     
                        i_stopped_path2_a &
                        ({(PC_MSB){i_aligner_pc_en_iv_n_a}})); 

   assign i_stopped_path1_a = ((h_pcwr | h_pcwr32) == 1'b 1) ?
          i_hwrite_a : 
                               (awake_a == 1'b 1) ?
          i_currentpc_r : 
          i_pc_plus_4_a; 

   assign i_stopped_path2_a = ((h_pcwr | h_pcwr32) == 1'b 1) ?
          i_hwrite_a : 
                               (awake_a == 1'b 1) ?
          i_currentpc_r : 
          {i_currentpc_to_cache_r, ONE_ZERO}; 

   assign i_running_sel_a = {i_ctrl_trfer_pc_flg_a, awake_a,
                             aligner_do_pc_plus_8};
   
   always @(i_ctrl_trfer_pc_a or i_currentpc_r or i_pc_plus_4_a or
            i_pc_plus_8_a or i_running_sel_a)
    begin : running_PROC
      case (i_running_sel_a)
        
        //  Misaligned linear instruction fetch.
        // 
        3'b 001:
         begin
            i_running_a = i_pc_plus_8_a;
         end

        //  Non-linear instruction fetch.
        // 
        3'b 101,
        3'b 100:
            begin
               i_running_a = i_ctrl_trfer_pc_a;
            end

        //  Aligned linear instruction fetch or misaligned instruction
        //  fetch with cache invalidate.
        //
        3'b 000:
         begin
            i_running_a = i_pc_plus_4_a;
         end

        //  Awaking after a reset or ivic
        // 
        default:
         begin
            i_running_a = i_currentpc_r;   
         end
      endcase
    end

   //  This pcen signal provides a minor speed-up.
   // 
   // 
   //  Note that with the revised PC muxer, aligner_pc_enable does not
   //  included ivalid - which is fine here since this decode is only
   //  true when ivalid = '1'. 
   // 
   assign i_pcounter_pcen_a = (pcen_niv & ivalid & (~aligner_pc_enable));
   
   assign i_pcounter_pcen_n_a = ((~pcen_niv) | (~ivalid) | aligner_pc_enable); 

   //  Next program counter value to the cache system. This takes into
   //  account the adjustments required for misaligned instruction
   //  accesses.
   // 
   assign i_currentpc_to_cache_nxt = (i_running_a[PC_MSB:2] &
                                      ({(PC_MSB-PC_LSB){i_pcounter_pcen_a}}) 
                                     | 
                                      i_stopped_a[PC_MSB:2] &
                                      ({(PC_MSB-PC_LSB){i_pcounter_pcen_n_a}}));

//------------------------------------------------------------------------------
// Output Drives
//------------------------------------------------------------------------------
// 
   //  Drive outputs from internal signals
   //
   assign currentpc_nxt = i_currentpc_nxt; 
   assign currentpc_r = {i_currentpc_r, ONE_ZERO}; 
   assign last_pc_plus_len = {i_last_pc_plus_len_r, ONE_ZERO}; 
   assign misaligned_target = i_misalign_target_a; 
   assign next_pc = {i_currentpc_to_cache_nxt, TWO_ZERO}; 
   assign p2_pc_r = {i_p2_pc_r, ONE_ZERO}; 
   assign p2b_pc_r = {i_p2b_pc_r, TWO_ZERO}; 
   assign p2_s1val_tmp_r = i_p2_s1val_tmp_r; 
   assign p2_target = {i_target_buffer_nxt, ONE_ZERO}; 
   assign pc_is_linear_r = i_pc_is_linear_r; 
   assign pcounter_jmp_restart_r = i_do_restart_r; 
   assign pcounter_jmp_restart_a = i_do_restart_nxt;
   assign running_pc = {i_running_a, ONE_ZERO}; 

endmodule // module pcounter
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This is the Clock control module. This module generates the clock
// gating signals. If clock gating has not been selected this module
// is empty.
//
//======================= Inputs to this block =======================--
//
// clk_ungated        U The ungated core clock which is always the same as
//                    clk_in. It is never gated even if clock gating has
//                    been selected. It is connected to the modules that
//                    control the ARC interfaces, the timer and the
//                    clock control.
//
//  en                U Global enable signal
//
// ctrl_cpu_start_r   This signal comes from the 'ctrl_cpu_start' input
//                    and will start the ARC running when it is halted.
//
//  do_inst_step_r    This signal is set when the single step flag (SS)
//                    and the instruction step flag (IS) in the debug
//                    register has been written to simultaneously through
//                    the host interface. It indicates that an instruction
//                    step is being performed. When the instruction step
//                    has finished this signal goes low.
//
// sleeping_r2        This is the pipelined version of sleeping for use by
//                    clock gating. Sleep mode (zz) flag in the debug
//                    register (bit 23).
//
//  p123int           U Indicates that there is an interrupt in stage 1,
//                    2 or 3. This signal is used by the clock
//                    generation module. If the option clock gating was
//                    not chosen this signal is removed during synthesis.
//
// host_rw            U This signal is true when an host access occurs,
//                    that is either a write (h_write = '1') or a read
//                    (h_read = '1').
//
// p4_disable_r       L This signals to the ARC that the pipeline has
//                    been flushed due to a breakpoint or sleep
//                    instruction. If it was due to a breakpoint
//                    instruction the ARC is halted via the 'en' bit,
//                    and the AH bit is set to '1' in the debug
//                    register.
//
// mem_access         U This signal is true if the main memory is being
//                    accessed and false otherwise.
//
// lpending           U Indicates to ARC that there is at least one load
//                    pending. It is the inverse of the empty flag from
//                    the scoreboard.
//
// instr_pending_r    U This signal is true when an instruction fetch has
//                    been issued, and it has not yet completed. It is not
//                    true directly after a reset before the ARC has
//                    started, as no instruction fetch will have been
//                    issued.
//
// ic_busy            U No Invalidate Instruction Cache. This signal is set
//                    true by the I-Cache, to indicate that no instruction
//                    cache invalidate requests (ivic) are to be made as the
//                    cache is busy. It is set true during tag clearing and
//                    line loads from memory.
// 
// pcp_wr_rq          U Debug interface write request. This is produced by
//                    the debug interface (PC/JTAG port).
//
// pcp_rd_rq          U Debug interface read request. This is produced by
//                    the  debug interface (PC/JTAG port).
//
// dc_full_r          L Data Cache Buffer Full. This signal is set true when
//                    the data cache buffer is full.
//
// dc_all_busy        U Data Cache Busy. This signal is set true by
//                    the cache to indicate that it is busy.
//
// fl_busy_r          Flush Buffer Busy Indicator.
//
// bcu_act            L This signal indicates that a burst transfer is
//                    in progress. This signal only exists for xy-
//                    memory.
//
// xym_en_ck          L This signal is set when any of the XY memory
//                    dmi request lines are asserted.
//
// wd_clear           Set when a timer watchdog reset is in progress.
//
// mload2b            Set when a load is in pipeline stage 2b.
//
// mstore2b           Set when a store is in pipeline stage 2b.
//
// cgm_dcache_idle    From mwdc_state, set when Dcache is idle.
//
// cgm_queue_idle     From ldst_queue, set when queue is idle.
//
// cgm_cmd_access     From xaux_regs, set when a Dcache control
//                    register is being accessed.

// is_local_ram       This signal is true when the address (dmp_addr) is
//                    within the address ranges of either the code RAM or
//                    the LD/ST RAM.
//
// debug_if_r        Debug Memory Access. This is asserted true when a debug
//                   access to memory is in progress.

//
//======================== Output from this block ====================--
//
// ck_disable         L This is the disable signal that gates the clock
//                    ck if the ARC is ready to be temporarily shut
//                    down.
// 
// ck_gated           U This is the signal that indicates to the host
//                    interface that the ARC is shut down. Host accesses
//                    are held of in the host interface until the ARC
//                    has woken up.
//
// ck_dmp_gated       The DMP clock domain is gated when this is true.
//
//====================================================================--
//
module ck_ctrl (
   clk_ungated,
   rst_a,
   test_mode,
   ctrl_cpu_start_sync_r,
   do_inst_step_r,
   sleeping_r2,
   en,
   q_busy,
   p123int,
   host_rw,
   p4_disable_r,
   mem_access,
   lpending,
   instr_pending_r,
   ic_busy,
   wd_clear,
   mload2b,
   mstore2b,
   dmp_mload,
   dmp_mstore,
   is_local_ram,
   debug_if_r,
   cgm_queue_idle,
   ibus_busy,
   pcp_rd_rq,
   pcp_wr_rq,

   ctrl_cpu_start_r,
   ck_disable,
   ck_gated,
   ck_dmp_gated);

`include "arcutil_pkg_defines.v" 
`include "arcutil.v"

   input   clk_ungated; 
   input   rst_a; 
   input   test_mode; 
   input   ctrl_cpu_start_sync_r;
   input   do_inst_step_r;
   input   sleeping_r2; 
   input   en;
   input   q_busy; 
   input   p123int; 
   input   host_rw; 
   input   p4_disable_r; 
   input   is_local_ram;
   input   debug_if_r;
   input   mem_access; 
   input   lpending; 
   input   instr_pending_r; 
   input   ic_busy;
   input   wd_clear;
   input   mload2b;
   input   mstore2b;
   input   dmp_mload;
   input   dmp_mstore;
   input   cgm_queue_idle;
   input   ibus_busy;
   input   pcp_rd_rq; 
   input   pcp_wr_rq; 

   output   ctrl_cpu_start_r;
   output   ck_disable; 
   output   ck_gated; 
   output   ck_dmp_gated;

   wire     ctrl_cpu_start_r;
   wire     ck_disable; 
   wire     ck_gated; 
   wire     ck_dmp_gated;
   reg      i_ctrl_cpu_start_r;
   reg      ick_dmp_disable;
   reg      i_ck_disable_r;
   reg     [1:0] i_postrst_count_r;
   wire    i_justafter_rst;

    reg     i_pcp_rq_ongoing_r;

   // -------------------------------------------------------------------------
   //  Main clock gate (controls clk)
   // 
   //  Provided that clock gating has been selected (CK_GATING = '1') the
   //  clock is gated if:
   // 
   //    1.  The ARC is halted (en = '0') and the external start is low
   //        (ctrl_cpu_start_r = '0'), or is sleeping after the
   //        pipeline has been flushed (sleeping_r2 = '1' and
   //        p4_disable_r = '1') and there is no pending instruction step
   //        (do_inst_step_r = '0').
   //    2.  There are no loads pending (lpending = '0')
   //    3.  The main memory is not being accessed (mem_access = '0')
   //    4.  The host is not accessing the ARC (host_rw = '0)
   //    5.  There is no pending instruction fetch (instr_pending_r = '0').
   //    6.  The instruction cache is not busy (ic_busy = '0').
   //    7.  The data cache buffer is empty (dc_full_r = '0').
   //    8.  The data cache is not busy (dc_all_busy = '0').
   //    9.  The host is not requesting to read (pcp_rd_rq = '0').
   //    10. The host is not requesting to write (pcp_wr_rq = '0').
   //    11. The xymemory is not bursting (bcu_act = '0').
   //    12. There is not a DMI request to XY memory (xym_en_ck = '0').
   //    13. There are no interrupt requests to service (p123int = '0').
   //    14. There is not a watchdog timer reset in progress.
   //    15. The data cache flush buffer is not busy (fl_busy_r = '0').
   // 
   // -------------------------------------------------------------------------
   always @(posedge clk_ungated or posedge rst_a)
     begin : disable_sync_PROC
            
      if (rst_a == 1'b 1)
         begin
         i_ck_disable_r <= 1'b 0; 
         end
      else 
          begin
            if (((en == 1'b 0 && i_ctrl_cpu_start_r == 1'b0) ||
               (sleeping_r2 == 1'b 1 && p4_disable_r == 1'b 1 && do_inst_step_r == 1'b 0)) & 
               do_inst_step_r == 1'b 0 && 
               lpending == 1'b 0 && 
                mem_access == 1'b 0 && 
               host_rw == 1'b 0 && 
               instr_pending_r == 1'b 0 && 
               ic_busy == 1'b 0 && 
                ibus_busy == 1'b 0 &&
	       q_busy == 1'b0 &&
               pcp_wr_rq == 1'b 0 &&
               pcp_rd_rq == 1'b 0 &&
              i_pcp_rq_ongoing_r == 1'b 0 &&
               p123int == 1'b 0 &&
               wd_clear == 1'b0 &&
               i_justafter_rst == 1'b 0)
   
               begin
               i_ck_disable_r <= 1'b 1;   
               end
            else
               begin
               i_ck_disable_r <= 1'b 0;   
               end
            end
         end


   assign ck_disable = i_ck_disable_r; 

   // -------------------------------------------------------------------------
   //  DMP clock gate (controls clk_dmp)
   // 
   //  Provided that clock gating has been selected (CK_GATING = '1') the
   //  DMP clock is gated independantly of the main clock when:
   // 
   // 1. There are no ld / st instructions about to happen (mload2b==0 and mstore2b==0)
   // 2. There are no accesses to the Dcache control registers (cgm_cmd_access==0)
   // 3. The Dcache is idle (cgm_dcache_idle==1)
   // 4. The ldst_queue is idle (cgm_queue==1)
   // 5. The score board is empty (lpending == 0)
   // 6. It's not just after reset
   //
   // -------------------------------------------------------------------------
   always @(posedge clk_ungated or posedge rst_a)
     begin : dmp_disable_sync_PROC 
      if (rst_a == 1'b 1)
        begin
          ick_dmp_disable <= 1'b 0; 
        end
        else 
        begin
          if (
               host_rw   == 1'b 0 &&
               pcp_wr_rq == 1'b 0 &&
               pcp_rd_rq == 1'b 0 &&
               mload2b == 1'b 0 &&
                  mstore2b == 1'b 0 &&
               dmp_mload == 1'b 0 &&
                  dmp_mstore == 1'b 0 &&
              cgm_queue_idle == 1'b 1 &&
               lpending == 1'b 0 &&
                  i_justafter_rst == 1'b 0 
             )
          begin
            ick_dmp_disable <= 1'b 1;   
          end
          else
          begin
            ick_dmp_disable <= 1'b 0;   
          end
        end
     end 
   
   // -----------------------------------------------------------------
   // Running after hardware reset
   //
   // Immediately after a global hardware reset, clock gating must be 
   // prevented from occurring until the arc_start_a value has been 
   // evaluated. If arc_start_a (see flags module) is set to 1 then the
   // processor starts running immediately after hardware reset. If 
   // arc_start is cleared then the processor remains halted after 
   // hardware reset. It takes two clock cycles after hardware reset
   // to evaluate arc_start_a, during which clock gating is not allowed
   // to occur.
   //
   // -----------------------------------------------------------------
   
   always @(posedge clk_ungated or posedge rst_a)
     begin: holdoff_ckgating
   
     if (rst_a == 1'b 1)
        begin
        i_postrst_count_r <= 2'b 0;
         end
     else
        begin
           i_postrst_count_r[0] <= 1'b 1;
           i_postrst_count_r[1] <= i_postrst_count_r[0];
           end
   
     end
   
   assign i_justafter_rst = (i_postrst_count_r == 2'b 11) ? 1'b 0: 1'b 1;
      
   // indicates whether the address phase of debug access is ongoing
   //
   always @(posedge clk_ungated or posedge rst_a)
     begin: pcp_rq_ongoing_PROC
     
      if (rst_a == 1'b 1)
         begin
         i_pcp_rq_ongoing_r <= 1'b 0;
         end
      else
         begin
         if (((pcp_wr_rq == 1'b 1) | (pcp_rd_rq == 1'b 1)) &
               debug_if_r==1'b1 & is_local_ram==1'b0)
            i_pcp_rq_ongoing_r <= 1'b 1;
         else if (mem_access == 1'b 1)
            i_pcp_rq_ongoing_r <= 1'b 0;
         end
      end

   // -------------------------------------------------------------------------
   // Register the start pin and release it once the core is running.
   // This is essential since the start pin must also clear the H bit
   // which is on the gated clock domian.
   //
   // -------------------------------------------------------------------------

   always @(posedge clk_ungated or posedge rst_a)
      begin : startpin_PROC        
       if (rst_a == 1'b 1)
          begin
          i_ctrl_cpu_start_r <= 1'b 0; 
          end   
       else
         begin
	 if (ctrl_cpu_start_sync_r == 1'b1)
	   begin
	   i_ctrl_cpu_start_r <= 1'b1;
	   end
	 else
	   begin
	   if (en == 1'b1)
	     begin
	     i_ctrl_cpu_start_r <= 1'b0;
	     end
	   end
 	end
      end
     
   // -------------------------------------------------------------------------
   //  Clock gated signal
   // 
   //  This signals is high when the main clock is gated and the ARC is not
   //  in test mode. It is used in hostif.v to hold off the host.
   // 
   // -------------------------------------------------------------------------
   
   assign ck_gated = i_ck_disable_r & ~test_mode;

   // DMP clock gating signal
   //
   assign ck_dmp_gated = ick_dmp_disable;  

   // External start signal to 'H' bit
   //
   assign ctrl_cpu_start_r = i_ctrl_cpu_start_r;
 

     

endmodule
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This module contains all the necessary logic to control the interrupts
// in the ARC600.
// 
// The ARC600 interrupt system can be extended to provide altogether 29
// interrupt lines. There are still only two priority levels, level 1
// (low priority) and level 2 (medimum priority) but the interrupts
// priority levels of each interrupt signal is now programmable
// on-the-fly through an auxiliary register.
//  
// There is a relatively large number of interrupt signals that need to 
// go through a priority encoder to select the highest priority active 
// interrupt. A priority encoder with more than 24 lines can produce a
// critical path in the system. Thus the encoder is now pipelined in
// two stages. This adds to the number of flipflops in this module but
// ensures that no new critical path is introduced in the system. As a
// side effect, the detection of an interrupt has now an added one cycle
// latency.
// 
// ========================= Inputs to this block =====================--
// 
//    clk_ungated The core ungated clock signal.
// 
//    rst_a       The global system reset signal.
// 
//    aux_write   From auxiliary unit to indicate that a write to an
//                auxiliary register is happening. The logic in this 
//                module checks for the matching register address and if
//                so then allows the  update to the selected register to
//                take place.
// 
//   aux_addr     From auxiliary unit to carry the address of the aux reg
//                that is being accessed. The address is compared to the 
//                int_unit aux register addresses and if matched then the 
//                selected register is updated with the aux data value.
// 
//   aux_wdata    From the auxiliary unit that carries the data value for 
//                an aux register write. If the write strobe is asserted
//                and the aux address register matches one the addresses
//                in this unit then the int_unit aux register is updated
//                with the new data value on this bus.
// 
//    irq3        L Original low Priority (level 1) interrupt signals. 
//    irq4        These signals are level sensitive by default but can be
//    irq5        programmed to be pulse sensitive. The priority level
//                can also be programmed to be medium level.
// 
//    irq6        L Original med Priority (level 2) interrupt signals. 
//    irq7        These signals are level sensitive by default but can be
//                programmed to be pulse sensitive. The priority level
//                can also be programmed to be low level.
// 
//    irq8        L extension interrupt lines - level sensitive and low
//    ...         priority by default but can be programmed to be pulse 
//    irq31       sensitive or medium priority.
// 
//    instruction_error
//                Instruction error. Generated by rctl and handled as
//                an pulse-sensitive input in this file.
//                It comes from a decode of the instruction opcode field,
//                combined with the signal from the extensions which
//                indicates whether an extension instruction is valid or
//                not. It does not currently include a decode of the
//                instruction's C field for single-operand instructions.
// 
//    memory_error
//                U Memory error. pulse sensitive input for the memory 
//                controller to use.
// 
//    en1         U Stage 2 pipeline latch control. True when an
//                instruction is being latched into pipeline stage 2.
//                Will be true at different times to pcen, as it allows
//                junk instructions to be latched into the pipeline. Used
//                in this case to  allow the interrupt-flag/fantasy
//                instruction to be passed down the pipeline.
// 
//    en2         U Stage 3 pipeline latch control. Controls transition 
//                of instruction in stage 2 to stage 3. Used here for
//                passing the interrupt down the pipeline correctly.
// 
//    en3         U Stage 4 pipeline latch control. Controls transition
//                of instruction in stage 3 to stage 4. Used here for
//                passing the interrupt down the pipeline correctly.
// 
//    interrupt_holdoff
//                U Hold off interrupts during this cycle. This signal is
//                set true by rctl.v to prevent an interrupt-op from
//                being inserted when a jump is in stage 2 (no interrupts
//                during delay slots) or when an instruction which uses 
//                long immediate data is in stage 2. This signal (or a
//                similar one) will be used in pipectl to prevent junk
//                instructions being inserted into the pipeline when
//                there is an interdependancy between the instructions
//                in stage 2 and the instruction in stage 1. Note that
//                this signal includes p2iv.
// 
//    e1flag_r      L from flags.v. The level 1 interrupt mask bit. 
// 
//    e2flag_r      L from flags.v. The level 2 interrupt mask bit. 
// 
// ======================== Output from this block ====================--
//
//    p1int       U indicates that an interrupt has been detected, and an
//                interrupt-op will be inserted into stage 2 on the next
//                cycle, (subject to pipeline enables) setting p2int
//                true. This signal will have the effect of cancelling
//                the instruction currently being fetched by stage 1 by
//                causing p2iv to be set false at the end of the cycle
//                when p1int is true.
// 
//    p2int       L Indicates that an interrupt-op instruction is in
//                stage 2. This signal is used in coreregs.v to control
//                the placing of the pc onto a source bus for writing
//                back to the interrupt link registers, and by aux_regs
//                to insert the interrupt vector int_vec[] into the
//                program counter.
// 
//    p2ilev1     L Indicates that the interrupt-op instruction in stage
//                2 was caused by a level 1 interrupt (irq3,4,5). It is
//                used by the load/store unit to stall an interrupt at
//                stage 2 if any loads are pending to ilink1 or ilink2.
// 
//    p2bint      L Indicates that an interrupt-op instruction is in
//                stage 2B. 
// 
//    p2bilev1    L Indicates that the interrupt-op instruction in stage
//                2B was caused by a level 1 interrupt (irq3,4,5). 
// 
//    p3int       L Indicates that an interrupt-op instruction is in 
//                stage 3. This signal is used by flags.v, along with
//                the p3ilev1 signal to clear one or both of the
//                interrupt mask bits in the status register.
// 
//    p3ilev1     L Indicates that the interrupt-op instruction in stage
//                3 was caused by a level 1 interrupt (irq3,4,5) and that 
//                only the e1 bit should be cleared. When this signal is
//                not true when p3int is true, both e1 and e2 bits are 
//                cleared. Also used to supply the correct register
//                address for the link register writeback.
// 
//    p123int     U Indicates that there is an interrupt in stage 1,2 or
//                3. This signal is used by the clock generation module.
//                If the option clock gating was not chosen this signal
//                is removed during synthesis.
// 
//    aux_lev     To auxliary unit to indicate the current value of the
//                interrupt level priority for all the interrupts. The 
//                programmer can set the priority of low priority by
//                writing to an aux register which is decoded and 
//                processed in this unit.
// 
//    int_vec     U This is the interrupt vector supplied to the 
//                program counter. Each interrupt line has a different
//                vector associated with it. It is latched into the PC
//                at the end of the cycle when p2int is true.
// 
//====================================================================--
//
module int_unit (clk_ungated,
                 rst_a,
                 irq,
                 instruction_error,
                 int_vector_base_r,
                 memory_error,
                 misaligned_int,
                 en1,
                 en2,
                 en2b,
                 en3,
                 interrupt_holdoff,
                 flagu_block,
                 e1flag_r,
                 e2flag_r,
                 aux_access,
                 aux_addr,
                 aux_dataw,
                 aux_write,
                 h_write,
                 h_addr,
                 h_dataw,
		 hold_int_st2_a,

                 int_vec,
                 p1int,
                 p2int,
                 p2bint,
                 p2ilev1,
                 p2bilev1,
                 p3int,
                 p3ilev1,
                 p123int,
                 aux_lv12,
                 aux_hint,
                 aux_lev);

`include "arcutil_pkg_defines.v" 
`include "arcutil.v" 
`include "extutil.v" 
`include "xdefs.v" 

input                       clk_ungated; 
input                       rst_a; 
input   [31:3]              irq; 
input                       instruction_error; 
input   [PC_MSB : `INT_BASE_LSB] int_vector_base_r; 
input                       memory_error; 
input                       misaligned_int;
input                       en1; 
input                       en2; 
input                       en2b; 
input                       en3; 
input                       interrupt_holdoff; 
input                       flagu_block; 
input                       e1flag_r; 
input                       e2flag_r; 
input                       aux_access; 
input   [31:0]              aux_addr; 
input   [31:0]              aux_dataw; 
input                       aux_write; 
input                       h_write; 
input   [31:0]              h_addr; 
input   [31:0]              h_dataw; 
input                       hold_int_st2_a;

output  [PC_MSB:0]          int_vec; 
output                      p1int; 
output                      p2int; 
output                      p2bint; 
output                      p2ilev1; 
output                      p2bilev1; 
output                      p3int; 
output                      p3ilev1; 
output                      p123int; 
output  [1:0]               aux_lv12; 
output  [4:0]               aux_hint; 
output   [31:3] aux_lev; 
wire    [PC_MSB:0]          int_vec; 
wire                        p1int; 
wire                        p2int; 
wire                        p2bint; 
wire                        p2ilev1; 
wire                        p2bilev1; 
wire                        p3int; 
wire                        p3ilev1; 
wire                        p123int; 
wire    [1:0]               aux_lv12; 
wire    [4:0]               aux_hint; 
wire    [31:3] aux_lev; 
reg [28:0]   i_swi_cancel_a;

//  INT_UNIT ARCHITECTURE
//
//  interrupt state constants
//
parameter S_IRQ0 = 5'b 00000; //  s_idle
parameter S_IRQ1 = 5'b 00001; //  s_mem
parameter S_IRQ2 = 5'b 00010; //  s_ins
parameter S_IRQ3 = 5'b 00011; 
parameter S_IRQ4 = 5'b 00100; 
parameter S_IRQ5 = 5'b 00101; 
parameter S_IRQ6 = 5'b 00110; 
parameter S_IRQ7 = 5'b 00111; 
parameter S_IRQ8 = 5'b 01000; 
parameter S_IRQ9 = 5'b 01001; 
parameter S_IRQ10 = 5'b 01010; 
parameter S_IRQ11 = 5'b 01011; 
parameter S_IRQ12 = 5'b 01100; 
parameter S_IRQ13 = 5'b 01101; 
parameter S_IRQ14 = 5'b 01110; 
parameter S_IRQ15 = 5'b 01111; 

parameter S_IRQ16 = 5'b 10000; 
parameter S_IRQ17 = 5'b 10001; 
parameter S_IRQ18 = 5'b 10010; 
parameter S_IRQ19 = 5'b 10011; 
parameter S_IRQ20 = 5'b 10100; 
parameter S_IRQ21 = 5'b 10101; 
parameter S_IRQ22 = 5'b 10110; 
parameter S_IRQ23 = 5'b 10111; 
parameter S_IRQ24 = 5'b 11000; 
parameter S_IRQ25 = 5'b 11001; 
parameter S_IRQ26 = 5'b 11010; 
parameter S_IRQ27 = 5'b 11011; 
parameter S_IRQ28 = 5'b 11100; 
parameter S_IRQ29 = 5'b 11101; 
parameter S_IRQ30 = 5'b 11110; 
parameter S_IRQ31 = 5'b 11111; 

//  Internal signals
//
//  Auxiliary registers
//
reg     [`INT_BASE_LSB_1:0] i_int_vec_a; 

reg     [31:3] i_aux_lev_r; 

//  Sticky flag that is set in hardware to indicate if a level 1
//  interrupt is taken. The flag should be reset in software.
//
reg     [1:0] i_aux_lev12_r; 

//  Five bits to encode the software triggered interrupt
//
reg     [4:0] i_aux_hint_r; 

//  Auxiliary lines for software driven interrupts
//
reg    [31:3] i_aux_hint_a; 

//  interrupt signals and registers
//
wire    [31:1] i_irq_a; 

reg     i_irq1_r; 
reg     i_irq2_r; 
reg     i_irq3_r; 
reg     i_irq4_r; 
reg     i_irq5_r; 
reg     i_irq6_r; 
reg     i_irq7_r; 
reg     i_irq8_r; 
reg     i_irq9_r; 
reg     i_irq10_r; 
reg     i_irq11_r; 
reg     i_irq12_r; 
reg     i_irq13_r; 
reg     i_irq14_r; 
reg     i_irq15_r; 

reg     i_irq16_r; 
reg     i_irq17_r; 
reg     i_irq18_r; 
reg     i_irq19_r; 
reg     i_irq20_r; 
reg     i_irq21_r; 
reg     i_irq22_r; 
reg     i_irq23_r; 
reg     i_irq24_r; 
reg     i_irq25_r; 
reg     i_irq26_r; 
reg     i_irq27_r; 
reg     i_irq28_r; 
reg     i_irq29_r; 
reg     i_irq30_r; 
reg     i_irq31_r; 

// Intermediate irq signals and states for stage 0,1 and 2
//
wire    [4:0] i_p0state0_nxt; 
wire    [4:0] i_p0state1_nxt; 
wire    [4:0] i_p0state2_nxt; 
wire    [4:0] i_p0state3_nxt; 
reg     [4:0] i_p0state0_r; 
reg     [4:0] i_p0state1_r; 
reg     [4:0] i_p0state2_r; 
reg     [4:0] i_p0state3_r; 
wire    [4:0] i_p1state_a; 
reg     [4:0] i_p2state_r; 

// Miscellanous internal signals
//
wire    i_blockout_a; 
wire    i_p1int_a; 
reg     i_p2bilevel1_r; 
wire    i_p2bint_nxt; 
reg     i_p2bint_r; 
wire    i_p2int_nxt; 
reg     i_p2int_r; 
reg     i_p2ilevel1_r; 
wire    i_p3int_nxt; 
reg     i_p3int_r; 
reg     i_p3ilevel1_r; 




// Select host interrupt
//
always @(
         i_aux_hint_r
         )
   begin : aux_hint_async_PROC
      case(i_aux_hint_r) 
        5'b 00011 : i_aux_hint_a = TWENTYNINE_ONE        ;
        5'b 00100 : i_aux_hint_a = TWENTYNINE_TWO        ;
        5'b 00101 : i_aux_hint_a = TWENTYNINE_THREE      ;
        5'b 00110 : i_aux_hint_a = TWENTYNINE_FOUR       ;
        5'b 00111 : i_aux_hint_a = TWENTYNINE_FIVE       ; 
        5'b 01000 : i_aux_hint_a = TWENTYNINE_SIX        ; 
        5'b 01001 : i_aux_hint_a = TWENTYNINE_SEVEN      ; 
        5'b 01010 : i_aux_hint_a = TWENTYNINE_EIGHT      ; 
        5'b 01011 : i_aux_hint_a = TWENTYNINE_NINE       ;
        5'b 01100 : i_aux_hint_a = TWENTYNINE_TEN        ;
        5'b 01101 : i_aux_hint_a = TWENTYNINE_ELEVEN     ;
        5'b 01110 : i_aux_hint_a = TWENTYNINE_TWELVE     ;
        5'b 01111 : i_aux_hint_a = TWENTYNINE_THIRTEEN   ;
        5'b 10000 : i_aux_hint_a = TWENTYNINE_FOURTEEN   ;
        5'b 10001 : i_aux_hint_a = TWENTYNINE_FIFTEEN    ;
        5'b 10010 : i_aux_hint_a = TWENTYNINE_SIXTEEN    ;
        5'b 10011 : i_aux_hint_a = TWENTYNINE_SEVENTEEN  ;
        5'b 10100 : i_aux_hint_a = TWENTYNINE_EIGHTEEN   ; 
        5'b 10101 : i_aux_hint_a = TWENTYNINE_NINETEEN   ; 
        5'b 10110 : i_aux_hint_a = TWENTYNINE_TWENTY     ; 
        5'b 10111 : i_aux_hint_a = TWENTYNINE_TWENTYONE  ; 
        5'b 11000 : i_aux_hint_a = TWENTYNINE_TWENTYTWO  ;
        5'b 11001 : i_aux_hint_a = TWENTYNINE_TWENTYTHREE;
        5'b 11010 : i_aux_hint_a = TWENTYNINE_TWENTYFOUR ;
        5'b 11011 : i_aux_hint_a = TWENTYNINE_TWENTYFIVE ;
        5'b 11100 : i_aux_hint_a = TWENTYNINE_TWENTYSIX  ;
        5'b 11101 : i_aux_hint_a = TWENTYNINE_TWENTYSEVEN;
        5'b 11110 : i_aux_hint_a = TWENTYNINE_TWENTYEIGHT;
        5'b 11111 : i_aux_hint_a = TWENTYNINE_TWENTYNINE ;  
        default   : i_aux_hint_a = THENTYNINE_ZERO       ;      
      endcase // case(l_aux_hit)
   end // block: i_aux_hit_mux
   

// An intermediate signal is created here which is true when:
//
//  a. The incoming interrupt signal is true
//
//  b. The intermediate signal was true on the last cycle.
//
// The intermediate signal is held low when the interrupt to 
// which it relates has been issued - i.e. has made it to stage 
// 2 of the pipeline. At this point blockout is asserted, so no 
// additional interrupts could be issued.
//
// Since the intermediate signal was held low on the previous 
// cycle, it will remain low until another pulse is received on 
// the incoming interrupt line.
//
// i_irq_a(0) is the reset exception and is handled differently.
//
assign i_irq_a[1] = ((memory_error | misaligned_int |
                    i_irq1_r) == 1'b 1 ) &
                  ( i_p2state_r != S_IRQ1 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[2] = ( (instruction_error | i_irq2_r) == 1'b 1 ) &
                  ( i_p2state_r != S_IRQ2 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[3] = ( (irq[3] | i_irq3_r | i_aux_hint_a[3]) == 1'b 1 ) & 
                  ( i_p2state_r != S_IRQ3 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[4] = ( (irq[4] | i_irq4_r | i_aux_hint_a[4]) == 1'b 1 ) & 
                   ( i_p2state_r != S_IRQ4 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[5] = ( (irq[5]  | i_irq5_r | i_aux_hint_a[5]) == 1'b 1 ) & 
                  ( i_p2state_r != S_IRQ5 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[6] = ( (irq[6]  | i_irq6_r | i_aux_hint_a[6]) == 1'b 1 ) & 
                  ( i_p2state_r != S_IRQ6 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[7] = ( (irq[7]  | i_irq7_r | i_aux_hint_a[7]) == 1'b 1 ) & 
                  ( i_p2state_r != S_IRQ7 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[8] = ( (irq[8] | i_irq8_r | i_aux_hint_a[8]) == 1'b 1 ) & 
                   ( i_p2state_r != S_IRQ8 ) ? 1'b 1 : 
       1'b 0;
 
assign i_irq_a[9] = ( (irq[9] | i_irq9_r | i_aux_hint_a[9]) == 1'b 1 ) & 
                   ( i_p2state_r != S_IRQ9 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[10] = ( (irq[10] | i_irq10_r | i_aux_hint_a[10]) == 1'b 1 ) & 
                   ( i_p2state_r != S_IRQ10 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[11] = ( (irq[11] | i_irq11_r | i_aux_hint_a[11]) == 1'b 1 ) & 
                   ( i_p2state_r != S_IRQ11 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[12] = ( (irq[12] | i_irq12_r | i_aux_hint_a[12]) == 1'b 1 ) & 
                   ( i_p2state_r != S_IRQ12 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[13] = ( (irq[13] | i_irq13_r | i_aux_hint_a[13]) == 1'b 1 ) & 
                   ( i_p2state_r != S_IRQ13 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[14] = ( (irq[14] | i_irq14_r | i_aux_hint_a[14]) == 1'b 1 ) & 
                   ( i_p2state_r != S_IRQ14 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[15] = ( (irq[15] | i_irq15_r | i_aux_hint_a[15]) == 1'b 1 ) & 
                   ( i_p2state_r != S_IRQ15 ) ? 1'b 1 : 
       1'b 0;

assign i_irq_a[16] = (((irq[16] | i_irq16_r | i_aux_hint_a[16]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ16)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[17] = (((irq[17] | i_irq17_r | i_aux_hint_a[17]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ17)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[18] = (((irq[18] | i_irq18_r | i_aux_hint_a[18]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ18)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[19] = (((irq[19] | i_irq19_r | i_aux_hint_a[19]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ19)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[20] = (((irq[20] | i_irq20_r | i_aux_hint_a[20]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ20)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[21] = (((irq[21] | i_irq21_r | i_aux_hint_a[21]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ21)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[22] = (((irq[22] | i_irq22_r | i_aux_hint_a[22]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ22)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[23] = (((irq[23] | i_irq23_r | i_aux_hint_a[23]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ23)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[24] = (((irq[24] | i_irq24_r | i_aux_hint_a[24]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ24)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[25] = (((irq[25] | i_irq25_r | i_aux_hint_a[25]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ25)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[26] = (((irq[26] | i_irq26_r | i_aux_hint_a[26]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ26)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[27] = (((irq[27] | i_irq27_r | i_aux_hint_a[27]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ27)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[28] = (((irq[28] | i_irq28_r | i_aux_hint_a[28]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ28)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[29] = (((irq[29] | i_irq29_r | i_aux_hint_a[29]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ29)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[30] = (((irq[30] | i_irq30_r | i_aux_hint_a[30]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ30)) ? 1'b 1 : 
       1'b 0;
assign i_irq_a[31] = (((irq[31] | i_irq31_r | i_aux_hint_a[31]) == 1'b 1) & 
                   (i_p2state_r != S_IRQ31)) ? 1'b 1 : 
       1'b 0;

// Process to register pulse sensitive interrupts and store the
// auxiliary write values coding: '0' = level , '1' = pulse
//
always @(posedge clk_ungated or posedge rst_a)
   begin : reg_irqs_PROC

   if (rst_a == 1'b 1)
      begin

   //  Reset stored intermediate signals & auxiliary registers
   //
      i_aux_lev_r <= 29'b00000000000000000000000011000;
      i_aux_hint_r <= 5'b 00000;    

   // The format of the logic for the interrupts represented below is
   // will cause synthesis tools to flag warnings. Note these can be
   // ignored since they appear when the interrupts are set to being
   // level sensitive.
   //
      if (MEM_IRQ_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq1_r <= 1'b 0; 
         end
      if (INS_IRQ_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq2_r <= 1'b 0; 
         end
      if (IRQ3_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq3_r <= 1'b 0; 
         end
      if (IRQ4_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq4_r <= 1'b 0; 
         end
      if (IRQ5_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq5_r <= 1'b 0; 
         end
      if (IRQ6_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq6_r <= 1'b 0; 
         end
      if (IRQ7_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq7_r <= 1'b 0; 
         end
      if (IRQ8_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq8_r <= 1'b 0; 
         end
      if (IRQ9_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq9_r <= 1'b 0; 
         end
      if (IRQ10_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq10_r <= 1'b 0;    
         end
      if (IRQ11_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq11_r <= 1'b 0;    
         end
      if (IRQ12_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq12_r <= 1'b 0;    
         end
      if (IRQ13_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq13_r <= 1'b 0;    
         end
      if (IRQ14_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq14_r <= 1'b 0;    
         end
      if (IRQ15_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq15_r <= 1'b 0;    
         end

      if (IRQ16_TYPE == IRQ_TYPE_LEVEL) begin i_irq16_r <= 1'b 0;    end
      if (IRQ17_TYPE == IRQ_TYPE_LEVEL) begin i_irq17_r <= 1'b 0;    end
      if (IRQ18_TYPE == IRQ_TYPE_LEVEL) begin i_irq18_r <= 1'b 0;    end
      if (IRQ19_TYPE == IRQ_TYPE_LEVEL) begin i_irq19_r <= 1'b 0;    end
      if (IRQ20_TYPE == IRQ_TYPE_LEVEL) begin i_irq20_r <= 1'b 0;    end
      if (IRQ21_TYPE == IRQ_TYPE_LEVEL) begin i_irq21_r <= 1'b 0;    end
      if (IRQ22_TYPE == IRQ_TYPE_LEVEL) begin i_irq22_r <= 1'b 0;    end
      if (IRQ23_TYPE == IRQ_TYPE_LEVEL) begin i_irq23_r <= 1'b 0;    end
      if (IRQ24_TYPE == IRQ_TYPE_LEVEL) begin i_irq24_r <= 1'b 0;    end
      if (IRQ25_TYPE == IRQ_TYPE_LEVEL) begin i_irq25_r <= 1'b 0;    end
      if (IRQ26_TYPE == IRQ_TYPE_LEVEL) begin i_irq26_r <= 1'b 0;    end
      if (IRQ27_TYPE == IRQ_TYPE_LEVEL) begin i_irq27_r <= 1'b 0;    end
      if (IRQ28_TYPE == IRQ_TYPE_LEVEL) begin i_irq28_r <= 1'b 0;    end
      if (IRQ29_TYPE == IRQ_TYPE_LEVEL) begin i_irq29_r <= 1'b 0;    end
      if (IRQ30_TYPE == IRQ_TYPE_LEVEL) begin i_irq30_r <= 1'b 0;    end
      if (IRQ31_TYPE == IRQ_TYPE_LEVEL) begin i_irq31_r <= 1'b 0;    end

      if (MEM_IRQ_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq1_r <= 1'b 0; 
         end
      if (INS_IRQ_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq2_r <= 1'b 0; 
         end
      if (IRQ3_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq3_r <= 1'b 0; 
         end
      if (IRQ4_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq4_r <= 1'b 0; 
         end
      if (IRQ5_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq5_r <= 1'b 0; 
         end
      if (IRQ6_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq6_r <= 1'b 0; 
         end
      if (IRQ7_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq7_r <= 1'b 0; 
         end
      if (IRQ8_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq8_r <= 1'b 0; 
         end
      if (IRQ9_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq9_r <= 1'b 0; 
         end
      if (IRQ10_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq10_r <= 1'b 0;    
         end
      if (IRQ11_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq11_r <= 1'b 0;    
         end
      if (IRQ12_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq12_r <= 1'b 0;    
         end
      if (IRQ13_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq13_r <= 1'b 0;    
         end
      if (IRQ14_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq14_r <= 1'b 0;    
         end
      if (IRQ15_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq15_r <= 1'b 0;    
         end

      if (IRQ16_TYPE == IRQ_TYPE_PULSE) begin i_irq16_r <= 1'b 0;    end
      if (IRQ17_TYPE == IRQ_TYPE_PULSE) begin i_irq17_r <= 1'b 0;    end
      if (IRQ18_TYPE == IRQ_TYPE_PULSE) begin i_irq18_r <= 1'b 0;    end
      if (IRQ19_TYPE == IRQ_TYPE_PULSE) begin i_irq19_r <= 1'b 0;    end
      if (IRQ20_TYPE == IRQ_TYPE_PULSE) begin i_irq20_r <= 1'b 0;    end
      if (IRQ21_TYPE == IRQ_TYPE_PULSE) begin i_irq21_r <= 1'b 0;    end
      if (IRQ22_TYPE == IRQ_TYPE_PULSE) begin i_irq22_r <= 1'b 0;    end
      if (IRQ23_TYPE == IRQ_TYPE_PULSE) begin i_irq23_r <= 1'b 0;    end
      if (IRQ24_TYPE == IRQ_TYPE_PULSE) begin i_irq24_r <= 1'b 0;    end
      if (IRQ25_TYPE == IRQ_TYPE_PULSE) begin i_irq25_r <= 1'b 0;    end
      if (IRQ26_TYPE == IRQ_TYPE_PULSE) begin i_irq26_r <= 1'b 0;    end
      if (IRQ27_TYPE == IRQ_TYPE_PULSE) begin i_irq27_r <= 1'b 0;    end
      if (IRQ28_TYPE == IRQ_TYPE_PULSE) begin i_irq28_r <= 1'b 0;    end
      if (IRQ29_TYPE == IRQ_TYPE_PULSE) begin i_irq29_r <= 1'b 0;    end
      if (IRQ30_TYPE == IRQ_TYPE_PULSE) begin i_irq30_r <= 1'b 0;    end
      if (IRQ31_TYPE == IRQ_TYPE_PULSE) begin i_irq31_r <= 1'b 0;    end

      end

   else
      begin

      // Store last value of interrupt signal if pulse catching
      // is required. The value will be reset to zero when the
      // interrupt is issued, since the intermediate value
      // is held low when the correct interrupt is issued.
      //
      // i_irq_a (0) corresponds to reset exception.
      //
      if (MEM_IRQ_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq1_r <= 1'b 0; 
         end
      if (INS_IRQ_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq2_r <= 1'b 0; 
         end
      if (IRQ3_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq3_r <= 1'b 0; 
         end
      if (IRQ4_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq4_r <= 1'b 0; 
         end
      if (IRQ5_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq5_r <= 1'b 0; 
         end
      if (IRQ6_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq6_r <= 1'b 0; 
         end
      if (IRQ7_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq7_r <= 1'b 0; 
         end
      if (IRQ8_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq8_r <= 1'b 0; 
         end
      if (IRQ9_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq9_r <= 1'b 0; 
         end
      if (IRQ10_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq10_r <= 1'b 0;    
         end
      if (IRQ11_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq11_r <= 1'b 0;    
         end
      if (IRQ12_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq12_r <= 1'b 0;    
         end
      if (IRQ13_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq13_r <= 1'b 0;    
         end
      if (IRQ14_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq14_r <= 1'b 0;    
         end
      if (IRQ15_TYPE == IRQ_TYPE_LEVEL)
         begin
         i_irq15_r <= 1'b 0;    
         end

      if (IRQ16_TYPE == IRQ_TYPE_LEVEL) begin i_irq16_r <= 1'b 0;    end
      if (IRQ17_TYPE == IRQ_TYPE_LEVEL) begin i_irq17_r <= 1'b 0;    end
      if (IRQ18_TYPE == IRQ_TYPE_LEVEL) begin i_irq18_r <= 1'b 0;    end
      if (IRQ19_TYPE == IRQ_TYPE_LEVEL) begin i_irq19_r <= 1'b 0;    end
      if (IRQ20_TYPE == IRQ_TYPE_LEVEL) begin i_irq20_r <= 1'b 0;    end
      if (IRQ21_TYPE == IRQ_TYPE_LEVEL) begin i_irq21_r <= 1'b 0;    end
      if (IRQ22_TYPE == IRQ_TYPE_LEVEL) begin i_irq22_r <= 1'b 0;    end
      if (IRQ23_TYPE == IRQ_TYPE_LEVEL) begin i_irq23_r <= 1'b 0;    end
      if (IRQ24_TYPE == IRQ_TYPE_LEVEL) begin i_irq24_r <= 1'b 0;    end
      if (IRQ25_TYPE == IRQ_TYPE_LEVEL) begin i_irq25_r <= 1'b 0;    end
      if (IRQ26_TYPE == IRQ_TYPE_LEVEL) begin i_irq26_r <= 1'b 0;    end
      if (IRQ27_TYPE == IRQ_TYPE_LEVEL) begin i_irq27_r <= 1'b 0;    end
      if (IRQ28_TYPE == IRQ_TYPE_LEVEL) begin i_irq28_r <= 1'b 0;    end
      if (IRQ29_TYPE == IRQ_TYPE_LEVEL) begin i_irq29_r <= 1'b 0;    end
      if (IRQ30_TYPE == IRQ_TYPE_LEVEL) begin i_irq30_r <= 1'b 0;    end
      if (IRQ31_TYPE == IRQ_TYPE_LEVEL) begin i_irq31_r <= 1'b 0;    end
      if (MEM_IRQ_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq1_r <= i_irq_a[1];    
         end
      if (INS_IRQ_TYPE == IRQ_TYPE_PULSE)
         begin
         i_irq2_r <= i_irq_a[2];    
         end
      if (IRQ3_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[0])
           i_irq3_r <= 1'b0;
         else
           i_irq3_r <= i_irq_a[3];    
         end
      if (IRQ4_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[1])
           i_irq4_r <= 1'b0;
         else
           i_irq4_r <= i_irq_a[4];    
         end
      if (IRQ5_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[2])
           i_irq5_r <= 1'b0;
         else
           i_irq5_r <= i_irq_a[5];    
         end
      if (IRQ6_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[3])
           i_irq6_r <= 1'b0;
         else
           i_irq6_r <= i_irq_a[6];    
         end
      if (IRQ7_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[4])
           i_irq7_r <= 1'b0;
         else
           i_irq7_r <= i_irq_a[7];    
         end
      if (IRQ8_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[5])
           i_irq8_r <= 1'b0;
         else
           i_irq8_r <= i_irq_a[8];    
         end
      if (IRQ9_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[6])
           i_irq9_r <= 1'b0;
         else
           i_irq9_r <= i_irq_a[9];    
         end
      if (IRQ10_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[7])
           i_irq10_r <= 1'b0;
         else
           i_irq10_r <= i_irq_a[10];  
         end
      if (IRQ11_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[8])
           i_irq11_r <= 1'b0;
         else
           i_irq11_r <= i_irq_a[11];  
         end
      if (IRQ12_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[9])
           i_irq12_r <= 1'b0;
         else
           i_irq12_r <= i_irq_a[12];  
         end 
      if (IRQ13_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[10])
           i_irq13_r <= 1'b0;
         else
           i_irq13_r <= i_irq_a[13];  
         end
      if (IRQ14_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[11])
           i_irq14_r <= 1'b0;
         else
           i_irq14_r <= i_irq_a[14];  
         end
      if (IRQ15_TYPE == IRQ_TYPE_PULSE)
         begin
         if (i_swi_cancel_a[12])
           i_irq15_r <= 1'b0;
         else
           i_irq15_r <= i_irq_a[15];  
         end
      if (IRQ16_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[13])
            i_irq16_r <= 1'b0;
         else
            i_irq16_r <= i_irq_a[16];  
         end
      if (IRQ17_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[14])
            i_irq17_r <= 1'b0;
         else
            i_irq17_r <= i_irq_a[17];  
         end
      if (IRQ18_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[15])
            i_irq18_r <= 1'b0;
         else
            i_irq18_r <= i_irq_a[18];  
         end
      if (IRQ19_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[16])
            i_irq19_r <= 1'b0;
         else
            i_irq19_r <= i_irq_a[19];  
         end
      if (IRQ20_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[17])
            i_irq20_r <= 1'b0;
         else
            i_irq20_r <= i_irq_a[20];  
         end
      if (IRQ21_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[18])
            i_irq21_r <= 1'b0;
         else
            i_irq21_r <= i_irq_a[21];  
         end
      if (IRQ22_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[19])
            i_irq22_r <= 1'b0;
         else
            i_irq22_r <= i_irq_a[22];  
         end
      if (IRQ23_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[20])
            i_irq23_r <= 1'b0;
         else
            i_irq23_r <= i_irq_a[23];  
         end
      if (IRQ24_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[21])
            i_irq24_r <= 1'b0;
         else
            i_irq24_r <= i_irq_a[24];  
         end
      if (IRQ25_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[22])
            i_irq25_r <= 1'b0;
         else
            i_irq25_r <= i_irq_a[25];  
         end
      if (IRQ26_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[23])
            i_irq26_r <= 1'b0;
         else
            i_irq26_r <= i_irq_a[26];  
         end
      if (IRQ27_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[24])
            i_irq27_r <= 1'b0;
         else
            i_irq27_r <= i_irq_a[27];  
         end
      if (IRQ28_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[25])
            i_irq28_r <= 1'b0;
         else
            i_irq28_r <= i_irq_a[28];  
         end
      if (IRQ29_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[26])
            i_irq29_r <= 1'b0;
         else
            i_irq29_r <= i_irq_a[29];  
         end
      if (IRQ30_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[27])
            i_irq30_r <= 1'b0;
         else
            i_irq30_r <= i_irq_a[30];  
         end
      if (IRQ31_TYPE == IRQ_TYPE_PULSE) 
         begin 
         if (i_swi_cancel_a[28])
            i_irq31_r <= 1'b0;
         else
            i_irq31_r <= i_irq_a[31];  
         end

      if (( auxdc(aux_addr, AUX_IRQ_LEV) == 1'b 1 ) &
          ( aux_write == 1'b 1 ))
         begin
         i_aux_lev_r <= aux_dataw[31:3];    
         end
      else if (( auxdc(h_addr, AUX_IRQ_LEV) == 1'b 1 ) &
               ( aux_access == 1'b 1 ) & h_write == 1'b 1 )
         begin
         i_aux_lev_r <= h_dataw[31:3];  
         end
      if (( auxdc(aux_addr, AUX_IRQ_HINT) == 1'b 1 ) &
          ( aux_write == 1'b 1 ))
         begin
         i_aux_hint_r <= aux_dataw[4:0];    
         end
      else if (( auxdc(h_addr, AUX_IRQ_HINT) == 1'b 1 ) &
               ( aux_access == 1'b 1 ) & ( h_write == 1'b 1 ) )
         begin
         i_aux_hint_r <= h_dataw[4:0];  
         end
      end
   end

// Cancel software interrupts when zero is written to
// the 'hint' register.
//        
always @(
         i_aux_hint_r or
         aux_addr or
         aux_write or 
         aux_dataw
         )
   begin : cancel_hint_PROC
   
     i_swi_cancel_a = 29'b0;
   
     if ((( auxdc(aux_addr, AUX_IRQ_HINT) == 1'b 1 ) &&
          ( aux_write == 1'b 1 )) && (aux_dataw == 32'b0))
     begin
      case(i_aux_hint_r) 
        5'b 00011 : i_swi_cancel_a[0]  = 1'b1;
        5'b 00100 : i_swi_cancel_a[1]  = 1'b1;
        5'b 00101 : i_swi_cancel_a[2]  = 1'b1;
        5'b 00110 : i_swi_cancel_a[3]  = 1'b1;
        5'b 00111 : i_swi_cancel_a[4]  = 1'b1;
        5'b 01000 : i_swi_cancel_a[5]  = 1'b1; 
        5'b 01001 : i_swi_cancel_a[6]  = 1'b1;
        5'b 01010 : i_swi_cancel_a[7]  = 1'b1;
        5'b 01011 : i_swi_cancel_a[8]  = 1'b1;
        5'b 01100 : i_swi_cancel_a[9]  = 1'b1;
        5'b 01101 : i_swi_cancel_a[10] = 1'b1;
        5'b 01110 : i_swi_cancel_a[11] = 1'b1;
        5'b 01111 : i_swi_cancel_a[12] = 1'b1;
        5'b 10000 : i_swi_cancel_a[13] = 1'b1;
        5'b 10001 : i_swi_cancel_a[14] = 1'b1;
        5'b 10010 : i_swi_cancel_a[15] = 1'b1;
        5'b 10011 : i_swi_cancel_a[16] = 1'b1;
        5'b 10100 : i_swi_cancel_a[17] = 1'b1;
        5'b 10101 : i_swi_cancel_a[18] = 1'b1;
        5'b 10110 : i_swi_cancel_a[19] = 1'b1;
        5'b 10111 : i_swi_cancel_a[20] = 1'b1;
        5'b 11000 : i_swi_cancel_a[21] = 1'b1;
        5'b 11001 : i_swi_cancel_a[22] = 1'b1;
        5'b 11010 : i_swi_cancel_a[23] = 1'b1;
        5'b 11011 : i_swi_cancel_a[24] = 1'b1;
        5'b 11100 : i_swi_cancel_a[25] = 1'b1;
        5'b 11101 : i_swi_cancel_a[26] = 1'b1;
        5'b 11110 : i_swi_cancel_a[27] = 1'b1;
        5'b 11111 : i_swi_cancel_a[28] = 1'b1;      
      endcase // case(l_aux_hit)
     end
   end 

// Block out interrupts when:
//
// a. Another interrupt is already being processed (p2int/p3int)
// 
// b. The instruction in stage2 depends on the next instruction 
//    following immediately after it. (interrupt_holdoff).
// 
// c. An instruction is present in stage 2 or 3 which could 
//    disable the interrupt flags. This ensures that no 
//    interrupts can be taken between the disabling instruction
//    at the time when the appropriate interrupt flag has been
//    cleared.
// 
assign i_blockout_a = i_p2int_r | i_p2bint_r | i_p3int_r | 
                      interrupt_holdoff | flagu_block; 


// Process to show interrupt in the pipeline. The signal p123int is 
// only used with clock gating.
//
assign p123int = i_p1int_a | i_p2int_r | i_p2bint_r | i_p3int_r;

// Interrupts at stage 0
// Decide which interrupt will be processed on the next cycle. This
// part also determines the priority of interrupts.
//

//  priority subset (3) - highest
assign i_p0state3_nxt =
   ((i_irq_a[7]  & i_aux_lev_r[7])  == 1'b 1) ? S_IRQ7 : 
   ((i_irq_a[31] & i_aux_lev_r[31]) == 1'b 1) ? S_IRQ31 : 
   ((i_irq_a[30] & i_aux_lev_r[30]) == 1'b 1) ? S_IRQ30 : 
   ((i_irq_a[29] & i_aux_lev_r[29]) == 1'b 1) ? S_IRQ29 : 
   ((i_irq_a[28] & i_aux_lev_r[28]) == 1'b 1) ? S_IRQ28 : 
   ((i_irq_a[27] & i_aux_lev_r[27]) == 1'b 1) ? S_IRQ27 : 
   ((i_irq_a[26] & i_aux_lev_r[26]) == 1'b 1) ? S_IRQ26 : 
   ((i_irq_a[25] & i_aux_lev_r[25]) == 1'b 1) ? S_IRQ25 : 
   ((i_irq_a[24] & i_aux_lev_r[24]) == 1'b 1) ? S_IRQ24 : 
   ((i_irq_a[23] & i_aux_lev_r[23]) == 1'b 1) ? S_IRQ23 : 
   ((i_irq_a[22] & i_aux_lev_r[22]) == 1'b 1) ? S_IRQ22 : 
   ((i_irq_a[21] & i_aux_lev_r[21]) == 1'b 1) ? S_IRQ21 : 
   ((i_irq_a[20] & i_aux_lev_r[20]) == 1'b 1) ? S_IRQ20 : 
   ((i_irq_a[19] & i_aux_lev_r[19]) == 1'b 1) ? S_IRQ19 : 
       S_IRQ0; 

//  priority subset (2)
assign i_p0state2_nxt =
   ((i_irq_a[18] & i_aux_lev_r[18]) == 1'b 1) ? S_IRQ18 : 
   ((i_irq_a[17] & i_aux_lev_r[17]) == 1'b 1) ? S_IRQ17 : 
   ((i_irq_a[16] & i_aux_lev_r[16]) == 1'b 1) ? S_IRQ16 : 
   ((i_irq_a[15] & i_aux_lev_r[15]) == 1'b 1) ? S_IRQ15 : 
   ((i_irq_a[14] & i_aux_lev_r[14]) == 1'b 1) ? S_IRQ14 : 
   ((i_irq_a[13] & i_aux_lev_r[13]) == 1'b 1) ? S_IRQ13 : 
   ((i_irq_a[12] & i_aux_lev_r[12]) == 1'b 1) ? S_IRQ12 : 
   ((i_irq_a[11] & i_aux_lev_r[11]) == 1'b 1) ? S_IRQ11 : 
   ((i_irq_a[10] & i_aux_lev_r[10]) == 1'b 1) ? S_IRQ10 : 
   ((i_irq_a[9] & i_aux_lev_r[9]) == 1'b 1) ? S_IRQ9 : 
   ((i_irq_a[8] & i_aux_lev_r[8]) == 1'b 1) ? S_IRQ8 : 
   ((i_irq_a[7] & i_aux_lev_r[7]) == 1'b 1) ? S_IRQ7 : 
   ((i_irq_a[6] & i_aux_lev_r[6]) == 1'b 1) ? S_IRQ6 : 
   ((i_irq_a[5] & i_aux_lev_r[5]) == 1'b 1) ? S_IRQ5 : 
   ((i_irq_a[4] & i_aux_lev_r[4]) == 1'b 1) ? S_IRQ4 : 
   ((i_irq_a[3] & i_aux_lev_r[3]) == 1'b 1) ? S_IRQ3 : 
       S_IRQ0; 

//  priority subset (1)
assign i_p0state1_nxt =
   ((i_irq_a[7]  & (~i_aux_lev_r[7]))  == 1'b 1) ? S_IRQ7 : 
   ((i_irq_a[31] & (~i_aux_lev_r[31])) == 1'b 1) ? S_IRQ31 : 
   ((i_irq_a[30] & (~i_aux_lev_r[30])) == 1'b 1) ? S_IRQ30 : 
   ((i_irq_a[29] & (~i_aux_lev_r[29])) == 1'b 1) ? S_IRQ29 : 
   ((i_irq_a[28] & (~i_aux_lev_r[28])) == 1'b 1) ? S_IRQ28 : 
   ((i_irq_a[27] & (~i_aux_lev_r[27])) == 1'b 1) ? S_IRQ27 : 
   ((i_irq_a[26] & (~i_aux_lev_r[26])) == 1'b 1) ? S_IRQ26 : 
   ((i_irq_a[25] & (~i_aux_lev_r[25])) == 1'b 1) ? S_IRQ25 : 
   ((i_irq_a[24] & (~i_aux_lev_r[24])) == 1'b 1) ? S_IRQ24 : 
   ((i_irq_a[23] & (~i_aux_lev_r[23])) == 1'b 1) ? S_IRQ23 : 
   ((i_irq_a[22] & (~i_aux_lev_r[22])) == 1'b 1) ? S_IRQ22 : 
   ((i_irq_a[21] & (~i_aux_lev_r[21])) == 1'b 1) ? S_IRQ21 : 
   ((i_irq_a[20] & (~i_aux_lev_r[20])) == 1'b 1) ? S_IRQ20 : 
   ((i_irq_a[19] & (~i_aux_lev_r[19])) == 1'b 1) ? S_IRQ19 : 
       S_IRQ0; 

//  priority subset (0) - lowest
assign i_p0state0_nxt =
   ((i_irq_a[18] & (~i_aux_lev_r[18])) == 1'b 1) ? S_IRQ18 : 
   ((i_irq_a[17] & (~i_aux_lev_r[17])) == 1'b 1) ? S_IRQ17 : 
   ((i_irq_a[16] & (~i_aux_lev_r[16])) == 1'b 1) ? S_IRQ16 : 
   ((i_irq_a[15] & (~i_aux_lev_r[15])) == 1'b 1) ? S_IRQ15 : 
   ((i_irq_a[14] & (~i_aux_lev_r[14])) == 1'b 1) ? S_IRQ14 : 
   ((i_irq_a[13] & (~i_aux_lev_r[13])) == 1'b 1) ? S_IRQ13 : 
   ((i_irq_a[12] & (~i_aux_lev_r[12])) == 1'b 1) ? S_IRQ12 : 
   ((i_irq_a[11] & (~i_aux_lev_r[11])) == 1'b 1) ? S_IRQ11 : 
   ((i_irq_a[10] & (~i_aux_lev_r[10])) == 1'b 1) ? S_IRQ10 : 
   ((i_irq_a[9] & (~i_aux_lev_r[9])) == 1'b 1) ? S_IRQ9 : 
   ((i_irq_a[8] & (~i_aux_lev_r[8])) == 1'b 1) ? S_IRQ8 : 
   ((i_irq_a[7] & (~i_aux_lev_r[7])) == 1'b 1) ? S_IRQ7 : 
   ((i_irq_a[6] & (~i_aux_lev_r[6])) == 1'b 1) ? S_IRQ6 : 
   ((i_irq_a[5] & (~i_aux_lev_r[5])) == 1'b 1) ? S_IRQ5 : 
   ((i_irq_a[4] & (~i_aux_lev_r[4])) == 1'b 1) ? S_IRQ4 : 
   ((i_irq_a[3] & (~i_aux_lev_r[3])) == 1'b 1) ? S_IRQ3 : 
       S_IRQ0;
 

// Process to register the results of priority encoders from stage 0
// interrupt detection.
//
always @(posedge clk_ungated or posedge rst_a)
   begin : irq_hierarchy_PROC
   if (rst_a == 1'b 1)
      begin
      i_p0state3_r <= S_IRQ0;   
      i_p0state2_r <= S_IRQ0;   
      i_p0state1_r <= S_IRQ0;   
      i_p0state0_r <= S_IRQ0;   
      end
   else
      begin
      i_p0state3_r <= i_p0state3_nxt;   
      i_p0state2_r <= i_p0state2_nxt;   
      i_p0state1_r <= i_p0state1_nxt;   
      i_p0state0_r <= i_p0state0_nxt;   
      end
   end

// Interrupts at stage 1
// detect the highest priority interrupt from what was registered
// in stage 0 and now the associated interrupt enable is set, go to
// idle state if no interrupts
//
assign i_p1state_a = ( i_blockout_a == 1'b 1 ) ? S_IRQ0 :
                     ( i_irq_a[1]   == 1'b 1 ) ? S_IRQ1 : 
                     ( i_irq_a[2]   == 1'b 1 ) ? S_IRQ2 : 
                     ( i_p0state3_r != S_IRQ0 ) & ( e2flag_r == 1'b 1 ) ?
       i_p0state3_r : 
                     ( i_p0state2_r != S_IRQ0 ) & ( e2flag_r == 1'b 1 ) ?
       i_p0state2_r : 
                     ( i_p0state1_r != S_IRQ0 ) & ( e1flag_r == 1'b 1 ) ?
       i_p0state1_r : 
                     ( i_p0state0_r != S_IRQ0 ) & ( e1flag_r == 1'b 1 ) ?
       i_p0state0_r : 
       S_IRQ0; 

assign i_p1int_a = ( i_blockout_a == 1'b 0 ) & ((( i_p0state3_r != S_IRQ0 ) | 
                   ( i_p0state2_r != S_IRQ0 )) & ( e2flag_r == 1'b 1 ) | 
                   (( i_p0state1_r != S_IRQ0 ) | ( i_p0state0_r != S_IRQ0 )) & 
                   ( e1flag_r == 1'b 1 ) | ( instruction_error == 1'b 1 ) | 
                   ( i_irq_a[1] == 1'b 1 ) | ( i_irq_a[2] == 1'b 1 )) ?
       1'b 1 : 
       1'b 0;

assign i_p2int_nxt = ( en1 == 1'b 0 ) & ( en2 == 1'b 1 ) ?
       1'b 0 :
                     ( en1 == 1'b 1 ) ?
       i_p1int_a : 
       i_p2int_r;


// Interrupt at stage 2
// p2int is p1int passed down the pipeline when en1 = '1'.
// p1state is passed down the pipe when en1 = '1'.
//
always @(posedge clk_ungated or posedge rst_a)
   begin : irq_state2_PROC
   if (rst_a == 1'b 1)
      begin
      i_aux_lev12_r <= {2{1'b 0}};  
      i_p2state_r   <= S_IRQ0;  
      i_p2int_r     <= 1'b 0;   
      i_p2ilevel1_r <= 1'b 0;   
      end
   else
      begin
      if (( auxdc(aux_addr, AUX_IRQ_LV12) == 1'b 1 ) & ( aux_write == 1'b 1 ))
         begin
         if (aux_dataw[0] == 1'b 1)
            begin
            i_aux_lev12_r[0] <= 1'b 0;  
            end
         if (aux_dataw[1] == 1'b 1)
            begin
            i_aux_lev12_r[1] <= 1'b 0;  
            end
         end
      else if (( auxdc(h_addr, AUX_IRQ_LV12) == 1'b 1 ) &
               ( aux_access == 1'b 1 ) & ( h_write == 1'b 1 ))
         begin
         if (h_dataw[0] == 1'b 1)
            begin
            i_aux_lev12_r[0] <= 1'b 0;  
            end
         if (h_dataw[1] == 1'b 1)
            begin
            i_aux_lev12_r[1] <= 1'b 0;  
            end
         end // if (auxdc(h_addr, AUX_IRQ_LV12) == 1'b 1 &...

      if (hold_int_st2_a == 1'b0)
          i_p2int_r <= i_p2int_nxt;
      
      if (en1 == 1'b 1)
         begin
         i_p2state_r <= i_p1state_a;    

         // Detect level1 interrupts
         // This is used to generate the link register writeback at
         // stage 3, and for use in the load/store unit which needs
         // to check for pending loads to the link register.
         //
         if (
   (( i_p1state_a == S_IRQ31 ) & (~i_aux_lev_r[31]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ30 ) & (~i_aux_lev_r[30]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ29 ) & (~i_aux_lev_r[29]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ28 ) & (~i_aux_lev_r[28]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ27 ) & (~i_aux_lev_r[27]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ26 ) & (~i_aux_lev_r[26]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ25 ) & (~i_aux_lev_r[25]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ24 ) & (~i_aux_lev_r[24]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ23 ) & (~i_aux_lev_r[23]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ22 ) & (~i_aux_lev_r[22]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ21 ) & (~i_aux_lev_r[21]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ20 ) & (~i_aux_lev_r[20]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ19 ) & (~i_aux_lev_r[19]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ18 ) & (~i_aux_lev_r[18]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ17 ) & (~i_aux_lev_r[17]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ16 ) & (~i_aux_lev_r[16]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ15 ) & (~i_aux_lev_r[15]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ14 ) & (~i_aux_lev_r[14]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ13 ) & (~i_aux_lev_r[13]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ12 ) & (~i_aux_lev_r[12]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ11 ) & (~i_aux_lev_r[11]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ10 ) & (~i_aux_lev_r[10]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ9 ) & (~i_aux_lev_r[9]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ8 ) & (~i_aux_lev_r[8]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ7 ) & (~i_aux_lev_r[7]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ6 ) & (~i_aux_lev_r[6]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ5 ) & (~i_aux_lev_r[5]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ4 ) & (~i_aux_lev_r[4]) == 1'b 1) | 
   (( i_p1state_a == S_IRQ3 ) & (~i_aux_lev_r[3]) == 1'b 1) | 
	1'b 0)
            //  level 1 interrupt
            begin
            i_p2ilevel1_r <= 1'b 1; 
            i_aux_lev12_r[0] <= 1'b 1;  
            end
         //  level 2 interrupt
         else if (i_p1state_a != S_IRQ0 )
            begin
            i_p2ilevel1_r <= 1'b 0; 
            i_aux_lev12_r[1] <= 1'b 1;  
            end
         //  no interrupt
         else
            begin
            i_p2ilevel1_r <= 1'b 0; 
            end

         end
      end
   end

 // Select the correct interrupt vector
 //
 // Select the interrupt vector address
 //
 always @(i_p2state_r)
      begin : int_vec_async_PROC
         case(i_p2state_r) 
           S_IRQ31 : i_int_vec_a = `IVECTOR_OFS31;
           S_IRQ30 : i_int_vec_a = `IVECTOR_OFS30;
           S_IRQ29 : i_int_vec_a = `IVECTOR_OFS29;
           S_IRQ28 : i_int_vec_a = `IVECTOR_OFS28;
           S_IRQ27 : i_int_vec_a = `IVECTOR_OFS27;
           S_IRQ26 : i_int_vec_a = `IVECTOR_OFS26;
           S_IRQ25 : i_int_vec_a = `IVECTOR_OFS25;
           S_IRQ24 : i_int_vec_a = `IVECTOR_OFS24;
           S_IRQ23 : i_int_vec_a = `IVECTOR_OFS23;
           S_IRQ22 : i_int_vec_a = `IVECTOR_OFS22;
           S_IRQ21 : i_int_vec_a = `IVECTOR_OFS21;
           S_IRQ20 : i_int_vec_a = `IVECTOR_OFS20;
           S_IRQ19 : i_int_vec_a = `IVECTOR_OFS19;
           S_IRQ18 : i_int_vec_a = `IVECTOR_OFS18;
           S_IRQ17 : i_int_vec_a = `IVECTOR_OFS17;
           S_IRQ16 : i_int_vec_a = `IVECTOR_OFS16;
           S_IRQ15 : i_int_vec_a = `IVECTOR_OFS15;
           S_IRQ14 : i_int_vec_a = `IVECTOR_OFS14;
           S_IRQ13 : i_int_vec_a = `IVECTOR_OFS13;
           S_IRQ12 : i_int_vec_a = `IVECTOR_OFS12;
           S_IRQ11 : i_int_vec_a = `IVECTOR_OFS11;
           S_IRQ10 : i_int_vec_a = `IVECTOR_OFS10;
           S_IRQ9 : i_int_vec_a = `IVECTOR_OFS9;
           S_IRQ8 : i_int_vec_a = `IVECTOR_OFS8;
           S_IRQ7 : i_int_vec_a = `IVECTOR_OFS7;
           S_IRQ6 : i_int_vec_a = `IVECTOR_OFS6;
           S_IRQ5 : i_int_vec_a = `IVECTOR_OFS5;
           S_IRQ4 : i_int_vec_a = `IVECTOR_OFS4;
           S_IRQ3 : i_int_vec_a = `IVECTOR_OFS3;
           S_IRQ2 : i_int_vec_a = `IVECTOR_OFS2;
           S_IRQ1 : i_int_vec_a = `IVECTOR_OFS1;
           default : i_int_vec_a = {(`INT_BASE_LSB) {1'b 0}};
         endcase // case(i_p2state_r)
      end // block: int_vec_mux

// Interrupts at stage 2B
// Generation of p2bint & p2bilev1.
// p2bint is p2int passed down the pipeline when en2 = '1'.
//
assign i_p2bint_nxt = ( en2 == 1'b 0 ) & ( en2b == 1'b 1 ) ?
       1'b 0 : 
                      ( en2 == 1'b 1 ) ? 
       i_p2int_r : 
       i_p2bint_r; 

// Move interrupt level and interrupt qualifier to stage 2B.
//
always @(posedge clk_ungated or posedge rst_a)
   begin : irq_state2b_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_p2bint_r <= 1'b 0;   
      i_p2bilevel1_r <= 1'b 0;   
      end
   else
      begin

      // Clock in newly generated stage 2B interrupt signal.
      //
      if (hold_int_st2_a)
        i_p2bint_r <= 1'b 0;
      else
        i_p2bint_r <= i_p2bint_nxt;
    
      // p2bilevl1 is set true when a level one interrupt passes
      // into stage 3. It is enabled by the pipeline enable en2.
      // (This logic does not explicitly handle pipeline tearing,
      // but as it is always qualified with p3int, then this is 
      // not a problem).
      //
      if (en2 == 1'b 1)
         begin
         i_p2bilevel1_r <= i_p2ilevel1_r;    
         end
      end
   end

// Interrupts at stage 3
// Generation of p3int & p3ilev1.
// p3int is p2bint passed down the pipeline when en2b = '1'.
//
assign i_p3int_nxt = ( en2b == 1'b 0 ) & ( en3 == 1'b 1 ) ? 
       1'b 0 : 
                     ( en2b == 1'b 1 ) ? 
       i_p2bint_r : 
       i_p3int_r; 

// Move interrupt level and interrupt qualifier to stage 3.
//
always @(posedge clk_ungated or posedge rst_a)
   begin : irq_state3_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_p3int_r <= 1'b 0;   
      i_p3ilevel1_r <= 1'b 0;   
      end
   else
      begin

      // Clock in newly generated stage 3 interrupt signal.
      //
      i_p3int_r <= i_p3int_nxt;
    
      // p3ilevl1 is set true when a level one interrupt passes
      // into stage 3. It is enabled by the pipeline enable en2.
      // (This logic does not explicitly handle pipeline tearing,
      // but as it is always qualified with p3int, then this is 
      // not a problem).
      //
      if (en2b == 1'b 1)
         begin
         i_p3ilevel1_r <= i_p2bilevel1_r;    
         end
      end
   end

//============================ Output drives =========================--
//
assign aux_hint  = i_aux_hint_r;
assign aux_lev   = i_aux_lev_r; 
assign aux_lv12  = i_aux_lev12_r;
assign int_vec   = {int_vector_base_r[PC_MSB : `INT_BASE_LSB],
                   i_int_vec_a};
assign p1int     = i_p1int_a;
assign p2bilev1  = i_p2bilevel1_r;
assign p2ilev1   = i_p2ilevel1_r;
assign p2bint    = i_p2bint_r; 
assign p2int     = i_p2int_r; 
assign p3ilev1   = i_p3ilevel1_r; 
assign p3int     = i_p3int_r; 

endmodule // module int_unit
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1999-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// Single item for use in the structural queue mechanism.
// 
// ========================= Inputs to this block =====================--
// 
//   add         The address in dest is added to this item if there is
//               something in the item ahead (as indicated by
//               stateahead) and this one is empty.
// 
//   pop_a       The address from the item behind (itemin) is latched
//               into this item when this signal is high.
// 
//   itemin[]    This is the output of the item which is behind this
//               item.
// 
//   pathin[]    This is the path of the item which is behind this item.
// 
//   pc_in[]     This is the PC of the item which is behind this item.
// 
//   statein     This is the state of the item which is behind this item.
//               0 means item behind is empty, 1 means it contains an
//               address.
// 
//   statein2    This is the state of the item which is two items behind
//               this item. 0 means item behind is empty, 1 means it
//               contains an address.
// 
//   stateahead  State of the item ahead of this item.
//               0 means item ahead is empty, 1 means it contains an
//               address.
// 
//   s1a[]       Source 1 register address which is compared with
//               itemout_r.
// 
//   s2a[]       Source 2 register address which is compared with
//               itemout_r.
// 
//   dest[]      destination register address which is compared with
//               itemout_r.
// 
//   add_path    Indicates that the path type (pathadd_a) should be added
//               to the FIFO item at the end of the FIFO on the next
//               clock edge.
//   
//   pathadd_a     The path type that is to be added to the FIFO item at
//               the end of the FIFO on the next clock edge. It
//               describes which path (DMP sub-module or peripheral) that
//               is servicing an outstanding load.
// 
// ======================== Output from this block ====================--
// 
//   itemout_r   The register address that is latched in this item. Only
//               valid when stateout_r is 1.
// 
//   pathout_r   The path that is servicing the outstanding load
//               associated with the return address in itemout_r.
// 
//   stateout_r  Indicates that this item contains a valid register
//               address that is being used by the memory controller.
// 
//   s1match_a   indicates that the register address on s1a matches
//               itemout_r
// 
//   s2match_a   indicates that the register address on s2a matches
//               itemout_r
// 
//   destmatch_a indicates that the register address on dest matches
//               itemout_r
// 
// ====================================================================--
//
module scoritem (clk,
                 rst_a,
                 add,
                 add_path,
                 pop_a,
                 kill,
                 itemin,
                 statein,
                 statein2,
                 pathin,
                 stateahead,
                 s1a,
                 s2a,
                 dest,
                 pathadd_a,

                 itemout_r,
                 stateout_r,
                 pathout_r,
                 s1match_a,
                 s2match_a,
                 destmatch_a);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"

input   clk; 
input   rst_a; 
input   add; 
input   add_path; 
input   pop_a; 
input   kill; 
input   [OPERAND_MSB:0] itemin; 
input   statein; 
input   statein2; 
input   [1:0] pathin; 
input   stateahead; 
input   [OPERAND_MSB:0] s1a; 
input   [OPERAND_MSB:0] s2a; 
input   [OPERAND_MSB:0] dest; 
input   [1:0] pathadd_a; 

output   [OPERAND_MSB:0] itemout_r; 
output   stateout_r; 
output   [1:0] pathout_r; 
output   s1match_a; 
output   s2match_a; 
output   destmatch_a; 

wire    [OPERAND_MSB:0] itemout_r; 
wire    stateout_r; 
wire    [1:0] pathout_r; 
wire    s1match_a; 
wire    s2match_a; 
wire    destmatch_a; 
wire    [OPERAND_MSB:0] i_item_nxt; 
reg     [OPERAND_MSB:0] i_item_r; 
wire    [1:0] i_path_nxt;
reg     [1:0] i_path_r; 
wire    i_state_nxt; 
reg     i_state_r;
 
//  Comparisons with s1, s2 and dest.
//
assign s1match_a = ((s1a == i_item_r) & (i_state_r == 1'b 1)) ? 1'b 1 : 
       1'b 0;
   
assign s2match_a = ((s2a == i_item_r) & (i_state_r == 1'b 1)) ? 1'b 1 : 
       1'b 0;
   
assign destmatch_a = ((dest == i_item_r) & (i_state_r == 1'b 1)) ? 1'b 1 :
       1'b 0; 

//  The actual item store
//
always @(posedge clk or posedge rst_a)
   begin : scorreg_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_item_r <= {(OPERAND_WIDTH){1'b 0}};        
      end
   else
      begin
      i_item_r <= i_item_nxt;        
      end
   end

//  state of item:   i_state_r '1' -> full or '0' -> empty
//     
always @(posedge clk or posedge rst_a)
   begin : statereg_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_state_r <= 1'b 0;        
      end
   else
      begin
      i_state_r <= i_state_nxt;        
      end
   end

//  Path type for item.
// 
//  It is a two bit wide value. Each code stands for a different
//  memory path, as defined in the package arcutil.
//
always @(posedge clk or posedge rst_a)
   begin : pathreg_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_path_r <= {(TWO){1'b 0}};        
      end
   else
      begin
      i_path_r <= i_path_nxt;        
      end
   end

// -------------------------------------------------------------------
//  Updating the state of this FIFO item
// -------------------------------------------------------------------
//  When the state of a FIFO item is set it means it contains data.
//  The updating mechanism has to take into account when a pop and add
//  happen at the same time and this item is the last one in the fifo.
//  There are four cases below:
//
//      1. If the item is killed due to a mispredicited compare and branch
//         then set the state to 0
//
//      2. Set the state to 1 of this FIFO item if a load is in
//         pipeline stage 2 (add = '1') and this item is empty
//         (i_state_r='0') and it is just after the last full item
//         (stateahead = '1') in the FIFO. Basically this means to
//         set the state of the first empty item to one.
// 
//      3. If a pop and add occurs at the same time the state should
//         be set to 1 if the item is full (i_state_r = '1') and the
//         item behind is empty (statein = '0'). Basically this means
//         to set the state of the last full item in the FIFO to one.
//         Because a pop occurs at the same time the last full item
//         will be empty at the end of the cycle. That is why the
//         state of the last full item is set to one.
// 
//      4. If only a pop happens this item is updated with the state
//         of the item behind it (statein) in the FIFO.
// 
//      5. If neither a pop nor an add is occuring the item keeps it
//         old state (i_state_r).
//
   
assign i_state_nxt = (kill       == 1'b 1)   ?
       1'b 0 :       ((add        == 1'b 1) &
                      (pop_a      == 1'b 0) & 
                      (i_state_r  == 1'b 0) &
                      (stateahead == 1'b 1))   ?
       1'b 1 : 
                     ((add        == 1'b 1) &
                      (pop_a      == 1'b 1) & 
                      (statein    == 1'b 0) &
                      (i_state_r  == 1'b 1))   ?
       1'b 1 : 
                     (pop_a      == 1'b 1)   ?
       statein : 
       i_state_r;

// -------------------------------------------------------------------
//  Updating the return address of this FIFO item
// -------------------------------------------------------------------
//  The updating mechanism has to take into account when a pop and add
//  happen at the same time and this item is the last one in the fifo.
//  There are four cases below:
//
//      1. If the item is killed due to a mispredicited compare and branch
//         then set the item to 0
//
//      2. Add destination address (dest) of a load in pipeline
//         stage 2 (add = '1') to this FIFO item if this item is empty
//         (i_state_r='0') and it is just after the last full item
//         (stateahead = '1') in the FIFO. Basically this means to
//         add it to the first empty item in the FIFO.
// 
//      3. If a pop and add occurs at the same time the destination
//         address (dest) should be added to this item if it is full
//         (i_state_r = '1') and the item behind is empty
//         (statein = '0'). Basically this means to add it to the
//         last full item in the FIFO. Because a pop occurs at the
//         same time the last full item will be empty at the end of
//         the cycle. That is why the destination address should be
//         added to the last full item.
// 
//      4. If a pop happens (pop = '1') this item is updated with the
//         content of the item behind it (itemin) in the FIFO.
// 
//      5. If neither a pop or an add is occuring the item keeps it
//         old content.
   
assign i_item_nxt = (kill       == 1'b 1)   ?
       SIX_ZERO :
                    ((add        == 1'b 1) &
                     (i_state_r  == 1'b 0) & 
                     (stateahead == 1'b 1))   ?
       dest : 
                    ((add        == 1'b 1) &
                     (pop_a      == 1'b 1) & 
                     (statein    == 1'b 0) &
                     (i_state_r  == 1'b 1))   ?
       dest : 
                    (pop_a      == 1'b 1)   ?
       itemin : 
       i_item_r;

// -------------------------------------------------------------------
//  Updating the path type of this FIFO item
// -------------------------------------------------------------------
//  The updating mechanism has to take into account when a pop and
//  path add happen at the same time and this item is the last one in
//  the fifo. There are four cases below:
// 
//      1. Add the path (pathadd_a) to this FIFO item if a load is in
//         pipeline stage 3 (add_path = '1') and this item is full
//         (i_state_r = '1') and the item behind is empty
//         (statein = '0'). Basically this means to add the path type
//         to the last full item in the FIFO. This is natural because
//         the last full FIFO item was added in pipeline stage 2, but
//         the path type is not added to the same item until pipeline
//         stage 3.
// 
//      2. If a pop and add occurs at the same time the path (pathadd_a)
//         should be added to this item if it is full
//         (i_state_r = '1') and the item two locations behind this
//         item is empty (statein2 = '0'). Basically this means to add
//         it to the second last full item in the FIFO. Because a pop
//         occurs at the same time the last full item will be empty at
//         the end of the cycle. That is why the path should be added
//         to the second last full item.
// 
//      3. If a pop happens (pop = '1') this item is updated with the
//         path type of the item behind it (pathin) in the FIFO.
// 
//      4. If neither a pop or an add is occuring the item keeps it
//         old path type (i_path_r).
//
assign i_path_nxt = ((add_path  == 1'b 1) &
                     (pop_a     == 1'b 0) & 
                     (statein   == 1'b 0) &
                     (i_state_r == 1'b 1))   ? pathadd_a : 
                    ((add_path  == 1'b 1) &
                     (pop_a     == 1'b 1) & 
                     (i_state_r == 1'b 1) &
                     (statein2  == 1'b 0))   ? pathadd_a : 
                    (pop_a     == 1'b 1)   ? pathin : 
                    i_path_r;

assign itemout_r  = i_item_r; 
assign stateout_r = i_state_r; 
assign pathout_r  = i_path_r; 

endmodule // module scoritem

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1999-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// The FIFO that is used in the scoreboard unit. This FIFO is not a true
// FIFO. Instead it is of a kind called "balking form" which means that
// the FIFO permits an item to be removed from a location other than the
// front of the FIFO.
// 
// ========================= Inputs to this block =====================--
// 
//   add             Indicates that the address on dest[] should be added
//                   to the fifo on next clk.
// 
//   pop_a           Indicates that the fifo will be shifted down on
//                   next clk. A new register address will appear on
//                   front[].
// 
//   s1a[]           Source 1 register address from stage 2. 
//                   Used for scoreboarding.
// 
//   s2a[]           Source 2 register address from stage 2.
//                   Used for scoreboarding.
// 
//   dest[]          Destination register address from stage 2.
//                   Used for scoreboarding.
// 
//   s1en            Source 1 address is valid.
//                   Used by the scoreboard unit for scoreboard hit.
// 
//   s2en            Source 2 address is valid.
//                   Used by the scoreboard unit for scoreboard hit.
// 
//   desten          Destination address is valid.
//                   Used by the scoreboard unit for scoreboard hit.
// 
//   add_path        Indicates that the path type (pathadd_a) should be
//                   added to the FIFO item at the end of the FIFO on
//                   the next clock edge.
//   
//   pathadd_a       The path type that is to be added to the FIFO item
//                   at the end of the FIFO on the next clock edge. It
//                   describes which path (DMP sub-module or peripheral)
//                   that is servicing an outstanding load.
// 
//   pathpop_a       The path from which the load returns. This FIFO item
//                   that is closest to the front of the FIFO and that
//                   matches this path type is the one that is popped.
//   
// ======================== Output from this block ====================--
// 
//   matchup_a       Indicates that a register address (s1a, s2a or dest)
//                   has matched up with a value in the fifo.
// 
//   full_r          Indicates that the fifo is full and cannot accept
//                   any more register address values.
// 
//   empty_a         Indicates that the fifo is empty and there are no
//                   loads waiting to complete.
// 
//   max_one_lpend   Indicates that the LSU contains zero or one pending
//                   load. It is generated from the inverse of the
//                   status flag of the second fifo item in the LSU. If
//                   the second fifo item is empty, then the LSU cannot
//                   contain more than at most one pending load. This
//                   signal is used by the DMP control logic.
// 
//   front[]         The register address at the front of the fifo. This
//                   is the value that is used by the load scoreboard
//                   unit for register writeback when a delayed load is
//                   completing.
// 
// ====================================================================--
//
module scorfifo (clk,
                 rst_a,
                 add,
                 add_path,
                 pop_a,
                 s1a,
                 s2a,
                 dest,
                 pathadd_a,
                 pathpop_a,
                 s1en,
                 s2en,
                 desten,
                 kill_last,

                 matchup_a,
                 full_r,
                 empty_a,
                 front_src1_match,
                 front_src2_match,
                 max_one_lpend,
                 front);

`include "arcutil_pkg_defines.v"
`include "arcutil.v" 

input    clk; 
input    rst_a; 
input    add; 
input    add_path; 
input    pop_a; 
input    [OPERAND_MSB:0] s1a; 
input    [OPERAND_MSB:0] s2a; 
input    [OPERAND_MSB:0] dest; 
input    [1:0] pathadd_a; 
input    [1:0] pathpop_a; 
input    s1en; 
input    s2en; 
input    desten; 
input    kill_last; 

output   matchup_a; 
output   full_r; 
output   empty_a; 
output   front_src1_match;   
output   front_src2_match;   
output   max_one_lpend;
output   [OPERAND_MSB:0] front; 

wire     matchup_a; 
wire     full_r; 
wire     empty_a; 
wire     max_one_lpend; 
wire     front_src1_match;   
wire     front_src2_match;   
wire     [OPERAND_MSB:0] front; 
wire     i_stateout0; 
wire     i_stateout1_r; 
wire     i_stateout4_r; 
wire     i_stateout5; //  input to tail of fifo
wire     i_stateout6; //  input to tail of fifo

//  source 1 adr match from each scoritem
wire     i_s1match1_a; 
wire     i_s1match4_a; 

//  source 2 adr match from each scoritem
wire     i_s2match1_a; 
wire     i_s2match4_a; 

//  source 2 adr match from each scoritem
wire     i_destmatch1_a; 
wire     i_destmatch4_a; 

//  the values in each scoritem
wire     [OPERAND_MSB:0] i_item1_r; //  front
wire     [OPERAND_MSB:0] i_item4_r; //  tail
wire     [OPERAND_MSB:0] i_item5_r; 
wire     i_matchup234_a; 
wire     i_matchup1_a; 
wire     i_matchup2_a; 
wire     i_matchup3_a; 
wire     i_matchup4_a; 

//  pop command for each fifo element
wire     i_pop1_a; 
wire     i_pop4_a; 

//  kill command for each fifo element
wire     i_kill1_a; 
wire     i_kill4_a; 

//  last command for each fifo element
wire     i_last1_a; 
wire     i_last4_a; 

//  remove command for each fifo element
wire     i_remove1_a; 
wire     i_remove4_a; 

//  content of the path bits for each fifo element
wire     [1:0] i_pathout1_r; 
wire     [1:0] i_pathout4_r; 
wire     [1:0] i_pathout5; 

//   
//    -------     -------     -------     -------
//   |       |   |       |   |       |   |       |
//   | fnum4 |-> | fnum3 |-> | fnum2 |-> | fnum1 |-> front
//   |       |   |       |   |       |   |       |
//   |       |   |       |   |       |   |       |
//    -------     -------     -------     -------

//  input for tail of fifo
assign i_stateout0 = 1'b 1;
assign i_stateout5 = 1'b 0; 
assign i_stateout6 = 1'b 0; 

//  core register 0
assign i_item5_r = r0;

//  load returned from load/store queue
assign i_pathout5 = LD_QUEUE;

//  front of fifo
scoritem U_scoritem0 (
                  .clk(clk),
                  .rst_a(rst_a),
                  .add(add),
                  .add_path(add_path),
                  .pop_a(i_pop1_a),
                  .kill(i_kill1_a),
                  .itemin(i_item4_r),
                  .statein(i_stateout4_r),
                  .statein2(1'b0),
                  .pathin(i_pathout4_r),
                  .stateahead(i_stateout0),
                  .s1a(s1a),
                  .s2a(s2a),
                  .dest(dest),
                  .pathadd_a(pathadd_a),

                  .itemout_r(i_item1_r),
                  .stateout_r(i_stateout1_r),
                  .pathout_r(i_pathout1_r),
                  .s1match_a(i_s1match1_a),
                  .s2match_a(i_s2match1_a),
                  .destmatch_a(i_destmatch1_a));


//  tail of fifo
scoritem U_scoritem3 (
                  .clk(clk),
                  .rst_a(rst_a),
                  .add(add),
                  .add_path(add_path),
                  .pop_a(i_pop4_a),
                  .kill(i_kill4_a),
                  .itemin(i_item5_r),
                  .statein(i_stateout5),
                  .statein2(i_stateout6),
                  .pathin(i_pathout5),
                  .stateahead(i_stateout1_r),
                  .s1a(s1a),
                  .s2a(s2a),
                  .dest(dest),
                  .pathadd_a(pathadd_a),

                  .itemout_r(i_item4_r),
                  .stateout_r(i_stateout4_r),
                  .pathout_r(i_pathout4_r),
                  .s1match_a(i_s1match4_a),
                  .s2match_a(i_s2match4_a),
                  .destmatch_a(i_destmatch4_a));

// Since each scoritem doesn't take into account of the enable
// signals, do it here.
//
// 
// This is a very difficult statement to get 100% multiple
// sub-condition coverage.
// 
// assign i_matchup234_a =
// 
//    (((i_s1match2_a  | i_s1match3_a   | i_s1match4_a)   & s1en) |
//    ((i_s2match2_a   | i_s2match3_a   | i_s2match4_a)   & s2en) |
//    ((i_destmatch2_a | i_destmatch3_a | i_destmatch4_a) & desten));
// 
// Report a match for the first load in the queue. This is used to
// allow returning loads to be shortcut into stage 2.
// 
assign i_matchup1_a = (i_s1match1_a & s1en) | (i_s2match1_a & s2en) | 
                    (i_destmatch1_a & desten);

assign i_matchup2_a = 1'b0;
assign i_matchup3_a = 1'b0;

assign i_matchup4_a = (i_s1match4_a & s1en) | (i_s2match4_a & s2en) | 
                    (i_destmatch4_a & desten);

assign i_matchup234_a = (i_matchup2_a | i_matchup3_a | i_matchup4_a);
 
//  Report a match from the FIFO
// 
assign matchup_a = (i_matchup1_a               == 1'b 1)  &
                   (~(i_remove1_a              == 1'b 1)) |
                   (i_matchup4_a               == 1'b 1)  & 
                   (~(i_remove4_a              == 1'b 1)) ?
       1'b 1 : 
       1'b 0;
 
// The remove signals indicate if a FIFO item is popped from
// the scoreboard.
// 
assign i_remove1_a = ((pop_a        == 1'b 1) &
                      (i_pathout1_r == pathpop_a)) ?
       1'b 1 :
       1'b 0;

assign i_remove4_a = ((pop_a        == 1'b 1)   &
                      ((i_pathout1_r != pathpop_a)
       ))  ? 1'b 1 : 1'b 0;
 
assign i_last1_a = ((i_stateout4_r == 1'b 0) &
                    (i_stateout1_r == 1'b 1)) ?
           1'b 1 :
           1'b 0;
   
   
assign i_last4_a = (i_stateout4_r == 1'b 1) ?
           1'b 1 :
           1'b 0;

assign i_kill1_a = ((kill_last == 1'b 1) &
                    (i_last1_a   == 1'b 1)) |
                   ((kill_last == 1'b 1) &
                    (i_stateout4_r   == 1'b 1) &
                    (pop_a       == 1'b 1)) ?
           1'b 1 :
           1'b 0;


assign i_kill4_a = ((kill_last == 1'b 1) &
                    (i_last4_a   == 1'b 1) &
                    (pop_a       == 1'b 0)) ?
           1'b 1 :
           1'b 0;

//  Each FIFO item is controlled by its separate pop_a control signal
//  A FIFO items is popped if the requested path of the pop (pathpop_a)
//  matches the path bits (e.g. i_pathout1_r) of either the FIFO item
//  itself or any FIFO item ahead of it. The last FIFO item is always
//  popped independent of matches, because every pop always succeeds.
//  That is why i_pop4_a (pop control for last FIFO item) equals the
//  global pop signal.
//
assign i_pop1_a = ((pop_a        == 1'b 1) &
                   (i_pathout1_r == pathpop_a)) ? 1'b 1 : 
       1'b 0; 


assign i_pop4_a = (pop_a == 1'b 1) ? 1'b 1 : 
       1'b 0;

//  The bus "front" is set to the item that is popped. The FIFO item
//  that has matching path type with the returning load and that
//  is closest to the front is popped.
// 

assign front_src1_match = (i_pathout1_r == pathpop_a) ?
           (i_s1match1_a &  s1en) :
                                  (i_pathout4_r == pathpop_a) ?
           (i_s1match4_a &  s1en) :
           1'b 0;

assign front_src2_match = (i_pathout1_r == pathpop_a) ?
           (i_s2match1_a &  s2en) :
                                  (i_pathout4_r == pathpop_a) ?
           (i_s2match4_a &  s2en) :
           1'b 0;

assign front = (i_pathout1_r == pathpop_a) ? i_item1_r : 
               (i_pathout4_r == pathpop_a) ? i_item4_r : 
       i_item1_r;

//  The signal max_one_lpend indicates that the LSU contains zero or
//  one pending load. It is generated from the inverse of the status
//  flag of the second fifo item in the LSU. If the second fifo item
//  is empty, then the LSU cannot contain more than at most one
//  pending load. This signal is used by the DMP control logic.
// 
assign max_one_lpend = (~i_stateout4_r); 
assign empty_a = (~i_stateout1_r); 
assign full_r = i_stateout4_r; 

endmodule // module scorfifo

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1999-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// The scoreboard functionality of the Load Scoreboard Unit (LSU).
// 
// ========================= Inputs to this block =====================--
//
//   s1a[]           Source 1 register address from stage 2. 
//                   Used for scoreboarding.
// 
//   s2a[]           Source 2 register address from stage 2.
//                   Used for scoreboarding.
// 
//   dest[]          Destination register address from stage 2
//                   Used for scoreboarding.
// 
//   s1en            Source 1 address is valid.
//                   Used by the scoreboard unit for scoreboard hit.
// 
//   s2en            Source 2 address is valid.
//                   Used by the scoreboard unit for scoreboard hit.
// 
//   desten          Destination address is valid.
//                   Used by the scoreboard unit for scoreboard hit.
// 
//   mload2b         Stage 2B contains a valid load instruction.
//                   Used by the scoreboard unit.
// 
//   en2b            Indicates that stage 2b is ready to move on.
//                   Used by the scoreboard to load up dest addr values.
// 
//   ldvalid         Indicates that there is a returning load. This
//                   signal is not set during debug access, because in
//                   that case the LSU is not used.
// 
//   q_ldvalid       Indicates that the load/store queue wishes to
//                   perform a writeback on the next cycle. 
//                   Writeback will be performed on behalf of the
//                   delayed load. The register address for writeback is
//                   provided on regadr[] and comes from the scoreboard
//                   unit. The amount of time required between this
//                   signal becoming valid and the end of the cycle will
//                   depend on the number of multiplexers in ALU which
//                   need to be switched to get everything lined up for
//                   writeback.
// 
//   dc_ldvalid_r    Indicates that the data cache wishes to perform a
//                   writeback on the next cycle. 
// 
//   loc_ldvalid     Indicates that the local RAM wishes to perform a
//                   writeback on the next cycle. 
// 
//   p_ldvalid       Indicates that the peripherals wishes to perform a
//                   writeback on the next cycle.
//         
//   en3             Indicates that pipeline stage 3 is ready to move on.
// 
//   mload           Indicates that pipeline stage 3 contains a load
//                   (LD) instruction.
// 
//   nocache         Indicates that the load (LD) or store (ST)
//                   instruction in pipeline stage 3 has the .DI
//                   extension enabled. This extension to LD/ST
//                   instructions can be used by the programmer/compiler
//                   to indicate that this memory request should not be
//                   serviced by the data cache.
// 
//   dc_disable_r    When the data cache is selected this auxiliary
//                   register is available. When it is set the data cache
//                   is disabled.
//
//   is_local_ram    Indicates that the address of a load (LD) or store
//                   (ST) request in pipeline stage 3 is within the
//                   boundaries of the Load/Store RAM (also called "local
//                   RAM"). The request will consequently be serviced by
//                   the Load/Store RAM.
// 
//   is_peripheral   Indicates that the address of a load (LD) or store
//                   (ST) request in pipeline stage 3 is within the
//                   boundaries of the peripherals. The request will
//                   consequently be serviced by a peripheral.
//
// ======================== Output from this block ====================--
// 
//   holdup12        Holds stages 1 and 2. The scoreboard uses this when
//                   the scoreboard is full or there is a scoreboard and
//                   register address hit. It is produced from s1a, s2a,
//                   dest, s1en, s2en, desten and the scoreboarding
//                   mechanism.
// 
//   empty_a         Indicates that the scoreboard is empty and there
//                   are no pending loads.
// 
//   max_one_lpend   Indicates that the LSU contains zero or one pending
//                   load. It is generated from the inverse of the
//                   status flag of the second fifo item in the LSU. If
//                   the second fifo item is empty, then the LSU cannot
//                   contain more than at most one pending load. This
//                   signal is used by the DMP control logic.
// 
//   regadr          Register address to be used for writes initiated by
//                   a load valid signal when a delayed load is
//                   completing.
// 
// ====================================================================--
//
module scorebd (clk,
                rst_a,
                s1a,
                s2a,
                dest,
                s1en,
                s2en,
                desten,
                mload2b,
                en2,
                en3,
                mload,
                nocache,
                dc_disable_r,
                kill_last,
                is_local_ram,
                is_peripheral,
                ldvalid,
                q_ldvalid,
                loc_ldvalid,

                regadr,
                holdup12,
                max_one_lpend,
                regadr_eq_src1,
                regadr_eq_src2,
                empty_a);

`include "arcutil_pkg_defines.v"
`include "arcutil.v" 

input   clk; 
input   rst_a; 
input   [OPERAND_MSB:0] s1a; 
input   [OPERAND_MSB:0] s2a; 
input   [OPERAND_MSB:0] dest; 
input   s1en; 
input   s2en; 
input   desten; 
input   mload2b; 
input   en2; 
input   en3; 
input   mload; 
input   nocache; 
input   dc_disable_r; 
input   kill_last; 
input   is_local_ram; 
input   is_peripheral;
 
input   ldvalid; 
input   q_ldvalid; 
input   loc_ldvalid; 

output   [OPERAND_MSB:0] regadr; 
output   holdup12; 
output   max_one_lpend; 
output   regadr_eq_src1; 
output   regadr_eq_src2; 
output   empty_a; 

wire    [OPERAND_MSB:0] regadr; 
wire    holdup12; 
wire    max_one_lpend; 
wire    regadr_eq_src1; 
wire    regadr_eq_src2; 
wire    empty_a; 
wire    i_add_a; 
wire    i_add_path_a; 
wire    i_pop_a; 
wire    [1:0] i_pathadd_a; 
wire    [1:0] i_pathpop_a; 
wire    i_full_r; 
wire    i_matchup_a; 
wire    i_freeslot_a; 

scorfifo U_scorfifo (.clk(clk),
                     .rst_a(rst_a),
                     .add(i_add_a),
                     .add_path(i_add_path_a),
                     .pop_a(i_pop_a),
                     .s1a(s1a),
                     .s2a(s2a),
                     .dest(dest),
                     .pathadd_a(i_pathadd_a),
                     .pathpop_a(i_pathpop_a),
                     .s1en(s1en),
                     .s2en(s2en),
                     .desten(desten),
                     .kill_last(kill_last),

                     .matchup_a(i_matchup_a),
                     .full_r(i_full_r),
                     .empty_a(empty_a),
                     .max_one_lpend(max_one_lpend),
                     .front_src1_match(regadr_eq_src1),
                     .front_src2_match(regadr_eq_src2),
                     .front(regadr));

assign i_add_a = ((mload2b      == 1'b 1) &&
                  (en2          == 1'b 1) && 
                  (i_freeslot_a == 1'b 1))   ?
       1'b 1 : 
       1'b 0;

// -------------------------------------------------------------------
//  Adding return address to the lsu fifo
// -------------------------------------------------------------------
// 
//  Always add when a load is in pipeline stage 2 and the fifo is not
//  full
// 
//  ...and if we allow load shortcutting:
// 
//     if fifo is full and a load is in stage2 and any load valid
//     signal is true then it is okay to add, since we will be
//     simultaneously popping as a result of ldvalid.
// 
// -------------------------------------------------------------------
//  Adding path to the LSU FIFO
// -------------------------------------------------------------------
// 
//  Always add the path in pipeline stage 3, when there is a load
//  instruction (mload = '1'), which is allowed to move on
//  (en3 = '1'). The path that is added depends on a couple of
//  qualifiers. The path is set to (in priority order):
// 
//     1. To the constant LD_PERIPH if is_peripheral is set.
// 
//     2. To the constant LD_RAM if is_local_ram is set.
// 
//     3. To the constant LD_QUEUE if the data cache is disabled
//        (dc_disable_r = '0') or the .DI extension has been used
//        on the LD/ST instruction to indicate that the instruction
//        should not be serviced by the data cache.
// 
//     4. If all 3 conditions above are false the path is set to
//        the data cache, i.e. to the constant LD_CACHE.
// 
//  The constants are defined in the include file arcutil.
//

assign i_add_path_a = ((mload == 1'b 1) && (en3 == 1'b 1)) ?
       1'b 1 : 
       1'b 0; 
       
assign i_pathadd_a = 
                     (is_peripheral == 1'b 1) ? LD_PERIPH : 
                     (is_local_ram == 1'b 1) ? LD_RAM : 
                     (dc_disable_r == 1'b 0) && (nocache == 1'b 0) ? LD_CACHE : 
       LD_QUEUE;

// -------------------------------------------------------------------
//  Popping return address from the LSU FIFO
// -------------------------------------------------------------------
//
//  Always pop when a delayed load comes back in pipeline stage 3, so
//  that the return address is available in pipeline stage 4.
//
//  The LSU FIFO is not a true FIFO, but a queue of a kind called
//  "balking form". Basically it is a FIFO that permits an item to be
//  removed from a location other than the front of the FIFO. Which
//  location that is being popped depends on from which path the load
//  returns. If the load returns from for example the data cache, the
//  FIFO item is popped that is closest to the the front of the FIFO
//  and that has the same path type (i.e. data cache in this
//  example). If the LSU FIFO only contains one path type, it acts
//  exactly as a FIFO.
// 
//  Loads can return from different paths at the same time, but only
//  one can be serviced at the time. The Load Return Arbitrator in
//  the DMP takes care of arbitrating between the returning loads.
//  The only thing the LSU needs to do is to make the return address
//  available for the returning load from the memory path with the
//  highest priority. The bus i_pathpop_a is set to the path type of the
//  load return with the highest priority. The bus i_pathpop_a is set
//  in priority order as follows (the constants are defined in
//  arcutil.v):
// 
//          1.To the constant LD_QUEUE (load/store queue) if a load
//            returns from the load/store queue (q_ldvalid = '1')
//
//          2.To the constant LD_CACHE (data cache) if a load returns
//            from the data cache (dc_ldvalid_r = '1').
//
//          3.To the constant LD_RAM (LD/ST RAM) if a load returns
//            from the load/store RAM (loc_ldvalid = '1').
//
//          4.To the constant LD_PERIPH (peripheral) if a load
//            returns from a peripheral (p_ldvalid = '1').
//
//          5.To the constant LD_QUEUE (load/store queue) if no load
//            returns at all.
//
assign i_pop_a = ldvalid; 
assign i_pathpop_a = 
                     (q_ldvalid == 1'b 1) ? LD_QUEUE : 
                     (loc_ldvalid == 1'b 1) ? LD_RAM : 
       LD_QUEUE;

// -------------------------------------------------------------------
//  Stall stage 2 under the following conditions:
// -------------------------------------------------------------------
// 
//  i.  There is a match between a source register in stage 2 and a
//      pending load.
// 
//       i_matchup_a == 1'b 1
//  
//  ii. The fifo is full, and we don't have a returning load - which
//      will clear a slot. A returning load clearing a slot can only
//      happen when we allow load shortcutting, since in the
//      always-stalls case, stage 3 is stalled by ldvalid, so we do
//      not need to include it here.
// 
//       (mload2b == 1'b 1 & i_freeslot_a == 1'b 0)
// 
//  What will happen in the case when an instruction in stage 2 is
//  waiting on a load to return? The FIFO now has a mode which will
//  prevent 'matchup' from being set if a returning load will write
//  the register which would otherwise cause a stall.
//  
//  The case would be :  ldvalid == 1'b 1
//                       regadr == s1a | regadr == s2a |
//                       regadr == dest
//                       (s1en == 1'b 1), (s2en == 1'b 1),
//                       (desten == 1'b 1) valid as appropriate
//                       (-> scorfifo s1match1/s2match1/destmatch1
//                       true, pop == 1'b 1)
// 
//  The case of instructions dependent on loads to non-shortcuttable
//  registers (e.g. loopcount) is handled by the ihp2_ld_nsc signal
//  in rctl.v. Essentially an additional pipeline stage 2 stall is
//  generated when a load is returning to a non-shortcuttable
//  register, and there is a read dependent upon this load.
// 
assign holdup12 = (((mload2b      == 1'b 1) &&
                    (i_freeslot_a == 1'b 0)) || 
                   (i_matchup_a  == 1'b 1)) ?
       1'b 1 : 
       1'b 0;

//  This signal is true when a free slot is, or is becoming available
//  in the fifo. Either the fifo already has a free slot, or a
//  returning load may cause a slot to become free, in the case where
//  the load queue is already full.
// 
assign i_freeslot_a = ((i_full_r == 1'b 0) || (i_pop_a == 1'b 1)) ?
       1'b 1 : 
       1'b 0; 

endmodule // module scorebd

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1999-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This is the top level of the Load Scoreboard Unit.
// 
// This unit scoreboards the loads to allow out of order load
// return between different data memory pipeline (DMP) sub-
// modules and peripherals. Two loads can return out of order
// if they go through different DMP sub-modules or peripherals.
// However, they return in order if they are serviced by the same
// sub-module. The peripherals count as one sub-module for the
// LSU, so two loads serviced by two different peripherals
// return in order. However one load to a DMP sub-module and
// one load to a peripheral can return out of order.
//  
// ========================= Inputs to this block =====================--
// 
//   s1a             Source 1 register address from stage 2. 
//                   Used for scoreboarding.
// 
//   fs2a            Source 2 register address from stage 2.
//                   Used for scoreboarding.
// 
//   dest            Destination register address from stage 2.
//                   Used for scoreboarding.
// 
//   mload2b         Stage 2B contains a valid load instruction.
//                   Used by the scoreboard unit.
// 
//   s1en            Source 1 address is valid.
//                   Used by the scoreboard unit for scoreboard hit.
// 
//   s2en            Source 2 address is valid.
//                   Used by the scoreboard unit for scoreboard hit.
// 
//   desten          Destination address is valid.
//                   Used by the scoreboard unit for scoreboard hit.
// 
//   en2b            Indicates that stage 2b is ready to move on.
//                   Used by the scoreboard to load up dest addr values.
// 
//   ldvalid         Indicates that there is a returning load. This
//                   signal is not set during debug access, because in
//                   that case the LSU is not used. 
// 
//   q_ldvalid       Indicates that the load/store queue wishes to
//                   perform a writeback on the next cycle. Writeback
//                   will be performed on behalf of the delayed load.
//                   The register address for writeback is provided on
//                   regadr[] and comes from the scoreboard unit. The
//                   amount of time required between this signal
//                   becoming valid and the end of the cycle will depend
//                   on the number of multiplexers in ALU which need to
//                   be switched to get everything lined up for
//                   writeback.
// 
//   dc_ldvalid_r    Indicates that the data cache wishes to perform a
//                   writeback on the next cycle.
// 
//   loc_ldvalid     Indicates that the local RAM wishes to perform a
//                   writeback on the next cycle.
// 
//   p_ldvalid       Indicates that the peripherals wishes to perform a
//                   writeback on the next cycle.
//         
//   en3             Indicates that pipeline stage 3 is ready to move on.
// 
//   mload           Indicates that pipeline stage 3 contains a load (LD)
//                   instruction.
// 
//   nocache         Indicates that the load (LD) or store (ST)
//                   instruction in pipeline stage 3 has the .DI
//                   extension enabled. This extension to LD/ST
//                   instructions can be used by the programmer/
//                   compiler to indicate that this memory request should
//                   not be serviced by the data cache.
// 
//   dc_disable_r    When the data cache is selected this auxiliary
//                   register is available. When it is set the data
//                   cache is disabled. If there is no data cache in the
//                   build then this signal is always set.
//
//   kill_last       True when a mispredicted compare & branch needs to
//                   remove an item from the load-store queue.
//         
//   is_local_ram    Indicates that the address of a load (LD) or store
//                   (ST) request in pipeline stage 3 is within the
//                   boundaries of the Load/Store RAM (also called "local
//                   RAM"). The request will consequently be serviced by
//                   the Load/Store RAM.
// 
//   is_peripheral   Indicates that the address of a load (LD) or store
//                   (ST) request in pipeline stage 3 is within the
//                   boundaries of the peripherals. The request will
//                   consequently be serviced by a peripheral.
//
   
// ======================== Output from this block ====================--
// 
//   holdup2b        Holds stage2b. The scoreboard uses this when
//                   the scoreboard is full or there is a scoreboard and
//                   register address hit. It is produced from s1a, fs2a,
//                   dest, s1en, s2en, desten and the scoreboarding
//                   mechanism.
// 
//   lpending        Indicates to ARC that there is at least one load
//                   pending. It is the inverse of the empty flag from
//                   the scoreboard.
// 
//   max_one_lpend   Indicates that the LSU contains zero or one pending
//                   load. It is generated from the inverse of the
//                   status flag of the second fifo item in the LSU. If
//                   the second fifo item is empty, then the LSU cannot
//                   contain more than at most one pending load. This
//                   signal is used by the DMP control logic.
// 
//   regadr          The register address which is to be used for a load
//                   writeback when ldvalid is true.
//
//
// regadr_eq_src1   U True when load return register address matches source 1
//                  of the instruction in stage2b
//
// regadr_eq_src2   U True when load return register address matches source 2
//                  of the instruction in stage2b
//
// ====================================================================--
//
module lsu (clk,
            rst_a,
            ldvalid,
            q_ldvalid,
            loc_ldvalid,
                is_local_ram,
                is_peripheral,
            s1a,
            fs2a,
            dest,
            mload2b,
            s1en,
            s2en,
            desten,
            en2b,
            kill_last,
            en3,
            mload,
            nocache,
            dc_disable_r,

            regadr,
            regadr_eq_src1,
            regadr_eq_src2,
            holdup2b,
            max_one_lpend,
            lpending);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"    

input   clk; 
input   rst_a; 
input   ldvalid;
input   q_ldvalid; 
input   loc_ldvalid; 
input   is_local_ram; 
input   is_peripheral;
 
input   [5:0] s1a; 
input   [5:0] fs2a; 
input   [5:0] dest; 
input   mload2b; 
input   s1en; 
input   s2en; 
input   desten; 
input   en2b;
input   kill_last;   
input   en3; 
input   mload; 
input   nocache; 
input   dc_disable_r; 

output  [5:0] regadr; 
output  regadr_eq_src1; 
output  regadr_eq_src2; 
output  holdup2b; 
output  max_one_lpend; 
output  lpending; 

wire    [5:0] regadr; 
wire    regadr_eq_src1; 
wire    regadr_eq_src2; 
wire    holdup2b; 
wire    max_one_lpend; 
wire    lpending; 
wire    i_empty_a; 

scorebd U_scoreboard(
                   .clk(clk),
                   .rst_a(rst_a),
                   .s1a(s1a),
                   .s2a(fs2a),
                   .dest(dest),
                   .s1en(s1en),
                   .s2en(s2en),
                   .desten(desten),
                   .mload2b(mload2b),
                   .en2(en2b),
                   .ldvalid(ldvalid),
                   .q_ldvalid(q_ldvalid),
                   .loc_ldvalid(loc_ldvalid),
                   .en3(en3),
                   .mload(mload),
                   .nocache(nocache),
                   .dc_disable_r(dc_disable_r),
                   .kill_last(kill_last),
                   .is_local_ram(is_local_ram),
                   .is_peripheral(is_peripheral),

                   .regadr(regadr),
                   .regadr_eq_src1(regadr_eq_src1),
                   .regadr_eq_src2(regadr_eq_src2),
                   .holdup12(holdup2b),
                   .max_one_lpend(max_one_lpend),
                   .empty_a(i_empty_a));

//  Load pending signal to be used by ARC as a bit of the debug
//  register.
// 
assign lpending = ~i_empty_a;


endmodule // module lsu

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains the placeholder for the extension control logic.
//
// 
// This file is extension RISC control unit for :
//       Single-cycle Barrel Shifter Instructions
//       Small Score Boarded Multiply Instruction, Revision info. :  600 Architecture IP Library version 4.9.7, file revision  $Date$
//       Normalise Instruction  
//       Swap Instruction, Revision info. :  600 Architecture IP Library version 4.9.7, file revision  $Date$
// 
// 
// ========================== Inputs to this block ==========================--
// 
// ------------------------- Stage 2 - Operand fetch --------------------------
// 
//  s1en            U This signal is used to indicate to the LSU that
//                  the instruction in pipeline stage 2 will use the
//                  data from the register specified by s1a[5:0]. If
//                  the signal is not true, the LSU will ignore
//                  s1a[5:0]. This signal includes p2iv as part of its
//                  decode.
// 
//  s2en            U This signal is used to indicate to the LSU that
//                  the instruction in pipeline stage 2 will use the
//                  data from the register specified by fs2a[5:0]. If the
//                  signal is not true, the LSU will ignore fs2a[5:0]. 
//                  This signal includes p2iv as part of its decode.
// 
//  en2             U Pipeline stage 2 enable. When this signal is true,
//                  the instruction in stage 2 can pass into stage 3 at
//                  the end of the cycle. When it is false, it will hold
//                  up stage 2 and stage 1 (pcen).
//
//  dmp_holdup12    U From the debug access unit in the Data Memory
//                  Pipeline (DMP). If the debug interface is accessing
//                  the load/store memory space then this signal is set.
//                  If there is a load (LD) or store (ST) in pipeline
//                  stage 2 when dmp_holdup12 is set then pipeline stages
//                  1-2 are stalled. The reason for stalling is that the
//                  DMP is busy servicing data memory accesses from the
//                  debug interface. However if the pipeline is free from
//                  LD/ST instructions it will continue to flow even if
//                  dmp_holdup12 is set. This signal is only used in a
//                  build with memory subsystem.
//
// mload2b           U This signal indicates to the LSU that there is a valid
//                  load instruction in stage 2. It is produced from a decode
//                  of p2opcode[4:0], p2subopcode[5:0] and the p2iv signal.
//  
// mstore2b          U This signal indicates to the actionpoint mechanism when
//                  selected that there is a valid store instruction in stage
//                  2. It is produced from a decode of p2opcode[4:0],
//                  p2subopcode[5:0] and the p2iv signal.
//  
// p2_b_field_r     This is the source B address field for 32-bit
//                  instructions.
// 
// p2_c_field_r     Instruction C field. This bus carries the region of 
//                  the instruction which contains the operand C field.
//
// p2conditional    This signal is set to true when a conditionally
//                  executed instruction is detected in stage two.
//
// p2opcode[4:0]    L Opcode word. This bus contains the instruction word
//                  which is being executed by stage 2. It must be qualified
//                  by p2iv.
//
// p2iv             L Opcode valid. This signal is used to indicate that the 
//                  opcode in pipeline stage 2 is a valid instruction. The
//                  instruction may not be valid if a junk instruction has
//                  been allowed to come into the pipeline in order to allow
//                  the pipeline to continue running when an instruction 
//                  cannot be fetched by the memory controller.
//
//  s1a[5:0]        L Source 1 register address. This is the B field from
//                  the instruction word, sent to the core registers (via
//                  hostif) and the LSU. It is qualified for LSU use by
//                  s1en.
// 
//  fs2a[5:0]       L Source 2 register address. This is the C field from
//                  the instruction word, sent to the core registers and 
//                  the LSU. It is qualified for LSU use by s2en.
// 
//  p2cc[3:0]       L This bus contains the region of the instruction 
//                  which contains the four-bit condition code field. It
//                  is sent to the extension condition code test logic
//                  which provides in return a signal (xp2ccmatch) which
//                  indicates whether it considers the condition to be
//                  true. The ARC decides whether to use the internal
//                  condition-true signal or the signal provided by
//                  extensions depending on the fifth bit of the
//                  instruction. This is handled within rctl.
// 
// ----------------------------- Stage 3 - ALU --------------------------------
// 
//  p3a_field_r     Instruction A field. This bus carries the region of 
//                  the instruction which contains the operand
//                  destination field in stage 3. 
//
//  p3b_field_r     Instruction B field. This bus carries the region of 
//                  the instruction which contains the source one operand
//                  field in stage 3. 
//
//  p3c_field_r     Instruction C field. This bus carries the region of 
//                  the instruction which contains the operand C field.
//
//  p3condtrue      U This signal is produced from the result of the
//                  internal stage 3 condition code unit or from an
//                  extension cc unit (if implemented). A bit (bit 5) in
//                  the instruction selects between the internal and
//                  extension cc unit results. In addition, this signal
//                  is set true if the instruction is using short
//                  immediate data.
//                  For extensions use it should always be qualified
//                  with an instruction decode and p3iv. 
//   
//  p3iv            L Opcode valid. This signal is used to indicate 
//                  that the opcode in pipeline stage 3 is a valid
//                  instruction. The instruction may not be valid if a
//                  junk instruction has been allowed to come into the
//                  pipeline in order to allow the pipeline to continue
//                  running when an instruction cannot be fetched by the
//                  memory controller, or when an instruction has been
//                  killed.
//                  It should be noted that it is possible for a stall 
//                  condition to occur in stage 2 whilst stage 3
//                  completes. This will mean that a 'bubble' will be
//                  introduced to the pipeline. State machines should
//                  always bear in mind that if an instruction moves out
//                  of stage 3, this does not always mean that a new
//                  instruction will come into stage 3.
// 
//  en3             U Pipeline stage 3 enable. When this signal is true,
//                  the instruction in stage 3 can pass into stage 4 at
//                  the end of the cycle. When it is false, it will
//                  probably hold up stage 1 and 2 (pcen, en2), along
//                  with stage 3.
// 
//  aluflags_r[3:0] L Direct from the latches, the Z N C V flags supplied
//                  to the ALU in stage 3.
// 
//  p3cc[3:0]       L This bus contains the region of the instruction 
//                  which contains the four-bit condition code field. It
//                  is sent with the alu flags to the extension condition 
//                  code test logic which provides in return a signal
//                  (xp3ccmatch) which indicates whether it considers the
//                  condition to be true. The ARC decides whether to use
//                  the internal condition-true signal or the signal
//                  provided by extensions depending on the fifth bit of 
//                  the instruction. This is handled within rctl.
// 
// p3minoropcode    Minor opcode (sub-sub-opcode) of instruction in
//                  stage 3.
//
// p3opcode[4:0]    Opcode word. This bus contains the instruction word
//                  which is being executed by stage 3. It must be
//                  qualified by p3iv.
//
// p3setflags       This signal is used by regular alu-type instructions
//                  and the jump instruction to control whether the
//                  supplied flags get stored. It is produced from the
//                  set-flags bit in the instruction word, but if that
//                  field is not present in the instruction then it will
//                  come from the set-flag modes implied by the
//                  instruction itself, i.e. TST, RCMP or CMP.
//                  Does not include p3iv.
//
// p3subopcode      Sub-opcode word (for 32-bit instruction).
//
// p3subopcode1_r   Sub-opcode word (for 16-bit instruction).
//
// p3subopcode2_r   Sub-opcode word (for 16-bit instruction).
//
// p3_xmultic_nwb   Multi-cycle Extension write-back not allowed. When
//                  this signal is asserted no multi-cycle extension is
//                  allowed to write back. If this signal and
//                  x_multic_wben is true then the multi-cycle extension
//                  pipeline must stall.
//
//========================= Output from this block ==========================--
//
// x_idecode2       To rctl module. This signal will be true when the
//                  extension logic detects an extension instruction in
//                  stage 2 and is produced from p2opcode[4:0].
//                  It is used in conjunction with internal decode
//                  signals to produce illegal-instruction interrupts.
//
// x_idop_decode2   This signal is asserted by 'xrctl' when the extension
//                  instruction in stage 2 is dual operand.
//
// x_isop_decode2   This signal is asserted by 'xrctl' when the extension
//                  instruction in stage 2 is single operand.
//
// x_p1_rev_src     This comes from 'xrctl' and when asserted causes the
//                  the source fields to be reversed.
//
// x_p2_jump_decode This signal is asserted for extension jump
//                  instructions.
//
// x_p2nosc1        To rctl module. Indicates that the register
//                  referenced by s1a[5:0] is not available for
//                  shortcutting. This signal should only be set true
//                  when the register in question is an extension core
//                  register. This signal is ignored unless constant
//                  XT_COREREG is set true.
//
// x_p2nosc2        To rctl module. Indicates that the register
//                  referenced by fs2a[5:0] is not available for
//                  shortcutting. This signal should only be set true
//                  when the register in question is an extension core
//                  register. This signal is ignored unless constant
//                  XT_COREREG is set true.
//
// x_p2shimm_a      To rctl module. Indicates that a short immediate
//                  is used for instruction in stage 2.
//
// xholdup2         To rctl module. This signal is used to hold up
//                  pipeline stages 1 and 2 (pcen, en1 and en2) when 
//                  extension logic requires that stage 2 be held up.
//                  For example, a core register is being used as a
//                  window into SRAM, and the SRAM is not available on
//                  this cycle, as a write is taking place from stage 4,
//                  the writeback stage. Hence stage 2 must be held to
//                  allow the write to complete before the load can
//                  happen. Stages 3 and 4 will continue running.
//
// xp2ccmatch       This signal is provided by an extension condition-
//                  code unit which takes the condition code field from
//                  the instruction (at stage 2), and the alu flags
//                  (from stage 3) performs some operation on them and
//                  produces this condition true signal. Another bit in
//                  the instruction word indicates to the ARC whether it
//                  should use the internal condition-true signal or
//                  this one provided by the extension logic. This
//                  technique will allow extra branch/jump conditions to
//                  be added which may be specific to different
//                  implementations of the ARC.
//
// xp2idest         To rctl module. This signal is used to indicate
//                  that the instruction in stage 2 will not actually
//                  write back to the register specifed in the A field.
//                  This is used with extension instructions which write
//                  to FifOs using the destination register to carry the
//                  co-pro register number. It has the effect of
//                  preventing the scoreboard unit from looking at the
//                  destination register by clearing the desten signal.
//                  It will only take effect when the top bit of the
//                  instruction opcode field is set, indicating that it
//                  is an extension instruction.
//
// x_flgen          Extension basecase flag update. This signal is true
//                  when any extension wants to update the basecase
//                  flags.
//
// x_multic_wba     Multi-cycle extension writeback address. This signal
//                  is the writeback address for the instruction
//                  asserting the x_multic_wben signal.
//
// x_multic_wben    Multi-cycle extension writeback enable. This signal
//                  is true when the multi-cycle instruction wants to
//                  write-back. It should have been qualified with p3iv,
//                  and p3condtrue and the extension  opcode. If any
//                  other instruction requires a write back at the same
//                  time this signal is true the ARCompact pipeline will
//                  stall and the multi-cycle extension will write back.
//
// x_snglec_wben    Single-cycle extension writeback enable. This signal
//                  is true when the multi-cycle instruction wants to
//                  write-back. It should have been qualified with p3iv,
//                  and p3condtrue and the extension  opcode. If any
//                  other instruction requires a write back at the same
//                  time this signal is true the ARCompact pipeline will
//                  stall and the multi-cycle extension will write back.
//
// ==========================================================================--
//
module xrctl (clk,
              rst_a,
              en,
              s1en,
              s2en,
   code_stall_ldst,
              mulatwork_r,
              ivalid_aligned,
              en2,
              p2_a_field_r,
              p2_b_field_r,
              p2_c_field_r,
              p2bch,
              p2cc,
              p2conditional,
              p2format,
              p2iv,
              p2minoropcode,  
              p2opcode,
              p2sleep_inst,
              p2setflags,
              p2st,
              p2subopcode,
              p2subopcode1_r,
              p2subopcode2_r,
              p2subopcode3_r,
              p2subopcode4_r,
              p2subopcode5_r,
              p2subopcode6_r,
              p2subopcode7_r,
              en2b,
              mload2b,
              mstore2b,
              p2bint,
              p2b_a_field_r,
              p2b_b_field_r,
              p2b_c_field_r,
              p2b_bch,
              p2b_cc,
              p2b_conditional,
              p2b_format,
              p2b_iv,
              p2b_minoropcode,
              p2b_opcode,
              p2b_setflags,
              p2b_st,
              p2b_subopcode,
              p2b_subopcode1_r,
              p2b_subopcode2_r,
              p2b_subopcode3_r,
              p2b_subopcode4_r,
              p2b_subopcode5_r,
              p2b_subopcode6_r,
              p2b_subopcode7_r,
              dmp_holdup12,
              fs2a,
              s1a,
              s1bus,
              s2bus,
              sc_reg1,
              sc_reg2,
              ext_s2val,
              s2val,
              p3a_field_r,
              p3b_field_r,
              p3c_field_r,
              p3condtrue,
              p3format,  
              p3iv,
              p3destlimm,
              p3minoropcode,  
              p3opcode,
              p3setflags,
              p3subopcode,
              p3subopcode1_r,
              p3subopcode2_r,
              p3subopcode3_r,
              p3wb_en,
              p3wba,
              en3,
              p3cc,
              dest,
              desten,
              aluflags_r,
              p3lr,
              p3sr,
              aux_addr,
              kill_p1_a,
              kill_p2_a,
              kill_p2b_a,
              kill_p3_a,
              p3_xmultic_nwb,
              ux_p2nosc1,
              ux_p2nosc2,
              uxp2ccmatch,
              uxp2bccmatch,
              uxp3ccmatch,
              uxholdup2,
              uxholdup2b,
              uxholdup3,
              uxnwb,
              uxp2idest,
              uxsetflags,
              ux_isop_decode2,
              ux_idop_decode2,
              ux_izop_decode2,
              ux_flgen,
              ux_p1_rev_src,
              ux_multic_wba,
              ux_multic_wben,
              ux_multic_busy,
              ux_p2_bfield_wb_a,
              ux_p2_jump_decode,
              ux_snglec_wben,

              barrel_type_r,
              x_p3_brl_decode_16_r,
              x_p3_brl_decode_32_r,
              x_p3_norm_decode_r,
              x_p3_snorm_decode_r,
              x_p3_swap_decode_r,
              p2dop32_inst,
              p2sop32_inst,
              p2zop32_inst,
              p2dop16_inst,
              p2sop16_inst,
              p2zop16_inst,
              p2b_dop32_inst,
              p2b_sop32_inst,
              p2b_zop32_inst,
              p2b_dop16_inst,
              p2b_sop16_inst,
              p2b_zop16_inst,
              p3dop32_inst,
              p3sop32_inst,
              p3zop32_inst,
              p3dop16_inst,
              p3sop16_inst,
              p3zop16_inst,
              x_p1_rev_src,
              xholdup2,
              xholdup2b,
              xp2idest,
              x_flgen,
              x_idecode2,
              x_idecode2b,
              x_isop_decode2,
              x_idop_decode2,
              x_izop_decode2,
              x_multic_wba,
              x_multic_wben,
              x_multic_busy,
              x_p2_bfield_wb_a,
              xp2ccmatch,
              xp2bccmatch,
              x_p2nosc1,
              x_p2nosc2,
              x_p2shimm_a,
              x_p2_jump_decode,
              x_p2b_jump_decode,
              x_snglec_wben,
              xsetflags,
              xp3ccmatch,
              xholdup3,
              x_idecode3,
              x_set_sflag,
              xnwb);

`include "arcutil_pkg_defines.v" 
`include "arcutil.v"        
`include "asmutil.v"
`include "extutil.v"         
`include "xdefs.v"       
//Extra include files required for extensions are inserted here.

   input         clk;  // system clock
   input         rst_a; //  system reset
   input         en;  //  system go
   input         s1en; 
   input         s2en;
   
   //Signals required for extensions are inserted here. The automatic
   //hierarchy generation system can be used to create the structural
   //HDL to tie all the components together, provided that certain
   //naming and usage rules are followed. Please see the document
   //'Automatic Hierarchy Generator' - $ARCHOME/arc/docs/hiergen.pdf
   
   input   code_stall_ldst; 
   input         mulatwork_r;
   input         ivalid_aligned;
   input         en2;
   input   [5:0] p2_a_field_r; 
   input   [5:0] p2_b_field_r;
   input   [5:0] p2_c_field_r;
   input         p2bch;
   input   [3:0] p2cc; 
   input         p2conditional;
   input   [1:0] p2format; 
   input         p2iv; 
   input   [5:0] p2minoropcode; 
   input   [4:0] p2opcode; 
   input         p2sleep_inst;
   input         p2setflags;
   input         p2st;
   input   [5:0] p2subopcode; 
   input   [1:0] p2subopcode1_r; 
   input   [4:0] p2subopcode2_r; 
   input   [2:0] p2subopcode3_r; 
   input         p2subopcode4_r; 
   input   [1:0] p2subopcode5_r; 
   input   [2:0] p2subopcode6_r; 
   input   [1:0] p2subopcode7_r; 
   input         en2b;
   input         mload2b;
   input         mstore2b;   
   input         p2bint;
   input   [5:0] p2b_a_field_r;
   input   [5:0] p2b_b_field_r;
   input   [5:0] p2b_c_field_r;
   input         p2b_bch;   
   input   [3:0] p2b_cc;   
   input         p2b_conditional;   
   input   [1:0] p2b_format;   
   input         p2b_iv;   
   input  [5:0]  p2b_minoropcode;   
   input  [4:0]  p2b_opcode;   
   input         p2b_setflags;   
   input         p2b_st;   
   input   [5:0] p2b_subopcode;   
   input   [1:0] p2b_subopcode1_r;   
   input   [4:0] p2b_subopcode2_r;   
   input   [2:0] p2b_subopcode3_r;   
   input         p2b_subopcode4_r;   
   input   [1:0] p2b_subopcode5_r;   
   input   [2:0] p2b_subopcode6_r;   
   input   [1:0] p2b_subopcode7_r;
   input         dmp_holdup12;
   input   [5:0] fs2a;
   input   [5:0] s1a; 
   input  [31:0] s1bus; 
   input  [31:0] s2bus;
   input         sc_reg1;
   input         sc_reg2;
   input  [31:0] ext_s2val;
   input  [31:0] s2val;
   input   [5:0] p3a_field_r; 
   input   [5:0] p3b_field_r;
   input   [5:0] p3c_field_r;
   input         p3condtrue; 
   input   [1:0] p3format; 
   input         p3iv;
   input         p3destlimm;
   input   [5:0] p3minoropcode; 
   input   [4:0] p3opcode; 
   input         p3setflags; 
   input   [5:0] p3subopcode; 
   input   [1:0] p3subopcode1_r; 
   input   [4:0] p3subopcode2_r; 
   input   [2:0] p3subopcode3_r; 
   input         p3wb_en;
   input   [5:0] p3wba;
   input         en3;
   input   [3:0] p3cc;
   input   [5:0] dest;
   input         desten;
   input   [3:0] aluflags_r;
   input         p3lr;
   input         p3sr;
   input [31:0]  aux_addr;
   input         kill_p1_a;
   input         kill_p2_a;
   input         kill_p2b_a;
   input         kill_p3_a;
   input         p3_xmultic_nwb;
   input         ux_p2nosc1;
   input         ux_p2nosc2;
   input         uxp2ccmatch;
   input         uxp2bccmatch;
   input         uxp3ccmatch;
   input         uxholdup2;
   input         uxholdup2b;
   input         uxholdup3;
   input         uxnwb;
   input         uxp2idest;
   input         uxsetflags;
   input         ux_isop_decode2;
   input         ux_idop_decode2;
   input         ux_izop_decode2;
   input         ux_flgen;
   input         ux_p1_rev_src;
   input   [5:0] ux_multic_wba;
   input         ux_multic_wben;
   input         ux_multic_busy;
   input         ux_p2_bfield_wb_a;
   input         ux_p2_jump_decode;
   input         ux_snglec_wben;

   //Signals required for extensions are inserted here. The automatic
   //hierarchy generation system can be used to create the structural
   //HDL to tie all the components together, provided that certain
   //naming and usage rules are followed. Please see the document
   //'Automatic Hierarchy Generator' - $ARCHOME/arc/docs/hiergen.pdf
   
      output  [1:0] barrel_type_r;
   output        x_p3_brl_decode_16_r;
   output        x_p3_brl_decode_32_r;  
   output        x_p3_norm_decode_r;
   output        x_p3_snorm_decode_r;
   output        x_p3_swap_decode_r;

   output        p2dop32_inst;
   output        p2sop32_inst;
   output        p2zop32_inst;
   output        p2dop16_inst;
   output        p2sop16_inst;
   output        p2zop16_inst;
   output        p2b_dop32_inst;
   output        p2b_sop32_inst;
   output        p2b_zop32_inst;
   output        p2b_dop16_inst;
   output        p2b_sop16_inst;
   output        p2b_zop16_inst;
   output        p3dop32_inst;
   output        p3sop32_inst;
   output        p3zop32_inst;
   output        p3dop16_inst;
   output        p3sop16_inst;
   output        p3zop16_inst;

   output        x_p1_rev_src;
   output        xholdup2; 
   output        xholdup2b; 
   output        xp2idest; 
   output        x_flgen; 
   output        x_idecode2; 
   output        x_idecode2b; 
   output        x_isop_decode2; 
   output        x_idop_decode2; 
   output        x_izop_decode2; 
   output  [5:0] x_multic_wba;
   output        x_multic_wben;
   output        x_multic_busy;
                 
   output        x_p2_bfield_wb_a; 
   output        xp2ccmatch;
   output        xp2bccmatch;
   output        x_p2nosc1; 
   output        x_p2nosc2;
   output        x_p2shimm_a; 
   output        x_p2_jump_decode;
   output        x_p2b_jump_decode;
   output        x_snglec_wben;
   output        xsetflags; 
   output        xp3ccmatch; 
   output        xholdup3; 
   output        x_idecode3;
   output        x_set_sflag; 
   output        xnwb;
    
      reg     [1:0] barrel_type_r;
   reg           x_p3_brl_decode_16_r;  
   reg           x_p3_brl_decode_32_r; 
   wire          x_p3_norm_decode_r;
   wire          x_p3_snorm_decode_r;
// SWAP
   wire          x_p3_swap_decode_r;
   wire          x_p1_rev_src; 
   wire          xholdup2; 
   wire          xholdup2b; 
   wire          xp2idest; 
   wire          x_flgen; 
   wire          x_idecode2; 
   wire          x_isop_decode2; 
   wire          x_idop_decode2; 
   wire          x_izop_decode2; 
   wire    [5:0] x_multic_wba;
   wire          x_multic_wben;
   wire          x_p2_bfield_wb_a; 
   wire          xp2ccmatch; 
   wire          xp2bccmatch;
   wire          x_p2nosc1; 
   wire          x_p2nosc2; 
   wire          x_p2shimm_a; 
   wire          x_p2_jump_decode; 
   wire          x_snglec_wben;
   wire          xsetflags; 
   wire          xp3ccmatch; 
   wire          xholdup3; 
   wire          x_idecode3;
   wire          x_set_sflag; 
   wire          xnwb; 
   wire          idmp_stall12;
   wire          i_snglec_wben;
   wire          ix_idecode2; 
   reg           ix_idecode2b_r; 
   reg           ix_idecode3_r;
   wire          ix_idop_decode2; 
   wire          ix_isop_decode2; 
   wire          ix_izop_decode2;
   wire          i_x_p2shimm_decode_a;
   wire          ix_multic_wben;
   wire          ix_wb_en;

   wire          i_dop_inst;
   wire          i_sop_inst;
   wire          i_zop_inst;
   reg           i_p2dop32_inst;
   reg           i_p2sop32_inst;
   reg           i_p2zop32_inst;
   reg           i_p2dop16_inst;
   reg           i_p2sop16_inst;
   reg           i_p2zop16_inst;
   reg           i_p2b_dop32_inst;
   reg           i_p2b_sop32_inst;
   reg           i_p2b_zop32_inst;
   reg           i_p2b_dop16_inst;
   reg           i_p2b_sop16_inst;
   reg           i_p2b_zop16_inst;
   reg           i_p3dop32_inst;
   reg           i_p3sop32_inst;
   reg           i_p3zop32_inst;
   reg           i_p3dop16_inst;
   reg           i_p3sop16_inst;
   reg           i_p3zop16_inst;

// Signal declarations for extensions to be added.
   wire    [1:0] i_barrel_type_nxt;
   wire          i_p2_ext16_brl_u3_a; 
   wire          i_p2_ext16_brl_u5_a; 
   wire          i_p2_ext_brl_decode_16_a; 
   wire          i_p2_ext_brl_decode_32_a; 
   wire          i_p2_fmt_cond_reg_a; 
   wire          i_p2_fmt_s12_a; 
   wire          i_p2_op_16_alu_gen_a; 
   wire          i_p2_op_16_ssub_a;

   reg           i_p2b_ext_brl_decode_16_r;
   reg           i_p2b_ext_brl_decode_32_r;
   wire          i_p3_barrel_decode_nxt;
   reg           i_p3_barrel_decode_r;
   wire          i_p3_barrel_decode_iv_a;

   wire          i_barrel_type_sel0_a;
   wire          i_barrel_type_sel1_a;
   wire          i_barrel_type_sel2_a;
   wire          i_barrel_type_sel3_a;
// Multiply 32x32
   wire          i_s1mul_a;
   wire          i_s2mul_a;
   wire          i_p2_mul64_decode_32_a;
   wire          i_p2_mul64_decode_16_a;
   reg           i_p2b_mul64_decode_r;
   wire          i_p2b_mul64_decode_iv_a;
   wire          i_p3mul64_a;
// Normalise
//
wire             i_p2_norm_decode_a;
wire             i_p2b_norm_decode_a;
wire             i_p2b_snorm_decode_a;
reg              i_p3_norm_decode_r;
reg              i_p3_snorm_decode_r;
   wire          i_p2_swap_decode_a;
   wire          i_p2b_swap_decode_a;
   reg           i_p3_swap_decode_r;

// ===================== Extension core registers ====================--
// 
//  x_p2nosc1/x_p2nosc2 : Extension pipeline Stage 2 no shortcut on
//                        source 1/2
// 
//  These signals are set true to tell the RISC control unit that the
//  register in the source 1 (x_p2nosc1) or source 2 (x_p2nosc2) fields
//  are not allowed to take advantage of the shortcut mechanism.
//  Shortcutting would normally take place if the register on s1a or fs2a
//  matched the destination register of an instruction in stage 3
//  writing a result. 
// 
//  Shortcutting should be disabled when extension core registers have
//  been added which do not support write-through, or if the value which
//  would be read from the register is not always the value which is
//  written into it. Registers such as control registers with read-only 
//  or write-only bits, or registers less than 32 bits would all fall
//  into this latter category.
// 
//  In this case, write-through means that the value being written to a
//  register (by stage 4) is available be read by stage 2 during the
//  write cycle. If flip-flops are used for registers, then special
//  logic must be implemented to provide write-through operation.
//  
//  This signal should only be set true when the register in question is
//  an extension core register. This signal is ignored if constant
//  XT_COREREG is set false in the include file extutil.
// 
//  All unused extension core register slots should be prevented from
//  shortcutting. This statement only disables shortcutting when an
//  extensions core register slot is accessed. The signal is true when 
//  loopcount is accessed, but this has shortcutting disabled already,
//  so it is not a problem.
//
   assign x_p2nosc1 = 
// Example :       s1a == my_shortcuttable_ext_core_reg ? 1'b 0 :
//
                   ux_p2nosc1; 
//
   assign x_p2nosc2 = 
// Example :       fs2a == my_shortcuttable_ext_core_reg ? 1'b 0 :
//
                   ux_p2nosc2;

//======================== Instruction Decode ========================-- 
//
// Stage 2.
//
//  x_idecode2 : Extension instruction decoded in stage 2
//
//  This signal should be set true when an extension instruction is
//  detected in stage 2. For regular extensions instructions, this is
//  done by decoding p2opcode[4:0]. Single operand extension instructions
//  are detected by decoding the subopcode field p2minoropcode[5:0].
//
//  If an instruction in stage 2 is valid (p2iv=1) and its opcode does
//  not correspond to a basecase instruction, the RISC control unit will
//  generate an illegal instruction interrupt unless x_idecode2 is set
//  true to 'claim' the instruction in stage 2.
//
//  The x_idecode2 signal must be latched by the extensions logic when
//  the instruction is allowed to pass into stage 3, in other words,
//  when en2=1. The latched result is x_idecode3.
//
//  To add a new instruction decode, add a condition to x_idecode2 for a
//  regular extension instruction, or to x_isop_decode2 for single-
//  operand instructions.
//
//  This signal is ignored if the constant XT_ALUOP is set false in the
//  include file extutil.
//
// Dual-operand extension instruction decode 
//
   assign ix_idop_decode2 =
//
// Example :         p2opcode == OP_FMT2 &
//                   p2subopcode == my_extension
//                                                             ? 1'b 1 :
//
//  Extension instruction decodes inserted here
                             i_p2_ext_brl_decode_16_a |
                             i_p2_ext_brl_decode_32_a |
                            i_p2_mul64_decode_32_a |
                            i_p2_mul64_decode_16_a |
                          ux_idop_decode2; 

// Single-operand extension instruction decode
//
   assign ix_isop_decode2 =
//
//  Example :            p2opcode == OP_FMT2 &
//                       p2subopcode == my_sop_field
//                       p2minoropcode == my_sop_extension
//                                                             ? 1'b 1 :
// 
// Extension single-operand instructions inserted here.
                            i_p2_norm_decode_a |
                         i_p2_swap_decode_a |
                         ux_isop_decode2; 

// Zero-operand extension instruction decode
//
   assign ix_izop_decode2 =
                         ux_izop_decode2; 

//  Combine regular and single-operand instruction decodes.
// 
   assign ix_idecode2 = ix_idop_decode2 | ix_isop_decode2 | ix_izop_decode2; 
   assign x_idecode2 = ix_idecode2; 
   assign x_isop_decode2 = ix_isop_decode2; 
   assign x_izop_decode2 = ix_izop_decode2; 
   assign x_idop_decode2 = ix_idop_decode2; 

   assign p2sop32_inst = i_p2sop32_inst; 
   assign p2zop32_inst = i_p2zop32_inst; 
   assign p2dop32_inst = i_p2dop32_inst; 
   assign p2sop16_inst = i_p2sop16_inst; 
   assign p2zop16_inst = i_p2zop16_inst; 
   assign p2dop16_inst = i_p2dop16_inst; 

// decode for 32-bits dual, single, and zero operand extension instructions
always @(p2iv or p2opcode or p2subopcode or p2minoropcode)
  begin : P2INST32_ASYNC_PROC
     i_p2zop32_inst = 1'b0;
     i_p2sop32_inst = 1'b0;
     i_p2dop32_inst = 1'b0;
  if (p2iv==1)
    begin
       if ((p2opcode==OP_FMT4) || (p2opcode==OP_FMT3))
         begin
            if (p2subopcode==SO_SOP)
              begin
                 if (p2minoropcode==MO_ZOP)
                   begin
                      //a valid 32-bits zero operand extension instruction enters into stage-2
                      i_p2zop32_inst = 1'b1;
                   end
                 else
                   begin
                      //a valid 32-bits single operand extension instruction enters into stage-2
                      i_p2sop32_inst = 1'b1;
                   end
              end
            else
              begin
                 //a valid 32-bits dual operand extension instruction enters into stage-2
                 i_p2dop32_inst = 1'b1;
              end
         end
    end
  end
                 
// decode for 16-bits dual, single, and zero operand extension instructions
always @(p2iv or p2opcode or p2subopcode2_r or p2subopcode3_r)
  begin : P2INST16_ASYNC_PROC
     i_p2zop16_inst = 1'b0;
     i_p2sop16_inst = 1'b0;
     i_p2dop16_inst = 1'b0;
     if (p2iv==1'b1)
       begin
          if ((p2opcode==OP_16_FMT3) || (p2opcode==OP_16_FMT4))
            begin
               if (p2subopcode2_r==SO16_SOP)
                 begin
                    if (p2subopcode3_r==SO16_SOP_ZOP)
                      begin
                         //a valid 16-bits zero operand extension instruction enters into stage-2
                         i_p2zop16_inst = 1'b1;
                      end
                    else
                      begin
                         //a valid 16-bits single operand extension instruction enters into stage-2
                         i_p2sop16_inst = 1'b1;
                      end
                 end
               else
                 begin
                    //a valid 16-bits dual operand extension instruction enters into stage-2
                    i_p2dop16_inst = 1'b1;
                 end
            end
       end
  end
     
//==================== Register File Access Stage ====================-- 
//
//   
   assign p2b_sop32_inst = i_p2b_sop32_inst; 
   assign p2b_zop32_inst = i_p2b_zop32_inst; 
   assign p2b_dop32_inst = i_p2b_dop32_inst; 
   assign p2b_sop16_inst = i_p2b_sop16_inst; 
   assign p2b_zop16_inst = i_p2b_zop16_inst; 
   assign p2b_dop16_inst = i_p2b_dop16_inst; 

// decode for 32-bits dual, single, and zero operand extension instructions
always @(p2b_iv or p2b_opcode or p2b_subopcode or p2b_minoropcode)
  begin : P2B_INST32_ASYNC_PROC
     i_p2b_zop32_inst = 1'b0;
     i_p2b_sop32_inst = 1'b0;
     i_p2b_dop32_inst = 1'b0;
  if (p2b_iv==1)
    begin
       if ((p2b_opcode==OP_FMT4) || (p2b_opcode==OP_FMT3))
         begin
            if (p2b_subopcode==SO_SOP)
              begin
                 if (p2b_minoropcode==MO_ZOP)
                   begin
                      //a valid 32-bits zero operand extension instruction enters into stage-2
                      i_p2b_zop32_inst = 1'b1;
                   end
                 else
                   begin
                      //a valid 32-bits single operand extension instruction enters into stage-2
                      i_p2b_sop32_inst = 1'b1;
                   end
              end
            else
              begin
                 //a valid 32-bits dual operand extension instruction enters into stage-2
                 i_p2b_dop32_inst = 1'b1;
              end
         end
    end
  end
                 
// decode for 16-bits dual, single, and zero operand extension instructions
always @(p2b_iv or p2b_opcode or p2b_subopcode2_r or p2b_subopcode3_r)
  begin : P2B_INST16_ASYNC_PROC
     i_p2b_zop16_inst = 1'b0;
     i_p2b_sop16_inst = 1'b0;
     i_p2b_dop16_inst = 1'b0;
     if (p2b_iv==1'b1)
       begin
          if ((p2b_opcode==OP_16_FMT3) || (p2b_opcode==OP_16_FMT4))
            begin
               if (p2b_subopcode2_r==SO16_SOP)
                 begin
                    if (p2b_subopcode3_r==SO16_SOP_ZOP)
                      begin
                         //a valid 16-bits zero operand extension instruction enters into stage-2
                         i_p2b_zop16_inst = 1'b1;
                      end
                    else
                      begin
                         //a valid 16-bits single operand extension instruction enters into stage-2
                         i_p2b_sop16_inst = 1'b1;
                      end
                 end
               else
                 begin
                    //a valid 16-bits dual operand extension instruction enters into stage-2
                    i_p2b_dop16_inst = 1'b1;
                 end
            end
       end
  end
     
//===================== sshimm and ushimm  Decode =====================--
//
//
// i_x_p2shimm_decode_a : Decoding of shimm type instruction in stage 2
//                        This signal is used to reduce logic as many extensions
//                        will use this signal.
    
   assign i_x_p2shimm_decode_a = ((p2format == FMT_U6)  |
                                  (p2format == FMT_S12) |
                                  ((p2format == FMT_COND_U6) &
                                   (p2_a_field_r[AOP_UBND] == 1'b 1))) ? 1'b 1 : 1'b 0;
                               
// x_p2shimm_a : Extension instruction in stage 2 is using the shimm
//               field.
//
   assign x_p2shimm_a =
                        //32-bit types
                        ((i_p2_ext_brl_decode_32_a == 1'b 1) &
                         (i_x_p2shimm_decode_a == 1'b 1 )) |
                        //16-bit types
                        (i_p2_ext16_brl_u3_a == 1'b 1) | 
                        (i_p2_ext16_brl_u5_a == 1'b 1) |
                        (i_p2_mul64_decode_32_a & i_x_p2shimm_decode_a) |
                        (i_p2_norm_decode_a & i_x_p2shimm_decode_a) |
                     (i_p2_swap_decode_a & i_x_p2shimm_decode_a) |
       (ux_idop_decode2 | 
        ux_isop_decode2 | 
        ux_izop_decode2) & 
       i_x_p2shimm_decode_a;

//======================= B-field Writeback Decode =========================--
//
// x_p2field_wben_a : Extension instruction in stage 2 is using the B-field
// as destination address for writeback.
//
   assign x_p2_bfield_wb_a =
                         (i_p2_ext_brl_decode_16_a &
                          (i_p2_op_16_alu_gen_a | i_p2_op_16_ssub_a)) | 
                         (i_p2_ext_brl_decode_32_a &
                          (i_p2_fmt_cond_reg_a | i_p2_fmt_s12_a))     | 
                            i_p2_norm_decode_a |
                         i_p2_swap_decode_a |
       ux_p2_bfield_wb_a;
  
// ======================== Instruction Execute =======================--
//
// 
//  Stage 3.
//  
//  x_idecode3 : Extension instruction decoded in stage 3.
// 
//  This signal is latched from x_idecode2, which is decoded from
//  p2opcode/p2subopcode at stage 2 (see above).
// 
//  It should be noted that if the instruction latches any data itself
//  in stage 3, then p3iv, p3condtrue and en3 should be combined to
//  generate the flip-flop enable signal. This will prevent junk data
//  being latched by stalled intructions, killed instructions or long 
//  immediate data words passing through the pipeline.
// 
//  When this signal is set true, the RISC control unit assumes that 
//  the instruction in stage 3 is a standard ALU-type extension
//  instruction unless any of the special control signals xnwb, 
//  x_p2shimm_a, xsetflags or xholdup3 are set to tell it
//  different.
// 
//  As the instruction is an extension, the RISC control unit will use
//  the 32-bit ALU result and flags provided by the extensions logic.
//  Instruction completion, writeback and flag setting are still
//  controlled by the RISC control unit, but when an extension
//  instruction is in stage 3, the values used will be provided by
//  extension logic and placed on the xresult and xflags buses.
// 
//  This signal is ignored if the constant XT_ALUOP is set false in the
//  include file extutil.
//
//  If extensions are being decoded onto x_idecode2, a flip-flop is
//  placed here to latch x_idecode2 on the clock edge, enabled by en2=1.
//  Otherwise x_idecode3 is set to zero.
//
// 


always @(posedge clk or posedge rst_a)
   begin : P2B_DECODE_PROC
   if (rst_a == 1'b 1)
      begin
      ix_idecode2b_r <= 1'b 0; 
      end
   else
      begin
      if (en2 == 1'b 1)
         begin
         ix_idecode2b_r <= ix_idecode2;    
         end
      end
   end

assign x_idecode2b = ix_idecode2b_r;

always @(posedge clk or posedge rst_a)
   begin : P3_DECODE_PROC
   if (rst_a == 1'b 1)
      begin
      ix_idecode3_r <= 1'b 0; 
      end
   else
      begin
      if (en2b == 1'b 1)
         begin
         ix_idecode3_r <= ix_idecode2b_r;    
         end
      end
   end

assign i_snglec_wben = ix_idecode3_r;

assign x_idecode3    = ix_idecode3_r;


// decode for 32-bits dual, single, and zero operand extension instructions

   assign p3dop32_inst = i_p3dop32_inst ;
   assign p3sop32_inst = i_p3sop32_inst ;
   assign p3zop32_inst = i_p3zop32_inst ;
   assign p3dop16_inst = i_p3dop16_inst ;
   assign p3sop16_inst = i_p3sop16_inst ;
   assign p3zop16_inst = i_p3zop16_inst ;

always @(p3iv or p3condtrue or p3opcode or p3subopcode or p3minoropcode)
  begin : P3INST32_ASYNC_PROC
     i_p3zop32_inst = 1'b0;
     i_p3sop32_inst = 1'b0;
     i_p3dop32_inst = 1'b0;
     if ((p3iv==1'b1) && (p3condtrue==1'b1))
       begin
          if ((p3opcode==OP_FMT3) || (p3opcode==OP_FMT4))
            begin
               if (p3subopcode==SO_SOP)
                 begin
                    if (p3minoropcode==MO_ZOP)
                      begin
                         //a valid 32-bits zero operand extension instruction enters into stage-3
                         i_p3zop32_inst = 1'b1;
                      end
                    else
                      begin
                         //a valid 32-bits single operand extension instruction enters into stage-3
                         i_p3sop32_inst = 1'b1;
                      end
                 end
               else
                 begin
                    //a valid 32-bits dual operand extension instruction enters into stage-3
                    i_p3dop32_inst = 1'b1;
                 end
            end
       end
  end

// decode for 16-bits dual, single, and zero operand extension instructions
always @(p3iv or p3opcode or p3subopcode2_r or p3subopcode3_r)
  begin : P3INST16_ASYNC_PROC
     i_p3zop16_inst = 1'b0;
     i_p3sop16_inst = 1'b0;
     i_p3dop16_inst = 1'b0;
     if (p3iv==1'b1)
       begin
          if ((p3opcode==OP_16_FMT3) || (p3opcode==OP_16_FMT4))
            begin
               if (p3subopcode2_r==SO16_SOP)
                 begin
                    if (p3subopcode3_r==SO16_SOP_ZOP)
                      begin
                         //a valid 16-bits zero operand extension instruction enters into stage-3
                         i_p3zop16_inst = 1'b1;
                      end
                    else
                      begin
                         //a valid 16-bits single operand extension instruction enters into stage-3
                         i_p3sop16_inst = 1'b1;
                      end
                 end
               else
                 begin
                    //a valid 16-bits dual operand extension instruction enters into stage-3
                    i_p3dop16_inst = 1'b1;
                 end
            end
       end
  end
   

   assign ix_wb_en   =
                    (i_p3_barrel_decode_r == 1'b 1) ?  i_snglec_wben :
                     (i_p3_norm_decode_r | i_p3_snorm_decode_r) == 1'b1 ?
                     i_snglec_wben :
                  (i_p3_swap_decode_r == 1'b1) ? i_snglec_wben :
       ux_snglec_wben;

   assign ix_multic_wben =
       ux_multic_wben;

// Multi-cycle extension writeback address. This signal is the writeback
// address for the instruction asserting the x_multic_wben signal.
//
   assign x_multic_wba =
       ux_multic_wba; 

// Multi-cycle extension instruction is busy.
// This is needed for instruction stepping.
   assign x_multic_busy =
                       ux_multic_busy;

// Multi-cycle extension writeback enable. This signal is true when the
// multi-cycle instruction wants to write-back.
//
   assign x_multic_wben = ix_multic_wben;

// The flag update signal for extensions should be qualified with p3iv
// and p3condtrue when the instruction is in stage 3.
//
   assign x_flgen = (ix_wb_en & p3setflags & en3 & p3condtrue & p3iv) |
                 (ux_flgen & (p3setflags | uxsetflags));

// Single-cycle extension writeback enable. This signal is true when the
// multi-cycle instruction wants to write-back.
//
   assign x_snglec_wben  = ix_wb_en & p3iv;

// ========================= Condition codes =========================--
//
//  xp2ccmatch/xp3ccmatch : Extension pipeline stage 2/3 condition code
//                          match
// 
//  In order to add extra condition codes to the ARC, two condition code
//  units are required - one for branches/jumps/loops in stage 2, and 
//  one for conditional instructions in stage 3.
// 
//  The function of an external condition code unit is to provide a 
//  number of true/false results - one for each extension condition. 
//  These extension condition codes do not have to be related to the ARC
//  ALU flags.
//   
//  Bit 5 of the instruction word indicates to this ARC whether it
//  should use the internal condition-true signal or this one provided
//  by the extension logic. Hence all extension condition codes are 0x10
//  -0x1f, and are defined here using only the lower four bits.
// 
//  A condition code might be defined which would be true when both an
//  external flag signal and the zero flag are set. This might be used 
//  in an algorithm to detect the presence of llamas in the upper
//  atmosphere.
// 
//  e.g. assign my_condition_true = external_flag & aluflags_r(A_Z_N);
//  
//   We can define two conditions, say, llamas and no_llamas, so we
//   may branch or jump on our newly defined condition being true or
//   false.
// 
//   The stage 2 condition code statement would look like this:
// 
// assign xp2ccmatch =  
//  Extension condition codes for stage 2 are inserted here.
// 
//                     p2cc == my_cc_llamas ? my_condition_true :
//                     p2cc == my_cc_no_llamas ? not(my_condition_true) :
//                     1'b 0;
// 
   assign xp2ccmatch = 
// Extension condition codes for stage 2 are inserted here.
    
                    uxp2ccmatch; 

   assign xp2bccmatch = 
// Extension condition codes for stage 2B are inserted here.
    
                    uxp2bccmatch; 

//  The stage 3 condition code statement would be identical, except that
//  it uses p3cc and produces xp3ccmatch.
//
// Extension condition codes for stage 3 are inserted here.
   assign xp3ccmatch =
    
                    uxp3ccmatch; 

// =================== Pipeline stall Conditions =====================--
// 
//  xholdup2 : Extension hold up stages 1 and 2.
// 
//  This signal is used to hold up pipeline stages 1 and 2, when 
//  extension logic requires that stage 2 be held up. Stages 3 and 4
//  will continue running if there are no other pipeline stall
//  conditions.
// 
//  The xholdup2 signal will typically be used to produce a stall if an 
//  extension register is not ready to provide information to an
//  instruction in stage 2. The register fetch logic in entity xcoreregs 
//  would produce a stall signal, which would be included here.
//  
//  Designers must be careful to ensure that the xholdup2 signal
//  arrives as early in the cycle as possible. It should be generated
//  from latched or early arriving signals - e.g. p2opcode, s1a, s1a,
//  s1en, s2en.
// 
//  It must not include any pipeline enable signals which it is used to
//  generate - ifetch, pcen, en1, en2, en3, aux_write, aux_read etc. -
//  or any signals generated from the above.
// 
//  This signal should be generated by ORing together multiple stall
//  signals.
// 
   assign xholdup2 =
// 
//  Example :      xcoreregs_stage2_stall |
// 
// Extension stage 2 stall conditions are inserted here.
                   uxholdup2; 

//  xholdup2b : Extension hold up stages 1, 2 and 2b..
//  This signal is used to hold up pipeline stages 1 and 2, when extension 
// logic requires that stage 2 be held up. Stages 3 and 4 will continue
// running if there are no other pipeline stall conditions.
//
//  The xholdup12 signal will typically be used to produce a stall if an 
// extension register is not ready to provide information to an instruction
// in stage 2. The register fetch logic in entity xcoreregs would produce 
// a stall signal, which would be included here.
// 
//  Designers must be careful to ensure that the xholdup2b signal arrives
// as early in the cycle as possible. It should be generated from latched
// or early arriving signals - e.g. p2b_opcode
//
//  It must not include any pipeline enable signals which it is used to
// generate - ifetch, pcen, en1, en2, en3, aux_write, aux_read etc. - or
// any signals generated from the above.
//
// This signal should be generated by ORing together multiple stall signals.
//    

   assign xholdup2b =
    //
    // Example :    xcoreregs_stage2_stall |
    //
//Extension stage 2 stall conditions are inserted here.
                    code_stall_ldst |
                      (mulatwork_r &
                       (i_s1mul_a |
                        i_s2mul_a |
                        i_p2b_mul64_decode_iv_a)) |
                   idmp_stall12 |
                    uxholdup2b;

//
// Note: That xholdup2b is true when the debug interface is accessing the
//       load/store memory space. Consequently the ARC cannot access the
//       load/store memory space. If there is a load (LD) or store (ST)
//       instruction in pipeline stage 2 then pipeline stages 1-2 needs
//       to be stalled (idmp_stall12 = '1').
//
//
//  xholdup3 : Extension hold up stage 3.
// 
//  The xholdup3 signal allows designers of extensions the ability to 
//  hold an instruction in stage 3. This might be used to wait for an 
//  operation which takes more than one cycle to complete - for example
//  a multi-cycle multiply function.
// 
//  When stage 3 is stalled, the operands being supplied on the stage 3
//  input latches (s1val, s2val, p3i, p3iv, etc.) will continue to be
//  valid until the instruction in stage 3 is allowed to complete.
// 
//  Under most circumstances, this signal will stall stages 1, 2 and 3.
//  It should be noted however that this stall signal will not
//  neccessarily stall stage 1. If stage 2 does not contain a valid
//  instruction, then the instruction being fetched in stage 1 may be
//  allowed to move into stage 2 in order to fill the blank slot.
// 
//  Designers must be careful to ensure that the xholdup3 signal
//  arrives as early in the cycle as possible. It should be generated
//  from latched or early arriving signals - e.g. p3i, p3iv, etc.
// 
//  It must not include any pipeline enable signals which it is used
//  to generate - ifetch, pcen, en1, en2, en3, aux_write, aux_read etc.
//  - or any signals generated from the above.
// 
//  This signal should be generated by ORing together multiple stall
//  signals.
// 
   assign xholdup3 =
// 
//  Example :       multi_cycle_instruction_stall |
//  
// Extension stage 3 stall conditions are inserted here.
                    uxholdup3; 

// ====================== Miscellaneous Logic ========================--
// 
//  This section of the file is for extra chunks of logic which do not
//  fit neatly into the various sections above - for example state 
//  machines to control extension functions and so on.
// 
//  Notes on design of extension instructions:
// 
//  State storage : See comments for signals p3condtrue, en3, p3iv.
//  If an extension instruction stores some state information - for
//  example an accumulator register in a multiply-accumulate function, 
//  then the designer must take steps to ensure the registers containing
//  the state are only updated when the instruction is allowed to
//  complete. As well as regular stall conditions, which should be
//  covered by the use of stage enable signals en2 and en3, the 
//  following conditions should be considered:
// 
//  Conditional instructions.
//  If an extension instruction stores data, and may be conditional, the
//  designer must decide if the data stored internally by the extension
//  is also to be subject to the true/false condition. If so, the data
//  latch- enable must include the stage 3 signal p3condtrue as well as
//  the usual p3iv, en3 and instruction decode signal.
// 
//  Stall conditions in different stages.
//  Designers implementing state machines which detect an instruction
//  both in stages 2 and 3 must be aware the cases when different
//  pipeline stages are enabled separately:
// 
//  Stage 1 and 2 stalled, stage 3 enabled : 
//  Caused by xholdup2 or scoreboard unit stall.
// 
//  Stage 1 enabled, stages 2 and 3 stalled : (e.g. xholdup3)
//  A new instruction is allowed to flow into stage 2 from stage 1, if
//  stage 2 does not contain a valid instruction. This situation would
//  be a concern if a system was implemented which detected an
//  instruction entering stage 2, and then caused some kind of stall at
//  stage 3 - in other words a heavily pipelined extension instruction.
//  Care must be taken to ensure the state machine does not get confused
//  by an instruction entering stage 2 whilst stage 3 is stalled.
//   
//
// Miscellaneous extension logic functions are inserted here.
// ======================== Barrel shifter Extension ========================--
//
//  Decode for 16-bit barrel shifting when employing 3-bit
//  unsigned shift value.
// 
  assign i_p2_ext16_brl_u3_a = (p2opcode == OP_16_ARITH) &
                            ((p2subopcode[SUBOPCODE_MSB_1:SUBOPCODE_MSB_2] ==
                            SO16_ASL) | 
                             (p2subopcode[SUBOPCODE_MSB_1:SUBOPCODE_MSB_2] ==
                            SO16_ASR)) ? 1'b 1 : 
         1'b 0;
   
  //  Decode for 16-bit barrel shifting when employing 5-bit
  //  unsigned shift value.
  // 
  assign i_p2_ext16_brl_u5_a =((p2opcode == OP_16_SSUB) &
                               ((p2subopcode3_r == SO16_ASL_U5) | 
                                (p2subopcode3_r == SO16_LSR_U5)  |
                                (p2subopcode3_r == SO16_ASR_U5)))? 1'b 1 : 
         1'b 0; 
  
  assign i_p2_ext_brl_decode_32_a =((p2opcode == OP_FMT2) &
                                    ((p2subopcode == MO_ASL_EXT) | 
                                     (p2subopcode == MO_LSR_EXT) |
                                     (p2subopcode == MO_ASR_EXT) | 
                                     (p2subopcode == MO_ROR_EXT))) ? 1'b 1 : 
         1'b 0;
  
  assign i_p2_ext_brl_decode_16_a = (p2opcode == OP_16_ALU_GEN) &
                                    ((p2subopcode[SUBOPCODE2_16_MSB:0] ==
                                    SO16_ASL_M) | 
                                     (p2subopcode[SUBOPCODE2_16_MSB:0] ==
                                    SO16_LSR_M) |
                                     (p2subopcode[SUBOPCODE2_16_MSB:0] ==
                                    SO16_ASR_M)) | 
                                    (i_p2_ext16_brl_u3_a == 1'b 1) |
                                    (i_p2_ext16_brl_u5_a == 1'b 1) ? 1'b 1 : 
         1'b 0;
  
  // Decode in stage 3 for all barrel shifter operations.
  //
  assign i_p3_barrel_decode_nxt = ((p2b_opcode == OP_16_ARITH) &
                                   ((p2b_subopcode[SUBOPCODE_MSB_1:
                                                SUBOPCODE_MSB_2] ==
                                  SO16_ASL) | 
                                    (p2b_subopcode[SUBOPCODE_MSB_1:
                                                SUBOPCODE_MSB_2] ==
                                  SO16_ASR)))                      |
                                ((p2b_opcode == OP_16_SSUB) &
                                 ((p2b_subopcode3_r == SO16_ASL_U5) | 
                                  (p2b_subopcode3_r == SO16_LSR_U5) |
                                  (p2b_subopcode3_r == SO16_ASR_U5))) |
                                ((p2b_opcode == OP_16_ALU_GEN) &
                                 ((p2b_subopcode[SUBOPCODE2_16_MSB:0] ==
                                  SO16_ASL_M) | 
                                  (p2b_subopcode[SUBOPCODE2_16_MSB:0] ==
                                  SO16_LSR_M) |
                                  (p2b_subopcode[SUBOPCODE2_16_MSB:0] ==
                                  SO16_ASR_M)))                    |
                                ((p2b_opcode == OP_FMT2) &
                                 ((p2b_subopcode == MO_ASL_EXT) | 
                                  (p2b_subopcode == MO_LSR_EXT) |
                                  (p2b_subopcode == MO_ASR_EXT) | 
                                  (p2b_subopcode == MO_ROR_EXT))) ?
         1'b 1 : 
         1'b 0;
  
  assign i_p2_fmt_cond_reg_a = (p2format == FMT_COND_REG) ? 1'b 1 : 1'b 0;
  
  assign i_p2_fmt_s12_a = (p2format == FMT_S12) ? 1'b 1 : 1'b 0;
  
  assign i_p2_op_16_alu_gen_a = (p2opcode == OP_16_ALU_GEN) ? 1'b 1 : 1'b 0;
  
  assign i_p2_op_16_ssub_a = (p2opcode == OP_16_SSUB) ? 1'b 1 : 1'b 0;
  
  assign i_barrel_type_sel0_a = (((p2b_opcode == OP_FMT2) &
                                  (p2b_subopcode == MO_ASL_EXT)) |
                                 ((p2b_opcode == OP_16_ARITH) &
                                  (p2b_subopcode1_r == SO16_ASL)) |
                                 ((p2b_opcode == OP_16_ALU_GEN) &
                                  (p2b_subopcode[SUBOPCODE2_16_MSB:0] == SO16_ASL_M)) |
                                 ((p2b_opcode == OP_16_SSUB) &
                                  (p2b_subopcode3_r == SO16_ASL_U5))) ? 1'b 1 : 
     1'b 0;

   assign i_barrel_type_sel1_a = (((p2b_opcode == OP_FMT2)    &
                                   (p2b_subopcode == MO_LSR_EXT))  |
                                  ((p2b_opcode == OP_16_ALU_GEN) &
                                   (p2b_subopcode[SUBOPCODE2_16_MSB:0] == SO16_LSR_M)) |
                                  ((p2b_opcode == OP_16_SSUB) &
                                   (p2b_subopcode3_r == SO16_LSR_U5))) ? 1'b 1 : 
     1'b 0;
   
   assign i_barrel_type_sel2_a = (((p2b_opcode == OP_FMT2)    &
                                   (p2b_subopcode == MO_ASR_EXT))  |
                                  ((p2b_opcode == OP_16_ARITH) &
                                   (p2b_subopcode1_r == SO16_ASR)) |
                                  ((p2b_opcode == OP_16_ALU_GEN) &
                                   (p2b_subopcode[SUBOPCODE2_16_MSB:0] == SO16_ASR_M)) |
                                  ((p2b_opcode == OP_16_SSUB) &
                                   (p2b_subopcode3_r == SO16_ASR_U5))) ? 1'b 1 : 
     1'b 0;

   assign i_barrel_type_sel3_a = (~(i_barrel_type_sel0_a |
                                    i_barrel_type_sel1_a |
                                    i_barrel_type_sel2_a));

   // Select the type of shift
   //
   assign i_barrel_type_nxt = (
                         (OP_ASL & {(2){i_barrel_type_sel0_a}})
                         |
                         (OP_LSR & {(2){i_barrel_type_sel1_a}})
                         |
                         (OP_ASR & {(2){i_barrel_type_sel2_a}})
                         |
                         (OP_ROR & {(2){i_barrel_type_sel3_a}})
                         );

  always @(posedge clk or posedge rst_a)
     begin : X_P3_BRL_DECODE_PROC
     if (rst_a == 1'b 1)
        begin
        //  asynchronous reset (active high)
        x_p3_brl_decode_16_r      <= 1'b 0;  
        x_p3_brl_decode_32_r      <= 1'b 0;  
        i_p2b_ext_brl_decode_16_r <= 1'b 0;
        i_p2b_ext_brl_decode_32_r <= 1'b 0;
        i_p3_barrel_decode_r      <= 1'b 0;
        barrel_type_r             <= 2'b 0;
        end
     else
        begin
        //  rising clock edge
        if (en2 == 1'b 1)
           begin
           i_p2b_ext_brl_decode_16_r <= i_p2_ext_brl_decode_16_a;   
           i_p2b_ext_brl_decode_32_r <= i_p2_ext_brl_decode_32_a;   
           end

        if (en2b == 1'b 1)
           begin
           i_p3_barrel_decode_r <= i_p3_barrel_decode_nxt;
           x_p3_brl_decode_16_r <= i_p2b_ext_brl_decode_16_r;
           x_p3_brl_decode_32_r <= i_p2b_ext_brl_decode_32_r;
           barrel_type_r        <= i_barrel_type_nxt;
           end 

        end
     end
  


// ======================= MUL64 decodes and control ========================--
//
assign i_p3mul64_a = ((p3opcode == OP_FMT2) &
                      ((p3subopcode == MO_MUL64) | (p3subopcode == MO_MULU64))) |
                     ((p3opcode == OP_16_ALU_GEN) &
                      (p3subopcode[SUBOPCODE2_16_MSB:0] == SO16_MUL64)) ?
       1'b1 :
       1'b0;

assign i_p2_mul64_decode_32_a = ((p2opcode == OP_FMT2) &
                                 ((p2subopcode == MO_MUL64) |
                                  (p2subopcode == MO_MULU64))) ?
       1'b1 :
       1'b0;

assign i_p2_mul64_decode_16_a = ((p2opcode == OP_16_ALU_GEN) &
                                 (p2subopcode[SUBOPCODE2_16_MSB:0]
                                 == SO16_MUL64)) ?
       1'b1 :
       1'b0;

// Register the multiplier decode from stage 2 to stage 2B
//
always @(posedge clk or posedge rst_a)
begin : REG_MUL_DECODE_PROC
   if (rst_a == 1'b1)
      i_p2b_mul64_decode_r <= 1'b0;
   else
   begin
      if (en2 == 1'b1)
         i_p2b_mul64_decode_r <= i_p2_mul64_decode_16_a |
                                 i_p2_mul64_decode_32_a;
   end
end

assign i_p2b_mul64_decode_iv_a = i_p2b_mul64_decode_r & p2b_iv;


// =========================== Multiply Scoreboard ==========================--
// 
// Stall stage 2 of the pipeline if an instruction is using the 
// multiply result registers.
// 
assign i_s1mul_a = (s1a == RMLO | s1a == rmmid | 
                    s1a == RMHI) ?
       s1en :
       1'b0;

assign i_s2mul_a = (fs2a == RMLO | fs2a == rmmid | 
                    fs2a == RMHI) ?
       s2en :
       1'b0;


// ======================== Normalise Extension =======================--
//
   assign i_p2_norm_decode_a =((p2opcode == OP_FMT2) &
                               (p2subopcode == SO_SOP) & 
                               ((p2minoropcode == SO_NORMW_EXT) |
                                (p2minoropcode == SO_NORM_EXT))) ? 1'b1 :
                                                                1'b0;

   assign i_p2b_norm_decode_a =((p2b_opcode == OP_FMT2) &
                                (p2b_subopcode == SO_SOP) & 
                                (p2b_minoropcode == SO_NORM_EXT)) ? 1'b1 :
                                                                 1'b0;

   assign i_p2b_snorm_decode_a =((p2b_opcode == OP_FMT2) &
                                 (p2b_subopcode == SO_SOP) &
                                 (p2b_minoropcode == SO_NORMW_EXT)) ? 1'b1 :
                                                                   1'b0;

   always @(posedge clk or posedge rst_a)
   begin : NORM_DEC_PROC
      if (rst_a == 1'b1)
      begin
         i_p3_norm_decode_r  <= 1'b0;
         i_p3_snorm_decode_r <= 1'b0;
      end
      else
      begin
         if (en2b == 1'b1)
         begin
            i_p3_norm_decode_r  <= i_p2b_norm_decode_a;
            i_p3_snorm_decode_r <= i_p2b_snorm_decode_a;
         end
      end
   end

   assign x_p3_norm_decode_r   = i_p3_norm_decode_r;
   assign x_p3_snorm_decode_r  = i_p3_snorm_decode_r;


// =========================== Swap Extension =========================--

   assign i_p2_swap_decode_a =((p2opcode == OP_FMT2) &
                               (p2subopcode == SO_SOP) & 
                               (p2minoropcode == SO_SWAP_EXT)) ?
                               1'b1 :
                               1'b0;

   assign i_p2b_swap_decode_a =((p2b_opcode == OP_FMT2) &
                                (p2b_subopcode == SO_SOP) &
                                (p2b_minoropcode == SO_SWAP_EXT)) ?
                                1'b1 :
                                1'b0;

   always @(posedge clk or posedge rst_a)
   begin : SWAP_DEC_PROC
      if (rst_a == 1'b1)
         i_p3_swap_decode_r <= 1'b0;
      else
      begin
         if (en2b == 1'b1)
            i_p3_swap_decode_r <= i_p2b_swap_decode_a;
      end
   end

   assign x_p3_swap_decode_r = i_p3_swap_decode_r;


// =================== Special case instructions =====================--

// x_set_sflag : Extenstion Stage 3 set Saturate flag.
//               This signal is set when an instruction in stage 3 is a
//               saturating type.  This signal in conjuction with the
//               xalu:x_s_flag will set the S bit in Aux. Ext. Reg. 41
   assign  x_set_sflag =
                          1'b 0;
// 
// x_p2_jump_decode : Extension Pipeline Stage 2 jump decode.
//
// ** For special case instruction encoding only! **
//
// A extention jump will use the ARC flags for in conditional execution.
//    
   assign x_p2_jump_decode =
                          ux_p2_jump_decode;

//
// x_p2b_jump_decode : Extension Pipeline Stage 2b jump decode
//
// ** For special case instruction encoding only! **
//
// A extention jump will use the ARC flags for in conditional execution
    
   assign x_p2b_jump_decode =
                           1'b0;

//
// x_p1_rev_src : Extension Pipeline Stage 1 reverse source field.
//
// ** For special case instruction encoding only! **
//
// This signal will cause the operands to be swapped.
//    
   assign x_p1_rev_src = 
       ux_p1_rev_src;
   
//  xp2idest : Extension Pipeline Stage 2 ignore destination field
// 
//  ** For special case instruction encoding only! **
// 
//  This signal is used to indicate that the instruction in stage 2 will
//  not write back to the register specified in the A field.
//  Setting the signal true has the effect of preventing the scoreboard
//  unit from checking the instruction's destination register for
//  clashes with pending loads. This signal will only take effect when 
//  the extension logic has 'claimed' the instruction by setting
//  x_idecode2.
// 
//  This signal would be used for special case instructions which do not
//  conform to normal extension instruction encoding rules, and use the 
//  destination field for some purpose other than specifying a register
//  to store the ALU result.
// 
//  It should be noted that if an instruction causes this signal to be 
//  asserted when it is in stage 2, the xnwb signal should be asserted 
//  when the instruction reaches stage 3, in order to prevent a
//  writeback to the register file.
// 
//  The signal should be held at zero for normal use.
//   
   assign xp2idest = 

       uxp2idest;

//  xsetflags : Extension force flag setting
// 
//  ** For special case instruction encoding only! **
// 
//  This signal allows extension logic to override the normal flag-
//  setting logic, and force the flags to be set from xflags[3:0]. This
//  signal is not qualified with x_idecode3 inside the ARC, so the
//  extension logic must not set this signal true unless x_idecode3 is
//  also true.
// 
//  This signal is ignored if the constant xt_aluflags_r is set false
//  inside the include file extutil.
// 
//  The signal should be held at zero for normal use.
//   
    assign xsetflags = 
        uxsetflags;

//  xnwb : Extension instruction no write back
// 
//  ** For special case instruction encoding only! **
// 
//   The decode unit sets this signal true to prevent the extension 
//  instruction in stage 3 from writing its result back to the register
//  file.
// 
//  The flag-setting logic is unaffected by this signal - hence the
//  programmer may set the flags using the .F mode on the extension
//  instruction. The flag values used come from the internal ALU.
// 
//  The xnwb signal has no effect when x_idecode3 is not asserted.
//  This signal is ignored if the XT_ALUOP constant is set false in the 
//  package include file extutil.
// 
//  The signal should be held at zero for normal use.
//   
   assign xnwb = 
                 i_p3mul64_a |
                 uxnwb; 

// idmp_stall12 : DMP stalling of pipeline stages 1-2
//
//
//  If the debug interface is accessing a Data Memory Pipeline (DMP)
//  sub-module (dmp_holdup12 = '1') then pipeline stage 2 must be
//  stalled if it contains a load or store instruction (mload2b = '1' or
//  mstore2b = '1'). The reason is that when the DMP is busy servicing
//  requests from the debug interface it cannot service requests from
//  the ARC pipeline at the same time. The signal dmp_stall12 is set
//  when pipeline stages 1-2 should be stalled. If the pipeline is free
//  from LD/ST instructions it will continue to flow even if
//  dmp_holdup12 is set. This signal is only used in a build with memory
//  subsystem.
//
   assign idmp_stall12 = ((dmp_holdup12) &
                          (mload2b | mstore2b)); 

//====================================================================--

endmodule // module xrctl

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file generates all the pipeline enables, decodes etc, as
// well as containing the pipeline registers.
//
//======================= Global System Signal =======================--
//
// clk                System Clock
// 
// rst_a              System Reset (Active high)
//
// en                 System Enable
//
//======================= Inputs to this block =======================--
//
// actionhalt         From flags. This signal is set true when the
//                    actionpoint (if selected) has been triggered by
//                    a valid condition. The ARC pipeline is halted
//                    and flushed when this signal is '1'.
//
//                    Note: The pipeline is flushed of instructions
//                    when the breakpoint instruction is detected, and
//                    it is important to disable each stage explicity.
//                    A normal instruction in stage one will mean that
//                    instructions in stage two,two-B, three and four
//                    will be allowed to complete. However, for an
//                    instruction in stage one which is in the delay
//                    slot of a branch, loop or jump instruction means
//                    that stage two has to be stalled as well.
//                    Therefore, only stages two-B, three and four
//                    will be allowed to complete.
//
// actionpt_pc_brk_a  From Action-points module. Indicates that a opcode 
//                    or PC actionpoint has been triggered.
//
// p2_ap_stall_a      From Action-points module. Used to stall action-points 
//                    in stage 2 until any BRccs instructions ahead have resolved.
//
// aluflags_r [3:0]   From flags.  This bus represents the condition
//                    of architectual basecase flags.
//
// aux_addr [31:0]    From hostif. This is the auxiliary mapped data
//                    space address bus.
//
// br_flags_a [3:0]   From bigalu. This is the flags generated for
//                    compare & branch instructions.
//
// cr_hostw           From hostif  This indicates that the host will
//                    perform a write to the core registers on the
//                    next cycle, provided that a load writeback does
//                    not bounce it out of the way.
//                    This signal is of a lower priority than ldvalid,
//                    so when both are true, cr_hostw is ignored.
//
// do_inst_step_r     From flags. This signal is set when the single
//                    step flag (SS) and the instruction step flag
//                    (IS) in the debug register has been written to
//                    simultaneously through the host interface. It
//                    indicates that an instruction step is being
//                    performed. When the instruction step has
//                    finished this signal goes low.
//
// h_pcwr             From aux_regs. This signal is set true when the host is
//                    attempting to write to the pc/status register, and
//                    the machine is stopped. It is used to trigger an
//                    instruction fetch when the PC is written when the
//                    machine is stopped. This is necessary to ensure the
//                    correct instruction is executed when the machine is
//                    restarted. It is also used to latch the new PC
//                    value.
//
// h_pcwr32           From aux_regs. This signal is set true when the host
//                    is attempting to write to the 32-bit pc register,
//                    and the machine is stopped. It is used to trigger an
//                    instruction fetch when the PC is written when the
//                    machine is stopped. This is necessary to ensure the
//                    correct instruction is executed when the machine is
//                    restarted.
//
// h_regadr [5:0]     From aux_regs. The register number to be written to by
//                    host writes to the core registers. Used when cr_hostw
//                    is true.
//
// holdup2b           From lsu. Holds stage 2b . The scoreboard uses this when
//                    the scoreboard is full or there is a scoreboard and
//                    register address hit. It is produced from s1a, fs2a,
//                    dest, s1en, s2en, desten and the scoreboarding
//                    mechanism.
//
//   
// ivalid_aligned     From inst_align. This signal is true when the ivalid
//                    signal from the ifetch interface is true except when the
//                    aligner need to get the next longword to be able to
//                    reconstruct the current instruction.
//                            
// ivic               From xaux_regs.  Invalidate Instruction Cache.
//                    This indicates that all values in the cache are
//                    to be invalidated. (it stands for InValidate
//                    Instruction Cache). It is anticipated that this
//                    signal will be generated from a decode of an 
//                    store (SR) instruction.
//                    Note that due to the pipelined nature of the  
//                    machine, up to four instructions could be issued 
//                    following the SR which generates the ivic signal
//                    to the instruction cache. Cache invalidates must
//                    be supressed when a line is being loaded from
//                    memory.
//
// ldvalid            From LSU. This signal is set true by the LSU to
//                    indicate that a delayed load writeback WILL occur on
//                    the next cycle. If the instruction in stage 3 wishes
//                    to perform a writeback, then pipeline stage 1,
//                    2, 2b and 3 will be held. If the instruction is stage 3 is
//                    invalid, or does not want to write a value into the
//                    core register set for some reason, then the
//                    instructions in stages 1 and 2 will move into 2 and
//                    3 respectively, and the instruction that was in
//                    stage 3 will be replaced in stage 4 by the delayed
//                    load writeback.
//
//                    Note that delayed load writebacks WILL complete,
//                    even if the processor is halted (en=0). In this
//                    instance, the host may be held off for a cycle
//                    (hold_host) if it is attempting to access the core
//                    registers. 
//
// loop_int_holdoff_a From loopcnt. This signal indicates that the
//                    loop mechanism want to hold off any interrupts
//                    from entering stage1 (i.e. p1int from being
//                    set).
//
// loop_kill_p1_a     From loopcnt. This signal indicates that the
//                    loop mechanism wants to kill the instruction in
//                    stage 1.  This will occur if a loop over-run
//                    has occured when the machine is attempting to
//                    find the loopend conditions.
//
// loopend_hit_a      From loopcnt.  This signal indicates that the
//                    loopend hit conditions have been met.
//
// lpending           From lsu. This signal indicates that there are
//                    still outstanding loads.
//
// mwait              From MC. This signal is set true by the DMP in order
//                    to hold up stages 1, 2, and 3. It is used when the 
//                    memory controller cannot service a request for a
//                    memory access which is being made by the LSU. It
//                    will be produced from mload, mstore and logic
//                    internal to the memory controller.
//
// p1int              From int_unit. Indicates that an interrupt has been
//                    detected, and an interrupt-op will be inserted into
//                    stage 2 on the next cycle, (subject to pipeline
//                    enables) setting p2int true. This signal will have
//                    the effect of cancelling the instruction currently
//                    being fetched by stage 1 by causing p2iv to be set
//                    false at the end of the cycle when p1int is true.
//    
// p1iw_aligned_a [31:0]
//                    From inst_align. This bus contains the current
//                    instruction word and is qualified with
//                    ivalid_aligned.
//
// p2int              From int_unit. This signal indicates that an interrupt jump
//                    instruction (fantasy instruction) is currently in
//                    stage 2. This signal has a number of consequences
//                    throughout the system, causing the interrupt vector
//                    (int_vec) to be put into the PC, and causing the old
//                    PC to be placed into the pipeline in order to be
//                    stored into the appropriate interrupt link register.
//                    Note that p2int and p2iv are mutually exclusive.
//
// p2bint             From int_unit. This signal indicates that an interrupt jump
//                    instruction (fantasy instruction) is currently in
//                    stage 2b. This signal has a number of consequences
//                    throughout the system, causing the interrupt vector
//                    (int_vec) to be put into the PC, and causing the old
//                    PC to be placed into the pipeline in order to be
//                    stored into the appropriate interrupt link register.
//                    Note that p2bint and p2b_iv are mutually exclusive.
//
// p3int              From int_unit. This signal indicates that an interrupt jump
//                    instruction (fantasy instruction) is currently in
//                    stage 2. This signal has a number of consequences
//                    throughout the system, causing the interrupt vector
//                    (int_vec) to be put into the PC, and causing the old
//                    PC to be placed into the pipeline in order to be
//                    stored into the appropriate interrupt link register.
//                    Note that p3int and p3iv are mutually exclusive.
//
// pcounter_jmp_restart_r
//                    From pcounter. This signals that there is a
//                    pending control transfer.  When a control transfer
//                    instruction is resolved and the instruction cache cannot
//                    accept another fetch request then the machine will set
//                    this signal and wait until the I$ can accept the request.
//
// regadr [5:0]       From lsu. This bus carries the address of the
//                    register into which the delayed load will writeback
//                    when ldvalid is true. rctl will ensure that this
//                    value is latched onto wba[5:0] at the end of a cycle
//                    when ldvalid is true, even cycles when the processor
//                    is halted (en = 0).
//
// regadr_eq_src1     From lsu.  This signal is true when current
//                    address to be writen back to from the returning
//                    load matches source1 register address in stage
//                    2b.
//
// regadr_eq_src2     From lsu.  This signal is true when current
//                    address to be writen back to from the returning
//                    load matches source2 register address in stage
//                    2b.
//
// sleeping           From debug. This is the sleep mode flag ZZ in
//                    the debug register. It stalls the pipeline when
//                    true.
//
// sleeping_r2        This is the pipelined version of sleeping for use by
//                    clock gating. Sleep mode (zz) flag in the debug
//                    register (bit 23).
//
// x_idecode2         From xrctl. This signal will be true when the
//                    extension logic detects an extension instruction in
//                    stage 2 and is produced from p2opcode[4:0].
//                    It is used in conjunction with internal decode
//                    signals to produce illegal-instruction interrupts.
//
// x_idecode2b        From xrctl. This signal will be true when the
//                    extension logic detects an extension instruction in
//                    stage 2b and is produced from p2b_opcode[4:0]
//                    and the sub-opcodes.
//                    
// x_idecode3         From xrctl. This signal will be true when the
//                    extension logic detects an extension instruction in
//                    stage 3 and is produced from p3opcode[4:0] and the sub-opcode.
//                    
// x_idop_decode2     From xrctl. when this signal is asserted the extension
//                    instruction in stage 2 is dual operand type.
//
// x_isop_decode2     From xrctl. when this signal is asserted the extension
//                    instruction in stage 2 is single operand type.
//
// x_multic_busy      From xrctl. Multi-cycle extension is busy. This signal
//                    is true when the multicycle instruction that is currently
//                    being stepped is busy.  The signal will become false
//                    when the extension instruction is finished.
//
// x_multic_wba [5:0] From xrctl. Multi-cycle extension writeback address.
//                    This signal is the writeback address for the instruction
//                    asserting the x_multic_wben signal.
//
// x_multic_wben      From xrctl. Multi-cycle extension writeback enable. This signal
//                    is true when the multi-cycle instruction wants to
//                    write-back. It should have been qualified with p3iv,
//                    and p3condtrue and the extension  opcode. If any
//                    other instruction requires a write back at the same
//                    time this signal is true the ARCompact pipeline will
//                    stall and the multi-cycle extension will write back.
//
// x_p1_rev_src       From xrctl. when asserted causes the the source fields to be
//                    reversed.
//
// x_p2_bfield_wb_a   From xrctl. Extension instruction in stage 2 is
//                    using the B-field as destination address for
//                    writeback.  
//
// x_p2_jump_decode   From xrctl. This signal is asserted for extension jump
//                    instructions in stage2
//
// x_p2b_jump_decode  From xrctl. This signal is asserted for extension jump
//                    instructions in stage2b
//
// x_p2nosc1          From xrctl. Indicates that the register
//                    referenced by s1a[5:0] is not available for
//                    shortcutting. This signal should only be set true
//                    when the register in question is an extension core
//                    register. This signal is ignored unless constant
//                     XT_COREREG is set true.
//
// x_p2nosc2          From xrctl. Indicates that the register
//                    referenced by fs2a[5:0] is not available for
//                    shortcutting. This signal should only be set true
//                    when the register in question is an extension core
//                    register. This signal is ignored unless constant
//                    XT_COREREG is set true.
// 
// x_p2shimm_a        From xrctl. Indicates that a short immediate
//                    is used for instruction in stage 2.
// 
// x_snglec_wben      From xrctl. Single-cycle extension writeback enable. This signal
//                    is true when the multi-cycle instruction wants to
//                    write-back. It should have been qualified with p3iv,
//                    and p3condtrue and the extension  opcode. If any
//                    other instruction requires a write back at the same
//                    time this signal is true the ARCompact pipeline will
//                    stall and the multi-cycle extension will write back.
//
// xholdup2           From xrctl. Extension holdup stage 2 signal.
//                    When asserted the core stage 2 is stalled.
//
// xholdup2b          From xrctl. Extension holdup stage 2b signal.
//                    When asserted the core stage 2b is stalled.
//
// xholdup3           From xrctl. Extension holdup stage 3 signal.
//                    When asserted the core stage 3 is stalled.
//
// xnwb               From xrctl. Extension instructions utilise
//                    the normal writeback-control logic (instruction
//                    condition codes) dest=immediate, short immediate
//                    data etc), but in addition have extra functions.
//                    When the extension logic has 'claimed' an
//                    instruction in stage 3 by setting x_idecode3, it can
//                    also disable writeback for that instruction by 
//                    setting xnwb. When x_idecode3 is low, or if the
//                    instruction is 'claimed' by the machine, xnwb has no
//                    effect.
//
// xp2ccmatch         From xrctl. This signal is provided by an extension condition
//                    -code unit which takes the condition code field
//                    from the instruction (at stage 2), and the alu flags
//                    (from stage 3) performs some operation on them and
//                    produces this condition true signal. Another bit in
//                    the instruction word indicates to the machine whether it
//                    should use the internal condition-true signal or the
//                    one provided by the extension logic. This technique
//                    will allow extra ALU instruction conditions to be
//                    added which may be specific to different
//                    implementations of the machine.
//
// xp2bccmatch        From xrctl. This signal is provided by an extension condition
//                    -code unit which takes the condition code field
//                    from the instruction (at stage 2b), and the alu flags
//                    (from stage 3) performs some operation on them and
//                    produces this condition true signal. Another bit in
//                    the instruction word indicates to the machine whether it
//                    should use the internal condition-true signal or the
//                    one provided by the extension logic. This technique
//                    will allow extra ALU instruction conditions to be
//                    added which may be specific to different
//                    implementations of the machine.
//
// xp3ccmatch         From xrctl. This signal is provided by an extension condition
//                    -code unit which takes the condition code field
//                    from the instruction (at stage 3), and the alu flags
//                    (from stage 3) performs some operation on them and
//                    produces this condition true signal. Another bit in
//                    the instruction word indicates to the machine whether it
//                    should use the internal condition-true signal or the
//                    one provided by the extension logic. This technique
//                    will allow extra ALU instruction conditions to be
//                    added which may be specific to different
//                    implementations of the machine.
//
// xp2idest           From xrctl. This signal is used to indicate
//                    that the instruction in stage 2 will not actually
//                    write back to the register specifed in the A field.
//                    This is used with extension instructions which write
//                    to FifOs using the destination register to carry the
//                    co-pro register number. It has the effect of
//                    preventing the scoreboard unit from looking at the
//                    destination register by clearing the desten signal.
//                    It will only take effect when the top bit of the
//                    instruction opcode field is set, indicating that it
//                    is an extension instruction.
//
//========================== Stage 1 Output ==========================--
//
// awake_a            This signal allows the PC signal sent to the cache to be
//                    synchronized with the  internally stored PC when
//                    re-awakening from reset or a cache invalidate.
//
// en1                Stage 1 pipeline latch control. True when an
//                    instruction is being latched into pipeline stage 2.
//                    This signal will be low when ivalid_aligned = 0,
//                    preventing junk instructions from being clocked into
//                    the pipeline. Also means that interrupts do not
//                    enter the pipe until a valid instruction is
//                    available in stage 1.
//                            
//                    *** A feature of this signal is that it will allow
//                    an instruction be clocked into stage 2 even when
//                    stage 2b is halted, provided that stage 2b is waiting for
//                    a LIMM or delay slot instruction. this is called
//                    a 'catch-up'. ***
//
// ifetch_aligned     This signal, similar to pcen, indicates to the
//                    memory controller that a new instruction is
//                    required, and should be fetched from memory from the
//                    address which will be clocked into currentpc[31:0]
//                    at the end of the cycle. It is also true for one
//                    cycle when the processor has been started following
//                    a reset, in order to get the ball rolling.
//                    An instruction fetch will also be issued if the host
//                    changes the program counter when the ARC is halted,
//                    provided it is not directly after a reset.
//                    The ifetch_aligned signal will never be set true
//                    whilst the memory controller is in the process of
//                    doing an instruction fetch, so it may be used by the
//                    memory controller as an acknowledgement of
//                    instruction receipt.
//                             
// inst_stepping      This signal indicates that instruction stepping is
//                    in progress.
//                             
// instr_pending_r    This signal is true when an instruction fetch has
//                    been issued, and it has not yet completed. It is
//                    not true directly after a reset before the ARC has
//                    started, as no instruction fetch will have been
//                    issued. It is used to hold off host writes to the
//                    program counter when the ARC is halted, as these
//                    accesses will trigger an instruction fetch.
//                             
   
// pcen               Program counter enable. When this signal is true,
//                    the PC will change at the end of the cycle,
//                    indicating that the memory controller needs to do a
//                    fetch on the next cycle using the address which will
//                    appear on currentpc, which is supplied from
//                    aux_regs.
//                    This signal is affected by interrupt logic and all
//                    the other pipeline stage enables
//
// pcen_niv           Same as above but with the ivalid_aligned qualification
//
// brk_inst_a         To flags. This signals to the ARC that a breakpoint
//                    instruction has been detected in stage two of the
//                    pipeline. Hence, the halt bit in the flag register
//                    has to be updated in addition to the BH bit in the
//                    debug register. The pipeline is stalled when this
//                    signal is set to '1'.
//
//                    Note: The pipeline is flushed of instructions when
//                    breakpoint instruction is detected, and it is
//                    important to disable each stage explicity. A normal
//                    instruction in stage one will mean that instructions
//                    in stage two, three and four will be allowed to
//                    complete. However, for an instruction in stage one
//                    which is in the delay slot of a  branch, loop or
//                    jump instruction means that stage two  has to be
//                    stalled as well. Therefore, only stages three and
//                    four will be allowed to complete.
//    
// 
// dest [5:0]         Destination register address. This is the A field
//                    from the instruction word, send to the LSU for
//                    register scoreboarding of loads. It is qualified by
//                    the desten signal.
//
// desten             This signal is used to indicate to the LSU that the
//                    instruction in pipeline stage 2 will use the data
//                    from the register specified by dest[5:0]. If the
//                    signal is not true, the LSU will ignore dest[5:0]. 
//                    This signal includes p2iv as part of its decode.
//
// en2                Pipeline stage 2 enable. When this signal is
//                    true, the instruction in stage 2 can pass into
//                    stage 2b at the end of the cycle. When it is
//                    false, it will hold up stage 2 and stage 1
//                    (pcen).
//
// fs2a [5:0]         Source 2 register address. This is the C field from
//                    the instruction word, sent to the core registers 
//                    (via hostif) and the LSU. It is qualified for LSU
//                    use by s2en.
//
// p2_a_field_r [5:0] Stage 2 instruction word a field section.
//
// p2_abs_neg_a       Stage 2 abs and negs instruction decode
//
// p2_b_field_r [5:0] Stage 2 instruction word b field section.
//
// p2_brcc_instr_a    Stage 2 compare&branch instruction decode.
//
// p2_c_field_r [5:0] Stage 2 instruction word c field section.
//
// p2_dopred          Stage 2 changed PC to PC+branch offset due to
//                    compare&branch prediction.
//
// p2_dopred_ds       Same as above except on true when the
//                    compare&branch has a delay slot.
//
// p2_dopred_nds      Same as above except on true when the
//                    compare&branch has a no delay slot.
//
// p2_dorel           True when a relative branch (not jump) is going to
//                    happen. Relates to the instruction in p2. Includes
//                    p2iv.
//
// p2_iw_r [31:0]     Stage 2 instruction word. 
//
// p2_jblcc_a         True when stage 2 contains a valid jump&link or
//                    branch&link instruction
//
// p2_lp_instr        True when stage 2 has decoded a LP instruction.
//
// p2_not_a           True when stage 2 has decoded a NOT instruction.
// 
// p2_s1a [5:0]       Stage 2 source 1 register address field.
// 
// p2_s1en            Stage 2 source 1 register address field enable.
// 
// p2_s2a [5:0]       Stage 2 source 2 register address field.
//
// p2_shimm_data [12:0]
//                    Stage 2 short immediate data
// 
// p2_shimm_s1_a      Stage 2 Source 1 uses the short immediate data
// 
// p2_shimm_s2_a      Stage 2 source 2 uses the short immediate data
// 
// p2bch              Stage 2 decode for branch instructions
// 
// p2cc [3:0]         This bus contains the region of the instruction
//                    which  contains the four-bit condition code field.
//                    It is sent to the extension condition code test
//                    logic which provides in return a signal (xp2ccmatch)
//                    which indicates whether it considers the condition
//                    to be true. The ARC decides whether to use the
//                    internal condition-true signal or the signal
//                    provided by extensions depending on the fifth bit of
//                    the instruction. 
// 
// p2conditional      Stage 2 contains a conditional type instruction 
//
// p2condtrue         Stage 2 condition code evaluation.  This signal
//                    is set true when the stage 2 condition code and
//                    the architectual flags match. S
// 
// p2delay_slot       Stage 2 instruction has a delay slot. This
//                    signal is set true when the instruction in stage
//                    2 uses a delay slot.  This signal does not have
//                    an information about the delay slot instruction
//                    itself.
// 
// p2format [1:0]     Stage 2 instruction format field. This field
//                    can be used to decode the type of instruction
//                    in stage 2.  The valid formats are 
//                     1) "00" register-register, 
//                     2) "01" register-unsigned 6-bit,
//                     3) "10" register-signed 12-bit and
//                     4) "11" conditional register
// 
// p2iv               Stage 2 instruction valid. This signal is set
//                    True when the current instruction is valid,
//                    i.e. not killed and actual instruction data.
// 
// p2limm             Indicates that the instruction in stage 2 will use 
//                    long immediate data.
// 
// p2lr               This is true when p2opcode = oldo, and p2iw(13) = 
//                    '1', which indicates that the instruction is the
//                    auxiliary register load instruction LR, not a memory
//                    load LDO instruction. This signal is used by
//                    coreregs to switch the currentpc_r bus onto the
//                    source2 bus (which is then passed through the same
//                    logic as the interrupt link register) in order to
//                    get the correct value of PC when it is read by an LR
//                    instruction. Does not include p2iv.
// 
// p2minoropcode [5:0] Minor opcode word for single operand instructions.          
// 
// p2offset [targz:0] This is the 24-bit relative address from
//                    the instruction in stage 2. It is sign-extended and
//                    added to the stage 2 program counter when a branch is
//                    to take place.
// 
// p2opcode [4:0]     Opcode word. This bus contains the instruction word
//                    which is being executed by stage 2. It must be
//                    qualified by p2iv.
// 
// p2setflags         This is bit 8 from the instruction word at stage 2,
//                    ie the .F or setflags bit used in the jump
//                    instruction. It is used in flags to determine
//                    whether the flags should be loaded by a jump
//                    instruction. The stage 3  signal p3setflags is much
//                    more complicated, having to take into account the
//                    complications presented by short immediate data,
//                    amongst other things.
// 
// p2sleep_inst       This signal is set when a sleep instruction has been
//                    decoded in pipeline stage 2. It is used to set the
//                    sleep mode flag ZZ (bit 23) in the debug register.
// 
// p2st               This signal is used by coreregs. It is produced from
//                    a decode of p2opcode[4:0], p2subopcode[5:0] and does
//                    include p2iv.
// 
// p2subopcode [5:0]  Sub-opcode word (for 32-bit instruction).
// 
// p2subopcode1_r [1:0] Sub-opcode word (for 32-bit instruction).
// 
// p2subopcode2_r [4:0] Sub-opcode word (for 32-bit instruction).
// 
// p2subopcode3_r [2:0] Sub-opcode word (for 32-bit instruction).
//
// p2subopcode4_r     Sub-opcode word (for 32-bit instruction).
// 
// p2subopcode5_r [1:0] Sub-opcode word (for 32-bit instruction).
//
// p2subopcode6_r [2:0] Sub-opcode word (for 32-bit instruction).
//
// p2subopcode7_r [1:0] Sub-opcode word (for 32-bit instruction).
// 
// s1a [5:0]          Source 1 register address. This is the B field from
//                    the instruction word, sent to the core registers
//                    (via hostif) and the LSU. It is qualified for LSU
//                    use by s1en.
// 
// s1en               This signal is used to indicate that the
//                    instruction in pipeline stage 2 will use the data
//                    from the register specified by s1a[5:0]. 
//                    This signal includes p2iv as part of its decode.
//
// s2en               This signal is used to indicate that the
//                    instruction in pipeline stage 2 will use the data
//                    from the register specified by fs2a[5:0]. 
//                    This signal includes p2iv as part of its decode.
//
//========================== Stage 2b Input ==========================--
//
// en2b               Pipeline stage 2B enable. When this signal is
//                    true, the instruction in stage 2b can pass into
//                    stage 3 at the end of the cycle. When it is
//                    false, it will hold up stage 2b, stage 2 and
//                    stage 1 (pcen).
// 
// mload2b            This signal indicates to the LSU that there is a
//                    valid load instruction in stage 2b. It is produced
//                    from a decode of p2b_opcode[4:0], p2b_subopcode[5:0]
//                    and the p2b_iv signal.
//  
// mstore2b           This signal indicates to the actionpoint mechanism
//                    when selected there is a valid store instruction
//                    in stage 2b. It is produced from decode of p2b_opcode,
//                    p2b_subopcode and the p2b_iv signal.
//
// p2b_a_field_r [5:0]
//                    Instruction A field. This bus carries the region of 
//                    the instruction which contains the operand
//                    destination field in stage 2b.//
//
// p2b_abs_op         Indicates that the instruction in stage 2 is an ABS.
//
// p2b_alu_op [1:0]   Describes which ALU operation is to be performed.
//                    "00" ADD/AND, "01" ADC/OR, "10" SUB/BIC & "11"
//                    SBC/XOR
//
// p2b_arithiv        Indicates that the ALU operation in stage 2b will be
//                    an arithmetic operation (as opposed to logical, say)
//
// p2b_awb_field [1:0]
//                    This field describes the address writeback mode of
//                    the LD/ST instruction in stage 2b.
//
// p2b_b_field_r [5:0]
//                    This is the source B address field for 32-bit
//                    instructions.
//
// p2b_bch            Stage 2b decode for branch instructions
//
// p2b_blcc_a         True when stage 2 contains a valid branch&link instruction
//
// p2b_c_field_r [5:0]
//                    Stage 2b instruction word c field section.
//
// p2b_cc [3:0]       This bus contains the region of the instruction
//                    which  contains the four-bit condition code field.
//                    It is sent to the extension condition code test
//                    logic which provides in return a signal (xp2ccmatch)
//                    which indicates whether it considers the condition
//                    to be true. The ARC decides whether to use the
//                    internal condition-true signal or the signal
//                    provided by extensions depending on the fifth bit of
//                    the instruction. This is handled within rctl.
//
// p2b_conditional    Stage 2b contains a conditional type instruction
//
// p2b_condtrue       Stage 2 condition code evaluation.  This signal
//                    is set true when the stage 2 condition code and
//                    the architectual flags match.
//                    
// p2b_delay_slot     Stage 2b instruction has a delay slot. This
//                    signal is set true when the instruction in stage
//                    2b uses a delay slot.  This signal does not have
//                    an information about the delay slot instruction
//                    itself.
//
// p2b_dojcc          True when a jump is going to happen.
//                    Relates to the instruction in stage 2b. Includes
//                    p2b_iv.
//
// p2b_dopred_ds      Stage 2b contains a compare&branch that has
//                    been predicited taken. The branch also has a
//                    delay slot.
//
// p2b_format [1:0]   Stage 1 instruction format field. This field
//                    can be used to decode the type of instruction
//                    in stage 2.  The valid formats are 
//                      1) "00" register-register,
//                      2) "01" register-unsigned 6-bit,
//                      3) "10" register-signed 12-bit and
//                      4) "11" conditional register
//
// p2b_iv             Stage 2b instruction valid. This signal is set
//                    true when the current instruction is valid,
//                    i.e. not killed and actual instruction data
//                    
// p2b_jlcc_a         Stage 2b contains a jump&link or branch&link
//
// p2b_limm           Stage 2b contains an instruction that uses lon
//                    immediate data.
//
// p2b_lr             Stage 2b has a valid LR instruction in it.
//
// p2b_minoropcode [5:0]
//                    Minor opcode word for single operand instructions.
// 
// p2b_neg_op         Indicates that the instruction in stage 2 is an NEG.
//
// p2b_not_op         Indicates that the instruction in stage 2 is an NOT.
//
// p2b_opcode [4:0]   Opcode word. This bus contains the instruction word
//                    which is being executed by stage 2b. It must be
//                    qualified by p2b_iv.
//
// p2b_setflags       This is bit 8 from the instruction word at stage 2,
//                    ie the .F or setflags bit used in the jump
//                    instruction. It is used in flags to determine
//                    whether the flags should be loaded by a jump
//                    instruction. The stage 3  signal p3setflags is much
//                    more complicated, having to take into account the
//                    complications presented by short immediate data,
//                    amongst other things.
//
// p2b_shift_by_one_a Used by shifting arith instructions (e.g. ADD1) and
//                    by shifting LD/ST instructions (e.g. LD.AS).
//
// p2b_shift_by_two_a Used by shifting arith instructions (e.g. ADD1) and
//                    by shifting LD/ST instructions (e.g. LD.AS).
//
// p2b_shift_by_three_a
//                    Used by shifting arith instructions (e.g. ADD1) and
//                    by shifting LD/ST instructions (e.g. LD.AS).
//
// p2b_shift_by_zero_a
//                    Used by shifting arith instructions (e.g. ADD1) and
//                    by shifting LD/ST instructions (e.g. LD.AS).
//
// p2b_shimm_data [12:0]
//                    This bus carries the short immediate data encoded
//                    on the instruction word. It is used by coreregs
//                    when one of the source (s1a/fs2a) registers being
//                    referenced is one of the short immediate registers.
//                    It always provides the region of the instruction
//                    where the short immediate data would be found,
//                    regardless of whether short immediate data is being
//                    used.
//
// p2b_shimm_s1_a     Operand 1 requires the short immediate data
//                    carried in p2b_shimm_data
//
// p2b_shimm_s2_a     Operand 2 requires the short immediate data
//                    carried in p2b_shimm_data
//
// p2b_size [1:0]     This pair of signals are used to indicate to the LSU
//                    the size of the memory transaction which is being 
//                    requested by a LD or ST instruction. It is produced 
//                    during stage 2b and latched as the size information bits
//                    are encoded in different places on the LD and ST 
//                    instructions. It must be qualified by the mload/mstore
//                    signals as it does not include an opcode decode.
//
// p2b_st             Stage 2b ST instruction decode. Is not qualified
//                    with p2b_iv
//
// p2b_subopcode [5:0]          Sub-opcode word (for 16-bit instruction).
//
// p2b_subopcode1_r [1:0]       Sub-opcode word (for 16-bit instruction).
//
// p2b_subopcode2_r [4:0]       Sub-opcode word (for 16-bit instruction).
//
// p2b_subopcode3_r [2:0]       Sub-opcode word (for 16-bit instruction).
//
// p2b_subopcode4_r             Sub-opcode word (for 16-bit instruction).
//
// p2b_subopcode5_r [1:0]       Sub-opcode word (for 16-bit instruction).
//
// p2b_subopcode6_r [2:0]       Sub-opcode word (for 16-bit instruction).
//
// p2b_subopcode7_r [1:0]       Sub-opcode word (for 16-bit instruction).
//
// en3                Pipeline stage 3 enable. When this signal is
//                    true, the instruction in stage 3 can pass into
//                    stage 4 at the end of the cycle. When it is
//                    false, it will probably hold up stage 1, 2 and
//                    2b (pcen, en2), along with stage 3.
//
// en3_niv_a          Same as above except no ivalid_aligned or mwait
//                    included in expression.  This signal is used to
//                    validiate auxiliary writes.
//
// ldvalid_wb         This signal is used to control the switching of
//                    returning load data onto the writeback path for the
//                    register file. It is set true whenever returning
//                    load data must pass through the regular load
//                    writeback path - this will be loads to r32-r60 for a
//                    4port regfile system, or loads to r0-r60 for a 3port
//                    register file system.      
//
// mload              This signal indicates to the LSU that there is a valid
//                    load instruction in stage 3. It is produced from a
//                    decode of p3opcode, p3iw(13) (to exclude LR) and the
//
// mstore             This signal indicates to the LSU that there is a valid
//                    p3iv signal. store instruction in stage 3. It is
//                    produced from a decode of p3opcode, p3iw(25) (to
//                    exclude SR) and the p3iv signal.
//
// nocache            This signal is used to indicate to the LSU whether
//                    the load/store operation is required to bypass the
//                    cache. It comes from bit 5 of the ld/st control
//                    group which is found in different places in the
//                    ldo/ldr/st instructions.
//
// p3_alu_absiv       Indicates that an ABS instruction is in stage 3.
//
// p3_alu_arithiv     Indicates that an ALU instruction is in stage 3.
//
// p3_alu_flagiv      Indicates that a flag setting ALU instruction is in
//                    stage 3.
//
// p3_alu_logiciv     Indicates that a logic instruction is in stage 3.
//
// p3_alu_minmaxiv    Indicates that a MIN/MAX instruction is in stage 3.
//
// p3_alu_op [1:0]    Describes which ALU operation is in stage 3.
//
// p3_alu_snglopiv    Indicates that a single operand instruction is in
//                    stage 3.
//
// p3_bit_op_sel [1:0]Indicates to the ALU which operation to
//                    complete for the compare&branch operations       
//
// p3_brcc_instr_a    Indicates that the instruction in stage 3 is a
//                    compare&branch. includes p3iv.
//
// p3_flag_instr      Indicates that the instruction in stage 3 is a
//                    flag . includes p3iv.
//
// p3_sync_instr      Indicates that the instruction in stage 3 is a 
//                    sync (includes p3iv).
//
// p3_max_instr       Indicates that the instruction in stage 3 is a
//                    max.
//
// p3_min_instr       Indicates that the instruction in stage 3 is a
//                    min.
//
// p3_ni_wbrq         This signal is the same as i_p3_wb_req_a, except that
//                    it does not include an option for the interrupt unit
//                    to write back. It is used in certain extensions
//                    where an external register set is provided, which
//                    are not allowed to accept loads, or fifo-type 
//                    extension alu instructions.
//
// p3_shiftin_sel_r [1:0]       This bus controls the what is shifted into the
//                    msb/lsb when a single bit shift is performed by
//                    the basecase ALU.
//
// p3_sop_op_r [2:0]  Indicates which SOP instruction is present in
//                    stage 3 of the pipeline.
//
// p3_xmultic_nwb     Multi-cycle Extension write-back not allowed. When
//                    this signal is asserted no multi-cycle extension is
//                    allowed to write back. If this signal and
//                    x_multic_wben is true then the multi-cycle extension
//                    pipeline must stall.
//                 
// p3a_field_r [5:0]  Instruction A field. This bus carries the region of 
//                    the instruction which contains the operand
//                    destination field in stage 3.
//
// p3awb_field_r [1:0] Indicates the write-back mode of the LD/ST
//                    instruction in stage 3.
//
// p3b_field_r [5:0]  Instruction B field. This bus carries the region of 
//                    the instruction which contains the source operand
//                    one field in stage 3.
//
// p3c_field_r [5:0]  Instruction C field. This bus carries the region of 
//                    the instruction which contains the source operand
//                    two field in stage 3. 
//
// p3cc[3:0]          This bus contains the region of the instruction
//                    which contains the four-bit condition code field. It
//                    is sent with the alu flags to the extension 
//                    condition code test logic which provides in return
//                    a signal (xp3ccmatch) which indicates whether it
//                    considers the condition to be true. The ARC decides
//                    whether to use the internal condition-true signal or
//                    the signal provided by extensions depending on the
//                    fifth bit of the instruction. This is handled within 
//                    rctl.
//                             
// p3condtrue         This signal is produced from the result of the
//                    internal stage 3 condition code unit or from an
//                    extension condition code unit (if implemented). A
//                    bit (bit 5) in the instruction selects between the
//                    internal and extension condition code unit results.
//                    In addition, this signal is set true if the
//                    instruction is using short immediate data. As it is
//                    only used by flags in conjunction with the p3opcode=
//                    oflag, and with p3setflags, it does not include a 
//                    decode for instructions which do not have a
//                    condition code field (i.e. all load and store
//                    operations). Does not include p3iv.
//
// p3destlimm         Indicates that the instruction is using a null
//                    destination i.e. the instruction will not write-back
//
// p3_docmprel_a      A mispredicted BRcc of BBITx has been taken by the ARC
//                    processor in stage 3. The corrective action will be taken
//                    in stage 4 where the correct PC will be presented at the
//                    instruction fetch interface.
//
// p3dolink           This signal is true when a JLcc or BLcc instruction
//                    has been taken, indicating that the link register needs
//                    to be stored. It is used by alu to switch the
//                    program counter value which has been passed down the 
//                    pipeline onto the p3result bus. If this signal is to
//                    be used to give a fully qualified indication that a 
//                    J/BLcc is in stage 3, it must be qualified with p3iv
//                    to take account of pipeline tearing between stages 2b
//                    and 3 which could cause the instruction in stage
//                    three to be repeated.         
//
// p3format [1:0]     Instruction word format of instruction in stage 3.
//
// p3iv               Opcode valid. This signal is used to indicate
//                    that the opcode in pipeline stage 3 is a valid
//                    instruction. The instruction may not be valid if
//                    a junk instruction has been allowed to come into
//                    the pipeline in order to allow the pipeline to
//                    continue running when an instruction cannot be
//                    fetched by the memory controller, or when an
//                    instruction has been killed.
//
// p3lr               This signal is used by hostif. It is produced from
//                    a decode of p3opcode, p3iw(13) (check for LR) and 
//                    includes p3iv. Also used in extension logic for
//                    seperate decoding of auxiliary accesses from host
//                    and ARC.
//
// p3minoropcode      Minor opcode (sub-sub-opcode) of instruction in
//                    stage 3.
//                             
// p3opcode[4:0]      Opcode word. This bus contains the instruction word
//                    which is being executed by stage 3. It must be
//                    qualified by p3iv.
//                             
// p3q                Condition code of instruction in stage 3.
//                             
// p3setflags         This signal is used by regular alu-type instructions
//                    and the jump instruction to control whether the
//                    supplied flags get stored. It is produced from the
//                    set-flags bit in the instruction word, but if that
//                    field is not present in the instruction then it will
//                    come from the set-flag modes implied by the
//                    instruction itself, i.e. TST, RCMP or CMP.
//                    Does not include p3iv.
//                             
// p3sr               U This signal is used by hostif. It is produced from
//                    a decode of p3opcode, p3iw(25) (check for SR) and 
//                    includes p3iv. Also used in extension logic for
//                    seperate decoding of auxiliary accesses from host
//                    and ARC.
//                             
// p3subopcode        Sub-opcode word (for 32-bit instruction).
//                             
// p3subopcode1_r     Sub-opcode word (for 16-bit instruction).
//                             
// p3subopcode2_r     Sub-opcode word (for 16-bit instruction).
//                             
// p3subopcode3_r     Sub-opcode word (for 16-bit instruction).
//                             
// p3subopcode4_r     Sub-opcode word (for 16-bit instruction).
//                             
// p3subopcode5_r     Sub-opcode word (for 16-bit instruction).
//                             
// p3subopcode6_r     Sub-opcode word (for 16-bit instruction).
//                             
// p3subopcode7_r     Sub-opcode word (for 16-bit instruction).
//                             
// p3wb_en            Stage 4 pipeline latch control. Controls transition
//                    of the data on the p3result[31:0] bus, and the
//                    corresponding register address from stage 3 to
//                    stage 4. As these buses carry data not only from
//                    instructions but from delayed load writebacks and
//                    host writes, they must be controlled separately from
//                    the instruction in stage 3. This is because if the
//                    instruction in stage 3 does not need to write a
//                    value back into a register, and a delayed load
//                    writeback is about to happen, the instruction is
//                    allowed to complete (i.e. set flags) whilst the data
//                    from the load is clocked into stage 4. If however
//                    the instruction in stage 3 DOES need to writeback to
//                    the register file when a delayed load or multicycle
//                    writeback is about to happen, then the instruction in
//                    stage 3 must be held up and not allowed to change the
//                    processor state, whilst the data from the delayed
//                    load is clocked into stage 4 from stage 3.
//                    *** Note that p3wb_en can be true even when the
//                    processor is halted, as delayed load writebacks and
//                    host writes use this signal in order to access the
//                    core registers. ***
//                    
// p3wb_en_nld        Same as above excpet no load return.
//
// p3wba [5:0]        Register writeback address of the instruction in
//                    stage 3.
//
// p3wba_nld [5:0]    Same as above for except no load return address.
//
// sc_load1           This signal is set true when data from a returning
//                    load is required to be shortcut onto the stage 2b
//                    source 1 result bus. If the 4-port register file
//                    is implemented, the data used for the shortcut comes
//                    direct from the memory system, this requiring an
//                    additional input into the shortcut multiplexer.
//                    Extension core registers can have shortcutting
//                    banned if x_p2nosc1 is set true at the appropriate
//                    time. Includes both p2biv and p3iv.
//                             
// sc_load2           This signal is set true when data from a returning
//                    load is required to be shortcut onto the stage 2b
//                    source 2b result bus. If the 4-port register file
//                    is implemented, the data used for the shortcut comes
//                    direct from the memory system, this requiring an
//                    additional input into the shortcut muxer.
//                    Extension core registers can have shortcutting
//                    banned if x_p2nosc2 is set true at the appropriate
//                    time. Includes both p2biv and p3iv.
//                             
// sc_reg1            This signal is produced by the pipeline control
//                    unit rctl, and is set true when an instruction in
//                    stage 3 is going to generate a write to the register
//                    being read by source 1 of the instruction in stage
//                    2b. This is a source 1 shortcut. It is used by the
//                    core register module to switch the stage 3 result
//                    bus onto the stage 2b source 1 result. 
//                    Extension core registers can have shortcutting
//                    banned if x_p2nosc1 is set true at the appropriate
//                    time. Includes both p2biv and p3iv.
//                             
// sc_reg2            This signal is produced by the pipeline control
//                    unit rctl, and is set true when an instruction in
//                    stage 3 is going to generate a write to the register
//                    being read by source 2b of the instruction in stage
//                    2b. This is a source 1 shortcut. It is used by the
//                    core register module to switch the stage 3 result
//                    bus onto the stage 2b source 2 result.
//                    Extension core registers can have shortcutting
//                    banned if x_p2nosc2 is set true at the appropriate
//                    time. Includes both p2biv and p3iv.
//                             
// sex                This signal is used to indicate to the LSU whether
//                    a sign-extended load is required. It is produced
//                    during stage 2b and latched as the sign-extend bit in
//                    the two versions of the LD instruction (LDO/LDR) are
//                    in different places in the instruction word.
//                             
// size [1:0]         This pair of signals are used to indicate to the LSU
//                    the size of the memory transaction which is being 
//                    requested by a LD or ST instruction. It is produced 
//                    during stage 2b and latched as the size information bits
//                    are encoded in different places on the LD and ST 
//                    instructions. It must be qualified by the mload/mstore
//                    signals as it does not include an opcode decode.
//                             
// wben_nxt           Set true when a register writeback will occur on the 
//                    next cycle. Used for generating writes with
//                    Synchronous register files.
//    
// wba [5:0]          This bus carries the address of the register to
//                    which the data on wbdata[31:0] is to be written at
//                    the end of the cycle if wben is true. It is produced
//                    during stage 3 and takes account of delayed load
//                    register writeback (taking a value from the LSU),
//                    LD/ST address writeback  (address from the B or C 
//                    field), and normal ALU operation destination
//                    addresses (instruction A field).
//                          
// wben               This signal is the enable signal which determines
//                    whether the data on wbdata[31:0] is written into the 
//                    register file at stage 4. It is produced in stage 3
//                    and takes into account delayed load writebacks, 
//                    cancelled instructions, and instructions which are
//                    not to be executed due to the cc result being false,
//                    amongst other things.        
//
// p4_docmprel        Stage 4 control transfer is in progress during
//                    the cycle.
//                    
// loopcount_hit_a    Indicates that the intruction in stage 3 will
//                    write to the loop count register at the ened of the
//                    cycle
//
// p4_disable_r       This signal is set true when the entire
//                    pipeline has been flushed.
//
// p4iv               Stage 4 instruction valid.            
//
// flagu_block        Holds off interrupts because a flag setting
//                    instruction is in the pipe.
//
// instruction_error  Instruction Exception. This causes an instruction
//                    error interrupt. This signal will be set true when
//                    a valid instruction in pipeline stage 2 is not one
//                    of the standard opcode set, and the extension logic
//                    has not 'claimed' the instruction in stage 2 as one
//                    of its own.mpu_kill_stage2a_a
//
// interrupt_holdoff  This signal is used to indicate that the instruction
//                    at stage 2 requires that the next instruction be in
//                    stage 1 before it can move off.
//                    This may be either to ensure correct delay slot
//                    operation for a branch or to make sure that long
//                    immediate data is fetched, and then killed before it
//                    can be processed as an instruction. 
//
// kill_last          This signal indicates that the last entry added
//                    to the LSU has to be killed.  This is required
//                    when a BRcc is followed by a ld and the BRcc is
//                    taken.
//
// kill_p1_a          Kill Stage 1 instruction
//
// kill_p1_en_a       Kill Stage 1 instruction includes enables.
// 
// kill_p1_nlp_a      Kill stage 1 excludes loop count overrun kill.
//
// kill_p1_nlp_en_a   Kill stage 1 excludes loop count overrun kill
//                    includes enables.
//
// kill_p2_a          Kill Stage 2. This is asserted true when the
//                    instructin in stage 2 should be killed.
//
// kill_p2_en_a       Kill stage 2 with enables
//
// kill_p2b_a         Kill stage 2b.
//
// kill_p3_a          Kill Stage 3
//
// kill_tagged_p1     Kill the longword that will arrive from the cache.
//
// stop_step          This signal is set when the instruction step has
//                    finished.       
//
//====================================================================--
//
module rctl (clk,
             rst_a,
             en,
             aux_addr,
             actionhalt,
             actionpt_swi_a,
             actionpt_pc_brk_a,
             p2_ap_stall_a,
             aluflags_r,
             br_flags_a,
             cr_hostw,
             do_inst_step_r,
             h_pcwr,
             h_pcwr32,
             h_regadr,
             holdup2b,
             ivalid_aligned,
             ivic,
             ldvalid,
	 	     
             loop_kill_p1_a,
             loop_int_holdoff_a,
             loopend_hit_a,
             sync_queue_idle,
             lpending,
	     debug_if_r,
	     dmp_mload,
	     dmp_mstore,
	     is_local_ram,
             mwait,
             p1int,
             p1iw_aligned_a,
             p2ilev1,
             p2int,
             p2bint,
             p3int,
             pcounter_jmp_restart_r,
             regadr,
             regadr_eq_src1,
             regadr_eq_src2,
             sleeping,
             sleeping_r2,
             x_idecode2,
             x_idecode2b,
             x_idecode3,
             x_idop_decode2,
             x_isop_decode2,
             x_multic_busy,
             x_multic_wba,
             x_multic_wben,
             x_p1_rev_src,
             x_p2_bfield_wb_a,
             x_p2_jump_decode,
             x_p2b_jump_decode,
             x_p2nosc1,
             x_p2nosc2,
             x_p2shimm_a,
             x_snglec_wben,
             xholdup2,
             xholdup2b,
             xholdup3,
             xnwb,
             xp2bccmatch,
             xp2ccmatch,
             xp2idest,
             xp3ccmatch,
             awake_a,
             en1,
             ifetch_aligned,
             inst_stepping,
             instr_pending_r,
             pcen,
             pcen_niv,
             brk_inst_a,
             dest,
             desten,
             en2,
             fs2a,
             p2_a_field_r,
             p2_abs_neg_a,
             p2_b_field_r,
             p2_brcc_instr_a,
             p2_c_field_r,
             p2_dopred,
             p2_dopred_ds,
             p2_dopred_nds,
             p2_dorel,
             p2_iw_r,
             p2_jblcc_a,
             p2_lp_instr,
             p2_not_a,
             p2_s1a,
             p2_s1en,
             p2_s2a,
             p2_shimm_data,
             p2_shimm_s1_a,
             p2_shimm_s2_a,
             p2bch,
             p2cc,
             p2conditional,
             p2condtrue,
             p2delay_slot,
             p2format,
             p2iv,
             p2limm,
             p2lr,
             p2minoropcode,
             p2offset,
             p2opcode,
             p2setflags,
             p2sleep_inst,
             p2st,
             p2subopcode,
             p2subopcode1_r,
             p2subopcode2_r,
             p2subopcode3_r,
             p2subopcode4_r,
             p2subopcode5_r,
             p2subopcode6_r,
             p2subopcode7_r,
             s1a,
             s1en,
             s2en,
             en2b,
             mload2b,
             mstore2b,
             p2b_a_field_r,
             p2b_abs_op,
             p2b_alu_op,
             p2b_arithiv,
             p2b_awb_field,
             p2b_b_field_r,
             p2b_bch,
             p2b_blcc_a,
             p2b_c_field_r,
             p2b_cc,
             p2b_conditional,
             p2b_condtrue,
             p2b_delay_slot,
             p2b_dojcc,
             p2b_dopred_ds,
             p2b_format,
             p2b_iv,
             p2b_jlcc_a,
             p2b_limm,
             p2b_lr,
             p2b_minoropcode,
             p2b_neg_op,
             p2b_not_op,
             p2b_opcode,
             p2b_setflags,
             p2b_shift_by_one_a,
             p2b_shift_by_three_a,
             p2b_shift_by_two_a,
             p2b_shift_by_zero_a,
             p2b_shimm_data,
             p2b_shimm_s1_a,
             p2b_shimm_s2_a,
             p2b_size,
             p2b_st,
             p2b_subopcode,
             p2b_subopcode1_r,
             p2b_subopcode2_r,
             p2b_subopcode3_r,
             p2b_subopcode4_r,
             p2b_subopcode5_r,
             p2b_subopcode6_r,
             p2b_subopcode7_r,
             p2b_jmp_holdup_a,
             en3,
             en3_niv_a,
             ldvalid_wb,
             mload,
             mstore,
             nocache,
             p3_alu_absiv,
             p3_alu_arithiv,
             p3_alu_logiciv,
             p3_alu_op,
             p3_alu_snglopiv,
             p3_bit_op_sel,
             p3_brcc_instr_a,
             p3_docmprel_a,
             p3_flag_instr,
	     p3_sync_instr,
             p3_max_instr,
             p3_min_instr,
             p3_ni_wbrq,
             p3_shiftin_sel_r,
             p3_sop_op_r,
             p3_xmultic_nwb,
             p3a_field_r,
             p3awb_field_r,
             p3b_field_r,
             p3c_field_r,
             p3cc,
             p3condtrue,
             p3destlimm,
             p3dolink,
             p3format,
             p3iv,
             p3lr,
             p3minoropcode,
             p3opcode,
             p3q,
             p3setflags,
             p3sr,
             p3subopcode,
             p3subopcode1_r,
             p3subopcode2_r,
             p3subopcode3_r,
             p3subopcode4_r,
             p3subopcode5_r,
             p3subopcode6_r,
             p3subopcode7_r,
             p3wb_en,
             p3wb_en_nld,
             p3wba,
             p3wba_nld,
             sc_load1,
             sc_load2,
             sc_reg1,
             sc_reg2,
             sex,
             size,
             wben_nxt,
             wba,
             wben,
             p4_docmprel,
             loopcount_hit_a,
             p4_disable_r,
             p4iv,
             flagu_block,
             instruction_error,
             interrupt_holdoff,
             kill_last,
             kill_p1_a,
             kill_p1_en_a,
             kill_p1_nlp_a,
             kill_p1_nlp_en_a,
             kill_p2_a,
             kill_p2_en_a,
             kill_p2b_a,
             kill_p3_a,
             kill_tagged_p1,
             stop_step,
             hold_int_st2_a);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
   
   input                          clk;  //  system clock
   input                          rst_a; //  system reset
   input                          en;  //  system go
   input                          actionhalt;
   input                          actionpt_swi_a;
   input                          actionpt_pc_brk_a;
   input                          p2_ap_stall_a;
   input [31:0]                   aux_addr; 
   input [3:0]                    aluflags_r; 
   input [3:0]                    br_flags_a; 
   input                          cr_hostw; 
   input                          do_inst_step_r; 
   input                          h_pcwr; 
   input                          h_pcwr32; 
   input [5:0]                    h_regadr; 
   input                          holdup2b; 
   input                          ivalid_aligned; 
   input                          ivic; 
   input                          ldvalid; 
	   
   input                          loop_kill_p1_a; 
   input                          loop_int_holdoff_a;
   input                          loopend_hit_a;
 
   input                          sync_queue_idle; 
   input                          dmp_mload;
   input                          dmp_mstore;
   input                          is_local_ram;
   input                          lpending; 
   input                          debug_if_r;
   input                          mwait; 
   input                          p1int; 
   input [DATAWORD_MSB:0]         p1iw_aligned_a; 
   input                          p2ilev1; 
   input                          p2int; 
   input                          p2bint; 
   input                          p3int; 
   input                          pcounter_jmp_restart_r; 
   input [5:0]                    regadr; 
   input                          regadr_eq_src1; 
   input                          regadr_eq_src2; 
   input                          sleeping; 
   input                          sleeping_r2;
   input                          x_idecode2; 
   input                          x_idecode2b; 
   input                          x_idecode3; 
   input                          x_idop_decode2; 
   input                          x_isop_decode2; 
   input                          x_multic_busy; 
   input [5:0]                    x_multic_wba; 
   input                          x_multic_wben; 
   input                          x_p1_rev_src; 
   input                          x_p2_bfield_wb_a; 
   input                          x_p2_jump_decode; 
   input                          x_p2b_jump_decode; 
   input                          x_p2nosc1; 
   input                          x_p2nosc2; 
   input                          x_p2shimm_a; 
   input                          x_snglec_wben; 
   input                          xholdup2; 
   input                          xholdup2b; 
   input                          xholdup3; 
   input                          xnwb; 
   input                          xp2bccmatch; 
   input                          xp2ccmatch; 
   input                          xp2idest; 
   input                          xp3ccmatch;

   output                         awake_a; 
   output                         en1; 
   output                         ifetch_aligned; 
   output                         inst_stepping; 
   output                         instr_pending_r; 
   output                         pcen; 
   output                         pcen_niv; 
   output                         brk_inst_a; 
   output [5:0]                   dest; 
   output                         desten; 
   output                         en2; 
   output [5:0]                   fs2a; 
   output [5:0]                   p2_a_field_r; 
   output                         p2_abs_neg_a; 
   output [5:0]                   p2_b_field_r; 
   output                         p2_brcc_instr_a; 
   output [5:0]                   p2_c_field_r;
   output                         p2_dopred; 
   output                         p2_dopred_ds; 
   output                         p2_dopred_nds; 
   output                         p2_dorel; 
   output [INSTR_UBND:0]          p2_iw_r; 
   output                         p2_jblcc_a; 
   output                         p2_lp_instr; 
   output                         p2_not_a; 
   output [5:0]                   p2_s1a; 
   output                         p2_s1en; 
   output [5:0]                   p2_s2a; 
   output [12:0]                  p2_shimm_data; 
   output                         p2_shimm_s1_a; 
   output                         p2_shimm_s2_a; 
   output                         p2bch; 
   output [3:0]                   p2cc; 
   output                         p2conditional; 
   output                         p2condtrue; 
   output                         p2delay_slot; 
   output [1:0]                   p2format; 
   output                         p2iv; 
   output                         p2limm; 
   output                         p2lr; 
   output [5:0]                   p2minoropcode; 
   output [TARGSZ:0]              p2offset; 
   output [4:0]                   p2opcode; 
   output                         p2setflags; 
   output                         p2sleep_inst; 
   output                         p2st; 
   output [5:0]                   p2subopcode; 
   output [1:0]                   p2subopcode1_r; 
   output [4:0]                   p2subopcode2_r; 
   output [2:0]                   p2subopcode3_r; 
   output                         p2subopcode4_r; 
   output [1:0]                   p2subopcode5_r; 
   output [2:0]                   p2subopcode6_r; 
   output [1:0]                   p2subopcode7_r; 
   output [5:0]                   s1a; 
   output                         s1en; 
   output                         s2en; 
   output                         en2b; 
   output                         mload2b; 
   output                         mstore2b; 
   output [5:0]                   p2b_a_field_r; 
   output                         p2b_abs_op; 
   output [1:0]                   p2b_alu_op; 
   output                         p2b_arithiv; 
   output [1:0]                   p2b_awb_field; 
   output [5:0]                   p2b_b_field_r; 
   output                         p2b_bch; 
   output                         p2b_blcc_a; 
   output [5:0]                   p2b_c_field_r; 
   output [3:0]                   p2b_cc; 
   output                         p2b_conditional; 
   output                         p2b_condtrue; 
   output                         p2b_delay_slot; 
   output                         p2b_dojcc; 
   output                         p2b_dopred_ds; 
   output [1:0]                   p2b_format; 
   output                         p2b_iv; 
   output                         p2b_jlcc_a; 
   output                         p2b_limm; 
   output                         p2b_lr; 
   output [5:0]                   p2b_minoropcode; 
   output                         p2b_neg_op; 
   output                         p2b_not_op; 
   output [4:0]                   p2b_opcode; 
   output                         p2b_setflags; 
   output                         p2b_shift_by_one_a; 
   output                         p2b_shift_by_three_a; 
   output                         p2b_shift_by_two_a; 
   output                         p2b_shift_by_zero_a; 
   output [12:0]                  p2b_shimm_data; 
   output                         p2b_shimm_s1_a; 
   output                         p2b_shimm_s2_a; 
   output [1:0]                   p2b_size; 
   output                         p2b_st; 
   output [5:0]                   p2b_subopcode; 
   output [1:0]                   p2b_subopcode1_r; 
   output [4:0]                   p2b_subopcode2_r; 
   output [2:0]                   p2b_subopcode3_r; 
   output                         p2b_subopcode4_r; 
   output [1:0]                   p2b_subopcode5_r; 
   output [2:0]                   p2b_subopcode6_r; 
   output [1:0]                   p2b_subopcode7_r; 
   output                          p2b_jmp_holdup_a;
   output                         en3; 
   output                         en3_niv_a; 
   output                         ldvalid_wb; 
   output                         mload; 
   output                         mstore; 
   output                         nocache; 
   output                         p3_alu_absiv; 
   output                         p3_alu_arithiv; 
   output                         p3_alu_logiciv; 
   output [1:0]                   p3_alu_op; 
   output                         p3_alu_snglopiv; 
   output [1:0]                   p3_bit_op_sel; 
   output                         p3_brcc_instr_a; 
   output                         p3_docmprel_a;
   output                         p3_flag_instr; 
   output                         p3_sync_instr;
   output                         p3_max_instr; 
   output                         p3_min_instr; 
   output                         p3_ni_wbrq; 
   output [1:0]                   p3_shiftin_sel_r; 
   output [2:0]                   p3_sop_op_r; 
   output                         p3_xmultic_nwb; 
   output [5:0]                   p3a_field_r; 
   output [1:0]                   p3awb_field_r; 
   output [5:0]                   p3b_field_r; 
   output [5:0]                   p3c_field_r; 
   output [3:0]                   p3cc; 
   output                         p3condtrue; 
   output                         p3destlimm; 
   output                         p3dolink; 
   output [1:0]                   p3format; 
   output                         p3iv; 
   output                         p3lr; 
   output [5:0]                   p3minoropcode; 
   output [4:0]                   p3opcode; 
   output [4:0]                   p3q; 
   output                         p3setflags; 
   output                         p3sr; 
   output [5:0]                   p3subopcode; 
   output [1:0]                   p3subopcode1_r; 
   output [4:0]                   p3subopcode2_r; 
   output [2:0]                   p3subopcode3_r; 
   output                         p3subopcode4_r; 
   output [1:0]                   p3subopcode5_r; 
   output [2:0]                   p3subopcode6_r; 
   output [1:0]                   p3subopcode7_r; 
   output                         p3wb_en; 
   output                         p3wb_en_nld; 
   output [5:0]                   p3wba; 
   output [5:0]                   p3wba_nld; 
   output                         sc_load1; 
   output                         sc_load2; 
   output                         sc_reg1; 
   output                         sc_reg2; 
   output                         sex; 
   output [1:0]                   size; 
   output                         wben_nxt; 
   output [5:0]                   wba; 
   output                         wben; 
   output                         p4_docmprel; 
   output                         loopcount_hit_a; 
   output                         p4_disable_r; 
   output                         p4iv; 
   output                         flagu_block; 
   output                         instruction_error; 
   output                         interrupt_holdoff; 
   output                         kill_last; 
   output                         kill_p1_a; 
   output                         kill_p1_en_a; 
   output                         kill_p1_nlp_a; 
   output                         kill_p1_nlp_en_a; 
   output                         kill_p2_a; 
   output                         kill_p2_en_a; 
   output                         kill_p2b_a; 
   output                         kill_p3_a; 
   output                         kill_tagged_p1; 
   output                         stop_step;
   output                         hold_int_st2_a;

//------------------------------------------------------------------------------
// Stage 1
//------------------------------------------------------------------------------
   wire                           awake_a; 
   wire                           en1; 
   wire                           ifetch_aligned; 
   wire                           inst_stepping; 
   wire                           instr_pending_r; 
   wire                           pcen; 
   wire                           pcen_niv;

//------------------------------------------------------------------------------
// Stage 2
//------------------------------------------------------------------------------
   wire                           brk_inst_a; 
   wire [5:0]                     dest; 
   wire                           desten; 
   wire                           en2; 
   wire [5:0]                     fs2a; 
   wire [5:0]                     p2_a_field_r; 
   wire                           p2_abs_neg_a; 
   wire [5:0]                     p2_b_field_r; 
   wire                           p2_brcc_instr_a; 
   wire [5:0]                     p2_c_field_r; 
   wire                           p2_dopred; 
   wire                           p2_dopred_ds; 
   wire                           p2_dopred_nds; 
   wire                           p2_dorel; 
   wire [INSTR_UBND:0]            p2_iw_r; 
   wire                           p2_jblcc_a; 
   wire                           p2_lp_instr; 
   wire                           p2_not_a; 
   wire [5:0]                     p2_s1a; 
   wire                           p2_s1en; 
   wire [5:0]                     p2_s2a; 
   wire [12:0]                    p2_shimm_data; 
   wire                           p2_shimm_s1_a; 
   wire                           p2_shimm_s2_a; 
   wire                           p2bch; 
   wire [3:0]                     p2cc; 
   wire                           p2conditional; 
   wire                           p2condtrue; 
   wire                           p2delay_slot; 
   wire [1:0]                     p2format; 
   wire                           p2iv; 
   wire                           p2limm; 
   wire                           p2lr; 
   wire [5:0]                     p2minoropcode; 
   wire [TARGSZ:0]                p2offset; 
   wire [4:0]                     p2opcode; 
   wire                           p2setflags; 
   wire                           p2sleep_inst; 
   wire                           p2st; 
   wire [5:0]                     p2subopcode; 
   wire [1:0]                     p2subopcode1_r; 
   wire [4:0]                     p2subopcode2_r; 
   wire [2:0]                     p2subopcode3_r; 
   wire                           p2subopcode4_r; 
   wire [1:0]                     p2subopcode5_r; 
   wire [2:0]                     p2subopcode6_r; 
   wire [1:0]                     p2subopcode7_r; 
   wire [5:0]                     s1a; 
   wire                           s1en; 
   wire                           s2en;

//------------------------------------------------------------------------------
// Stage 2b
//------------------------------------------------------------------------------
   wire                           en2b; 
   wire                           en2b_niv_a; 
   wire                           mload2b; 
   wire                           mstore2b; 
   wire [5:0]                     p2b_a_field_r; 
   wire                           p2b_abs_op; 
   wire [1:0]                     p2b_alu_op; 
   wire                           p2b_arithiv; 
   wire [1:0]                     p2b_awb_field; 
   wire [5:0]                     p2b_b_field_r; 
   wire                           p2b_bch; 
   wire                           p2b_blcc_a; 
   wire [5:0]                     p2b_c_field_r; 
   wire [3:0]                     p2b_cc; 
   wire                           p2b_conditional; 
   wire                           p2b_condtrue; 
   wire                           p2b_delay_slot; 
   wire                           p2b_dojcc; 
   wire                           p2b_dopred_ds; 
   wire [1:0]                     p2b_format; 
   wire                           p2b_iv; 
   wire                           p2b_jlcc_a; 
   wire                           p2b_limm; 
   wire                           p2b_lr; 
   wire [5:0]                     p2b_minoropcode; 
   wire                           p2b_neg_op; 
   wire                           p2b_not_op; 
   wire [4:0]                     p2b_opcode; 
   wire                           p2b_setflags; 
   wire                           p2b_shift_by_one_a; 
   wire                           p2b_shift_by_three_a; 
   wire                           p2b_shift_by_two_a; 
   wire                           p2b_shift_by_zero_a; 
   wire [12:0]                    p2b_shimm_data; 
   wire                           p2b_shimm_s1_a; 
   wire                           p2b_shimm_s2_a; 
   wire                                  p2b_jmp_holdup_a;
   wire [1:0]                     p2b_size; 
   wire                           p2b_st; 
   wire [5:0]                     p2b_subopcode; 
   wire [1:0]                     p2b_subopcode1_r; 
   wire [4:0]                     p2b_subopcode2_r; 
   wire [2:0]                     p2b_subopcode3_r; 
   wire                           p2b_subopcode4_r; 
   wire [1:0]                     p2b_subopcode5_r; 
   wire [2:0]                     p2b_subopcode6_r; 
   wire [1:0]                     p2b_subopcode7_r;

//------------------------------------------------------------------------------
// Stage 3
//------------------------------------------------------------------------------
   wire                           en3; 
   wire                           en3_niv_a; 
   wire                           ldvalid_wb; 
   wire                           mload; 
   wire                           mstore; 
   wire                           nocache; 
   wire                           p3_alu_absiv; 
   wire                           p3_alu_arithiv; 
   wire                           p3_alu_logiciv; 
   wire [1:0]                     p3_alu_op; 
   wire                           p3_alu_snglopiv; 
   wire [1:0]                     p3_bit_op_sel; 
   wire                           p3_brcc_instr_a; 
   wire                           p3_docmprel_a;
   wire                           p3_flag_instr;
   wire                           p3_sync_instr; 
   wire                           p3_max_instr; 
   wire                           p3_min_instr; 
   wire                           p3_ni_wbrq; 
   wire [1:0]                     p3_shiftin_sel_r; 
   wire [2:0]                     p3_sop_op_r; 
   wire                           p3_xmultic_nwb; 
   wire [5:0]                     p3a_field_r; 
   wire [1:0]                     p3awb_field_r; 
   wire [5:0]                     p3b_field_r; 
   wire [5:0]                     p3c_field_r; 
   wire [3:0]                     p3cc; 
   wire                           p3condtrue; 
   wire                           p3destlimm; 
   wire                           p3dolink; 
   wire [1:0]                     p3format; 
   wire                           p3iv; 
   wire                           p3lr; 
   wire [5:0]                     p3minoropcode; 
   wire [4:0]                     p3opcode; 
   wire [4:0]                     p3q; 
   wire                           p3setflags; 
   wire                           p3sr; 
   wire [5:0]                     p3subopcode; 
   wire [1:0]                     p3subopcode1_r; 
   wire [4:0]                     p3subopcode2_r; 
   wire [2:0]                     p3subopcode3_r; 
   wire                           p3subopcode4_r; 
   wire [1:0]                     p3subopcode5_r; 
   wire [2:0]                     p3subopcode6_r; 
   wire [1:0]                     p3subopcode7_r; 
   wire                           p3wb_en; 
   wire                           p3wb_en_nld; 
   wire [5:0]                     p3wba; 
   wire [5:0]                     p3wba_nld; 
   wire                           sc_load1; 
   wire                           sc_load2; 
   wire                           sc_reg1; 
   wire                           sc_reg2; 
   wire                           sex; 
   wire [1:0]                     size; 
   wire                           wben_nxt;
  
//------------------------------------------------------------------------------
// Stage 4
//------------------------------------------------------------------------------
   wire [5:0]                     wba; 
   wire                           wben; 
   wire                           p4_docmprel; 
   wire                           loopcount_hit_a; 
   wire                           p4_disable_r;
   wire                           p4iv;
   

//------------------------------------------------------------------------------
// Interrupts
//------------------------------------------------------------------------------

   wire                           flagu_block; 
   wire                           instruction_error; 
   wire                           interrupt_holdoff;

//------------------------------------------------------------------------------
// Misc.
//------------------------------------------------------------------------------

   wire                           kill_last; 
   wire                           kill_p1_a; 
   wire                           kill_p1_en_a; 
   wire                           kill_p1_nlp_a; 
   wire                           kill_p1_nlp_en_a; 
   wire                           kill_p2_a; 
   wire                           kill_p2_en_a; 
   wire                           kill_p2b_a; 
   wire                           kill_p3_a; 
   wire                           kill_tagged_p1; 
   wire                           stop_step;
   wire                           hold_int_st2_a;
   wire                           i_hold_int_st2_a;
   wire                           i_no_pc_stall_a;
   

//------------------------------------------------------------------------------
// Internal signals
//------------------------------------------------------------------------------
   
//------------------------------------------------------------------------------
// Stage 1
//------------------------------------------------------------------------------
   reg                            i_go_r; 
   reg                            i_instr_pending_r; 
   reg                            i_p1p2step_r; 
   wire                           i_awake_a; 
   wire                           i_flagu_block_a; 
   wire                           i_go_a; 
   wire                           i_go_nxt; 
   wire                           i_hostload_non_iv_a; 
   wire                           i_ifetch_aligned_a; 
   wire                           i_inst_stepping_a; 
   wire                           i_interrupt_holdoff_a; 
   wire                           i_kill_p1_a; 
   wire                           i_kill_p1_en_a; 
   wire                           i_kill_p1_nlp_a; 
   wire                           i_kill_p1_nlp_en_a; 
   wire                           i_kill_p2_a; 
   wire                           i_kill_p2_en_a; 
   wire                           i_p1_zero_loop_stall_a;
   wire                           i_p1_ct_int_loop_stall_a;
   wire                           i_p1_enable_a; 
   wire                           i_p1_enable_niv_a; 
   wire                           i_p1_step_stall_a;
   wire                           i_p2_step_a; 
   wire                           i_pcen_a; 
   wire                           i_pcen_mwait_a; 
   wire                           i_pcen_non_iv_a; 
   wire                           i_pcen_p1_a; 
   wire                           i_pcen_p2_a; 
   wire                           i_pcen_p2b_a; 
   wire                           i_pcen_p3_a; 
   wire                           i_pcen_step_a; 
   wire                           i_start_step_a; 
   wire                           i_stop_step_a;
   reg                            i_tag_nxt_p1_killed_r; 
   wire                           i_tag_nxt_p1_killed_nxt;
   wire                           i_actionhalt_a;
   wire                           i_actionhalt_holdoff_a;
   
//------------------------------------------------------------------------------
// Stage 2
//------------------------------------------------------------------------------
   wire                           i_p2_instruction_error_a; 
   wire                           i_p2_no_arc_or_ext_instr_a; 
   wire  [CONDITION_CODE_MSB:0]   i_p2_16_q_a; 
   wire                           i_p2_16_sop_inst_a; 
   wire  [CONDITION_CODE_MSB:0]   i_p2_32_q_a; 
   wire                           i_p2_32_sop_inst_a; 
   wire  [OPERAND_MSB:0]          i_p2_a_field16_r; 
   wire                           i_p2_a_field_long_imm_a; 
   wire  [OPERAND_MSB:0]          i_p2_a_field_r; 
   wire                           i_p2_abs_neg_decode_a; 
   reg                            i_p2_arcop_a; 
   wire                           i_p2_b32_a; 
   wire  [OPERAND16_MSB:0]        i_p2_b_field16_r; 
   wire                           i_p2_b_field16_zop_j_a; 
   wire                           i_p2_b_field16_zop_jd_a; 
   wire                           i_p2_b_field16_zop_jeq_a; 
   wire                           i_p2_b_field16_zop_jne_a; 
   wire                           i_p2_b_field_long_imm_a; 
   wire  [OPERAND_MSB:0]          i_p2_b_field_r; 
   wire                           i_p2_b_field_zop_sleep_a; 
   wire                           i_p2_b_field_zop_swi_a; 
   wire  [TARGSZ:0]               i_p2_b_offset_a; 
   wire                           i_p2_bcc16_no_delay_a; 
   wire                           i_p2_bcc32_a; 
   wire                           i_p2_bl32_a; 
   wire                           i_p2_bl_blcc_32_a; 
   wire                           i_p2_bl_niv_a; 
   wire                           i_p2_jblcc_iv_a; 
   wire                           i_p2_jblcc_niv_a; 
   wire  [TARGSZ:0]               i_p2_bl_offset_a; 
   wire                           i_p2_blcc32_a; 
   wire                           i_p2_br16_no_delay_a; 
   wire                           i_p2_br32_u6_a; 
   wire  [TARGSZ:0]               i_p2_br_offset_a; 
   wire                           i_p2_br_or_bbit_a; 
   wire                           i_p2_br_or_bbit_iv_a; 
   wire                           i_p2_bra32_a; 
   wire                           i_p2_branch16_a; 
   wire                           i_p2_branch16_cc_a; 
   wire                           i_p2_branch32_a; 
   wire                           i_p2_branch32_cc_a; 
   wire                           i_p2_branch_iv_a; 
   wire                           i_p2_branch_cc_a; 
   wire                           i_p2_branch_holdup_a; 
   wire                           i_p2_brcc_pred_nds_a; 
   wire                           i_p2_brcc_pred_nds_en_a; 
   wire                           i_p2_brk_inst_a; 
   wire                           i_p2_brk_sleep_swi_a; 
   wire  [OPERAND_MSB:0]          i_p2_c_field16_2_r; 
   wire  [OPERAND16_MSB:0]        i_p2_c_field16_r; 
   wire                           i_p2_c_field16_sop_j_a; 
   wire                           i_p2_c_field16_sop_jd_a; 
   wire                           i_p2_c_field16_sop_jl_a; 
   wire                           i_p2_c_field16_sop_jld_a; 
   wire                           i_p2_c_field16_sop_sub_a; 
   wire                           i_p2_c_field16_zop_a; 
   wire                           i_p2_c_field_long_imm_a; 
   wire  [OPERAND_MSB:0]          i_p2_c_field_r; 
   reg                            i_p2_ccmatch16_a; 
   reg                            i_p2_ccmatch32_a; 
   wire                           i_p2_ccmatch_alu_ext_a; 
   wire                           i_p2_conditional_a; 
   wire                           i_p2_condtrue_a; 
   wire                           i_p2_condtrue_lp_a; 
   wire                           i_p2_condtrue_nlp_a; 
   wire                           i_p2_condtrue_sel0_a; 
   wire                           i_p2_condtrue_sel1_a; 
   wire                           i_p2_condtrue_sel2_a; 
   wire                           i_p2_dest_imm_a; 
   wire                           i_p2_dest_immediate_a; 
   wire                           i_p2_dest_sel0_a; 
   wire                           i_p2_dest_sel10_a; 
   wire                           i_p2_dest_sel1_a; 
   wire                           i_p2_dest_sel2_a; 
   wire                           i_p2_dest_sel3_a; 
   wire                           i_p2_dest_sel4_a; 
   wire                           i_p2_dest_sel5_a; 
   wire                           i_p2_dest_sel6_a; 
   wire                           i_p2_dest_sel7_a; 
   wire                           i_p2_dest_sel8_a; 
   wire                           i_p2_dest_sel9_a; 
   wire  [OPERAND_MSB:0]          i_p2_destination_a; 
   wire                           i_p2_destination_en_a; 
   wire                           i_p2_dolink_a; 
   wire                           i_p2_dorel_a; 
   wire                           i_p2_enable_a; 
   wire                           i_p2_en_no_pwr_save_a; 
   wire                           i_p2_flag_bit_a; 
   wire                           i_p2_flagu_block_a; 
   wire                           i_p2_fmt_cond_reg_a; 
   wire                           i_p2_fmt_cond_reg_dec_a; 
   wire                           i_p2_fmt_cond_reg_u6_a; 
   wire                           i_p2_fmt_reg_a; 
   wire                           i_p2_fmt_s12_a; 
   wire                           i_p2_fmt_u6_a; 
   wire  [FORMAT_MSB:0]           i_p2_format_r; 
   wire                           i_p2_has_dslot_a; 
   wire                           i_p2_hi_reg16_long_imm_a; 
   wire  [OPERAND_MSB:0]          i_p2_hi_reg16_r; 
   wire                           i_p2_holdup_stall_a; 
   wire                           i_p2_instr_err_stall_a;
   wire                           i_p2_is_dslot_nxt; 
   reg                            i_p2_is_dslot_r; 
   wire                           i_p2_is_limm_nxt; 
   reg                            i_p2_is_limm_r; 
   wire                           i_p2_iv_nxt; 
   reg                            i_p2_iv_r; 
   reg   [INSTR_UBND:0]           i_p2_iw_r; 
   wire                           i_p2_kill_p1_a; 
   wire                           i_p2_kill_p1_en_a; 
   wire                           i_p2_ldo16_a; 
   wire                           i_p2_long_immediate1_a; 
   wire                           i_p2_long_immediate2_a; 
   wire                           i_p2_long_immediate_a; 
   wire                           i_p2_limm_a; 
   wire                           i_p2_loop32_a; 
   wire                           i_p2_loop32_cc_a; 
   wire                           i_p2_loop32_ncc_a; 
   wire                           i_p2_ct_brcc_stall_a; 
   wire  [TARGSZ:0]               i_p2_lp_offset_a; 
   wire                           i_p2_lr_decode_iv_a; 
   wire                           i_p2_minor_op_abs_a; 
   wire  [SUBOPCODE_MSB:0]        i_p2_minoropcode_r; 
   wire                           i_p2_mov_hi_a; 
   wire                           i_p2_no_ld_a; 
   wire                           i_p2_no_ld_and_rev_a; 
   wire                           i_p2_nojump_a; 
   wire                           i_p2_not_decode_a; 
   wire  [TARGSZ:0]               i_p2_offset_a; 
   wire                           i_p2_opcode_16_addcmp_a; 
   wire                           i_p2_opcode_16_alu_a; 
   wire                           i_p2_opcode_16_arith_a; 
   wire                           i_p2_opcode_16_bcc_a; 
   wire                           i_p2_opcode_16_bcc_cc_a; 
   wire                           i_p2_opc_16_bcc_cc_s7_a; 
   wire                           i_p2_opcode_16_bl_a; 
   wire                           i_p2_opcode_16_brcc_a; 
   wire                           i_p2_opcode_16_gp_rel_a; 
   wire                           i_p2_opcode_16_ld_add_a; 
   wire                           i_p2_opcode_16_ld_pc_a; 
   wire                           i_p2_opcode_16_mov_a; 
   wire                           i_p2_opcode_16_mv_add_a; 
   wire                           i_p2_opcode_16_sp_rel_a; 
   wire                           i_p2_opcode_16_ushimm_shft_a; 
   wire                           i_p2_opcode_16_ssub_a; 
   wire                           i_p2_opcode_32_bcc_a; 
   wire                           i_p2_opcode_32_blcc_a; 
   wire                           i_p2_opcode_32_fmt1_a; 
   wire                           i_p2_opcode_32_ld_a; 
   wire                           i_p2_opcode_32_st_a; 
   wire  [OPCODE_MSB:0]           i_p2_opcode_a; 
   wire                           i_p2_p2b_jmp_iv_a; 
   wire                           i_p2_push_blink_a; 
   wire                           i_p2_push_decode_a; 
   wire                           i_p2_pop_decode_a; 
   wire                           i_p2_pwr_save_stall_a; 
   wire  [CONDITION_CODE_MSB:0]   i_p2_q_a; 
   wire                           i_p2_q_sel_16_a; 
   wire                           i_p2_rev_arith_a; 
   reg                            i_p2_s1_en_cfield_dec_a; 
   reg                            i_p2_s1_en_decode_a; 
   reg                            i_p2_s1_en_subop2_dec_a; 
   reg                            i_p2_s1_en_subop_dec_a;
   reg                            i_p2_s2_en_decode_a; 
   wire                           i_p2_shimm16_a; 
   wire  [SHIMM_MSB:0]            i_p2_shimm16_data_a; 
   wire                           i_p2_shimm16_data_sel0_a; 
   wire                           i_p2_shimm16_data_sel1_a; 
   wire                           i_p2_shimm16_data_sel2_a; 
   wire                           i_p2_shimm16_data_sel3_a; 
   wire                           i_p2_shimm16_data_sel4_a; 
   wire                           i_p2_shimm16_data_sel5_a; 
   wire                           i_p2_shimm16_data_sel6_a; 
   wire                           i_p2_shimm_a; 
   wire                           i_p2_shimm_s1_a; 
   wire                           i_p2_short_imm_sel0_a; 
   wire                           i_p2_short_imm_sel1_a; 
   wire                           i_p2_short_imm_sel2_a; 
   wire                           i_p2_short_imm_sel3_a; 
   wire  [SHIMM_MSB:0]            i_p2_short_immediate_a; 
   wire                           i_p2_sleep_inst_a; 
   wire                           i_p2_sleep_inst_niv_a; 
   wire  [OPERAND_MSB:0]          i_p2_source1_addr_a; 
   wire                           i_p2_source1_en_a; 
   wire  [OPERAND_MSB:0]          i_p2_source2_addr_a; 
   wire                           i_p2_source2_en_a; 
   wire                           i_p2_src1_addr_sel0_a; 
   wire                           i_p2_src1_addr_sel1_a; 
   wire                           i_p2_src2_addr_sel0_a; 
   wire                           i_p2_src2_addr_sel1_a; 
   wire                           i_p2_src2_b_field_a; 
   wire                           i_p2_src2_hi_a; 
   wire                           i_p2_src2_rblink_a; 
   wire                           i_p2_sshimm16_a; 
   wire                           i_p2_sshimm16_s1_a; 
   wire                           i_p2_sshimm32_a; 
   wire                           i_p2_sshimm32_s1_a; 
   wire                           i_p2_sshimm_a; 
   wire                           i_p2_sshimm_s1_a; 
   wire                           i_p2_sto16_a; 
   wire  [SUBOPCODE1_16_MSB:0]    i_p2_subopcode1_r; 
   wire  [SUBOPCODE2_16_MSB:0]    i_p2_subopcode2_r; 
   wire  [SUBOPCODE3_16_MSB:0]    i_p2_subopcode3_r; 
   wire                           i_p2_subopcode4_r; 
   wire  [SUBOPCODE1_16_MSB:0]    i_p2_subopcode5_r; 
   wire  [SUBOPCODE3_16_MSB:0]    i_p2_subopcode6_r; 
   wire  [SUBOPCODE1_16_MSB:0]    i_p2_subopcode7_r; 
   wire                           i_p2_subop_16_abs_a; 
   wire                           i_p2_subop_16_brk_a; 
   wire                           i_p2_subop_16_btst_u5_a; 
   wire                           i_p2_subop_16_ldb_gp_a; 
   wire                           i_p2_subop_16_ldw_gp_a; 
   wire                           i_p2_subop_16_mov_hi1_a; 
   wire                           i_p2_subop_16_mov_hi2_a; 
   wire                           i_p2_subop_16_neg_a; 
   wire                           i_p2_subop_16_not_a; 
   wire                           i_p2_subop_16_pop_u7_a; 
   wire                           i_p2_subop_16_push_u7_a; 
   wire                           i_p2_subop_16_sop_a; 
   wire                           i_p2_subopcode_flag_a; 
   wire                           i_p2_subopcode_j_a; 
   wire                           i_p2_subopcode_jd_a; 
   wire                           i_p2_subopcode_jl_a; 
   wire                           i_p2_subopcode_jld_a; 
   wire                           i_p2_subopcode_ld_a; 
   wire                           i_p2_subopcode_ldb_a; 
   wire                           i_p2_subopcode_ldb_x_a; 
   wire                           i_p2_subopcode_ldw_a; 
   wire                           i_p2_subopcode_ldw_x_a; 
   wire                           i_p2_subopcode_lr_a; 
   wire                           i_p2_subopcode_mov_a; 
   wire  [SUBOPCODE_MSB:0]        i_p2_subopcode_r; 
   wire                           i_p2_subopcode_rcmp_a; 
   wire                           i_p2_subopcode_rsub_a; 
   wire                           i_p2_subopcode_sop_a; 
   wire                           i_p2_swi_inst_a; 
   wire                           i_p2_swi_inst_niv_a; 
   wire                           i_p2_tag_nxt_p1_dslot_nxt; 
   reg                            i_p2_tag_nxt_p1_dslot_r; 
   wire                           i_p2_tag_nxt_p1_limm_nxt; 
   reg                            i_p2_tag_nxt_p1_limm_r; 
   wire                           i_p2_ushimm16_a; 
   wire                           i_p2_ushimm32_a; 
   wire                           i_p2_ushimm32_s1_a; 
   wire                           i_p2_ushimm_a; 
   wire                           i_p2_ushimm_s1_a; 
   wire                           i_p2_zop_decode_a;
   wire                           i_p2_sync_inst_niv_a; 
   wire                           i_p2_b_field_zop_sync_a;
   wire                           i_p2_sync_inst_a;
   reg                            i_p2_ccunit_32_fz_a; 
   reg                            i_p2_ccunit_32_fn_a; 
   reg                            i_p2_ccunit_32_fc_a; 
   reg                            i_p2_ccunit_32_fv_a; 
   reg                            i_p2_ccunit_32_nfz_a; 
   reg                            i_p2_ccunit_32_nfn_a; 
   reg                            i_p2_ccunit_32_nfc_a; 
   reg                            i_p2_ccunit_32_nfv_a; 
   reg                            i_p2_ccunit_16_fz_a; 
   reg                            i_p2_ccunit_16_fn_a; 
   reg                            i_p2_ccunit_16_fc_a; 
   reg                            i_p2_ccunit_16_fv_a; 
   reg                            i_p2_ccunit_16_nfz_a; 
   reg                            i_p2_ccunit_16_nfn_a; 
   reg                            i_p2_ccunit_16_nfc_a; 
   reg                            i_p2_ccunit_16_nfv_a;
   reg                            i_p2_loopend_hit_r;
   
//------------------------------------------------------------------------------
// Stage 2b
//------------------------------------------------------------------------------
   reg                                  i_p2b_jblcc_iv_r; 
   reg                                  i_p2b_branch_iv_r;
   wire                           i_p2b_br_or_bbit32_nxt; 
   wire                           i_p2b_brcc_instr_ds_nxt; 
   wire                           i_p2b_brcc_instr_nds_nxt; 
   wire                           i_p2b_brcc_pred_nxt; 
   wire                           i_p2b_brcc_pred_ds_nxt; 
   reg                            i_p2b_brcc_pred_ds_r; 
   reg                            i_p2b_brcc_pred_r; 
   wire                           i_p2b_16_bit_instr_a; 
   wire                           i_p2b_16_sop_inst_a; 
   wire  [OPERAND_MSB:0]          i_p2b_a_field16_r; 
   wire  [OPERAND_MSB:0]          i_p2b_a_field_r; 
   wire  [OPERAND_MSB:0]          i_p2b_a_field_a; 
   wire                           i_p2b_a_field_a_sel0_a; 
   wire                           i_p2b_a_field_a_sel1_a; 
   wire  [1:0]                    i_p2b_awb_field_a; 
   wire                           i_p2b_awb_field_sel0_a; 
   wire                           i_p2b_awb_field_sel1_a; 
   wire                           i_p2b_awb_field_sel2_a; 
   wire                           i_p2b_awb_field_sel3_a; 
   wire  [OPERAND16_MSB:0]        i_p2b_b_field16_r; 
   wire                           i_p2b_b_field16_zop_j_a; 
   wire                           i_p2b_b_field16_zop_jd_a; 
   wire                           i_p2b_b_field16_zop_jeq_a; 
   wire                           i_p2b_b_field16_zop_jne_a; 
   wire  [OPERAND_MSB:0]          i_p2b_b_field_r; 
   wire                           i_p2b_bch_flagset_a; 
   wire  [SUBOPCODE_MSB:0]        i_p2b_br_bl_subopcode_r; 
   reg                            i_p2b_br_or_bbit32_r; 
   wire                           i_p2b_br_or_bbit_iv_a; 
   reg                            i_p2b_br_or_bbit_r; 
   wire  [OPERAND_MSB:0]          i_p2b_c_field16_2_r; 
   wire  [OPERAND16_MSB:0]        i_p2b_c_field16_r; 
   wire                           i_p2b_c_field16_sop_j_a; 
   wire                           i_p2b_c_field16_sop_jd_a; 
   wire                           i_p2b_c_field16_sop_jl_a; 
   wire                           i_p2b_c_field16_sop_jld_a; 
   wire                           i_p2b_c_field16_sop_sub_a; 
   wire                           i_p2b_c_field16_zop_a; 
   wire  [OPERAND_MSB:0]          i_p2b_c_field_r; 
   reg                            i_p2b_ccmatch32_a; 
   wire                           i_p2b_ccmatch_alu_ext_a; 
   wire                           i_p2b_conditional_a; 
   wire                           i_p2b_condtrue_a; 
   wire                           i_p2b_condtrue_sel0_a; 
   wire                           i_p2b_condtrue_sel1_a; 
   wire                           i_p2b_condtrue_sel2_a; 
   wire                           i_p2b_condtrue_sel3_a; 
   reg                            i_p2b_dest_imm_r; 
   reg                            i_p2b_destination_en_r; 
   wire                           i_p2b_dest_en_iv_a; 
   reg   [OPERAND_MSB:0]          i_p2b_destination_r; 
   wire                           i_p2b_disable_nxt; 
   reg                            i_p2b_disable_r; 
   wire                           i_p2b_dojcc_a; 
   reg                            i_p2b_dolink_r; 
   wire                           i_p2b_dolink_iv_a; 
   wire                           i_p2b_enable_a; 
   wire                           i_p2b_en_nopwr_save_a; 
   wire                           i_p2b_flag_bit_r; 
   wire                           i_p2b_flagu_block_a; 
   wire                           i_p2b_fmt_cond_reg_a; 
   wire  [FORMAT_MSB:0]           i_p2b_format_r; 
   reg                            i_p2b_has_dslot_r; 
   wire                           i_p2b_has_dslot_nxt; 
   reg                            i_p2b_has_limm_r; 
   wire                           i_p2b_has_limm_nxt; 
   wire  [OPERAND_MSB:0]          i_p2b_hi_reg16_r; 
   wire                           i_p2b_holdup_stall_a; 
   wire                           i_p2b_iv_nxt; 
   reg                            i_p2b_iv_r; 
   reg   [INSTR_UBND:0]           i_p2b_iw_r; 
   wire                           i_p2b_jlcc_niv_nxt; 
   wire                           i_p2_jlcc_a; 
   reg                            i_p2b_jlcc_niv_r; 
   wire                           i_p2b_jlcc_iv_a; 
   wire                           i_p2b_jcc_sc_stall_a; 
   wire                           i_p2b_jmp16_niv_a; 
   wire                           i_p2b_jmp16_cc_a; 
   wire                           i_p2b_jmp16_delay_a; 
   wire                           i_p2b_jmp16_delay_sop_a; 
   wire                           i_p2b_jmp16_no_delay_a; 
   wire                           i_p2b_jmp16_no_dly_sop_a; 
   wire                           i_p2b_jmp32_niv_a; 
   wire                           i_p2b_jmp32_cc_a; 
   wire                           i_p2b_jmp32_delay_a; 
   wire                           i_p2b_jmp32_no_delay_a; 
   wire                           i_p2b_jmp_iv_a; 
   wire                           i_p2b_jmp_niv_a; 
   wire                           i_p2b_jmp_cc_a; 
   wire                           i_p2b_jump_holdup_a; 
   wire                           i_p2b_kill_p1_a; 
   wire                           i_p2b_kill_p1_en_a; 
   wire                           i_p2b_kill_p2_a; 
   wire                           i_p2b_kill_p2_en_a; 
   wire                           i_p2b_ld_decode_a; 
   wire                           i_p2b_ld_nsc1_a; 
   wire                           i_p2b_ld_nsc2_a; 
   wire                           i_p2b_ld_nsc_a; 
   wire                           i_p2b_ldo16_a; 
   wire  [MEMOP_ESZ:0]            i_p2b_ldr_e_a; 
   wire                           i_p2b_ldst_shift_a; 
   reg                            i_p2b_limm_dslot_stall_r; 
   wire                           i_p2b_limm_dslot_stall_nxt; 
   reg                            i_p2b_long_immediate_r; 
   wire                           i_p2b_lr_decode_a; 
   wire  [SUBOPCODE_MSB:0]        i_p2b_minoropcode_r; 
   wire  [MEMOP_ESZ:0]            i_p2b_mop_e_a; 
   wire                           i_p2b_nocache_a; 
   wire                           i_p2b_nojump_a; 
   wire                           i_p2b_opcode_16_addcmp_a; 
   wire                           i_p2b_opcode_16_alu_a; 
   wire                           i_p2b_opcode_16_arith_a; 
   wire                           i_p2b_opcode_16_gp_rel_a; 
   wire                           i_p2b_opcode_16_ld_add_a; 
   wire                           i_p2b_opcode_16_ld_pc_a; 
   wire                           i_p2b_opcode_16_ld_u7_a; 
   wire                           i_p2b_opcode_16_ldb_u5_a; 
   wire                           i_p2b_opcode_16_ldw_u6_a; 
   wire                           i_p2b_opc_16_ldwx_u6_a; 
   wire                           i_p2b_opcode_16_mov_a; 
   wire                           i_p2b_opcode_16_mv_add_a; 
   wire                           i_p2b_opcode_16_sp_rel_a; 
   wire                           i_p2b_opcode_16_ssub_a; 
   wire                           i_p2b_opcode_16_st_u7_a; 
   wire                           i_p2b_opcode_16_stb_u5_a; 
   wire                           i_p2b_opcode_16_stw_u6_a; 
   wire                           i_p2b_opcode_32_fmt1_a; 
   wire                           i_p2b_opcode_32_ld_a; 
   wire                           i_p2b_opcode_32_st_a; 
   wire  [OPCODE_MSB:0]           i_p2b_opcode_r; 
   wire                           i_p2b_pwr_save_stall_a; 
   reg   [CONDITION_CODE_MSB:0]   i_p2b_q_r; 
   wire                           i_p2b_sc_load1_a; 
   wire                           i_p2b_sc_load2_a; 
   wire                           i_p2b_sc_reg1_a; 
   wire                           i_p2b_sc_reg1_nwb_a; 
   wire                           i_p2b_sc_reg2_a; 
   wire                           i_p2b_sc_reg2_nwb_a; 
   wire                           i_p2b_setflags_nxt; 
   reg                            i_p2b_setflags_r; 
   wire                           i_p2b_sex_a; 
   wire                           i_p2b_shift_by_one_a; 
   wire                           i_p2b_shift_by_three_a; 
   wire                           i_p2b_shift_by_two_a; 
   wire                           i_p2b_shift_by_zero_a; 
   reg                            i_p2b_shimm_r; 
   reg                            i_p2b_shimm_s1_r; 
   reg   [SHIMM_MSB:0]            i_p2b_short_immediate_r; 
   wire  [1:0]                    i_p2b_size_a; 
   wire                           i_p2b_size_sel0_a; 
   wire                           i_p2b_size_sel1_a; 
   wire                           i_p2b_size_sel2_a; 
   wire                           i_p2b_size_sel3_a; 
   reg   [OPERAND_MSB:0]          i_p2b_source1_addr_r; 
   reg                            i_p2b_source1_en_r; 
   reg   [OPERAND_MSB:0]          i_p2b_source2_addr_r; 
   reg                            i_p2b_source2_en_r; 
   wire                           i_p2b_special_flagset_a; 
   wire                           i_p2b_sr_decode_a; 
   wire                           i_p2b_st_decode_a; 
   wire                           i_p2b_sto16_a; 
   wire  [SUBOPCODE1_16_MSB:0]    i_p2b_subopcode1_r; 
   wire  [SUBOPCODE2_16_MSB:0]    i_p2b_subopcode2_r; 
   wire  [SUBOPCODE3_16_MSB:0]    i_p2b_subopcode3_r; 
   wire                           i_p2b_subopcode4_r; 
   wire  [SUBOPCODE1_16_MSB:0]    i_p2b_subopcode5_r; 
   wire  [SUBOPCODE3_16_MSB:0]    i_p2b_subopcode6_r; 
   wire  [SUBOPCODE1_16_MSB:0]    i_p2b_subopcode7_r; 
   wire                           i_p2b_subop_16_brk_a; 
   wire                           i_p2b_subop_16_ld_a; 
   wire                           i_p2b_subop_16_ld_gp_a; 
   wire                           i_p2b_subop_16_ld_sp_a; 
   wire                           i_p2b_subop_16_ldb_a; 
   wire                           i_p2b_subop_16_ldb_gp_a; 
   wire                           i_p2b_subop_16_ldb_sp_a; 
   wire                           i_p2b_subop_16_ldw_a; 
   wire                           i_p2b_subop_16_ldw_gp_a; 
   wire                           i_p2b_subop_16_mov_hi2_a; 
   wire                           i_p2b_subop_16_pop_u7_a; 
   wire                           i_p2b_subop_16_push_u7_a; 
   wire                           i_p2b_subop_16_sop_a; 
   wire                           i_p2b_subop_16_st_sp_a; 
   wire                           i_p2b_subop_16_stb_sp_a; 
   wire                           i_p2b_subopcode_flag_a; 
   wire                           i_p2b_subopcode_j_a; 
   wire                           i_p2b_subopcode_jd_a; 
   wire                           i_p2b_subopcode_jl_a; 
   wire                           i_p2b_subopcode_jld_a; 
   wire                           i_p2b_subopcode_ld_a; 
   wire                           i_p2b_subopcode_ldb_a; 
   wire                           i_p2b_subopcode_ldb_x_a; 
   wire                           i_p2b_subopcode_ldw_a; 
   wire                           i_p2b_subopcode_ldw_x_a; 
   wire                           i_p2b_subopcode_lr_a; 
   reg   [SUBOPCODE_MSB:0]        i_p2b_subopcode_r; 
   wire                           i_p2b_subopcode_sr_a;
   reg                            i_p2b_ccunit_32_fz_a; 
   reg                            i_p2b_ccunit_32_fn_a; 
   reg                            i_p2b_ccunit_32_fc_a; 
   reg                            i_p2b_ccunit_32_fv_a; 
   reg                            i_p2b_ccunit_32_nfz_a; 
   reg                            i_p2b_ccunit_32_nfn_a; 
   reg                            i_p2b_ccunit_32_nfc_a; 
   reg                            i_p2b_ccunit_32_nfv_a;
   reg                            i_p2b_sync_inst_r;
   
//------------------------------------------------------------------------------
// Stage 3
//------------------------------------------------------------------------------
   reg   [OPERAND_MSB:0]          i_p3_a_field_r; 
   wire                           i_p3_alu16_condtrue_nxt; 
   reg                            i_p3_alu16_condtrue_r; 
   reg                            i_p3_alu_absiv_nxt; 
   reg                            i_p3_alu_absiv_r; 
   reg                            i_p3_alu_arithiv_nxt; 
   reg                            i_p3_alu_arithiv_r; 
   reg                            i_p3_alu_breq16_nxt; 
   reg                            i_p3_alu_breq16_r; 
   reg                            i_p3_alu_brne16_nxt; 
   reg                            i_p3_alu_brne16_r; 
   reg                            i_p3_alu_logiciv_nxt; 
   reg                            i_p3_alu_logiciv_r; 
   reg                            i_p3_alu_max_nxt; 
   reg                            i_p3_alu_max_r; 
   reg                            i_p3_alu_min_nxt; 
   reg                            i_p3_alu_min_r; 
   reg                            i_p3_alu_negiv_nxt; 
   reg                            i_p3_alu_notiv_nxt; 
   reg   [1:0]                    i_p3_alu_op_nxt; 
   reg  [1:0]                     i_p3_alu_op_r; 
   reg                            i_p3_alu_snglopiv_nxt; 
   reg                            i_p3_alu_snglopiv_r; 
   wire                           i_p3_ashift_right_nxt; 
   reg  [1:0]                     i_p3_awb_field_r; 
   wire                           i_p3_awb_pre_wb_nxt; 
   reg  [OPERAND_MSB:0]           i_p3_b_field_r; 
   wire                           i_p3_bch_flagset_a; 
   reg   [1:0]                    i_p3_bit_operand_sel_nxt; 
   reg  [1:0]                     i_p3_bit_operand_sel_r; 
   reg                            i_p3_br_or_bbit32_r; 
   wire                           i_p3_br_or_bbit_iv_a; 
   reg                            i_p3_br_or_bbit_r; 
   wire  [STD_COND_CODE_MSB:0]    i_p3_br_q_a; 
   reg                            i_p3_brcc_pred_r; 
   reg   [OPERAND_MSB:0]          i_p3_c_field_r; 
   wire                           i_p3_cc_xwb_wb_op_a; 
   reg                            i_p3_ccmatch_a; 
   wire                           i_p3_ccmatch_alu_ext_a; 
   wire                           i_p3_ccwbop_decode_iv_a; 
   reg                            i_p3_ccwbop_decode_nxt; 
   reg                            i_p3_ccwbop_decode_r; 
   wire                           i_p3_condtrue_a; 
   wire                           i_p3_condtrue_sel0_a; 
   wire                           i_p3_condtrue_sel1_a; 
   reg                            i_p3_dest_imm_r; 
   wire                           i_p3_destination_en_iv_a; 
   reg                            i_p3_destination_en_r; 
   wire                           i_p3_disable_nxt; 
   reg                            i_p3_disable_r; 
   wire                           i_p3_dolink_iv_a; 
   wire                           i_p3_dolink_nxt; 
   reg                            i_p3_dolink_r; 
   wire                           i_p3_enable_a; 
   wire                           i_p3_enable_nopwr_save_a; 
   wire                           i_p3_en_non_iv_mwait_a; 
   wire                           i_p3_flag_instr_iv_a; 
   wire                           i_p3_flag_instr_nxt; 
   reg                            i_p3_flag_instr_r; 
   wire                           i_p3_flagu_block_a; 
   reg                            i_p3_fmt_cond_reg_r; 
   reg  [FORMAT_MSB:0]            i_p3_format_r; 
   reg                            i_p3_has_dslot_r; 
   wire                           i_p3_holdup_stall_a; 
   wire [STD_COND_CODE_MSB:0]     i_p3_inv_br_q_16_a; 
   reg  [STD_COND_CODE_MSB:0]     i_p3_inv_br_q_32_a; 
   wire [STD_COND_CODE_MSB:0]     i_p3_inv_br_q_a; 
   wire                           i_p3_iv_nxt; 
   reg                            i_p3_iv_r; 
   wire                           i_p3_ld_decode_iv_a; 
   reg                            i_p3_ld_decode_r; 
   wire                           i_p3_ldst_awb_nxt; 
   wire                           i_p3_load_stall_a; 
   wire                           i_p3_lr_a; 
   wire                           i_p3_lr_decode_iv_a; 
   reg                            i_p3_lr_decode_r; 
   reg   [SUBOPCODE_MSB:0]        i_p3_minoropcode_r; 
   wire                           i_p3_mload_a;
   wire                           i_p3_loopcount_hit_a;  
   wire                           i_p3_mstore_a; 
   wire                           i_p3_multic_wben_stall_a; 
   wire                           i_p3_ni_wbrq_a; 
   wire                           i_p3_ni_wbrq_predec_iv_a; 
   reg                            i_p3_ni_wbrq_predec_r; 
   wire [STD_COND_CODE_MSB:0]     i_p3_no_inv_br_q_a; 
   reg  [STD_COND_CODE_MSB:0]     i_p3_no_inv_br_q_tmp; 
   reg                            i_p3_nocache_r; 
   reg                            i_p3_opcode_32_fmt1_r; 
   reg  [OPCODE_MSB:0]            i_p3_opcode_r; 
   wire                           i_p3_pwr_save_stall_a; 
   reg  [CONDITION_CODE_MSB:0]    i_p3_q_r; 
   wire [OPERAND_MSB:0]           i_p3_sc_dest_nxt; 
   wire                           i_p3_sc_dest_nxt_sel1_a; 
   wire                           i_p3_sc_dest_nxt_sel2_a; 
   wire                           i_p3_sc_dest_nxt_sel3_a; 
   reg   [OPERAND_MSB:0]          i_p3_sc_dest_r; 
   wire [OPERAND_MSB:0]           i_p3_sc_wba_a; 
   reg                            i_p3_setflags_r; 
   reg                            i_p3_sex_r; 
   wire [1:0]                     i_p3_shiftin_sel_nxt; 
   reg  [1:0]                     i_p3_shiftin_sel_r; 
   reg  [1:0]                     i_p3_size_r; 
   wire [SOPSIZE:0]               i_p3_sop_op_nxt; 
   wire                           i_p3_sop_op_nxt_sel0_a; 
   wire                           i_p3_sop_op_nxt_sel1_a; 
   wire                           i_p3_sop_op_nxt_sel2_a; 
   wire                           i_p3_sop_op_nxt_sel3_a; 
   wire                           i_p3_sop_op_nxt_sel4_a; 
   wire                           i_p3_sop_op_nxt_sel5_a; 
   wire                           i_p3_sop_op_nxt_sel6_a; 
   reg  [SOPSIZE:0]               i_p3_sop_op_r; 
   wire                           i_p3_sop_sub_nxt; 
   reg                            i_p3_sop_sub_r; 
   reg                            i_p3_special_flagset_r; 
   wire                           i_p3_sr_a; 
   wire                           i_p3_sr_decode_iv_a; 
   reg                            i_p3_sr_decode_r; 
   wire                           i_p3_st_decode_iv_a; 
   reg                            i_p3_st_decode_r; 
   wire                           i_p3_step_stall_a; 
   reg  [SUBOPCODE1_16_MSB:0]     i_p3_subopcode1_r; 
   reg  [SUBOPCODE2_16_MSB:0]     i_p3_subopcode2_r; 
   reg  [SUBOPCODE3_16_MSB:0]     i_p3_subopcode3_r; 
   reg                            i_p3_subopcode4_r; 
   reg  [SUBOPCODE1_16_MSB:0]     i_p3_subopcode5_r; 
   reg  [SUBOPCODE3_16_MSB:0]     i_p3_subopcode6_r; 
   reg  [SUBOPCODE1_16_MSB:0]     i_p3_subopcode7_r; 
   reg  [SUBOPCODE_MSB:0]         i_p3_subopcode_r; 
   wire                           i_p3_wb_instr_a; 
   wire                           i_p3_wb_req_a; 
   wire                           i_p3_wb_rsv_a; 
   wire                           i_p3_wb_stall_a; 
   wire [OPERAND_MSB:0]           i_p3_wback_addr_a; 
   wire [OPERAND_MSB:0]           i_p3_wback_addr_nld_a; 
   wire                           i_p3_wback_en_a; 
   wire                           i_p3_wback_en_nld_a; 
   wire                           i_p3_x_snglec_wben_iv_a; 
   wire                           i_p3_xmultic_nwb_a; 
   wire                           i_p3_xwb_op_a;
   wire                           i_p3_sync_stalls_pipe_a; 
   wire                           i_p3_sync_instr_iv_a; 
   wire                           i_ignore_debug_op_a;
   wire                           i_p3_sync_stalls_pipe;
   reg                            i_store_in_progress_r;
   reg                            i_ignore_debug_op_r;
   reg             i_p3_sync_inst_r;
   reg                            i_p3_sync_stalls_pipe_r;
   reg                            i_sync_local_ld_r; 
   reg                            i_lpending_prev_r;  
   reg                            i_p3_ccunit_fz_a; 
   reg                            i_p3_ccunit_fn_a; 
   reg                            i_p3_ccunit_fc_a; 
   reg                            i_p3_ccunit_fv_a; 
   reg                            i_p3_ccunit_nfz_a; 
   reg                            i_p3_ccunit_nfn_a; 
   reg                            i_p3_ccunit_nfc_a; 
   reg                            i_p3_ccunit_nfv_a;
   reg                            i_p3_br_ccunit_fz_a; 
   reg                            i_p3_br_ccunit_fn_a; 
   reg                            i_p3_br_ccunit_fc_a; 
   reg                            i_p3_br_ccunit_fv_a; 
   reg                            i_p3_br_ccunit_nfz_a; 
   reg                            i_p3_br_ccunit_nfn_a; 
   reg                            i_p3_br_ccunit_nfc_a; 
   reg                            i_p3_br_ccunit_nfv_a; 
  
//------------------------------------------------------------------------------
// Stage 4
//------------------------------------------------------------------------------
   wire                           i_p4_br_or_bbit_iv_a; 
   reg                            i_p4_br_or_bbit_r; 
   reg                            i_p4_ccmatch_br_a; 
   wire                           i_p4_ccmatch_br_nxt; 
   reg                            i_p4_ccmatch_br_r; 
   wire                           i_p4_disable_nxt; 
   reg                            i_p4_disable_r; 
   wire                           i_p4_docmprel_a; 
   reg                            i_p4_has_dslot_r; 
   wire                           i_p4_iv_nxt; 
   reg                            i_p4_iv_r; 
   wire                           i_p4_kill_p1_a; 
   wire                           i_p4_kill_p2_a; 
   wire                           i_p4_kill_p2b_a; 
   wire                           i_p4_kill_p3_a; 
   wire                           i_p4_no_kill_p3_a; 
   wire                           i_p4_ldvalid_wback_a; 
   reg [OPERAND_MSB:0]            i_p4_wba_r; 
   wire                           i_p4_wben_nld_nxt; 
   wire                           i_p4_wben_nxt; 
   reg                            i_p4_wben_r;   


   
//------------------------------------------------------------------------------
// Perform an instruction fetch
//------------------------------------------------------------------------------
//
//  This signal is used to tell the memory controller to do another
//  instruction fetch with the program counter value which will appear
//  at the end of the cycle. It is normally the same as pcen except for
//  when the processor is restarted after a reset, when an initial
//  instruction fetch request must be issued to start the ball rolling.
// 
//  In addition, ifetch_aligned will be set true when the host is allowed
//  to change the program counter when the ARC is halted. This will means
//  that the new program counter value will be passed out to the memory
//  controller correctly. The ifetch_aligned signal is not set true when
//  there is an instruction fetch still pending.
// 
//  Signal i_awake will be true for one cycle after the processor is
//  started after a reset.
// 
   assign i_awake_a = en & (~i_go_r);
   
   //  Signal i_hostload will be true when an new instruction fetch needs
   //  to be issued due to the host changing the program counter.
   // 
   //  This does not include ivalid_aligned - this is included later on
   //  i_ifetch_aligned.
   // 
   assign i_hostload_non_iv_a = (h_pcwr | h_pcwr32) & i_go_nxt;
   
   //  The ifetch_aligned signal comes from either pcen, kick-start after
   //  reset, or when a fetch is required as the host has changed the
   //  program counter.
   // 
   assign i_ifetch_aligned_a = (i_pcen_non_iv_a | i_hostload_non_iv_a) &
                                 ivalid_aligned | i_awake_a;
   
   //  The latch is set true after the processor is started after a
   //  reset, and will stay true until the next reset.
   // 
   //  The signal i_go_r is taken low when the instruction cache is 
   //  invalidated (ivic). This is in order to prevent a lockup
   //  situation.
   // 
   assign i_go_nxt = en | i_go_r;
   
   assign i_go_a = i_go_nxt & (~ivic);
   
   always @(posedge clk or posedge rst_a)
     begin : go_core_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_go_r <= 1'b 0;   
          end
        else
          begin
             i_go_r <= i_go_a;   
          end
     end

//------------------------------------------------------------------------------
// instr_pending_r : An instruction is being fetched
//------------------------------------------------------------------------------
// 
//  This signal is set true when an instruction fetched has been issued,
//  (i.e. not directly after reset) and the fetch has not yet completed,
//  signalled by ivalid_aligned = '0'.
//  It is used to prevent writes to the pc from the host from
//  generating an ifetch_aligned request when there is already an
//  instruction fetch pending. Host accesses are rejected with hold_host,
//  generated by the hostif block.
// 
// 
   always @(posedge clk or posedge rst_a)
     begin : ipend_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_instr_pending_r <= 1'b 0;   
          end
        else
          begin
             
             //  Entry state : when ARC is started onwards
             if (i_ifetch_aligned_a == 1'b 1)
               begin
                  i_instr_pending_r <= 1'b 1;   
               end
             else
               begin
               //  Exit state : i.e. when no more fetches are required 
               //  
               //  Or: An instruction cache invalidate puts us back into
               //      the immediately post-reset condition.
               // 
               if ((i_ifetch_aligned_a == 1'b 0) & (ivalid_aligned == 1'b 1) | 
                   (ivic == 1'b 1))
                 begin
                    i_instr_pending_r <= 1'b 0;   
                 end
               end
          end
     end 

//------------------------------------------------------------------------------
// Stage 1 stall signals 
//------------------------------------------------------------------------------
//
// Instruction step stall
//
// Stage 1 is only enabled whilst instruction stepping to allow a single
// instruction packet into the pipeline.
// The signal "i_p2_step_a" is true the cycle after an instruction step starts
// by which time the first potential instruction of a packet is in stage 2
// (decode) at this point the machine will have decoding all the information
// need to either block or allow the next instruction longword into the
// pipeline.  The next longword is allowed into the pipeline under following
// conditions:
// (1) The instruction has long immediate data.
// (2) The instruction has a delay slot.
// 
   assign i_p1_step_stall_a = ((i_p2_step_a == 1'b 1) &
                              
                               // If the instruction in stage 2 has a
                               // LIMM then don't stall stage 1.
                               (i_p2_long_immediate_a == 1'b 0) &
                               // or if the processor is waiting for
                               // the LIMM to arrive.
                               (i_p2_tag_nxt_p1_limm_r == 1'b 0) &
                               // the processor is not waiting for the
                               // delay slot or LIMM to arrive.
                               (i_p2_tag_nxt_p1_dslot_r == 1'b 0) & 
                               
                               (p2int == 1'b 0) &
                               
                               (i_p2_has_dslot_a == 1'b 0) & 
                               
                               (i_p2_kill_p1_a == 1'b 0)) ? 1'b 1 : 
                              1'b 0; 

   // Zero delay loop stalls
   //
   // Stage 1 is stalled if there is a hit to the loopend whilst there is an
   // instruction in stage 3 that is writing to either LP_COUNT, LP_END or
   // LP_START
   //
   assign i_p1_zero_loop_stall_a = (loopend_hit_a &
                                  (i_p3_loopcount_hit_a
                                   |
                                   ((auxdc(aux_addr,AX_LSTART_N) |
                                     auxdc(aux_addr,AX_LEND_N)) &
                                    i_p3_sr_a)));

   
   // Control transfer and interrupt/LP_END hit stalls
   //
   // When a control transfer instruction is in the pipeline any interrupts must
   // be held in stage 1 to prevent the ilink register from being written with
   // an incorrect PC.  The PC would be incorrect if the interrupt read the PC
   // before the control transfer has been resolved.  In addition to this any
   // hit to the end of Zero delay loop need to be stalled because the control
   // transfer may modify the PC.
   //
   assign i_p1_ct_int_loop_stall_a = ((p1int | loopend_hit_a)     &
                                      
                                      // Dont stall any delay slot instruction
                                      // It is not allowed for a interrupt to
                                      // split a delay slot from it's parent
                                      // instruction. A delay slot instruction
                                      // may not occupy the last instruction
                                      // slot in a loop. This, therefore means
                                      // that this should never get to be
                                      // stalled under the conditions that are
                                      // being be prevented.
                                      //
                                      (~i_p2_tag_nxt_p1_dslot_r) &
                                      
                                      // Don't stall bcc if it has a delay slot.
                                      //
                                      ((i_p2_branch_iv_a &
                                        (~i_p2_has_dslot_a))                 |
                                       
                                       // Dont stall the jcc if it has a lim or
                                       // delay slot.
                                       //
                                       (i_p2_p2b_jmp_iv_a &
                                        (~(i_p2_limm_a | i_p2_has_dslot_a))) |
                                       
                                       i_p2b_jmp_iv_a                      |

                                       // Don't stall bcc if it has a delay
                                       // slot.
                                       //
                                       (i_p2_br_or_bbit_iv_a &
                                        (~(i_p2_limm_a | i_p2_has_dslot_a))) |
                                       
                                       i_p2b_br_or_bbit_iv_a               | 
                                       i_p3_br_or_bbit_iv_a                | 
                                       i_p4_br_or_bbit_iv_a));

//------------------------------------------------------------------------------
//  Pipeline 1 -> 2 transition enable
//------------------------------------------------------------------------------
//
   // Stage 1 pipeline enable
   //
   // Stage 1 is only enabled if both the pipeline can accept another
   // instruction and the cache/aligner has a valid instruction available.
   //
   assign i_p1_enable_a = ((i_p1_enable_niv_a == 1'b 0) | 
                           (ivalid_aligned == 1'b 0)) ? 1'b 0 : 
          1'b 1;
   
   // Stage 1 partial pipeline enable.
   //
   // This signal is used in the main pipeline enable signal is will prevent
   // any instruction in stage 1 from moving onto stage 2.  The conditions
   // under which the instruction will not move are:
   //
   // (1) if the processor is halted.
   // (2) When instruction stepping and the instruction packet in stage 1 is not
   //     allowed to move on. See above for conditions
   // (3) When there is an interrupt in stage 1 or a lp_end hit and a control
   //     transfer instruction is in the pipeline.
   // (4) when a write to any of the LP_END,LP_START or LP_COUNT registers and
   //     there is a lp_end hit
   // (5) If the pipeline ahead is stalled, except when stage 2b is waiting for
   //     a LIMM or delay-slot. The machine can only squash these type of
   //     bubbles due to static timing reasons limiting the complexity on the
   //     enable signals.
   //
   assign i_p1_enable_niv_a = ((en                          == 1'b 0) | 
                               (i_p1_step_stall_a           == 1'b 1) | 
                               (i_p2_brk_sleep_swi_a        == 1'b 1) | 
                               (i_p1_ct_int_loop_stall_a    == 1'b 1) |
                               (i_p1_zero_loop_stall_a      == 1'b 1) |
                               ((i_p2_en_no_pwr_save_a      == 1'b 0) & 
                               (i_p2b_limm_dslot_stall_r   == 1'b 0))) ?
          1'b 0 : 
          1'b 1;

//------------------------------------------------------------------------------
// Stage 1 to stage 2 pipeline register
//------------------------------------------------------------------------------
//
   // The stage 1 instruction word is moved into stage 2 only when the stage 1
   // enable allows it.
   //  
   always @(posedge clk or posedge rst_a)
     begin : Stage_2_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_p2_iw_r <= {(INSTR_UBND + 1){1'b 0}}; 
          end
        else
          begin
             if (i_p1_enable_a == 1'b 1)
               begin
                  i_p2_iw_r <= p1iw_aligned_a;  
               end
          end
     end

   // Loopend detection for actionpoints in stage 1.
   //
   always @(posedge clk or posedge rst_a)
     begin : Stage_2_lpend_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_p2_loopend_hit_r <= 1'b0;               
          end
        else
          begin
             if (i_p1_enable_a == 1'b 1)
               begin
                  i_p2_loopend_hit_r <= loopend_hit_a;
               end
          end
     end

   //------------------------------------------------------------------------------
// Stage 2 instruction field extraction
//------------------------------------------------------------------------------
// 
//  The various component parts of the instruction set are extracted here
//  to internal signals.
// 
//  Stage 1 address field decode for the sync_regs module.
//    
   //  Opcode [31:27]
   // 
   assign i_p2_opcode_a = i_p2_iw_r[INSTR_UBND:INSTR_LBND]; 

   //  Minor opcode
   // 
   assign i_p2_minoropcode_r = i_p2_iw_r[AOP_UBND:AOP_LBND]; 

   //  Sub opcode
   // 
   assign i_p2_subopcode_r = i_p2_iw_r[MINOR_OP_UBND:MINOR_OP_LBND]; 

   //  Sub opcode1
   // 
   assign i_p2_subopcode1_r = i_p2_iw_r[MINOR16_OP1_UBND:MINOR16_OP1_LBND]; 

   //  Sub opcode2
   // 
   assign i_p2_subopcode2_r = i_p2_iw_r[MINOR16_OP2_UBND:MINOR16_OP2_LBND]; 

   //  Sub opcode3
   // 
   assign i_p2_subopcode3_r = i_p2_iw_r[MINOR16_OP3_UBND:MINOR16_OP3_LBND]; 

   //  Sub opcode4
   // 
   assign i_p2_subopcode4_r = i_p2_iw_r[SUBOPCODE_BIT]; 

   //  Sub opcode5
   // 
   assign i_p2_subopcode5_r = i_p2_iw_r[MINOR16_BR1_UBND:MINOR16_BR1_LBND]; 

   //  Sub opcode6
   // 
   assign i_p2_subopcode6_r = i_p2_iw_r[MINOR16_BR2_UBND:MINOR16_BR2_LBND]; 

   //  Sub opcode7
   // 
   assign i_p2_subopcode7_r = i_p2_iw_r[MINOR16_OP4_UBND:MINOR16_OP4_LBND]; 

   //  A field
   //
   assign i_p2_a_field_r = i_p2_iw_r[AOP_UBND:AOP_LBND]; 

   //  A field for 16-bit
   //
   assign i_p2_a_field16_r = {TWO_ZERO, i_p2_iw_r[AOP_UBND16], 
                              i_p2_iw_r[AOP_UBND16:AOP_LBND16]}; 

   //  C field for 16-bit
   //
   assign i_p2_c_field16_r = i_p2_iw_r[COP_UBND16:COP_LBND16]; 

   //  C field for 16-bit (extended to fit writeback address register
   //  field).
   // 
   assign i_p2_c_field16_2_r = {TWO_ZERO, i_p2_iw_r[COP_UBND16], 
                                i_p2_iw_r[COP_UBND16:COP_LBND16]}; 

   //  B field
   //
   assign i_p2_b_field_r = {i_p2_iw_r[BOP_MSB_UBND:BOP_MSB_LBND], 
                            i_p2_iw_r[BOP_LSB_UBND:BOP_LSB_LBND]}; 

   //  B field for 16-bit
   //
   assign i_p2_b_field16_r = i_p2_iw_r[BOP_LSB_UBND:BOP_LSB_LBND]; 

   //  High register field for 16-bit
   //
   assign i_p2_hi_reg16_r = {i_p2_iw_r[AOP_UBND16:AOP_LBND16], 
                             i_p2_iw_r[COP_UBND16:COP_LBND16]}; 

   //  C field for 32-bit
   //
   assign i_p2_c_field_r = i_p2_iw_r[COP_UBND:COP_LBND]; 

   //  Format for operands
   //
   assign i_p2_format_r = i_p2_iw_r[MINOR_OP_UBND + 2:MINOR_OP_UBND + 1]; 

//------------------------------------------------------------------------------
// Stage 2 instruction decode
//------------------------------------------------------------------------------

   // Register & signed 12-bit immediate
   //
   assign i_p2_fmt_s12_a = (i_p2_format_r == FMT_S12) ? 1'b 1 : 
          1'b 0; 

   // Register & unsigned 6-bit immediate
   //
   assign i_p2_fmt_u6_a = (i_p2_format_r == FMT_U6) ? 1'b 1 : 
          1'b 0; 

   // Conditional register
   //
   assign i_p2_fmt_cond_reg_dec_a = (i_p2_format_r == FMT_COND_REG) ? 1'b 1 : 
          1'b 0; 

   // Condtional register & register
   //
   assign i_p2_fmt_cond_reg_a = (i_p2_fmt_cond_reg_dec_a & 
                                 (~i_p2_iw_r[AOP_UBND])); 

   // Conditional register & unsigned 6-bit immediate
   //
   assign i_p2_fmt_cond_reg_u6_a = (i_p2_fmt_cond_reg_dec_a & 
                                    i_p2_iw_r[AOP_UBND]); 

   // Register & register
   //   
   assign i_p2_fmt_reg_a = (i_p2_format_r == FMT_REG) ? 1'b 1 : 
          1'b 0;

//------------------------------------------------------------------------------
// Opcode decodes
//------------------------------------------------------------------------------
// 
   //  Decode for 16-bit Single Operand instruction.
   // 
   assign i_p2_16_sop_inst_a = (i_p2_opcode_16_alu_a & 
                                i_p2_subop_16_sop_a); 

   //  Decode for 32-bit Single Operand instruction.
   // 
   assign i_p2_32_sop_inst_a = (i_p2_opcode_32_fmt1_a & 
                                i_p2_subopcode_sop_a); 

   //  Decode for 32-bit Basecase Instruction Opcode slot.
   // 
   assign i_p2_opcode_32_fmt1_a = (i_p2_opcode_a == OP_FMT1) ? 1'b 1 : 
          1'b 0; 

   //  Decode for 16-bit Basecase ALU Instruction Opcode slot.
   // 
   assign i_p2_opcode_16_alu_a = (i_p2_opcode_a == OP_16_ALU_GEN) ? 1'b 1 : 
          1'b 0;  

   //  Decode for 16-bit ADD/CMP instruction with unsigned 7-bit short
   //  immediate.
   // 
   assign i_p2_opcode_16_addcmp_a = (i_p2_opcode_a == OP_16_ADDCMP) ? 1'b 1 : 
        1'b 0;  

   //  Select appropriate address for 16-bit Global pointer instructions.
   //  
   assign i_p2_opcode_16_gp_rel_a = (i_p2_opcode_a == OP_16_GP_REL) ? 1'b 1 : 
          1'b 0;  

   //  Select appropriate address for 16-bit Stack pointer instructions.
   // 
   assign i_p2_opcode_16_sp_rel_a = (i_p2_opcode_a == OP_16_SP_REL) ? 1'b 1 : 
          1'b 0;  

   //  Decode for 16-bit ADD/SUB and shift register instructions.
   // 
   assign i_p2_opcode_16_arith_a = (i_p2_opcode_a == OP_16_ARITH) ? 1'b 1 : 
          1'b 0;  

   //  Decode for 16-bit MOV instruction.
   // 
   assign i_p2_opcode_16_mov_a = (i_p2_opcode_a == OP_16_MV) ? 1'b 1 : 
          1'b 0;  

   //  Select PC register for LD PC relative instructions.
   // 
   assign i_p2_opcode_16_ld_pc_a = (i_p2_opcode_a == OP_16_LD_PC) ? 1'b 1 : 
          1'b 0; 
   
   //Main decode for 16-bit conditional branch (b,beq & bne)
   //
   assign i_p2_opcode_16_bcc_a = (i_p2_opcode_a == OP_16_BCC) ? 1'b 1 : 
          1'b 0;  

   // Sub-decode for 16-bit conditional branch (bgt, bge, blt, ble, bhi, bhs,
   // blo & bls)
   //
   assign i_p2_opcode_16_bcc_cc_a = ((i_p2_opcode_16_bcc_a == 1'b 1) &
                                     (i_p2_subopcode5_r != 2'b 11)) ? 1'b 1 : 
          1'b 0;  

   // Sub-decode for 16-bit conditional branch  (b,beq & bne)
   //
   assign i_p2_opc_16_bcc_cc_s7_a = ((i_p2_opcode_16_bcc_a == 1'b 1) & 
                                        (i_p2_subopcode5_r == 2'b 11)) ? 1'b 1 : 
          1'b 0;  

   // Decode for 16-bit compare&branch
   //
   assign i_p2_opcode_16_brcc_a = (i_p2_opcode_a == OP_16_BRCC) ? 1'b 1 : 
          1'b 0;  

   // Decode for 16-bit unconditional branch&link
   //
   assign i_p2_opcode_16_bl_a = (i_p2_opcode_a == OP_16_BL) ? 1'b 1 : 
          1'b 0;  

   // Decode for 32-bit conditional branch
   //
   assign i_p2_opcode_32_bcc_a = (i_p2_opcode_a == OP_BCC) ? 1'b 1 : 
          1'b 0;  

   // Decode for 32-bit conditional branch&link
   //
   assign i_p2_opcode_32_blcc_a = (i_p2_opcode_a == OP_BLCC) ? 1'b 1 : 
          1'b 0;  

   // Decode for 16-bit mov, cmp, add with high registers
   //
   assign i_p2_opcode_16_mv_add_a = (i_p2_opcode_a == OP_16_MV_ADD) ? 1'b 1 : 
          1'b 0;  

   // Decode for 16-bit add, sub, shift with reg & u3 imm
   //
   assign i_p2_opcode_16_ssub_a = (i_p2_opcode_a == OP_16_SSUB) ?  1'b 1 : 
          1'b 0;  

   // Decode for 16-bit ld & add with reg - reg
   //
   assign i_p2_opcode_16_ld_add_a = (i_p2_opcode_a == OP_16_LD_ADD) ? 1'b 1 : 
          1'b 0;  

   // Decode for 32-bit ST with reg, reg, s9
   //  
   assign i_p2_opcode_32_st_a = (i_p2_opcode_a == OP_ST) ? 1'b 1 : 
          1'b 0; 
   
   // Decode for 32-bit LD with reg, reg, s9
   //
   assign i_p2_opcode_32_ld_a = (i_p2_opcode_a == OP_LD) ? 1'b 1 : 
          1'b 0;  

//------------------------------------------------------------------------------
// Subopcode decodes
//------------------------------------------------------------------------------

   // Sub-decode for 16-bit single operand instructions
   //
   assign i_p2_subop_16_sop_a = (i_p2_subopcode2_r == SO16_SOP) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit single operand move 
   //
   assign i_p2_subopcode_mov_a = (i_p2_subopcode_r == SO_MOV) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit single operand flag
   //
   assign i_p2_subopcode_flag_a = (i_p2_subopcode_r == SO_FLAG) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit single operand instruction 
   //
   assign i_p2_subopcode_sop_a = (i_p2_subopcode_r) == SO_SOP ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit jump with delay slot 
   //
   assign i_p2_subopcode_lr_a = (i_p2_subopcode_r == SO_LR) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit jump with delay slot 
   //
   assign i_p2_subopcode_jd_a = (i_p2_subopcode_r == SO_J_D) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit jump&link with delay slot 
   //
   assign i_p2_subopcode_jld_a = (i_p2_subopcode_r == SO_JL_D) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit jump 
   //
   assign i_p2_subopcode_j_a = (i_p2_subopcode_r == SO_J) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit jump&link
   //
   assign i_p2_subopcode_jl_a = (i_p2_subopcode_r == SO_JL) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit memory longword load 
   //
   assign i_p2_subopcode_ld_a = (i_p2_subopcode_r == SO_LD) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit memory byte load
   //
   assign i_p2_subopcode_ldb_a = (i_p2_subopcode_r == SO_LDB) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit memory byte load with sign extension 
   //
   assign i_p2_subopcode_ldb_x_a = (i_p2_subopcode_r == SO_LDB_X) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit memory word load  
   //
   assign i_p2_subopcode_ldw_a = (i_p2_subopcode_r == SO_LDW) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit memory word load with sign extension 
   //
   assign i_p2_subopcode_ldw_x_a = (i_p2_subopcode_r == SO_LDW_X) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit global pointer relative byte load
   //
   assign i_p2_subop_16_ldb_gp_a = (i_p2_subopcode7_r == SO16_LDB_GP) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit global pointer relative word load
   //  
   assign i_p2_subop_16_ldw_gp_a = (i_p2_subopcode7_r == SO16_LDW_GP) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit move with hi register
   //
   assign i_p2_subop_16_mov_hi2_a = (i_p2_subopcode1_r == SO16_MOV_HI2) ? 1'b 1 :
          1'b 0; 

   // Sub-decode for 16-bit bit-test with 5-bit unsigned immediate 
   //
   assign i_p2_subop_16_btst_u5_a = (i_p2_subopcode3_r == SO16_BTST_U5) ? 1'b 1 :
          1'b 0; 

   // Sub-decode for 16-bit push with unsigned 7-bit immediate 
   //
   assign i_p2_subop_16_push_u7_a = (i_p2_subopcode3_r == SO16_PUSH_U7) ? 1'b 1 :
          1'b 0; 

   // Sub-decode for 16-bit pop with unsigned 7-bit immediate 
   //
   assign i_p2_subop_16_pop_u7_a = (i_p2_subopcode3_r == SO16_POP_U7) ? 1'b 1 :
          1'b 0; 

   // Sub-decode for 32-bit reverse subtract
   //
   assign i_p2_subopcode_rsub_a = (i_p2_subopcode_r == SO_RSUB) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 32-bit reverse compare 
   //
   assign i_p2_subopcode_rcmp_a = (i_p2_subopcode_r == SO_RCMP) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit move with hi register
   //
   assign i_p2_subop_16_mov_hi1_a = (i_p2_subopcode1_r == SO16_MOV_HI1) ? 1'b 1 :
          1'b 0; 

   // Sub-decode for 16-bit break 
   //
   assign i_p2_subop_16_brk_a = (i_p2_subopcode2_r == SO16_BRK) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit negate 
   //
   assign i_p2_subop_16_neg_a = (i_p2_subopcode2_r == SO16_NEG) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit absolute 
   //
   assign i_p2_subop_16_abs_a = (i_p2_subopcode2_r == SO16_ABS) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit logical not 
   //
   assign i_p2_subop_16_not_a = (i_p2_subopcode2_r == SO16_NOT) ? 1'b 1 : 
          1'b 0; 

//------------------------------------------------------------------------------
//  C field decodes 
//------------------------------------------------------------------------------
//
   // The c field is used when the operation is a single operand instruction
   //
   // Sub-decode for 16-bit zero operand instruction 
   //
   assign i_p2_c_field16_zop_a = (i_p2_c_field16_r == SO16_SOP_ZOP) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit single operand subtract
   //
   assign i_p2_c_field16_sop_sub_a = (i_p2_c_field16_r == SO16_SOP_SUB) ? 1'b 1 :
          1'b 0; 

   // Sub-decode for 16-bit single operand jump with delay slot 
   //
   assign i_p2_c_field16_sop_jd_a = (i_p2_c_field16_r == SO16_SOP_JD) ? 1'b 1 :
          1'b 0; 

   // Sub-decode for 16-bit single operand jump with delay slot 
   //
   assign i_p2_c_field16_sop_jld_a = (i_p2_c_field16_r == SO16_SOP_JLD) ? 1'b 1 :
          1'b 0; 

   // Sub-decode for 16-bit single operand jump 
   //
   assign i_p2_c_field16_sop_j_a = (i_p2_c_field16_r == SO16_SOP_J) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit single operand jump&link 
   //
   assign i_p2_c_field16_sop_jl_a = (i_p2_c_field16_r == SO16_SOP_JL) ? 1'b 1 :
          1'b 0; 

//------------------------------------------------------------------------------
// B field decodes 
//------------------------------------------------------------------------------
//
// The B field is uses for decoding the zero operand instructions
//

   // Sub-decode for 16-bit zero operand jump on equal
   //
   assign i_p2_b_field16_zop_jeq_a = (i_p2_b_field16_r == SO16_ZOP_JEQ) ? 1'b 1 :
          1'b 0; 

   // Sub-decode for 16-bit zero operand jump on not equal 
   //
   assign i_p2_b_field16_zop_jne_a = (i_p2_b_field16_r == SO16_ZOP_JNE) ? 1'b 1 :
          1'b 0; 

   // Sub-decode for 16-bit zero operand jump with delay slot 
   //
   assign i_p2_b_field16_zop_jd_a = (i_p2_b_field16_r == SO16_ZOP_JD) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit zero operand jump 
   //
   assign i_p2_b_field16_zop_j_a = (i_p2_b_field16_r == SO16_ZOP_J) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit zero operand software interrupt 
   //
   assign i_p2_b_field_zop_swi_a = (i_p2_b_field_r == ZO_SWI) ? 1'b 1 : 
          1'b 0; 

   // Sub-decode for 16-bit zero operand sleep 
   //
   assign i_p2_b_field_zop_sleep_a = (i_p2_b_field_r == ZO_SLEEP) ? 1'b 1 : 
          1'b 0; 
          
   // Sub-decode for zero operand sync
   //
   assign i_p2_b_field_zop_sync_a = (i_p2_b_field_r == ZO_SYNC) ? 1'b 1 : 
          1'b 0;

//------------------------------------------------------------------------------
// Minor-opcode decodes
//------------------------------------------------------------------------------


   // Minor-opcode decode for zero operand instructions
   //
   assign i_p2_zop_decode_a = ((i_p2_minoropcode_r == MO_ZOP) & 
                               (i_p2_32_sop_inst_a == 1'b 1)) ? 1'b 1 :
          1'b 0; 
  
   // Minor-opcode decode for absoulute
   //
   assign i_p2_minor_op_abs_a = (i_p2_minoropcode_r == MO_ABS) ? 1'b 1 : 
          1'b 0; 

//------------------------------------------------------------------------------
//  Extended decodes
//------------------------------------------------------------------------------

   // Decode for 16-bit push operations
   //
   assign i_p2_push_decode_a = (i_p2_opcode_16_sp_rel_a & 
                                i_p2_subop_16_push_u7_a);
   
   // Decode for 16-bit pop operations
   //
   assign i_p2_pop_decode_a = (i_p2_opcode_16_sp_rel_a & 
                               i_p2_subop_16_pop_u7_a);
   
   // Decode for all 16-bit shift operations
   //
   assign i_p2_opcode_16_ushimm_shft_a = (((i_p2_opcode_16_ssub_a == 1'b 1) &
                                           ((i_p2_subopcode3_r == SO16_ASL_U5)  | 
                                            (i_p2_subopcode3_r == SO16_LSR_U5)  | 
                                            (i_p2_subopcode3_r == SO16_ASR_U5)))
                                            | 
                                            ((i_p2_opcode_16_arith_a == 1'b 1) & 
                                             ((i_p2_subopcode1_r == SO16_ASL) | 
                                              (i_p2_subopcode1_r == SO16_ASR)))) ?
          1'b 1 :
          1'b 0;
   
   // 16-bit LD register + offset instructions.
   // 
   assign i_p2_ldo16_a = ((i_p2_opcode_a == OP_16_LD_U7) | 
                    (i_p2_opcode_a == OP_16_LDB_U5) | 
                    (i_p2_opcode_a == OP_16_LDW_U6) | 
                    (i_p2_opcode_a == OP_16_LDWX_U6)) ? 1'b 1 :
          1'b 0; 

   // 16-bit ST register + offset instructions.
   // 
   assign i_p2_sto16_a = ((i_p2_opcode_a == OP_16_ST_U7) | 
                    (i_p2_opcode_a == OP_16_STB_U5) | 
                    (i_p2_opcode_a == OP_16_STW_U6)) ? 1'b 1 :
          1'b 0; 

   // Decode forPush [blink] 
   //
   assign i_p2_push_blink_a = ((i_p2_opcode_16_sp_rel_a     == 1'b 1) & 
                        (i_p2_subop_16_push_u7_a == 1'b 1) & 
                        (i_p2_iw_r[SP_MODE_1]        == 1'b 1) & 
                        (i_p2_iw_r[SP_MODE_2]        == 1'b 1)) ? 1'b 1 :
          1'b 0; 

   // Select appropriate field for 16-bit MOV with full addressing to
   // register file.
   // 
   assign i_p2_mov_hi_a = (i_p2_opcode_16_mv_add_a & 
                           i_p2_subop_16_mov_hi1_a);

   // Decode for 32-bit conditional branch
   //   
   assign i_p2_bcc32_a = (i_p2_opcode_32_bcc_a & 
                          (~i_p2_subopcode_r[SUBOPCODE_LSB])); 

   // Decode for 32-bit branch
   //
   assign i_p2_b32_a = (i_p2_opcode_32_bcc_a & 
                        i_p2_subopcode_r[SUBOPCODE_LSB]); 

   // Decode for 32-bit conditonal branch&link
   //
   assign i_p2_blcc32_a = (i_p2_opcode_32_blcc_a & 
                           (~i_p2_iw_r[SET_BLCC]) & 
                           (~i_p2_iw_r[BR_FMT])); 

   // Decode for 32-bit branch&link
   //
   assign i_p2_bl32_a = (i_p2_opcode_32_blcc_a & 
                         i_p2_iw_r[SET_BLCC] & 
                         (~i_p2_iw_r[BR_FMT])); 

   // Decode for 32-bit branch&link and conditional branch&link
   //
   assign i_p2_bl_blcc_32_a = (i_p2_opcode_32_blcc_a & 
                               (~i_p2_iw_r[BR_FMT])); 

   // Decode for 32-bit compare&branch with unsigned 6-bit immediate 
   //
   assign i_p2_br32_u6_a = (i_p2_opcode_32_blcc_a & 
                            i_p2_iw_r[BR_FMT] & 
                            i_p2_iw_r[QQ_UBND]); 

   // Decode for 32-bit all major opcode 4 except the loads
   //
   assign i_p2_no_ld_a = ((i_p2_opcode_32_fmt1_a  == 1'b 1) & 
                          (i_p2_subopcode_ld_a    == 1'b 0) & 
                          (i_p2_subopcode_ldb_a   == 1'b 0) & 
                          (i_p2_subopcode_ldb_x_a == 1'b 0) & 
                          (i_p2_subopcode_ldw_a   == 1'b 0) & 
                          (i_p2_subopcode_ldw_x_a == 1'b 0)) ?
          1'b 1 :
          1'b 0;

   // Decode for 32-bit all major opcode 4 except the loads and reverse
   // operations.
   //
   assign i_p2_no_ld_and_rev_a = ((i_p2_opcode_32_fmt1_a == 1'b 1) & 
                                  (i_p2_subopcode_rsub_a == 1'b 0) & 
                                  (i_p2_subopcode_rcmp_a == 1'b 0) & 
                                  (i_p2_no_ld_a          == 1'b 1)) ?
          1'b 1 :
          1'b 0; 

   // Auxiliary Load.
   // 
   assign i_p2_lr_decode_iv_a = (i_p2_opcode_32_fmt1_a & 
                                 i_p2_subopcode_lr_a & 
                                 i_p2_iv_r); 

   // Decode for all absolute or negate operations
   //
   assign i_p2_abs_neg_decode_a = (((i_p2_opcode_32_fmt1_a & 
                                     i_p2_32_sop_inst_a & 
                                     i_p2_minor_op_abs_a) 
                                    | 
                                    (i_p2_opcode_16_alu_a & 
                                     i_p2_16_sop_inst_a & 
                                     (i_p2_subop_16_abs_a | 
                                      i_p2_subop_16_neg_a))) & 
                                   i_p2_iv_r); 

   // Decode for logical not operations
   //
   assign i_p2_not_decode_a = (i_p2_opcode_16_alu_a    & 
                               i_p2_16_sop_inst_a      & 
                               i_p2_subop_16_not_a & 
                               i_p2_iv_r); 

   // 16-bit version of BRK. This signal is only asserted if the instruction is
   // not about to be killed by a control transfer. 
   //
   assign i_p2_brk_inst_a = (i_p2_opcode_16_alu_a    & 
                             i_p2_subop_16_brk_a     & 
                             i_p2_iv_r               & 
                             (~i_kill_p2_a)); 


   // The Software Interrupt (SWI) instruction is determined at stage 2
   // from:
   //
   //    [1] Decode of p2iw
   //    [2] Instruction at stage 2 is valid
   //    [3] An actionpoint wants to insert a SWI
   //
   assign i_p2_swi_inst_a = (i_p2_swi_inst_niv_a & i_p2_iv_r) & 
                             ~actionpt_pc_brk_a;

   assign i_p2_swi_inst_niv_a = i_p2_zop_decode_a & i_p2_b_field_zop_swi_a; 


   // 
   //  The sleep instruction is determined at stage 2 from:
   // 
   //     [1] Decode of p2iw,
   //     [2] Instruction at stage 2 is valid.
   // 
   assign i_p2_sleep_inst_a = i_p2_sleep_inst_niv_a & i_p2_iv_r & (~i_kill_p2_a);
 
   assign i_p2_sleep_inst_niv_a = i_p2_zop_decode_a & i_p2_b_field_zop_sleep_a; 
   
   
   // SYNC instruction is determined here.
   // 
   assign i_p2_sync_inst_a = i_p2_sync_inst_niv_a & i_p2_iv_r;
   
   assign i_p2_sync_inst_niv_a = i_p2_zop_decode_a & i_p2_b_field_zop_sync_a;

//------------------------------------------------------------------------------
// Long immediate detection
//------------------------------------------------------------------------------
//
// Long immediate detection is done as early as possible as the aligner uses the
// p2limm signal to control the next_pc generation, which is critical path
//
   assign i_p2_a_field_long_imm_a = (i_p2_a_field_r == RLIMM) ? 1'b 1 : 
          1'b 0;
   
   assign i_p2_c_field_long_imm_a = (i_p2_c_field_r == RLIMM) ? 1'b 1 : 
          1'b 0;
   
   assign i_p2_b_field_long_imm_a = (i_p2_b_field_r == RLIMM) ? 1'b 1 : 
          1'b 0;
   
   assign i_p2_hi_reg16_long_imm_a = (i_p2_hi_reg16_r == RLIMM) ? 1'b 1 :
          1'b 0; 


//------------------------------------------------------------------------------
// Source 1 register address selection
//------------------------------------------------------------------------------
//
// The source 1 address field selects the following:
//
// [1] C-field for 32-bit instructions, MOV, RSUB and RCMP,
// [2] High register field when 16-bit instruction access all 64
//     core registers,
// [3] Global pointer for 16-bit GP relative LD/STs,
// [4] Stack pointer for 16-bit SP relative LDs,
// [5] PC value for 16-bit PC relative LDs,
// [6] Otherwise it selects the B-field.
// 

   assign i_p2_src1_addr_sel0_a = x_p1_rev_src | i_p2_rev_arith_a;
   
   assign i_p2_src1_addr_sel1_a = (~(i_p2_src1_addr_sel0_a   | 
                                    i_p2_mov_hi_a           | 
                                    i_p2_opcode_16_gp_rel_a | 
                                    i_p2_opcode_16_sp_rel_a | 
                                    i_p2_opcode_16_ld_pc_a));
   
   // Select the correct source 1 register address
   //
   assign i_p2_source1_addr_a = (i_p2_c_field_r & 
                                 ({(OPERAND_WIDTH){i_p2_src1_addr_sel0_a}})   | 

                                 i_p2_hi_reg16_r & 
                                 ({(OPERAND_WIDTH){i_p2_mov_hi_a}})           | 
                         
                                 RGLOBALPTR & 
                                 ({(OPERAND_WIDTH){i_p2_opcode_16_gp_rel_a}}) | 
                         
                                 RSTACKPTR & 
                                 ({(OPERAND_WIDTH){i_p2_opcode_16_sp_rel_a}}) | 
                         
                                 RCURRENTPC & 
                                 ({(OPERAND_WIDTH){i_p2_opcode_16_ld_pc_a}})  | 
                                 i_p2_b_field_r & 
                                 ({(OPERAND_WIDTH){i_p2_src1_addr_sel1_a}}));

   // Source 1 long immediate detect selection.
   // 
   assign i_p2_long_immediate1_a = ((i_p2_c_field_long_imm_a &
                                     i_p2_src1_addr_sel0_a) 
                                    | 
                                    (i_p2_hi_reg16_long_imm_a &
                                     i_p2_mov_hi_a)
                                    | 
                                    (i_p2_b_field_long_imm_a &
                                     i_p2_src1_addr_sel1_a)); 
  
//------------------------------------------------------------------------------
// Source 2 register address selection
//------------------------------------------------------------------------------
//
// The B-field is selected for 32-bit instructions, MOV, RSUB and RCMP, or SP
// relative instructions or 16-bit MOV with high register as a source.
// 
   assign i_p2_src2_b_field_a = ((i_p2_opcode_32_fmt1_a == 1'b 1) & 
                         ((i_p2_subopcode_rcmp_a == 1'b 1) | 
                          (i_p2_subopcode_rsub_a == 1'b 1)) 
                         | 
                         ((i_p2_opcode_16_mv_add_a == 1'b 1) & 
                          (i_p2_subop_16_mov_hi2_a == 1'b 1) 
                          |
                          (i_p2_opcode_16_sp_rel_a == 1'b 1) & 
                          (i_p2_push_blink_a == 1'b 0) 
                          | 
                          (i_p2_16_sop_inst_a & 
                           (i_p2_c_field16_sop_sub_a | 
                           i_p2_c_field16_sop_jd_a |
                           i_p2_c_field16_sop_j_a |
                           i_p2_c_field16_sop_jl_a |
                           i_p2_c_field16_sop_jld_a)) == 1'b 1)) ? 1'b 1 : 
          1'b 0;
   
   //  Select appropriate field for 16-bit MOV with full addressing to
   //  register file.
   //  
   assign i_p2_src2_hi_a =((i_p2_opcode_16_mv_add_a == 1'b 1) & 
                     ((i_p2_subop_16_mov_hi1_a == 1'b 1) | 
                     (i_p2_subopcode1_r == SO16_ADD_HI) | 
                     (i_p2_subopcode1_r == SO16_CMP))) ? 1'b 1 :
        1'b 0; 

   //  Select BLINK register when 16-bit jump/link instructions are
   //  performed.
   //  
   assign i_p2_src2_rblink_a = (((i_p2_16_sop_inst_a == 1'b 1) & 
                         ((i_p2_c_field16_zop_a == 1'b 1) &
                          ((i_p2_b_field16_zop_jeq_a == 1'b 1) | 
                           (i_p2_b_field16_zop_jne_a == 1'b 1) | 
                           (i_p2_b_field16_zop_j_a == 1'b 1) | 
                           (i_p2_b_field16_zop_jd_a == 1'b 1))) | 
                         (i_p2_push_blink_a == 1'b 1))) ? 1'b 1 : 
          1'b 0; 


   // Select b field if directly decoded or requested by extention instruction
   //
   assign i_p2_src2_addr_sel0_a = (x_p1_rev_src | i_p2_src2_b_field_a);

   // Select c field as default
   //  
   assign i_p2_src2_addr_sel1_a = (~(i_p2_src2_addr_sel0_a | 
                                    i_p2_src2_hi_a        | 
                                    i_p2_src2_rblink_a)); 

   // Select the correct source 2 register address field
   //
   assign i_p2_source2_addr_a =
                        (i_p2_b_field_r & ({(OPERAND_WIDTH){i_p2_src2_addr_sel0_a}}) 
                         | 
                         i_p2_hi_reg16_r & ({(OPERAND_WIDTH){i_p2_src2_hi_a}}) 
                         |
                         RBLINK & ({(OPERAND_WIDTH){i_p2_src2_rblink_a}}) 
                         |
                         i_p2_c_field_r & ({(OPERAND_WIDTH){i_p2_src2_addr_sel1_a}})); 

   // Long immediate detection selection.
   //                
   assign i_p2_long_immediate2_a =
                      ((i_p2_b_field_long_imm_a & i_p2_src2_addr_sel0_a)
                           | 
                       (i_p2_hi_reg16_long_imm_a & i_p2_src2_hi_a)
                           | 
                       (i_p2_c_field_long_imm_a & i_p2_src2_addr_sel1_a)); 
  
//------------------------------------------------------------------------------
// Source 1 register field validation
//------------------------------------------------------------------------------
//
// The following logic is used to determine if the data in the source1 register
// address field is valid. 
// 
   always @(i_p2_subopcode_r or 
            i_p2_fmt_cond_reg_a or 
            i_p2_fmt_reg_a)
    begin : s1en_subop_async_PROC
      case (i_p2_subopcode_r) 
        SO_ADD,  SO_ADC,   SO_SUB,  SO_SBC,
        SO_AND,  SO_OR,    SO_BIC,  SO_XOR,
        SO_MAX,  SO_MIN,   SO_BSET, SO_BCLR,
        SO_BTST, SO_BMSK,  SO_BXOR, SO_LD, 
        SO_LDB,  SO_LDB_X, SO_LDW,  SO_LDW_X, 
        SO_SR,   SO_ADD1,  SO_ADD2, SO_ADD3, 
        SO_SUB1, SO_SUB2,  SO_SUB3, SO_TST, 
        SO_CMP: 
         i_p2_s1_en_subop_dec_a = 1'b 1;   
         
        SO_RCMP, SO_RSUB:
          if ((i_p2_fmt_cond_reg_a == 1'b 1) | 
            (i_p2_fmt_reg_a      == 1'b 1))
           i_p2_s1_en_subop_dec_a = 1'b 1;   
         else
           i_p2_s1_en_subop_dec_a = 1'b 0;   
        
        SO_MOV:
         begin
            if ((i_p2_fmt_cond_reg_a == 1'b 1) | 
               (i_p2_fmt_reg_a      == 1'b 1))
                i_p2_s1_en_subop_dec_a = 1'b 1;   
            else
             i_p2_s1_en_subop_dec_a = 1'b 0;   
         end
        
        default:
         i_p2_s1_en_subop_dec_a = 1'b 0;   
      
      endcase
    end
   

   always @(i_p2_subopcode2_r or i_p2_s1_en_cfield_dec_a)
    begin : s1en_subop2_async_PROC
      case (i_p2_subopcode2_r)
        SO16_SUB_REG, SO16_AND,  SO16_OR,
        SO16_BIC,     SO16_XOR,  SO16_TST,
        SO16_MUL64,   SO16_ADD1,  SO16_ADD2,
        SO16_ADD3,    SO16_ASL_M, SO16_LSR_M,
        SO16_ASR_M:
         i_p2_s1_en_subop2_dec_a = 1'b 1;  
          
        SO16_SOP:
            i_p2_s1_en_subop2_dec_a = i_p2_s1_en_cfield_dec_a;
          
        default:
            i_p2_s1_en_subop2_dec_a = 1'b 0;   
        
      endcase
    end 
   

   always @(i_p2_c_field16_r)
    begin : s1en_cfield_decode_PROC
      case (i_p2_c_field16_r) 
        SO16_SOP_SUB:
         i_p2_s1_en_cfield_dec_a = 1'b 1;   
        
        default:
         i_p2_s1_en_cfield_dec_a = 1'b 0;   
      
      endcase
    end 
   

   always @(i_p2_opcode_a or i_p2_subopcode_r or 
         i_p2_s1_en_subop_dec_a or i_p2_s1_en_subop2_dec_a)
    begin : s1en_decode_PROC
      case (i_p2_opcode_a) 
        OP_BLCC:
         begin
            if (i_p2_subopcode_r[0] == 1'b 1) //BRcc
             i_p2_s1_en_decode_a = 1'b 1;   
            else
             i_p2_s1_en_decode_a = 1'b 0;   
            
         end
        
        OP_LD, OP_ST:
         i_p2_s1_en_decode_a = 1'b 1;   
        
        OP_FMT1:
         i_p2_s1_en_decode_a = i_p2_s1_en_subop_dec_a;
         
        OP_16_LD_ADD, OP_16_LD_PC,   OP_16_ARITH, 
        OP_16_LD_U7,  OP_16_LDB_U5,  OP_16_LDW_U6, 
        OP_16_MV_ADD, OP_16_LDWX_U6, OP_16_ST_U7, 
        OP_16_STB_U5, OP_16_STW_U6,  OP_16_SSUB, 
        OP_16_SP_REL, OP_16_GP_REL,  OP_16_ADDCMP, 
        OP_16_BRCC:
         i_p2_s1_en_decode_a = 1'b 1;   
         
        OP_16_ALU_GEN:
         i_p2_s1_en_decode_a = i_p2_s1_en_subop2_dec_a;
        
        default:
         i_p2_s1_en_decode_a = 1'b 0;   
         
      endcase
    end 

   // Final source 1 address validation
   // 
   assign i_p2_source1_en_a = i_p2_iv_r           & 
                             (i_p2_s1_en_decode_a | 
                              XT_ALUOP            & 
                              x_idop_decode2);

//------------------------------------------------------------------------------
// Source 2 register address field validation
//------------------------------------------------------------------------------

   always @(i_p2_opcode_a or i_p2_subopcode_r or i_p2_subopcode2_r or 
            i_p2_subopcode3_r or i_p2_a_field_r or i_p2_b_field16_r or 
            i_p2_minoropcode_r or i_p2_c_field16_r or 
            i_p2_fmt_cond_reg_a or i_p2_fmt_reg_a)
    
    begin : s2en_decode_PROC
      
      case (i_p2_opcode_a)
        OP_BLCC:
         begin
            if ((i_p2_subopcode_r[0] == 1'b 1) & 
               (i_p2_a_field_r[SUBOPCODE_MSB_1] == 1'b 0))
               i_p2_s2_en_decode_a = 1'b 1;   
            else
               i_p2_s2_en_decode_a = 1'b 0;   

         end
        OP_LD: i_p2_s2_en_decode_a = 1'b 0;   
        
        OP_ST: i_p2_s2_en_decode_a = 1'b 1;   
         
        OP_FMT1:
         begin
            case (i_p2_subopcode_r) 
             SO_ADD,   SO_ADC,   SO_SUB,   SO_SBC,    
             SO_AND,   SO_OR,    SO_BIC,   SO_XOR,    
             SO_MAX,   SO_MIN,   SO_LR,    SO_SR,    
             SO_MOV,   SO_J,     SO_BSET,  SO_BCLR,    
             SO_BTST,  SO_BMSK,  SO_BXOR,  SO_J_D,    
             SO_JL,    SO_JL_D,  SO_ADD1,  SO_ADD2,    
             SO_ADD3,  SO_SUB2,  SO_SUB3,  SO_TST,    
             SO_CMP,   SO_SUB1,  SO_FLAG:
               begin
                 if ((i_p2_fmt_cond_reg_a == 1'b 1) | 
                    (i_p2_fmt_reg_a == 1'b 1))
                  begin
                     i_p2_s2_en_decode_a = 1'b 1;   
                  end
                 else
                  begin
                     i_p2_s2_en_decode_a = 1'b 0;   
                  end
               end
             SO_SOP:
               begin
                 if (i_p2_minoropcode_r == MO_ZOP)
                  begin
                     i_p2_s2_en_decode_a = 1'b 0;   
                  end
                 else
                  begin
                     if ((i_p2_fmt_cond_reg_a == 1'b 1) | 
                        (i_p2_fmt_reg_a == 1'b 1))
                      begin
                        i_p2_s2_en_decode_a = 1'b 1;   
                      end
                     else
                      begin
                        i_p2_s2_en_decode_a = 1'b 0;   
                      end
                  end
               end
             SO_LD,    SO_RCMP,  SO_RSUB,    
             SO_LDB,   SO_LDB_X, SO_LDW,    
             SO_LDW_X:
               begin
                 i_p2_s2_en_decode_a = 1'b 1;   
               end
             default:
               begin
                 i_p2_s2_en_decode_a = 1'b 0;   
               end
            endcase
         end
        OP_16_LD_ADD, 
        OP_16_MV_ADD:
         begin
            i_p2_s2_en_decode_a = 1'b 1;   
         end
        OP_16_ALU_GEN:
         begin
            case (i_p2_subopcode2_r) 
             SO16_SUB_REG, SO16_AND,   SO16_OR, 
             SO16_BIC,     SO16_XOR,   SO16_TST, 
             SO16_MUL64,   SO16_SEXB,  SO16_SEXW,
             SO16_EXTB,    SO16_EXTW,  SO16_ABS, 
             SO16_NOT,     SO16_NEG,   SO16_ADD1, 
             SO16_ADD2,    SO16_ADD3,  SO16_ASL_M, 
             SO16_LSR_M,   SO16_ASR_M, SO16_ASL_1, 
             SO16_ASR_1,   SO16_LSR_1:
               begin
                 i_p2_s2_en_decode_a = 1'b 1;   
               end
             SO16_SOP:
               begin
                 case (i_p2_c_field16_r) 
                  SO16_SOP_SUB, SO16_SOP_J, 
                  SO16_SOP_JD, SO16_SOP_JL, 
                  SO16_SOP_JLD:
                    begin
                      i_p2_s2_en_decode_a = 1'b 1;   
                    end
                  SO16_SOP_ZOP:
                    begin
                      case (i_p2_b_field16_r) 
                        SO16_ZOP_JEQ, SO16_ZOP_JNE, 
                        SO16_ZOP_J,   SO16_ZOP_JD:
                         begin
                           i_p2_s2_en_decode_a = 1'b 1;   
                         end
                        default:
                         begin
                           i_p2_s2_en_decode_a = 1'b 0;   
                         end
                      endcase
                    end
                  default:
                    begin
                      i_p2_s2_en_decode_a = 1'b 0;   
                    end
                 endcase
               end
             default:
               begin
                 i_p2_s2_en_decode_a = 1'b 0;   
               end
            endcase
         end
        OP_16_ST_U7, 
           OP_16_STB_U5, 
           OP_16_STW_U6:
            begin
               i_p2_s2_en_decode_a = 1'b 1;   
            end
        OP_16_SP_REL:
         begin
            case (i_p2_subopcode3_r) 
             SO16_ST_SP, SO16_STB_SP, SO16_PUSH_U7:
               begin
                 i_p2_s2_en_decode_a = 1'b 1;   
               end
             default:
               begin
                 i_p2_s2_en_decode_a = 1'b 0;   
               end
            endcase
         end
        default:
         begin
            i_p2_s2_en_decode_a = 1'b 0;   
         end
      endcase
    end // block: s2en_decode_PROC

   // Final source 2 address validation
   // 
   assign i_p2_source2_en_a = i_p2_iv_r           & 
                             (i_p2_s2_en_decode_a | 
                              (x_idop_decode2     | 
                               x_isop_decode2)    & 
                               (~x_p2shimm_a) & XT_ALUOP); 



//------------------------------------------------------------------------------
// Stage 2 Destination field
//------------------------------------------------------------------------------

   // [0] Blink Register
   //
   assign i_p2_dest_sel0_a = ((i_p2_iv_r == 1'b 1) & 
                              ((i_p2_opcode_16_sp_rel_a == 1'b 1) & 
                               (i_p2_subop_16_pop_u7_a == 1'b 1) & 
                               (i_p2_iw_r[SP_MODE_1] == 1'b 1) & 
                               (i_p2_iw_r[SP_MODE_2] == 1'b 1) | 
                               (i_p2_jblcc_niv_a == 1'b 1))) ? 1'b 1 : 
          1'b 0; 

  
   // [1] Ilink1 Register
   //
   assign i_p2_dest_sel1_a = p2int & p2ilev1; 

   //  [2]  Ilink2 Register
   // 
   assign i_p2_dest_sel2_a = p2int & ~p2ilev1; 

   //  [3] RLIMM Register : 16-bit NOP
   // 
   assign i_p2_dest_sel3_a = ((i_p2_iv_r == 1'b 1) & 
                              ((i_p2_16_sop_inst_a == 1'b 1) & 
                               (i_p2_c_field16_zop_a == 1'b 1) &
                               (i_p2_b_field16_r == SO16_ZOP_NOP))) ?   1'b 1 : 
          1'b 0; 

   //  [4] Rstackptr Register : 16-bit SP relative instructions, else
   //   
   assign i_p2_dest_sel4_a = ((i_p2_iv_r == 1'b 1) & 
                              ((i_p2_opcode_16_sp_rel_a == 1'b 1) & 
                               ((i_p2_subopcode3_r == SO16_SUB_SP) | 
                                (i_p2_subop_16_push_u7_a == 1'b 1)))) ?
          1'b 1 : 
          1'b 0; 

   //  [5] R0 Register : 16-bit GP relative opcode
   //                          
   assign i_p2_dest_sel5_a = ((i_p2_iv_r == 1'b 1) &
                              (i_p2_opcode_16_gp_rel_a == 1'b 1)) ? 1'b 1 : 
          1'b 0; 

   //  [6] B field   : LD/ST, MOV, and most 16-bit instructions
   // 
   assign i_p2_dest_sel6_a = ((i_p2_iv_r == 1'b 1) & 
                       ((x_p2_bfield_wb_a == 1'b 1) 
                        | 
                        (i_p2_opcode_32_st_a == 1'b 1) 
                        | 
                        ((i_p2_opcode_32_fmt1_a == 1'b 1) & 
                        ((i_p2_subopcode_mov_a == 1'b 1) | 
                         (i_p2_subopcode_sop_a == 1'b 1) | 
                         (i_p2_subopcode_lr_a == 1'b 1))) 
                        | 
                        ((i_p2_no_ld_a == 1'b 1) & 
                        (i_p2_jlcc_a == 1'b 0) & 
                        ((i_p2_fmt_s12_a == 1'b 1) | 
                         (i_p2_fmt_cond_reg_dec_a == 1'b 1)))
                        |
                        (((i_p2_opcode_16_mv_add_a == 1'b 1) & 
                         (i_p2_subop_16_mov_hi2_a == 1'b 0)) 
                        | 
                        (i_p2_opcode_16_alu_a == 1'b 1) 
                        | 
                        (i_p2_opcode_16_ld_pc_a == 1'b 1) 
                        | 
                        ((i_p2_opcode_16_ssub_a == 1'b 1) & 
                         (i_p2_subop_16_btst_u5_a == 1'b 0))
                        | 
                        (i_p2_opcode_16_mov_a == 1'b 1) 
                        | 
                        ((i_p2_opcode_16_addcmp_a == 1'b 1) & 
                         (i_p2_subopcode4_r == SO16_ADD_U7))
                        | 
                        (i_p2_opcode_16_sp_rel_a == 1'b 1) & 
                        ((i_p2_subopcode3_r == SO16_LD_SP) | 
                         (i_p2_subopcode3_r == SO16_LDB_SP) | 
                         (i_p2_subopcode3_r == SO16_ST_SP) | 
                         (i_p2_subopcode3_r == SO16_STB_SP) | 
                         (i_p2_subopcode3_r == SO16_ADD_SP) | 
                         ((i_p2_subop_16_pop_u7_a == 1'b 1) & 
                          (i_p2_iw_r[SP_MODE_2] == 1'b 0)) | 
                         ((i_p2_subop_16_push_u7_a == 1'b 1) & 
                          (i_p2_iw_r[SP_MODE_2] == 1'b 0)))))) ? 1'b 1 : 
          1'b 0; 

   //  [7] H field   : 16-bit MOV/ADD opcode
   // 
   assign i_p2_dest_sel7_a = ((i_p2_iv_r == 1'b 1) &
                       (i_p2_opcode_16_mv_add_a == 1'b 1) & 
                       (i_p2_subop_16_mov_hi2_a == 1'b 1)) ?  1'b 1 : 
          1'b 0; 

   //  [8] A field   : 16-bit LD/ADD opcode
   //          
   assign i_p2_dest_sel8_a = ((i_p2_iv_r == 1'b 1) & 
                       (i_p2_opcode_16_ld_add_a == 1'b 1)) ? 1'b 1 : 
          1'b 0; 

   //  [9] C field   : 16-bit ARITH opcode or 
   //                  16-bit LD/ST with offset instructions
   // 
   assign i_p2_dest_sel9_a = ((i_p2_iv_r == 1'b 1) &
                              ((i_p2_opcode_16_arith_a == 1'b 1) | 
                               (i_p2_ldo16_a == 1'b 1)           | 
                               (i_p2_sto16_a == 1'b 1))) ? 1'b 1 : 
          1'b 0; 

   //  [10] A field
   // 
   assign i_p2_dest_sel10_a = (~(i_p2_dest_sel0_a    |
                                i_p2_dest_sel1_a    | 
                                i_p2_dest_sel2_a    |
                                i_p2_dest_sel3_a    | 
                                i_p2_dest_sel4_a    |
                                i_p2_dest_sel5_a    | 
                                i_p2_dest_sel6_a    |
                                i_p2_dest_sel7_a    | 
                                i_p2_dest_sel8_a    |
                                i_p2_dest_sel9_a)); 


   // Select the correct destination address for the instruction.
   // The destination may be implied by the instruction or explicitly defined
   // within the instruction word.
   //
   assign i_p2_destination_a = (RBLINK & ({(OPERAND_WIDTH){i_p2_dest_sel0_a}}) |
                        
                      RILINK1 & ({(OPERAND_WIDTH){i_p2_dest_sel1_a}}) |
                        
                      RILINK2 & ({(OPERAND_WIDTH){i_p2_dest_sel2_a}}) |
                        
                      RLIMM & ({(OPERAND_WIDTH){i_p2_dest_sel3_a}}) |
                        
                      RSTACKPTR & ({(OPERAND_WIDTH){i_p2_dest_sel4_a}}) |
                        
                      r0 & ({(OPERAND_WIDTH){i_p2_dest_sel5_a}}) |
                        
                      i_p2_b_field_r & ({(OPERAND_WIDTH){i_p2_dest_sel6_a}}) |
                        
                      i_p2_hi_reg16_r & ({(OPERAND_WIDTH){i_p2_dest_sel7_a}}) |
                         
                      i_p2_a_field16_r & ({(OPERAND_WIDTH){i_p2_dest_sel8_a}}) |
                        
                      i_p2_c_field16_2_r & ({(OPERAND_WIDTH){i_p2_dest_sel9_a}}) |
                        
                      i_p2_a_field_r & ({(OPERAND_WIDTH){i_p2_dest_sel10_a}})); 
         
   // Null destination select
   //               
   assign i_p2_dest_immediate_a = ((i_p2_c_field_long_imm_a &
                                    i_p2_dest_sel9_a) 
                           | 
                           (i_p2_hi_reg16_long_imm_a & i_p2_dest_sel7_a) 
                           | 
                           (i_p2_b_field_long_imm_a & i_p2_dest_sel6_a) 
                           | 
                           (i_p2_a_field_long_imm_a & i_p2_dest_sel10_a)
                           | 
                           i_p2_dest_sel3_a); 

//------------------------------------------------------------------------------
// Stage 2 destination address field validation
//------------------------------------------------------------------------------
//
   // This signal is set true when the current instruction in stage 2 has a
   // destination. This implies that the destination address field is correct
   // and should be used to write back to if allowed.
   //
   assign i_p2_destination_en_a = ((i_p2_iv_r & 
                                   (f_desten(i_p2_opcode_a,
                                             i_p2_subopcode_r, 
                                             i_p2_subopcode2_r, 
                                             i_p2_subopcode3_r, 
                                             i_p2_iw_r[ST_AWB_UBND:
                                                       ST_AWB_LBND], 
                                             i_p2_a_field_r, 
                                             i_p2_c_field16_r) | 
                                    i_p2_dest_sel0_a 
                                    | 
                                    (x_idecode2 & 
                                     XT_ALUOP & 
                                     (~xp2idest)))) 
                                    | 
                                    i_p2_dest_sel1_a 
                                    | 
                                    i_p2_dest_sel2_a); 

//------------------------------------------------------------------------------
// Stage 2 Long Immediate Data
//------------------------------------------------------------------------------
//
// Generate signals for pipeline control and interrupt control units.
//
   // p2limm - this will be true when a valid instruction which uses long
   // immediate data is in stage 2. Note that this signal will include
   // p2iv as it includes s1en/s2en.
   //
   assign i_p2_long_immediate_a = ((i_p2_long_immediate1_a &
                                    i_p2_source1_en_a)
                                   | 
                                   (i_p2_long_immediate2_a &
                                    i_p2_source2_en_a));

   assign i_p2_limm_a = i_p2_long_immediate_a | i_p2_tag_nxt_p1_limm_r; 

   // The signal i_p2_dest_imm_a is true when the destination register
   // contains an immediate value.
   //
   assign i_p2_dest_imm_a = i_p2_dest_immediate_a & i_p2_destination_en_a; 

   // This signal is true when the instruction in stage 2 has a long immediate
   // and the instruction will move into stage 2b.  The signal is cleared when
   // instruction with the LIMM leaves stage 2b.  The instruction can leave
   // stage 2b either by normal instruction flow or by the instruction being
   // killed. This can This signal is registers to become i_p2b_has_limm_r.
   // 
   assign i_p2b_has_limm_nxt = ((i_p4_kill_p2b_a           == 1'b 1) | 
                                (i_p2b_has_limm_r          == 1'b 1) & 
                                (i_p2b_en_nopwr_save_a == 1'b 1)) ? 
          1'b 0 :
                               ((i_p2_long_immediate_a == 1'b 1) & 
                                (i_p2_enable_a         == 1'b 1) & 
                                (i_p2_iv_r             == 1'b 1) & 
                                (i_kill_p2_en_a        == 1'b 0)) ?
          1'b 1 : 
          i_p2b_has_limm_r; 
   
   // This signal is true when the instruction in stage 2 has decoded that it
   // has long immediate data, however the data has not yet arrived in stage 1.
   //  The signal denotes that the next longword to arrive from the cache will
   // be long immediate data.
   //
   assign i_p2_tag_nxt_p1_limm_nxt = ((i_p4_kill_p2b_a         == 1'b 1) |
                                      ((i_p2_tag_nxt_p1_limm_r == 1'b 1) &
                                       (i_p1_enable_a          == 1'b 1))) ?
          1'b 0 : 
                                     ((i_p2_long_immediate_a == 1'b 1) & 
                                      (i_p2_enable_a         == 1'b 1) & 
                                      (i_p2_iv_r             == 1'b 1) & 
                                      (i_kill_p2_en_a        == 1'b 0) & 
                                      (ivalid_aligned        == 1'b 0)) ?
          1'b 1 : 
          i_p2_tag_nxt_p1_limm_r; 

   // This signal indicates that the longword currently in stage 2 is long
   // immediate data. This signal includes the decoding for when an instruction
   // and its long immediate data is separated.
   //
   assign i_p2_is_limm_nxt = ((i_kill_p2_en_a            == 1'b 1) | 
                              (i_p2_is_limm_r            == 1'b 1) & 
                              (i_p2_en_no_pwr_save_a     == 1'b 1)) ? 
          1'b 0 : 
                             (((i_p2_tag_nxt_p1_limm_r    == 1'b 1) & 
                              (i_p1_enable_a             == 1'b 1))
                                | 
                             ((i_p2_long_immediate_a == 1'b 1) & 
                              (i_p2_enable_a         == 1'b 1) & 
                              (i_p2_iv_r             == 1'b 1) & 
                              (i_kill_p2_en_a        == 1'b 0) & 
                              (i_p1_enable_a         == 1'b 1))) ?
          1'b 1 : 
          i_p2_is_limm_r; 

  
   // This signal is used to tag the next longword to be returned from the cache
   // as one that should be killed. This is true under the following conditions:
   //
   // (1) If the instruction that has tagged the next longword out of the cache
   //     as long immediate data is killed by a compare&branch
   // (2) The instruction in stage 2 is to be killed that requires a LIMM,
   //     however it is not available in stage 1
   // (3) A branch or predicted compare&branch that has no delay slot is being
   //     taken and there is a fetch outstanding. The longword being fetched
   //     needs to be killed
   // (4) An interrupt has arrived in stage 2 and will do a delayed PC update.
   //     The longword that is currently being fetch requires killing.
   // (5) A jump is to be taken in stage 2b and either it has no delay slot or
   //     it's delay slot is in stage 2 and the current fetch has not completed.
   // (6) A compare&branch is to be taken in stage 4 and the current fetch has
   //     not completed
   //
   assign i_tag_nxt_p1_killed_nxt = (((i_p2_tag_nxt_p1_limm_r == 1'b 1) &
                               (i_p1_enable_a == 1'b 0) &
                               (i_p4_kill_p2b_a == 1'b 1))
                              | 
                              ((i_p2_long_immediate_a == 1'b 1) & 
                               (i_p2_enable_a == 1'b 1) & 
                               (i_p2_iv_r == 1'b 1) & 
                               (i_kill_p2_en_a == 1'b 1) & 
                               (ivalid_aligned == 1'b 0))
                              | 
                              ((i_p2_dorel_a | 
                                (i_p2b_brcc_pred_nxt) == 1'b 1) & 
                               (i_p2_enable_a == 1'b 1) & 
                               (i_p2_iv_r == 1'b 1) & 
                               (i_p2_has_dslot_a == 1'b 0) & 
                               (ivalid_aligned == 1'b 0)) 
                              | 
                              ((p2int == 1'b 1) & 
                               (i_p2_enable_a == 1'b 1) & 
                               (ivalid_aligned == 1'b 0))
                              | 
                               ((i_p2b_dojcc_a == 1'b 1) & 
                                (i_p2b_enable_a == 1'b 1) & 
                                (i_p2b_iv_r == 1'b 1) & 
                                ((i_p2b_has_dslot_r == 1'b 0) & 
                                 (ivalid_aligned == 1'b 0) | 
                                 (i_p2b_has_dslot_r == 1'b 1) & 
                                 (i_p2_iv_r == 1'b 1) & 
                                 (ivalid_aligned == 1'b 0)))
                              | 
                              ((i_p4_docmprel_a == 1'b 1) & 
                               (i_p4_has_dslot_r == 1'b 0) & 
                               (ivalid_aligned == 1'b 0))
                              | 
                              ((i_p4_docmprel_a == 1'b 1) & 
                               (i_p4_has_dslot_r == 1'b 1) & 
                               ((i_p3_iv_r == 1'b 1) | 
                                (i_p2b_iv_r == 1'b 1) | 
                                (i_p2_iv_r == 1'b 1)) & 
                               (ivalid_aligned == 1'b 0))) ? 
          1'b 1 : 
                              ((i_tag_nxt_p1_killed_r == 1'b 1) & 
                               (i_ifetch_aligned_a == 1'b 1)) ?
          1'b 0 : 
          i_tag_nxt_p1_killed_r; 

   // This signal is true when the instruction in stage 2 has decoded that it
   // has a delay slot, however the delay-slot instruction has not yet arrived
   // in stage 1. The signal denotes that the next longword to arrive from the
   // cache will be a delay slot instruction.
   //
   assign i_p2_tag_nxt_p1_dslot_nxt = ((i_p4_kill_p2b_a         == 1'b 1) | 
                                       (i_p2_tag_nxt_p1_dslot_r == 1'b 1) & 
                                       (i_p1_enable_a           == 1'b 1)) ?
          1'b 0 : 
                                      ((i_p2_has_dslot_a == 1'b 1) & 
                                       (i_p2_enable_a    == 1'b 1) & 
                                       (i_p2_iv_r        == 1'b 1) & 
                                       (i_kill_p2_en_a   == 1'b 0) & 
                                       (ivalid_aligned   == 1'b 0)) ?
          1'b 1 : 
          i_p2_tag_nxt_p1_dslot_r; 

   // This signal is set to true when the instruction in stage 2 has a delay
   // slot and the instruction will move to stage 2b.
   //
   assign i_p2b_has_dslot_nxt = ((i_p4_kill_p2b_a           == 1'b 1) | 
                                 (i_p2b_has_dslot_r         == 1'b 1) & 
                                 (i_p2b_en_nopwr_save_a == 1'b 1)) ? 
          1'b 0 : 
                                ((i_p2_has_dslot_a == 1'b 1) & 
                                 (i_p2_enable_a    == 1'b 1) & 
                                 (i_p2_iv_r        == 1'b 1) & 
                                 (i_kill_p2_en_a   == 1'b 0)) ?
          1'b 1 : 
          i_p2b_has_dslot_r; 

   // This signal is set to true when either:
   //
   // (1) The longword to arrive in stage 1 had been tagged as a delay slot, or
   // (2) The instruction in stage 2 has a delay slot and it will move to stage
   //     2b and the delays slot i in stage 1 and will move to stage 2.
   //
   assign i_p2_is_dslot_nxt =  (i_kill_p2_en_a == 1'b 1) 
                               | 
                               ((i_p2_is_dslot_r == 1'b 1) & 
                                (i_p2_enable_a   == 1'b 1)) ? 
          1'b 0 : 
                               ((i_p2_tag_nxt_p1_dslot_r == 1'b 1) & 
                                (i_p1_enable_a           == 1'b 1))
                               | 
                               ((i_p2_has_dslot_a == 1'b 1) & 
                                (i_p2_enable_a    == 1'b 1) & 
                                (i_p2_iv_r        == 1'b 1) & 
                                (i_kill_p2_en_a   == 1'b 0) & 
                                (i_p1_enable_a    == 1'b 1))  ?
          1'b 1 : 
          i_p2_is_dslot_r; 


//------------------------------------------------------------------------------
// Stall Due to Limm/Delay Slot
//------------------------------------------------------------------------------
//
   // This stall will stop any instruction that has a LIMM or delay slot from
   // moving past stage 2b until the child data has caught up with the parent
   // instruction.
   //
   assign i_p2b_limm_dslot_stall_nxt =  ((i_p2b_has_limm_nxt == 1'b 1) & 
                                         (i_p2b_iv_nxt       == 1'b 1) & 
                                         (i_p2_is_limm_nxt   == 1'b 0))
                                        | 
                                        ((i_p2b_has_dslot_nxt == 1'b 1) & 
                                         (i_p2b_iv_nxt        == 1'b 1) & 
                                         (i_p2_is_dslot_nxt   == 1'b 0))  ?
          1'b 1 : 
          1'b 0; 

   always @(posedge clk or posedge rst_a)
    begin : stall_p2_sync_PROC
      if (rst_a == 1'b 1)
        begin
          i_p2_is_dslot_r          <= 1'b 0;   
          i_p2_is_limm_r           <= 1'b 0;   
          i_p2_tag_nxt_p1_dslot_r  <= 1'b 0;   
          i_p2_tag_nxt_p1_limm_r   <= 1'b 0;   
          i_p2b_has_dslot_r        <= 1'b 0;   
          i_p2b_has_limm_r         <= 1'b 0;   
          i_tag_nxt_p1_killed_r    <= 1'b 0;   
          i_p2b_limm_dslot_stall_r <= 1'b 0;   
        end
      else
        begin
          i_p2_is_limm_r           <= i_p2_is_limm_nxt;   
          i_p2_tag_nxt_p1_limm_r   <= i_p2_tag_nxt_p1_limm_nxt;   
          i_p2b_has_limm_r         <= i_p2b_has_limm_nxt;   
          i_tag_nxt_p1_killed_r    <= i_tag_nxt_p1_killed_nxt;   
          i_p2_is_dslot_r          <= i_p2_is_dslot_nxt;   
          i_p2_tag_nxt_p1_dslot_r  <= i_p2_tag_nxt_p1_dslot_nxt;   
          i_p2b_has_dslot_r        <= i_p2b_has_dslot_nxt;   
          i_p2b_limm_dslot_stall_r <= i_p2b_limm_dslot_stall_nxt;   
        end
    end 
   
  
//------------------------------------------------------------------------------
// Offset selection for branches / compare & branches
//------------------------------------------------------------------------------
  

   // Branch offset
   //
   assign i_p2_b_offset_a = ((i_p2_iw_r[MINOR_OP_LBND] == 1'b 1) ? 
                      {i_p2_iw_r[TARG_BL_MSB_UBND:TARG_BL_MSB_LBND], 
                       i_p2_iw_r[TARG_BL_MID_UBND:TARG_BL_MID_LBND], 
                       i_p2_iw_r[TARG_BL_LSB_UBND:TARG_BL_LSB_LBND], 
                       i_p2_iw_r[TARG_B_LSB_POS]} : 
                      {{(FOUR){i_p2_iw_r[TARG_BL_MID_UBND]}}, 
                       i_p2_iw_r[TARG_BL_MID_UBND:TARG_BL_MID_LBND], 
                       i_p2_iw_r[TARG_BL_LSB_UBND:TARG_BL_LSB_LBND], 
                       i_p2_iw_r[TARG_B_LSB_POS]});


   // Branch and link offset
   //
   assign i_p2_bl_offset_a = ((i_p2_iw_r[MINOR_OP_LBND + 1] == 1'b 1) ? 
                       {i_p2_iw_r[TARG_BL_MSB_UBND:TARG_BL_MSB_LBND], 
                        i_p2_iw_r[TARG_BL_MID_UBND:TARG_BL_MID_LBND], 
                        i_p2_iw_r[TARG_BL_LSB_UBND:TARG_BL_LSB_LBND],
                        ONE_ZERO} :
                       {{(FOUR){i_p2_iw_r[TARG_BL_MID_UBND]}}, 
                        i_p2_iw_r[TARG_BL_MID_UBND:TARG_BL_MID_LBND], 
                        i_p2_iw_r[TARG_BL_LSB_UBND:TARG_BL_LSB_LBND],
                        ONE_ZERO});
   
   // Compare and branch offset
   //
   assign i_p2_br_offset_a = {{(SEVENTEEN){i_p2_iw_r[TARG_BR_MSB_POS]}}, 
                       i_p2_iw_r[TARG_BR_LSB_UBND:TARG_BR_LSB_LBND]}; 

   // Loop offset
   //
   assign i_p2_lp_offset_a = ((i_p2_fmt_s12_a == 1'b 1) ? 
                       {{(TWELVE){i_p2_iw_r[AOP_UBND]}}, 
                        i_p2_iw_r[AOP_UBND:AOP_LBND], 
                        i_p2_iw_r[COP_UBND:COP_LBND]} : 
                       {{(EIGHTEEN){1'b 0}}, i_p2_iw_r[COP_UBND:COP_LBND]});


   // Select the correct offset for the current instruction
   //
   assign i_p2_offset_a =
                  ((i_p2_b_offset_a & 
                    ({(TARGET_WIDTH){i_p2_opcode_32_bcc_a}}))       | 
                   (i_p2_br_offset_a &
                    ({(TARGET_WIDTH){i_p2b_br_or_bbit32_nxt}}))     | 
                   (i_p2_lp_offset_a &
                    ({(TARGET_WIDTH){i_p2_loop32_a}}))              | 
                   ({{(SEVENTEEN){i_p2_iw_r[SHIMM16_S8_UBND]}}, 
                    i_p2_iw_r[SHIMM16_S8_UBND:SHIMM16_S8_LBND]} &
                    ({(TARGET_WIDTH){i_p2_opcode_16_brcc_a}}))      | 
                   ({{(TWELVE){i_p2_iw_r[SHIMM16_S13_UBND]}}, 
                    i_p2_iw_r[SHIMM16_S13_UBND:SHIMM16_S13_LBND], 
                    ONE_ZERO} &
                    ({(TARGET_WIDTH){i_p2_opcode_16_bl_a}}))        |
                   ({{(FIFTEEN){i_p2_iw_r[SHIMM16_S10_UBND]}},
                    i_p2_iw_r[SHIMM16_S10_UBND:SHIMM16_S10_LBND]} &
                    ({(TARGET_WIDTH){i_p2_opcode_16_bcc_cc_a}}))    | 
                   ({{(EIGHTEEN){i_p2_iw_r[SHIMM16_S7_UBND]}},                   
                    i_p2_iw_r[SHIMM16_S7_UBND:SHIMM16_S7_LBND]} &
                    ({(TARGET_WIDTH){i_p2_opc_16_bcc_cc_s7_a}})) |
                   (i_p2_bl_offset_a &
                    ({(TARGET_WIDTH){i_p2_bl_blcc_32_a}})));

//------------------------------------------------------------------------------
// Short immediate (Shimm) field selction
//------------------------------------------------------------------------------
//
// The short immediate data for 16-bit instructions is defined as follows:
//
   // Unsigned 7-bit data
   //        
   assign i_p2_shimm16_data_sel0_a = ((i_p2_opcode_a == OP_16_LD_U7) 
                             | 
                             (i_p2_opcode_a == OP_16_ST_U7) 
                             | 
                             ((i_p2_opcode_16_sp_rel_a == 1'b 1) & 
                              (i_p2_subop_16_pop_u7_a == 1'b 0) & 
                              (i_p2_subop_16_push_u7_a == 1'b 0))) ?
          1'b 1 :
          1'b 0; 

   // Unsigned 5-bit data
   //
   assign i_p2_shimm16_data_sel1_a = ((i_p2_opcode_a == OP_16_LDB_U5) | 
                             (i_p2_opcode_a == OP_16_STB_U5)) ?  1'b 1 : 
          1'b 0; 

   // Unsigned 6-bit data
   //
   assign i_p2_shimm16_data_sel2_a = ((i_p2_opcode_a == OP_16_LDW_U6) | 
                             (i_p2_opcode_a == OP_16_LDWX_U6) | 
                             (i_p2_opcode_a == OP_16_STW_U6)) ? 1'b 1 : 
          1'b 0; 
 
   // Longword aligned Signed 9-bit data
   //
   assign i_p2_shimm16_data_sel3_a = ((i_p2_opcode_16_gp_rel_a == 1'b 1) & 
                             ((i_p2_subopcode7_r == SO16_LD_GP) | 
                              (i_p2_subopcode7_r == SO16_ADD_GP))) ?   1'b 1 : 
          1'b 0; 

   // Byte aligned signed 9-bit data
   //
   assign i_p2_shimm16_data_sel4_a = ((i_p2_opcode_16_gp_rel_a == 1'b 1) & 
                             (i_p2_subop_16_ldb_gp_a == 1'b 1)) ? 1'b 1 : 
          1'b 0; 

   // Word aligned signed 9-bit data
   //
   assign i_p2_shimm16_data_sel5_a = ((i_p2_opcode_16_gp_rel_a == 1'b 1) & 
                                      (i_p2_subop_16_ldw_gp_a == 1'b 1)) ?
          1'b 1 : 
          1'b 0; 

   // Long word aligned signed 13-bit data
   //
   assign i_p2_shimm16_data_sel6_a = (~(i_p2_opcode_16_arith_a   | 
                                       i_p2_opcode_16_ssub_a    | 
                                       i_p2_shimm16_data_sel0_a | 
                                       i_p2_push_decode_a       | 
                                       i_p2_pop_decode_a        | 
                                       i_p2_opcode_16_brcc_a    | 
                                       i_p2_shimm16_data_sel1_a | 
                                       i_p2_shimm16_data_sel2_a | 
                                       i_p2_shimm16_data_sel3_a | 
                                       i_p2_shimm16_data_sel4_a | 
                                       i_p2_opcode_16_ld_pc_a   | 
                                       i_p2_opcode_16_mov_a     | 
                                       i_p2_opcode_16_addcmp_a  | 
                                       i_p2_shimm16_data_sel5_a)); 

  
   // Select the correct short immediate data for 16-bit instructions
   //
   assign i_p2_shimm16_data_a = (({TEN_ZERO, 
                           i_p2_iw_r[SHIMM16_U3_UBND:
                                  SHIMM16_U3_LBND]} & 
                          ({SHIMM_WIDTH{i_p2_opcode_16_arith_a}}))
                         |  
                         ({EIGHT_ZERO,
                           i_p2_iw_r[SHIMM16_U5_UBND:
                                  SHIMM16_U5_LBND]} &
                          ({SHIMM_WIDTH{i_p2_opcode_16_ssub_a}}))
                         |
                           ({SIX_ZERO,
                           i_p2_iw_r[SHIMM16_U5_UBND:
                                  SHIMM16_U5_LBND],
                           TWO_ZERO} &
                          ({SHIMM_WIDTH{i_p2_shimm16_data_sel0_a}}))
                         |     
                         (PLUS_4 & 
                          ({SHIMM_WIDTH{i_p2_pop_decode_a}})) 
                         |                                            
                         (MINUS_4 &
                          ({SHIMM_WIDTH{i_p2_push_decode_a}}))
                         |                                            
                         (THIRTEEN_ZERO &
                          ({SHIMM_WIDTH{i_p2_opcode_16_brcc_a}})) 
                         |
                                 ({EIGHT_ZERO,
                           i_p2_iw_r[SHIMM16_U5_UBND:
                                  SHIMM16_U5_LBND]} &
                          ({SHIMM_WIDTH{i_p2_shimm16_data_sel1_a}}))
                         |
                                 ({SEVEN_ZERO,
                           i_p2_iw_r[SHIMM16_U5_UBND:
                                  SHIMM16_U5_LBND],ONE_ZERO} & 
                          ({SHIMM_WIDTH{i_p2_shimm16_data_sel2_a}}))
                         |
                                 ({{(TWO){i_p2_iw_r[SHIMM16_S9_UBND]}},                            
                           i_p2_iw_r[SHIMM16_S9_UBND:SHIMM16_S9_LBND], 
                           TWO_ZERO} & 
                          ({SHIMM_WIDTH{i_p2_shimm16_data_sel3_a}}))
                         |
                                 ({{(FOUR){i_p2_iw_r[SHIMM16_S9_UBND]}},
                           i_p2_iw_r[SHIMM16_S9_UBND: SHIMM16_S9_LBND]} &
                          ({SHIMM_WIDTH{i_p2_shimm16_data_sel4_a}}))
                         |
                                 ({THREE_ZERO,
                           i_p2_iw_r[SHIMM16_U10_UBND: 
                                  SHIMM16_U10_LBND],TWO_ZERO} &
                          ({SHIMM_WIDTH{i_p2_opcode_16_ld_pc_a}}))
                         |
                                 ({FIVE_ZERO,                            
                           i_p2_iw_r[SHIMM16_U10_UBND:
                                  SHIMM16_U10_LBND]} & 
                          ({SHIMM_WIDTH{i_p2_opcode_16_mov_a}}))
                         |
                                 ({SIX_ZERO,
                           i_p2_iw_r[SHIMM16_U7_UBND:
                                  SHIMM16_U7_LBND]} & 
                          ({SHIMM_WIDTH{i_p2_opcode_16_addcmp_a}}) )
                         |
                                 ({{(THREE){i_p2_iw_r[SHIMM16_S9_UBND]}},                           
                           i_p2_iw_r[SHIMM16_S9_UBND:
                                  SHIMM16_S9_LBND],
                           ONE_ZERO} & 
                          ({SHIMM_WIDTH{i_p2_shimm16_data_sel5_a}})) 
                         |
                                 ({i_p2_iw_r[SHIMM16_S13_UBND:
                                  SHIMM16_S13_LBND], 
                           TWO_ZERO} & 
                          ({SHIMM_WIDTH{i_p2_shimm16_data_sel6_a}}))); 
                     

   // 16-bit instruction short immmediate
   // 
   assign i_p2_short_imm_sel0_a = i_p2_shimm16_a; 

   // 32-bit ld/st instruction short immediate.
   //   
   assign i_p2_short_imm_sel1_a = (i_p2_opcode_32_st_a | i_p2_opcode_32_ld_a); 

   // 32-bit extension and compare&branch instruction short immediate
   //
   assign i_p2_short_imm_sel2_a =
                           ((((i_p2_opcode_32_fmt1_a == 1'b 1) | 
                              ((x_idecode2 == 1'b 1) & 
                               (i_p2_opcode_16_ushimm_shft_a == 1'b 0))) & 
                             ((i_p2_fmt_u6_a == 1'b 1)         | 
                              (i_p2_fmt_cond_reg_u6_a == 1'b 1))) | 
                            ((i_p2b_br_or_bbit32_nxt == 1'b 1) & 
                             (i_p2_iw_r[OPCODE_MSB] == BR_FMT_U6))) ?
          1'b 1 : 
          1'b 0; 


   // Signed 12-bit short immediate data.
   //
   assign i_p2_short_imm_sel3_a = (~(i_p2_short_imm_sel0_a | 
                                    i_p2_short_imm_sel1_a | 
                                    i_p2_short_imm_sel2_a)); 


   // Select the correct short immediate field for uses by the instruction
   // 
   assign i_p2_short_immediate_a = ((i_p2_shimm16_data_a &
                                     {SHIMM_WIDTH{i_p2_short_imm_sel0_a}})
                           |
                           ({{(FIVE){i_p2_iw_r[SHIMM32_S8_MSB_POS]}},
                             i_p2_iw_r[SHIMM32_S8_LSB_UBND:
                                    SHIMM32_S8_LSB_LBND]} &
                            ({SHIMM_WIDTH{i_p2_short_imm_sel1_a}})) 
                           |
                           ({SEVEN_ZERO,
                             i_p2_iw_r[SHIMM32_U6_UBND:
                                    SHIMM32_U6_LBND]} & 
                            ({SHIMM_WIDTH{i_p2_short_imm_sel2_a}}))
                           |      
                           ({i_p2_iw_r[SHIMM32_S12_MSB_UBND], 
                             i_p2_iw_r[SHIMM32_S12_MSB_UBND:
                                    SHIMM32_S12_MSB_LBND], 
                             i_p2_iw_r[SHIMM32_S12_LSB_UBND:
                                    SHIMM32_S12_LSB_LBND]} & 
                            ({SHIMM_WIDTH{i_p2_short_imm_sel3_a}}))); 


//------------------------------------------------------------------------------
// Stage 2 Short Immediate (32-bit)
//------------------------------------------------------------------------------
//
// Now produce signals which indicate whether a short-immediate field
// is present at the bottom of the instruction
//

   // Unsigned short immediate date for 32-bit instructions is set for
   // basecase ALU instructions (opcode = 0x4) and branch & link
   // instructions.
   //
   assign i_p2_ushimm32_a = ((i_p2_br32_u6_a          == 1'b 1) | 
                             (i_p2_no_ld_and_rev_a    == 1'b 1) & 
                             ((i_p2_fmt_cond_reg_u6_a == 1'b 1) | 
                              (i_p2_fmt_u6_a          == 1'b 1))) ?
          1'b 1 : 
          1'b 0;

   // Signed short immediate date for 32-bit instructions is set for
   // basecase ALU instructions (opcode = 0x4) not including reverse
   // arithmetic operations and LD/ST instructions (opcode = 0x2/0x3).
   //
   assign i_p2_sshimm32_a = ((i_p2_opcode_32_ld_a == 1'b 1) 
                            | 
                            (i_p2_opcode_32_st_a == 1'b 1) 
                            | 
                            ((i_p2_no_ld_and_rev_a == 1'b 1) & 
                             (i_p2_fmt_s12_a == 1'b 1))) ?
          1'b 1 : 
          1'b 0; 

   //  This signal is set to true when the instruction in stage two
   //  employs the source one operand with the short imeddiate data
   //  value.
   // 
   assign i_p2_rev_arith_a = (i_p2_opcode_32_fmt1_a & 
                              (i_p2_subopcode_mov_a | 
                               i_p2_subopcode_rsub_a | 
                               i_p2_subopcode_rcmp_a)); 

   //  Signed short immediate date for 32-bit instructions is set for
   //  basecase reverse arithmetic instructions (opcode = 0x4).
   // 
   assign i_p2_sshimm32_s1_a = i_p2_rev_arith_a & i_p2_fmt_s12_a; 

   assign i_p2_ushimm32_s1_a = i_p2_rev_arith_a & (i_p2_fmt_u6_a | 
                                                   i_p2_fmt_cond_reg_u6_a); 

//------------------------------------------------------------------------------
// Stage 2 Short Immediate (16-bit)
//------------------------------------------------------------------------------
//
   // Now produce signals which indicate whether a short-immediate field
   // is present at the bottom of the instruction, due to a 16-bit
   // instruction (i_p2_shimm16_a).
   //
   assign i_p2_shimm16_a = (i_p2_ushimm16_a | i_p2_sshimm16_a); 

   // This selects signed short immediates including branches that
   // are exclusively employed for generating target addresses in stage
   // two. This includes GP relative loads which use signed
   // short immediate data values.
   //
   assign i_p2_sshimm16_a = (i_p2_opcode_16_gp_rel_a | 
                      i_p2_bcc16_no_delay_a |
                      i_p2_br16_no_delay_a); 

   // Signed short immediate date for 32-bit instructions is set for
   // basecase reverse arithmetic instructions (opcode = 0x4).
   //
   assign i_p2_sshimm16_s1_a = i_p2_opcode_16_mov_a; 

   // This selects unsigned short immediates not including branches that
   // are exclusively employed for generating target addresses in stage
   // two so not necessary for stage three. This also does not include
   // GP relative loads which use signed short immediate data values.
   //
   assign i_p2_ushimm16_a = (i_p2_opcode_16_arith_a | 
                             i_p2_ldo16_a | 
                             i_p2_sto16_a | 
                             i_p2_opcode_16_ssub_a | 
                             i_p2_opcode_16_ld_pc_a | 
                             i_p2_opcode_16_sp_rel_a | 
                             i_p2_opcode_16_mov_a | 
                             i_p2_opcode_16_addcmp_a); 


//------------------------------------------------------------------------------
// All Stage 2 Short immediate combinations
//------------------------------------------------------------------------------
//
   assign i_p2_shimm_a = (i_p2_sshimm_a | i_p2_ushimm_a | x_p2shimm_a); 
   assign i_p2_shimm_s1_a = (i_p2_sshimm_s1_a | i_p2_ushimm_s1_a); 
   assign i_p2_sshimm_a = (i_p2_sshimm16_a | i_p2_sshimm32_a); 
   assign i_p2_sshimm_s1_a = (i_p2_sshimm16_s1_a | i_p2_sshimm32_s1_a); 
   assign i_p2_ushimm_a = (i_p2_ushimm16_a | i_p2_ushimm32_a); 
   assign i_p2_ushimm_s1_a = i_p2_ushimm32_s1_a; 

//------------------------------------------------------------------------------
// Stage 2 flag bit
//------------------------------------------------------------------------------
//
   assign i_p2_flag_bit_a = ((i_p2_swi_inst_niv_a == 1'b 1) | 
                             (i_p2_sleep_inst_niv_a == 1'b 1)) ? 1'b 0 : 
                             i_p2_iw_r[SETFLGPOS]; 

//------------------------------------------------------------------------------
// Stage 2 condition code field
//------------------------------------------------------------------------------
//  
   // Q field select for 16bit implied
   //
   assign i_p2_q_sel_16_a = (i_p2_16_sop_inst_a & 
                             i_p2_c_field16_sop_sub_a);

   // This signal is used by instructions in stage 2b,3 & 4.
   //
   assign i_p2_q_a = (({ONE_ZERO, CCNZ} &
                       ({CONDITION_CODE_WIDTH{i_p2_q_sel_16_a}}))
                      |
                      (i_p2_32_q_a &
                       ({CONDITION_CODE_WIDTH{~i_p2_q_sel_16_a}})));

   // Q field for 32-bit instructions.
   //
   assign i_p2_32_q_a = i_p2_iw_r[QQUBND:QQLBND];

   // Q field for 16-bit instructions.
   //
   assign i_p2_16_q_a = i_p2_iw_r[QQ16_UBND:QQ16_LBND]; 


//------------------------------------------------------------------------------
// Stage 2 Condition Codes evaluation
//------------------------------------------------------------------------------
//
// The condition is calculated either by the internal condition code
// unit, or by an external condition code unit whose presence is
// signaled by the extutil constant XT_JMPCC. Bit 4 of the instruction
// word condition code field is used to select between the internal and
// external condition code units. If an external condition code unit
// is not present, and the condition specified refers to an external
// condition, then p2condtrue will be false.
// The signal is only used for branch instructions, and does
// not include any logic to set the output to 0 or 1 when the
// instruction being executed in stage 2 is not a branch .
// p2condtrue must always be decoded along with a test for a branch
// instruction.
//
   always @(aluflags_r or i_p2_32_q_a)
    begin : p2_ccunit_32_PROC

      i_p2_ccunit_32_fz_a = aluflags_r[A_Z_N];   
      i_p2_ccunit_32_fn_a = aluflags_r[A_N_N];   
      i_p2_ccunit_32_fc_a = aluflags_r[A_C_N];   
      i_p2_ccunit_32_fv_a = aluflags_r[A_V_N];   
      i_p2_ccunit_32_nfz_a = ~aluflags_r[A_Z_N];   
      i_p2_ccunit_32_nfn_a = ~aluflags_r[A_N_N];   
      i_p2_ccunit_32_nfc_a = ~aluflags_r[A_C_N];   
      i_p2_ccunit_32_nfv_a = ~aluflags_r[A_V_N];   

      case (i_p2_32_q_a[CCUBND:0]) 
                     
        CCZ:i_p2_ccmatch32_a = i_p2_ccunit_32_fz_a;//   Z,  EQ

        CCNZ:i_p2_ccmatch32_a = i_p2_ccunit_32_nfz_a;//   NZ, NE

        CCPL:i_p2_ccmatch32_a = i_p2_ccunit_32_nfn_a;//   PL, P

        CCMI:i_p2_ccmatch32_a = i_p2_ccunit_32_fn_a;//   MI, N

        CCCS:i_p2_ccmatch32_a = i_p2_ccunit_32_fc_a;//   CS, C

        CCCC:i_p2_ccmatch32_a = i_p2_ccunit_32_nfc_a;//   CC, NC

        CCVS:i_p2_ccmatch32_a = i_p2_ccunit_32_fv_a;//   VS, V

        CCVC:i_p2_ccmatch32_a = i_p2_ccunit_32_nfv_a;//   VC, NV

        CCGT:i_p2_ccmatch32_a = i_p2_ccunit_32_fn_a & 
                           i_p2_ccunit_32_fv_a & 
                           i_p2_ccunit_32_nfz_a | 
                           i_p2_ccunit_32_nfn_a & 
                           i_p2_ccunit_32_nfv_a & 
                           i_p2_ccunit_32_nfz_a;//   GT

        CCGE:i_p2_ccmatch32_a = i_p2_ccunit_32_fn_a & 
                           i_p2_ccunit_32_fv_a | 
                           i_p2_ccunit_32_nfn_a & 
                           i_p2_ccunit_32_nfv_a;//   GE

        CCLT:i_p2_ccmatch32_a = i_p2_ccunit_32_fn_a & 
                           i_p2_ccunit_32_nfv_a | 
                           i_p2_ccunit_32_nfn_a & 
                           i_p2_ccunit_32_fv_a;//   LT

        CCLE:i_p2_ccmatch32_a = i_p2_ccunit_32_fz_a | 
                           i_p2_ccunit_32_fn_a & 
                           i_p2_ccunit_32_nfv_a | 
                           i_p2_ccunit_32_nfn_a & 
                           i_p2_ccunit_32_fv_a;//   LE

        CCHI:i_p2_ccmatch32_a = i_p2_ccunit_32_nfc_a & 
                           i_p2_ccunit_32_nfz_a;//   HI

        CCLS:i_p2_ccmatch32_a = i_p2_ccunit_32_fc_a | 
                           i_p2_ccunit_32_fz_a;//   LS

        CCPNZ:i_p2_ccmatch32_a = i_p2_ccunit_32_nfn_a & 
                           i_p2_ccunit_32_nfz_a;//   PNZ

        default:i_p2_ccmatch32_a = 1'b 1;//   AL

      endcase
    end 
   

   always @(aluflags_r or i_p2_16_q_a)
    begin : p2_ccunit_16_PROC

      i_p2_ccunit_16_fz_a = aluflags_r[A_Z_N];   
      i_p2_ccunit_16_fn_a = aluflags_r[A_N_N];   
      i_p2_ccunit_16_fc_a = aluflags_r[A_C_N];   
      i_p2_ccunit_16_fv_a = aluflags_r[A_V_N];   
      i_p2_ccunit_16_nfz_a = ~aluflags_r[A_Z_N];   
      i_p2_ccunit_16_nfn_a = ~aluflags_r[A_N_N];   
      i_p2_ccunit_16_nfc_a = ~aluflags_r[A_C_N];   
      i_p2_ccunit_16_nfv_a = ~aluflags_r[A_V_N];   

      case (i_p2_16_q_a[CONDITION_CODE_MSB:STD_COND_CODE_MSB]) 
        CCZ_16:
         begin
            i_p2_ccmatch16_a = i_p2_ccunit_16_fz_a;//   Z,  EQ
         end
        CCNZ_16:
         begin
            i_p2_ccmatch16_a = i_p2_ccunit_16_nfz_a;//   NZ, NE
         end
        CC_BCC_16:
         begin
            case (i_p2_16_q_a[STD_COND_CODE_MSB_1:0]) 
             CCGT_16:
               begin
                 i_p2_ccmatch16_a = i_p2_ccunit_16_fn_a & 
                                    i_p2_ccunit_16_fv_a & 
                                    i_p2_ccunit_16_nfz_a | 
                                    i_p2_ccunit_16_nfn_a & 
                                    i_p2_ccunit_16_nfv_a & 
                                    i_p2_ccunit_16_nfz_a;//   GT
               end
             CCGE_16:
               begin
                 i_p2_ccmatch16_a = i_p2_ccunit_16_fn_a & 
                                    i_p2_ccunit_16_fv_a | 
                                    i_p2_ccunit_16_nfn_a & 
                                    i_p2_ccunit_16_nfv_a;//   GE
               end
             CCLT_16:
               begin
                 i_p2_ccmatch16_a = i_p2_ccunit_16_fn_a & 
                                    i_p2_ccunit_16_nfv_a | 
                                    i_p2_ccunit_16_nfn_a & 
                                    i_p2_ccunit_16_fv_a;//   LT
               end
             CCLE_16:
               begin
                 i_p2_ccmatch16_a = i_p2_ccunit_16_fz_a | 
                                    i_p2_ccunit_16_fn_a & 
                                    i_p2_ccunit_16_nfv_a | 
                                    i_p2_ccunit_16_nfn_a & 
                                    i_p2_ccunit_16_fv_a;//   LE
               end
             CCHI_16:
               begin
                 i_p2_ccmatch16_a = i_p2_ccunit_16_nfc_a & 
                                    i_p2_ccunit_16_nfz_a;//   HI
               end
             CCHS_16:
               begin
                 i_p2_ccmatch16_a = i_p2_ccunit_16_nfc_a;//   HS
               end
             CCLO_16:
               begin
                 i_p2_ccmatch16_a = i_p2_ccunit_16_fc_a;//   LO
               end
             default:
               begin
                 i_p2_ccmatch16_a = i_p2_ccunit_16_fc_a | 
                                    i_p2_ccunit_16_fz_a;//   LS
               end
            endcase
         end
        default:
         begin
            i_p2_ccmatch16_a = 1'b 1;//   AL
         end
      endcase
    end 
   

   // 16-bit conditional branch
   //
   assign i_p2_condtrue_sel0_a = i_p2_opcode_16_bcc_a;

   // 32-bit unconditional branch and branch&link decodes
   // 
   assign i_p2_condtrue_sel1_a = ((i_p2_b32_a == 1'b 1) | 
                                  (i_p2_bl32_a == 1'b 1) | 
                                  (i_p2_opcode_16_bl_a == 1'b 1)) ?  1'b 1 : 
          1'b 0; 

   // 32-bit conditional branch, branch&link and extension branches decodes.
   //
   assign i_p2_condtrue_sel2_a = ((x_p2_jump_decode == 1'b 1) & 
                          (i_p2_fmt_cond_reg_dec_a == 1'b 1) | 
                          (i_p2_bcc32_a == 1'b 1) | 
                          (i_p2_blcc32_a == 1'b 1))?  1'b 1 : 
          1'b 0; 

   // Select the conditional evaluations for the different type branches, this
   // signal does not include the lp instruction evaluations.
   //                         
   assign i_p2_condtrue_nlp_a = ((i_p2_ccmatch16_a & i_p2_condtrue_sel0_a)
                                 | 
                                 (i_p2_condtrue_sel1_a) 
                                 | 
                                 (i_p2_ccmatch_alu_ext_a &
                                  i_p2_condtrue_sel2_a)); 

   // Indicates that the branching instruction in stage 2 has met the conditions
   // to do the branch.
   //
   assign i_p2_condtrue_a = (i_p2_condtrue_nlp_a | 
                             (i_p2_ccmatch_alu_ext_a & i_p2_loop32_cc_a) | 
                              i_p2_loop32_ncc_a); 

   // True when the lp instruction in stage 2 will not execute the zero delay
   // loop but will branch over the loop.
   //
   assign i_p2_condtrue_lp_a = (~i_p2_ccmatch_alu_ext_a) & i_p2_loop32_cc_a; 


   // This signal is true when an instruction in stage 2 that employs an
   // extension condition code has been set.
   //
   assign i_p2_ccmatch_alu_ext_a = (i_p2_iw_r[CCXBPOS] == 1'b 0 | 
                                       XT_JMPCC == 1'b 0) ?
          i_p2_ccmatch32_a : 
          xp2ccmatch;

   // Detection of conditional instructions at stage 2:
   // 
   // This signal is used to determine if the instruction in stage 2 is a
   // non-always conditional instruction.
   //
   assign i_p2_conditional_a = (((i_p2_32_q_a != FIVE_ZERO) & 
                         (i_p2_branch32_cc_a 
                          |
                          (x_idecode2 &
                                   i_p2_fmt_cond_reg_dec_a)
                          |
                          i_p2_loop32_cc_a) == 1'b 1)
                        | 
                        ((i_p2_opcode_16_bcc_a == 1'b 1) & 
                         (i_p2_subopcode5_r != TWO_ZERO))) ? i_p2_iv_r : 
          1'b 0; 


//------------------------------------------------------------------------------
// STAGE 2 Branch Decodes
//------------------------------------------------------------------------------

   // 32-bit B/BL decode
   //
   assign i_p2_bra32_a = i_p2_opcode_32_bcc_a | i_p2_bl_blcc_32_a; 

   // 32-bit LP decode
   //
   assign i_p2_loop32_a = ((i_p2_opcode_32_fmt1_a == 1'b 1) & 
                           (i_p2_subopcode_r == SO_LP)) ?  1'b 1 : 
          1'b 0; 

   // 32-bit LP with condition code
   //
   assign i_p2_loop32_cc_a = i_p2_loop32_a & i_p2_fmt_cond_reg_dec_a;

   // 32-bit LP decode without condition code
   //
   assign i_p2_loop32_ncc_a = i_p2_loop32_a & (~i_p2_fmt_cond_reg_dec_a); 

   // 16-bit conditional branch without delay slot
   //
   assign i_p2_bcc16_no_delay_a = i_p2_opcode_16_bcc_a | i_p2_opcode_16_bl_a; 

   // 32-bit always executing branch instruction
   //
   assign i_p2_branch32_a = i_p2_bra32_a | i_p2_loop32_a; 

   // 32-bit Conditionally executed branch instructions.
   //
   assign i_p2_branch32_cc_a = i_p2_bcc32_a | i_p2_blcc32_a; 

   // 16-bit conditional executed branch instructions
   //
   assign i_p2_branch16_cc_a = ((i_p2_opcode_16_bcc_a == 1'b 1) & 
                                (i_p2_subopcode5_r != SO16_B_S9)) ?
          1'b 1 : 
          1'b 0; 

   // All 16-bit branch instructions.
   //
   assign i_p2_branch16_a = i_p2_bcc16_no_delay_a; 

   // This includes both the 32-bit and 16-bit decodes for all non-conditional
   // branch and branch&link instructions.
   //
   assign i_p2_branch_iv_a = i_p2_iv_r & (i_p2_branch16_a | i_p2_branch32_a); 
   
   // This includes decodes for all conditional executed branch and branch &
   // link.
   //                  
   assign i_p2_branch_cc_a = i_p2_branch16_cc_a | i_p2_branch32_cc_a;
 
//------------------------------------------------------------------------------
// Delay slot mode
//------------------------------------------------------------------------------
// 
   // For 16-bit instructions the delay slot mode is intrinsic whereas for
   // 32-bit instructions it is explicit.
   // 
   assign i_p2_has_dslot_a = ((~i_p2_long_immediate_a) & 
                              i_p2_iv_r & 
                              (((i_p2_16_sop_inst_a & 
                                (i_p2_c_field16_sop_jd_a | 
                                 i_p2_c_field16_sop_jld_a | 
                                 (i_p2_c_field16_zop_a & 
                                  i_p2_b_field16_zop_jd_a)))) 
                              | 
                              (i_p2_opcode_32_fmt1_a & 
                               (i_p2_subopcode_jd_a | 
                                i_p2_subopcode_jld_a))
                                | 
                                (i_p2_iw_r[DEL_SLOT_MODE] & 
                                 (i_p2_branch32_cc_a | 
                                  i_p2_bra32_a       | 
                                  i_p2b_br_or_bbit32_nxt)))); 
   
//------------------------------------------------------------------------------
// Stage 2 Branch/Jump/Loop not taken
//------------------------------------------------------------------------------

   assign i_p2_nojump_a = (i_p2_iv_r & 
                           (((~i_p2_condtrue_nlp_a) & 
                              i_p2_branch_cc_a) 
                           | 
                            (i_p2_ccmatch_alu_ext_a & 
                             i_p2_loop32_cc_a))); 


//------------------------------------------------------------------------------
// Stage 2 Branch Taken
//------------------------------------------------------------------------------

   // Cause a relative branch for Bcc and BLcc (branch & link) when the branch
   // condition is true, and for LPcc (loop) when the condition is false. (but
   // only when the instruction in pipeline stage 2 is valid).
   //
   assign i_p2_dorel_a = i_p2_iv_r & (i_p2_condtrue_nlp_a | 
                                      i_p2_condtrue_lp_a); 

//------------------------------------------------------------------------------
// Delay slot instruction handling
//------------------------------------------------------------------------------
  
   assign i_p2_kill_p1_a = ((i_p2_dorel_a     == 1'b 1) & 
                            (i_p2_has_dslot_a == 1'b 0)) ?  1'b 1 : 
          1'b 0;
                     
   assign i_p2_kill_p1_en_a = i_p2_kill_p1_a & i_p2_enable_a; 

//------------------------------------------------------------------------------
// Branch prediction for BRcc
//------------------------------------------------------------------------------
//
// The machine uses static prediction for compare&branches due to the excessive
// number of cycles it takes to resolve the instruction.  The branches are
// predicted taken for backward branches and not taken for forward branches.
// The sign of the offset determines if the branch will be predicted or not.
// Upon a prediction the next pc is set to the branch target location and the
// location of the next instruction (when no delay slot) or the location of the
// instruction after the delay slot is then carried down the pipeline.  If when
// the compare&branch reaches it's resolution point (stage4) it determines that
// the prediction is incorrect then the next pc is set to the address that is
// being carried along the pipeline. 
//
   // This instruction decodes compare&branch instructions with delay-slots or
   // long immediate data.  This will cause the fall through address to be set
   // to 8 bytes after the branch address.
   //
   assign i_p2b_brcc_instr_ds_nxt = (i_p2_iv_r & 
                                     (i_p2b_br_or_bbit32_nxt & 
                                      (i_p2_iw_r[DEL_SLOT_MODE] |
                                       i_p2_limm_a)));

   // This decodes branches without a delay-slot or long immediate data.  The
   // fall through address is 4 bytes if the branch is a 32-bit or 2 bytes after
   // if the branch is 16-bits.
   // 
   assign i_p2b_brcc_instr_nds_nxt = (i_p2_iv_r & 
                                      (i_p2_br16_no_delay_a | 
                                       (i_p2b_br_or_bbit32_nxt   & 
                                       (~i_p2_iw_r[DEL_SLOT_MODE]) & 
                                       (~i_p2_limm_a)))); 


   // Compare & Branch Backward branch predict taken delay slot independent.
   //
   assign i_p2b_brcc_pred_nxt = (i_p2_offset_a[TARGSZ] & 
                                 (i_p2b_brcc_instr_nds_nxt |
                                  i_p2b_brcc_instr_ds_nxt));

   // Compare & Branch Backward branch predict taken with delay slot
   //
   assign i_p2b_brcc_pred_ds_nxt = (i_p2_offset_a[TARGSZ] & 
                                    i_p2b_brcc_instr_ds_nxt); 

   // Compare & Branch Backward branch predict taken without delay slot
   //                         
   assign i_p2_brcc_pred_nds_a = (i_p2_offset_a[TARGSZ] & 
                                  i_p2b_brcc_instr_nds_nxt);

   // Compare & Branch Backward branch predict taken without delay slot
   // including stage 2 enable signal
   // 
   assign i_p2_brcc_pred_nds_en_a = (i_p2_brcc_pred_nds_a & 
                                     i_p2_enable_a); 

//------------------------------------------------------------------------------
// Jump & link and Branch & link decodes
//------------------------------------------------------------------------------  
//
// Now some simple decodes from the opcode field are performed.
// These are for files which do their own decode of the p2opcode
// field.
//
   // Here are the 32/16-bit equivalent decodes for the jump/link, branch/link
   // instructions from the p2opcode and subopcode fields.
   //
   assign i_p2_bl_niv_a = ((i_p2_opcode_32_blcc_a & (~i_p2_iw_r[BR_FMT]))
                           | 
                           (i_p2_opcode_16_bl_a)); 
                     
   // Branch and link.
   //
   assign i_p2_jlcc_a = i_p2_opcode_32_fmt1_a & (i_p2_subopcode_jl_a | 
                                                 i_p2_subopcode_jld_a); 

   assign i_p2b_jlcc_niv_nxt = (i_p2_jlcc_a | 
                                (i_p2_16_sop_inst_a & 
                                 (i_p2_c_field16_sop_jl_a | 
                                  i_p2_c_field16_sop_jld_a))); 

   // Jump and link.
   //
   assign i_p2_jblcc_niv_a = i_p2b_jlcc_niv_nxt | i_p2_bl_niv_a;
 
   assign i_p2_jblcc_iv_a = i_p2_jblcc_niv_a & i_p2_iv_r; 

//------------------------------------------------------------------------------  
// Store link register for branch and link.
//------------------------------------------------------------------------------  
//
   // This signal is set true when a valid branch-and-link instruction
   // is in stage 2, and the condition is valid, meaning that the
   // register should be passed down the pipeline to go into the
   // register file. It is necessary to latch this signal into p3dolink
   // as the condition code may evaluate with a different result when
   // the instruction gets to stage 3.
   //
   assign i_p2_dolink_a = i_p2_bl_niv_a & i_p2_iv_r & i_p2_condtrue_nlp_a; 


//------------------------------------------------------------------------------
// Stage2 BRcc decode
//------------------------------------------------------------------------------

   // A 32-bit compare/branch (BRcc) instruction has entered stage two.
   //
   assign i_p2b_br_or_bbit32_nxt =
                                ((i_p2_opcode_32_blcc_a              == 1'b 1) & 
                                 (i_p2_iw_r[BR_FMT] == 1'b 1) & 
                                 ((i_p2_a_field_r[SUBOPCODE_MSB_2:0] == BR_CCEQ) |
                                  (i_p2_a_field_r[SUBOPCODE_MSB_2:0] == BR_CCNE) |
                                  (i_p2_a_field_r[SUBOPCODE_MSB_2:0] == BR_CCLT) |
                                  (i_p2_a_field_r[SUBOPCODE_MSB_2:0] == BR_CCGE) |
                                  (i_p2_a_field_r[SUBOPCODE_MSB_2:0] == BR_CCLO) |
                                  (i_p2_a_field_r[SUBOPCODE_MSB_2:0] == BR_CCHS) |
                                  (i_p2_a_field_r[SUBOPCODE_MSB_2:0] == BBIT0)   |
                                  (i_p2_a_field_r[SUBOPCODE_MSB_2:0] == BBIT1))) ?
          1'b 1 : 
          1'b 0; 

   // A 16-bit compare/branch (BRcc) instruction has entered stage two.
   //
   assign i_p2_br16_no_delay_a = i_p2_opcode_16_brcc_a; 

   // Combine 16 and 32 bit compare/branch (BRcc) instruction detection.
   //
   assign i_p2_br_or_bbit_a = i_p2b_br_or_bbit32_nxt | i_p2_br16_no_delay_a;


   // Combine 16 and 32 bit compare/branch (BRcc) instruction detection,
   // with 'instruction valid'
   //
   assign i_p2_br_or_bbit_iv_a = i_p2_br_or_bbit_a & i_p2_iv_r; 

//------------------------------------------------------------------------------
// Stage 2 decode of stage2b jumps
//------------------------------------------------------------------------------

   assign i_p2_p2b_jmp_iv_a = (i_p2_iv_r & 
                               (((i_p2_16_sop_inst_a & 
                                  (i_p2_c_field16_sop_jd_a  | 
                                   i_p2_c_field16_sop_j_a   |
                                   i_p2_c_field16_sop_jl_a  | 
                                   i_p2_c_field16_sop_jld_a | 
                                   (i_p2_c_field16_zop_a & 
                                    (i_p2_b_field16_zop_jeq_a | 
                                     i_p2_b_field16_zop_jd_a  | 
                                     i_p2_b_field16_zop_jne_a | 
                                     i_p2_b_field16_zop_j_a)))))
                              | 
                              (i_p2_opcode_32_fmt1_a & 
                               (i_p2_subopcode_jd_a | 
                                i_p2_subopcode_jld_a | 
                                i_p2_subopcode_j_a | 
                                i_p2_subopcode_jl_a)))); 
                     
//------------------------------------------------------------------------------
// Interrupt hold off
//------------------------------------------------------------------------------
//
// This signal is fed to the interrupt unit to hold off any interrupt from
// entering the pipeline under certain conditions, those conditions are:
//
// (1) The instruction in stage 2 has decoded a long immediate using
//     instruction. The interrupt can overwrite the LIMM as the parent
//     instruction would not execute correctly.
// (2) The instruction in stage 2 has decoded that it requires has a delay slot
//     instruction.  An interrupt cannot separate a instruction from its delay
//     slot because the stall logic would cause a hold up.
// (3) A zero delay loop overrun has occured and the ZD loop logic requires a
//     cycle to correct the overrun.
// (4) A delayed branch or jump is waiting to happened.  This is need to prevent
//     the interrupt from obtaining the wrong address to write to the ilink
//     register.
// (5) A swi is draining the pipeline. This is to prevent a lower priority
//     interrupt from entering the pipeline before the swi is serviced.
//
   assign i_interrupt_holdoff_a = (i_p2_long_immediate_a | 
                                   i_p2_has_dslot_a | 
                                   i_p2_tag_nxt_p1_limm_r | 
                                   i_p2_tag_nxt_p1_dslot_r |
                                   loop_int_holdoff_a |
                                   pcounter_jmp_restart_r |
                                   (i_p2_swi_inst_niv_a & i_p2_iv_r & ~i_p4_disable_r));

//------------------------------------------------------------------------------
// Actionpoint halt holdoff
//------------------------------------------------------------------------------
//
//  An (watch-point) actionpoint should be delayed if:
//  
//  1. The last instruction of a zero delay loop
//  2. A 64-bit instruction with it's opcode in stage 2 and LIMM in stage 1
//  3. Any unresolved branches/jumps currently in the pipeline
//  4. An interupt currently being serviced  

assign i_actionhalt_holdoff_a =  (i_p2_loopend_hit_r & i_p2_iv_r)
                                  |
                                 (p1int | p2int | p3int)      
                                  |
                                  x_multic_busy
                                  |
                                 // wait until 64-bit instruction moved out of pipeline
                                 (i_p2b_long_immediate_r & i_p2b_iv_r & (~i_p2b_enable_a)) | i_p2_long_immediate_a
                                    |
                                    // wait until branches/jumps move out of the pipeline
                                    i_p2_branch_iv_a  | (i_p2_branch_cc_a & i_p2_iv_r) |
                                    i_p2_p2b_jmp_iv_a | ((i_p2b_jmp_niv_a | i_p2b_jmp_cc_a) & i_p2b_iv_r) |
                                 (i_p2b_branch_iv_r & i_p2b_iv_r) | (i_p2_jblcc_iv_a & i_p2_iv_r)  |
                                 (i_p2b_jblcc_iv_r & i_p2b_iv_r) 
                                    | 
                                    // wait until any outstanding kills on stage 1 are done
                                    i_tag_nxt_p1_killed_r | i_p4_docmprel_a
                                  |
                                  // BRcc instructions in stages 2, 2b, 3
                                   (i_p2_br_or_bbit_iv_a & i_p2_iv_r)
                                    |
                                   (i_p2b_br_or_bbit_iv_a & i_p2b_iv_r)
                                    |
                                   (i_p3_br_or_bbit_iv_a & i_p3_iv_r);

assign i_actionhalt_a =         actionhalt & ((~i_actionhalt_holdoff_a) | actionpt_pc_brk_a);


//------------------------------------------------------------------------------
// Is the current instruction in stage part of the instruction set
//------------------------------------------------------------------------------
//
   // The following logic decodes the entire ISA if the longword in stage 2 is
   // decoded to one of the instruction in the set then the i_p2_arcop_a signal
   // is set otherwise it is not.
   //
   always @(i_p2_opcode_a or i_p2_subopcode_r or i_p2_subopcode2_r or 
            i_p2_a_field_r or i_p2_b_field_r or i_p2_b_field16_r or 
            i_p2_subopcode3_r or i_p2_subopcode1_r or
            i_p2_c_field16_r or i_p2_format_r)
    begin : arcop_PROC
      case (i_p2_opcode_a) 
        OP_BCC, OP_LD, OP_ST:
         begin
            i_p2_arcop_a = 1'b 1;   
         end
        OP_BLCC:
         begin
            if (i_p2_subopcode_r[0] == 1'b 1)
             begin
               case (i_p2_a_field_r[SUBOPCODE_MSB_2:0])
                 BR_CCEQ, BR_CCNE, BR_CCLT, 
                 BR_CCGE, BR_CCLO, BR_CCHS, 
                 BBIT0, BBIT1:
                  begin
                     i_p2_arcop_a = 1'b 1;   
                  end
                 default:
                  begin
                     i_p2_arcop_a = 1'b 0;   
                  end
               endcase
             end
            else
             begin
               i_p2_arcop_a = 1'b 1;   
             end
         end
        OP_FMT1:
         begin
            case (i_p2_subopcode_r) 
             SO_SOP:
               begin
                 case (i_p2_a_field_r) 
                  MO_ASL,  MO_ASR,  MO_LSR, 
                  MO_ROR,  MO_RRC,  MO_SEXB, 
                  MO_SEXW, MO_EXTB, MO_EXTW, 
                  MO_ABS,  MO_NOT,  MO_RLC:
                    begin
                      if (i_p2_format_r == FMT_REG | 
                         i_p2_format_r == FMT_U6)
                        begin
                          i_p2_arcop_a = 1'b 1;   
                        end
                      else
                        begin
                          i_p2_arcop_a = 1'b 0;   
                        end
                    end
                  MO_ZOP:
                    begin
                      case (i_p2_b_field_r) 
                        ZO_SLEEP, ZO_SWI, ZO_SYNC:
                         begin
                           if ((i_p2_format_r == FMT_REG) | 
                              (i_p2_format_r == FMT_U6))
                             begin
                               i_p2_arcop_a = 1'b 1;   
                             end
                           else
                             begin
                               i_p2_arcop_a = 1'b 0;   
                             end
                         end
                        default:
                         begin
                           i_p2_arcop_a = 1'b 0;   
                         end
                      endcase
                    end
                  default:
                    begin
                      i_p2_arcop_a = 1'b 0;   
                    end
                 endcase
               end
             SO_ADD, SO_ADC, SO_SUB, SO_SBC, 
                SO_AND, SO_OR, SO_BIC, SO_XOR, 
                SO_MAX, SO_MIN, SO_J, SO_J_D, 
                SO_JL, SO_JL_D, SO_LP, SO_LR, 
                SO_SR, SO_FLAG, SO_LD, SO_LDB, 
                SO_LDB_X, SO_LDW, SO_LDW_X, 
                SO_MOV, SO_BSET, SO_BCLR, 
                SO_BTST, SO_BMSK, SO_BXOR, SO_ADD1,
                SO_ADD2, SO_ADD3, SO_SUB1, SO_SUB2, 
                SO_SUB3, SO_TST, SO_CMP, SO_RCMP, 
                SO_RSUB:
                  begin
                 i_p2_arcop_a = 1'b 1;   
               end
             default:
               begin
                 i_p2_arcop_a = 1'b 0;   
               end
            endcase
         end
        OP_16_LD_ADD, OP_16_MV_ADD, 
           OP_16_LD_U7, OP_16_LDB_U5, OP_16_LDW_U6, 
           OP_16_LDWX_U6, OP_16_ST_U7, OP_16_STB_U5, 
           OP_16_STW_U6, OP_16_SP_REL, 
           OP_16_GP_REL, OP_16_LD_PC, OP_16_MV, 
           OP_16_ADDCMP, OP_16_BRCC, OP_16_BCC, 
           OP_16_BL:
         begin
            i_p2_arcop_a = 1'b 1;   
         end
	OP_16_ARITH:
         begin
	    case (i_p2_subopcode1_r)
              SO16_ASL: i_p2_arcop_a = 1'b 0;
              SO16_ASR: i_p2_arcop_a = 1'b 0;
	      default: i_p2_arcop_a = 1'b 1;
            endcase
         end
	OP_16_SSUB:
	  begin
            case (i_p2_subopcode3_r)
	      SO16_LSR_U5, SO16_ASR_U5, SO16_ASL_U5: i_p2_arcop_a = 1'b 0;
	      default: i_p2_arcop_a = 1'b 1;
	    endcase
	  end
        OP_16_ALU_GEN:
         begin
            case (i_p2_subopcode2_r) 
             SO16_SOP:
               begin
                 case (i_p2_c_field16_r) 
                  SO16_SOP_J, SO16_SOP_JD, SO16_SOP_JL,
                  SO16_SOP_JLD, SO16_SOP_SUB:
                    begin
                      i_p2_arcop_a = 1'b 1;   
                    end
                  SO16_SOP_ZOP:
                    begin
                      case (i_p2_b_field16_r) 
                        SO16_ZOP_NOP, SO16_ZOP_JEQ, SO16_ZOP_JNE, 
                        SO16_ZOP_J, SO16_ZOP_JD:
                         begin
                           i_p2_arcop_a = 1'b 1;   
                         end
                        default:
                         begin
                           i_p2_arcop_a = 1'b 0;   
                         end
                      endcase
                    end
                  default:
                    begin
                      i_p2_arcop_a = 1'b 0;   
                    end
                 endcase
               end
             SO16_SUB_REG, SO16_AND, SO16_BRK, 
                SO16_OR, SO16_BIC, SO16_XOR, 
                SO16_TST, SO16_MUL64, SO16_SEXB, 
                SO16_SEXW, SO16_EXTB, SO16_EXTW, 
                SO16_ABS, SO16_NOT, SO16_NEG, 
                SO16_ADD1, SO16_ADD2, SO16_ADD3, 
                SO16_ASL_1, SO16_ASR_1, SO16_LSR_1:
               begin
                 i_p2_arcop_a = 1'b 1;   
               end
             default:
               begin
                 i_p2_arcop_a = 1'b 0;   
               end
            endcase
         end
        default:
         begin
            i_p2_arcop_a = 1'b 0;   
         end
      endcase
    end 
   

//------------------------------------------------------------------------------
// Generate an Instruction Error
//------------------------------------------------------------------------------
//
// This will occur when a valid instruction in stage 2 is not one of the
// standard opcode set, and the extension logic has not 'claimed' 
// the instruction in stage 2 as one of its own.
//
   // An instruction error is generated when a SWI instruction is detected in
   // stage 2. This is identical to an unknown-instruction interrupt, but we
   // have assigned a specific encoding to reliably generate this interrupt
   // under program control.
   //
   assign i_p2_no_arc_or_ext_instr_a = ((i_p2_arcop_a == 1'b 0) &
                                        ((x_idecode2 & XT_ALUOP) == 1'b 0) &
                                        (i_p2_iv_r == 1'b 1)) ? 1'b 1 : 
          1'b 0;

   // The instruction error interrupt generated by a swi does not actually get
   // triggered until the pipeline has been drained. This is to allow any
   // control transfer instructions to leave the pipe and the prevent an BRK
   // instruction from halting the pipe if they are not on the correct
   // instruction path.
   //
   // This interrupt is also used by the actionpoint SWI mechanism.
   //
   assign i_p2_instruction_error_a = (i_p2_enable_a                  &
                                      i_p2_no_arc_or_ext_instr_a)        | 
                                     (i_p2_swi_inst_a                &
                                      i_p4_disable_r)                    |
                                     actionpt_swi_a; 

//------------------------------------------------------------------------------
// Branch Protection system
//------------------------------------------------------------------------------
//
// In order to generate the stall, we also need to detect a valid
// branch instruction present in stage 2 (i_p2_branch_cc_a).
//
// We generate a stall when the two conditions are present together:
//
//  a. An instruction in stage 3 or stage 2b is attempting to set the flags
//  b. A branch instruction at stage 2 needs to use these new flags
//
// Note that it would be possible to detect the following conditions
// to give theoretical improvements in performance. These are very
// marginal, and have been left out here for the sake of simplicity,
// and the fact it would be difficult for the compiler to take
// advantage of these optimisations. Both cases remove the link
// between setting the flags and the following branch, either because
// the flags don't get set, or because the branch doesn't check the
// flags.
//
//  i. Conditional flag set instruction at stage 3 does not set flags
//      e.g.  add.cc.f r0,r0,r0, resulting in C=1
//
// ii. Branch at stage 2 uses the AL (always) condition code.
//
   assign i_p2_branch_holdup_a = ( //Stage 3 setting flags
                                  (i_p3_bch_flagset_a | 
                                   //  p2b setting flags 
                                   i_p2b_bch_flagset_a) & 
                                   //  branch or loop in p2
                                   (i_p2_branch_cc_a | 
                                    i_p2_loop32_cc_a)); 

//------------------------------------------------------------------------------
// Decode Stage 2 instruction valid
//------------------------------------------------------------------------------
//
// This signal is used to determine if the long word in stage 2 is a valid
// instruction that should be treated as such, when true the instruction is
// valid.  When false the instruction is not valid and should be ignored. The
// condition under which the instruction is not valid are:
//
// (1) The current longword is either garbage or is long immediate data.
// (2) The current longword is tagged to be killed when it arrives from the
//     cache.
// (3) There is a brk instruction in stage 2. When an IVIC occurs the brk must
//     be removed.
// (4) The instruction cannot move from stage 1 into stage 2 following the
//     instruction already in stage 2, i.e. the two instruction have been
//     separated.
// (5) Stage 1 is being killed.  The instruction is being killed as it leaves
//    stage 1.
// (6) Stage 2 is being killed whilst the stage is stalled.
// (7) The data about to enter stage 2 is long immediate data.
// (8) There is an interrupt about to move into stage 2
// (9) The fetch as the interrupt moves from stage 1 to stage 2 is not needed
//     and the data is killed.
//
   assign i_p2_iv_nxt = (((i_p2_tag_nxt_p1_limm_r == 1'b 1) &
                          (i_p1_enable_a == 1'b 1)) 
                         | 
                         ((i_tag_nxt_p1_killed_r == 1'b 1) & (i_p1_enable_a == 1'b 1))
                         | 
                         ((ivic == 1'b 1) & (actionpt_pc_brk_a == 1'b 1))                          
                         | 
                         ((ivic == 1'b 1) & (i_p2_brk_inst_a == 1'b 1)) 
                         | 
                         ((i_p2_enable_a == 1'b 1) & (i_p1_enable_a == 1'b 0))
                         | 
                         ((i_p1_enable_a == 1'b 1) & (i_kill_p1_en_a == 1'b 1))
                         | 
                         ((i_p2_enable_a == 1'b 0) & (i_kill_p2_en_a == 1'b 1))
                         | 
                         ((i_p2_long_immediate_a == 1'b 1) & (i_p2_enable_a == 1'b 1))
                         | 
                         ((p1int == 1'b 1) & (i_p1_enable_a == 1'b 1))
                         | 
                         (p2int == 1'b 1)) ?
          1'b 0 :
 
                        ((i_p2_enable_a == 1'b 0) & (i_p2_iv_r == 1'b 1)) ?
          1'b 1 : 
          
                        ((i_p2_enable_a == 1'b 0) & (i_p1_enable_a == 1'b 0)) ?
          i_p2_iv_r : 
          ivalid_aligned; 

   always @(posedge clk or posedge rst_a)
    begin : p2_iv_sync_PROC
      if (rst_a == 1'b 1)
        begin
          i_p2_iv_r <= 1'b 0;   
        end
      else
        begin
          i_p2_iv_r <= i_p2_iv_nxt;   
        end
    end

//------------------------------------------------------------------------------
// Pipeline 2 -> 2b transition enable
//------------------------------------------------------------------------------
//
// This signal is true when the processor is running, and the instruction in
// stage 2 can be allowed to move on into stage 2b. It may be held up for a
// number of reasons:    
//

   // The following stall signal is used to prevent any of the following
   // signals:
   //
   // [1] Zero delay loops                        OR
   // [2] SWI instruction is detected in stage 2  OR
   // [3] Interrupt                               OR
   // [4] SLEEP                                   OR
   //
   // from being allowed to progress down the pipeline if they are in the
   // shadow of control transfer instruction.  The ZD loop or interrupt or SLEEP
   // may be on a mispredicted path and will be killed.
   //
   assign i_p2_ct_brcc_stall_a = (i_p2_loop32_a              | 
                                  i_p2_no_arc_or_ext_instr_a | 
                                  i_p2_swi_inst_a            |
                                  i_p2_sleep_inst_a)        & 
                                  (i_p2b_jmp_iv_a            | 
                                   i_p2b_br_or_bbit_iv_a     | 
                                   i_p3_br_or_bbit_iv_a      | 
                                   i_p4_br_or_bbit_iv_a); 
  
   // This stall prevents a branch from moving on if it is conditional and there
   // is a flag setting instruction in the pipeline.  The xholdup2 term is used
   // by extension instructions that require stage 2 being held up.
   // SWI instructions must be held in stage two and prevented from initiating
   // an interrupt if there are still instructions in the pipeline.  This is to
   // prevent a brk after a swi from halting the processor before the interrupt
   // has been serviced.
   //
   assign i_p2_holdup_stall_a = ((xholdup2 & XT_ALUOP)
                                 |
                                 p2_ap_stall_a
                                 |
                                 (i_p2_branch_holdup_a & i_p2_iv_r)
                                 |
                                 (i_p2_swi_inst_a & (~i_p4_disable_r))); 

   // This stall is used to prevent garbage for traveling down the pipeline.
   //
   assign i_p2_pwr_save_stall_a = (~i_p2_iv_r) & (~p2int); 

   // There is a stall in stage 2 to stop illegal instruction errors from being
   // lost:
   //
   // [1] An instruction error is happening in stage 2.
   //
   // [2] There is a flag setting instruction in stages 2B, 3 so stall the
   //     processor until this has been completed
   //
  assign i_p2_instr_err_stall_a = (i_p2b_flagu_block_a |
                                   i_p3_flagu_block_a) &
                                  i_p2_no_arc_or_ext_instr_a;

   // The power saving stalls are not stalls that need to propagate down
   // pipeline
   //
   assign i_p2_en_no_pwr_save_a = ((en                        == 1'b 0) | 
                                       (i_p2b_en_nopwr_save_a == 1'b 0) | 
                                       (i_p2_holdup_stall_a       == 1'b 1) |
     (actionpt_pc_brk_a         == 1'b 1) |                                       
                                       (i_p2_ct_brcc_stall_a      == 1'b 1) | 
                                       (i_p2_brk_inst_a           == 1'b 1) |
                                       (i_p2_instr_err_stall_a    == 1'b 1)) ?
          1'b 0 :
          1'b 1; 

   assign i_p2_enable_a = ((i_p2_en_no_pwr_save_a == 1'b 0) 
                           | 
                           (i_p2_pwr_save_stall_a == 1'b 1)) ? 1'b 0 : 
          1'b 1; 


//------------------------------------------------------------------------------
// End of Stage registers
//------------------------------------------------------------------------------

   always @(posedge clk or posedge rst_a)
    begin : Stage_2b_sync_PROC
      if (rst_a == 1'b 1)
        begin
          i_p2b_br_or_bbit32_r    <= 1'b 0;   
          i_p2b_br_or_bbit_r      <= 1'b 0;   
          i_p2b_brcc_pred_r       <= 1'b 0;   
          i_p2b_brcc_pred_ds_r    <= 1'b 0; 
          i_p2b_dest_imm_r        <= 1'b 0;   
          i_p2b_destination_en_r  <= 1'b 0;   
          i_p2b_destination_r     <= {(OPERAND_MSB + 1){1'b 0}};   
          i_p2b_dolink_r          <= 1'b 0;   
          i_p2b_iw_r              <= {(INSTR_UBND + 1){1'b 0}};   
          i_p2b_jlcc_niv_r        <= 1'b 0;   
          i_p2b_long_immediate_r  <= 1'b 0;   
          i_p2b_q_r               <= {CONDITION_CODE_WIDTH{1'b 0}};   
          i_p2b_setflags_r        <= 1'b 0;   
          i_p2b_shimm_r           <= 1'b 0;   
          i_p2b_shimm_s1_r        <= 1'b 0;   
          i_p2b_short_immediate_r <= {(SHIMM_MSB + 1){1'b 0}};   
          i_p2b_source1_addr_r    <= {(OPERAND_MSB + 1){1'b 0}};   
          i_p2b_source1_en_r      <= 1'b 0;   
          i_p2b_source2_addr_r    <= {(OPERAND_MSB + 1){1'b 0}};   
          i_p2b_source2_en_r      <= 1'b 0;   
          i_p2b_subopcode_r       <= {(SUBOPCODE_MSB + 1){1'b 0}};
          i_p2b_sync_inst_r       <= 1'b 0;             
          i_p2b_jblcc_iv_r        <= 1'b 0; 
        i_p2b_branch_iv_r       <= 1'b 0;  
        end
      else
        begin
          if (i_p2_enable_a == 1'b 1)
            begin
              i_p2b_br_or_bbit32_r    <= i_p2b_br_or_bbit32_nxt;   
              i_p2b_br_or_bbit_r      <= i_p2_br_or_bbit_iv_a;   
              i_p2b_brcc_pred_r       <= i_p2b_brcc_pred_nxt;   
              i_p2b_brcc_pred_ds_r    <= i_p2b_brcc_pred_ds_nxt; 
              i_p2b_dest_imm_r        <= i_p2_dest_imm_a;   
              i_p2b_destination_en_r  <= i_p2_destination_en_a;   
              i_p2b_destination_r     <= i_p2_destination_a;   
              i_p2b_dolink_r          <= i_p2_dolink_a;   
              i_p2b_iw_r              <= i_p2_iw_r;   
              i_p2b_jlcc_niv_r        <= i_p2b_jlcc_niv_nxt;   
              i_p2b_long_immediate_r  <= i_p2_long_immediate_a;   
              i_p2b_q_r               <= i_p2_q_a;   
              i_p2b_setflags_r        <= i_p2b_setflags_nxt;   
              i_p2b_shimm_r           <= i_p2_shimm_a;   
              i_p2b_shimm_s1_r        <= i_p2_shimm_s1_a;   
              i_p2b_short_immediate_r <= i_p2_short_immediate_a;   
              i_p2b_source1_addr_r    <= i_p2_source1_addr_a;   
              i_p2b_source1_en_r      <= i_p2_source1_en_a;   
              i_p2b_source2_addr_r    <= i_p2_source2_addr_a;   
              i_p2b_source2_en_r      <= i_p2_source2_en_a;   
              i_p2b_subopcode_r       <= i_p2_subopcode_r; 
              i_p2b_sync_inst_r       <= i_p2_sync_inst_a;  
              i_p2b_jblcc_iv_r        <= i_p2_jblcc_iv_a; 
              i_p2b_branch_iv_r       <= i_p2_branch_iv_a | (i_p2_branch_cc_a & i_p2_iv_r);                
            end
        end
    end
   
   // Combine signals with the stage 2b instruction valid signal
   //
   assign i_p2b_br_or_bbit_iv_a = i_p2b_br_or_bbit_r & i_p2b_iv_r; 
   assign i_p2b_dolink_iv_a = i_p2b_dolink_r & i_p2b_iv_r; 
   assign i_p2b_jlcc_iv_a = i_p2b_jlcc_niv_r & i_p2b_iv_r; 
   assign i_p2b_dest_en_iv_a = i_p2b_destination_en_r & i_p2b_iv_r;

//------------------------------------------------------------------------------
// RF Stage Instruction Fields
//------------------------------------------------------------------------------
//
// The various component parts of the instruction set are extracted here
// to internal signals.
//
   // Major opcode
   //
   assign i_p2b_opcode_r = i_p2b_iw_r[INSTR_UBND:INSTR_LBND]; 

   // Branch and branch&link opcodes
   //
   assign i_p2b_br_bl_subopcode_r = ({i_p2b_iw_r[MINOR_OP_LBND], 1'b 0, 
                                      i_p2b_iw_r[MINOR_BR_UBND:
                                                 MINOR_BR_LBND]}); 
   // B field
   //
   assign i_p2b_b_field_r = {i_p2b_iw_r[BOP_MSB_UBND:BOP_MSB_LBND], 
                             i_p2b_iw_r[BOP_LSB_UBND:BOP_LSB_LBND]}; 

   // C field for 32-bit
   //
   assign i_p2b_c_field_r = i_p2b_iw_r[COP_UBND:COP_LBND]; 

   // Minor opcode
   //
   assign i_p2b_minoropcode_r = i_p2b_iw_r[AOP_UBND:AOP_LBND]; 

   // Format for operands
   //
   assign i_p2b_format_r = i_p2b_iw_r[MINOR_OP_UBND + 2:MINOR_OP_UBND + 1]; 

   // A field
   //
   assign i_p2b_a_field_r = i_p2b_iw_r[AOP_UBND:AOP_LBND]; 

   // The various component parts of the 16-bit instruction set are
   // extracted here to internal signals.
   //
   // Sub Opcodes 1 
   //
   assign i_p2b_subopcode1_r = i_p2b_subopcode_r[SUBOPCODE2_16_MSB:
                                                 SUBOPCODE_MSB_2];

   // Sub Opcodes 2 
   //
   assign i_p2b_subopcode2_r = i_p2b_subopcode_r[SUBOPCODE2_16_MSB:0];

   // Sub Opcodes 3 
   //
   assign i_p2b_subopcode3_r = i_p2b_iw_r[MINOR16_OP3_UBND:MINOR16_OP3_LBND];

   // Sub Opcodes 4 
   //
   assign i_p2b_subopcode4_r = i_p2b_iw_r[SUBOPCODE_BIT];

   // Sub Opcodes 5 
   //
   assign i_p2b_subopcode5_r = i_p2b_iw_r[MINOR16_BR1_UBND:MINOR16_BR1_LBND];

   // Sub Opcodes 6 
   //
   assign i_p2b_subopcode6_r = i_p2b_iw_r[MINOR16_BR2_UBND:MINOR16_BR2_LBND];

   // Sub Opcodes 7 
   //
   assign i_p2b_subopcode7_r = i_p2b_iw_r[MINOR16_OP4_UBND:MINOR16_OP4_LBND]; 


   // A field for 16-bit
   //
   assign i_p2b_a_field16_r = {TWO_ZERO, i_p2b_iw_r[AOP_UBND16], 
                               i_p2b_iw_r[AOP_UBND16:AOP_LBND16]};

   // B field for 16-bit
   //
   assign i_p2b_b_field16_r = i_p2b_b_field_r[OPERAND16_MSB:0]; 

   // C field for 16-bit
   //
   assign i_p2b_c_field16_r = i_p2b_iw_r[COP_UBND16:COP_LBND16]; 

   // C field for 16-bit (extended to fit write-back address register
   // field).
   //
   assign i_p2b_c_field16_2_r = {TWO_ZERO, i_p2b_iw_r[COP_UBND16], 
                                 i_p2b_iw_r[COP_UBND16:COP_LBND16]}; 

   // High register field for 16-bit
   //
   assign i_p2b_hi_reg16_r = {i_p2b_iw_r[AOP_UBND16:AOP_LBND16], 
                              i_p2b_iw_r[COP_UBND16:COP_LBND16]}; 


//------------------------------------------------------------------------------
// Format decodes
//------------------------------------------------------------------------------

   // Conditional register + register
   //
   assign i_p2b_fmt_cond_reg_a = i_p2b_format_r == FMT_COND_REG ? 1'b 1 : 
          1'b 0; 

//------------------------------------------------------------------------------
// Opcode decodes
//------------------------------------------------------------------------------

   // Decode for 16-bit Single Operand instruction.
   //
   assign i_p2b_16_sop_inst_a = (i_p2b_opcode_16_alu_a & 
                                 i_p2b_subop_16_sop_a);

   // Decode for 16-bit instruction
   // 
   assign i_p2b_16_bit_instr_a = (i_p2b_opcode_r[OPCODE_MSB] | 
                                  i_p2b_opcode_r[OPCODE_MSB_1]); 

   // Decode for 32-bit Basecase Instruction Opcode slot.
   //
   assign i_p2b_opcode_32_fmt1_a = (i_p2b_opcode_r == OP_FMT1) ? 1'b 1 : 
          1'b 0; 

   // Decode for 16-bit Basecase ALU Instruction Opcode slot.
   //
   assign i_p2b_opcode_16_alu_a = (i_p2b_opcode_r == OP_16_ALU_GEN) ? 1'b 1 : 
          1'b 0; 

   // Select appropriate address for 16-bit Global pointer instructions.
   //
   assign i_p2b_opcode_16_gp_rel_a = (i_p2b_opcode_r == OP_16_GP_REL) ? 1'b 1 : 
          1'b 0; 

   // Select appropriate address for 16-bit Stack pointer instructions.
   //
   assign i_p2b_opcode_16_sp_rel_a = (i_p2b_opcode_r == OP_16_SP_REL) ? 1'b 1 : 
          1'b 0; 

   // Decode for 16-bit MOV instruction.
   //
   assign i_p2b_opcode_16_mov_a = (i_p2b_opcode_r == OP_16_MV) ? 1'b 1 : 
          1'b 0; 

   // Select PC register for LD PC relative instructions.
   //
   assign i_p2b_opcode_16_ld_pc_a = (i_p2b_opcode_r == OP_16_LD_PC) ? 1'b 1 : 
          1'b 0; 
      
    
   // Decode for 16-bit mov,add & cmp major opcodes
   //
   assign i_p2b_opcode_16_mv_add_a = (i_p2b_opcode_r == OP_16_MV_ADD) ? 1'b 1 : 
          1'b 0; 
  
   // Decode for 16-bit shift & sub major opcodes
   //
   assign i_p2b_opcode_16_ssub_a = (i_p2b_opcode_r == OP_16_SSUB) ? 1'b 1 : 
          1'b 0; 
  
   // Decode for 16-bit load & add major opcodes
   //
   assign i_p2b_opcode_16_ld_add_a = (i_p2b_opcode_r == OP_16_LD_ADD) ? 1'b 1 : 
          1'b 0; 

   // Decode for 16-bit load & add major opcodes
   //
   assign i_p2b_opcode_16_ld_u7_a = (i_p2b_opcode_r == OP_16_LD_U7) ? 1'b 1 : 
          1'b 0; 

   // Decode for 16-bit byte ld with unsigned 5-bit immediate data
   //
   assign i_p2b_opcode_16_ldb_u5_a = (i_p2b_opcode_r == OP_16_LDB_U5) ? 1'b 1 : 
          1'b 0; 
  
   // Decode for 16-bit word ld with unsigned 6-bit immediate data
   //
   assign i_p2b_opcode_16_ldw_u6_a = (i_p2b_opcode_r == OP_16_LDW_U6) ? 1'b 1 : 
          1'b 0; 
  
   // Decode for 16-bit word ld with unsigned 6-bit immediate data and sign
   // extension
   //
   assign i_p2b_opc_16_ldwx_u6_a = (i_p2b_opcode_r == OP_16_LDWX_U6) ? 1'b 1 : 
          1'b 0; 
  
   // Decode for 16-bit st with unsigned 7-bit data
   //
   assign i_p2b_opcode_16_st_u7_a = (i_p2b_opcode_r == OP_16_ST_U7) ? 1'b 1 : 
          1'b 0; 
  
   // Decode for 16-bit byte st with unsigned 5-bit data
   //
   assign i_p2b_opcode_16_stb_u5_a = (i_p2b_opcode_r == OP_16_STB_U5) ? 1'b 1 : 
          1'b 0; 
  
   // Decode for 16-bit word st with unsigned 6-bit data
   //
   assign i_p2b_opcode_16_stw_u6_a = (i_p2b_opcode_r == OP_16_STW_U6) ? 1'b 1 : 
          1'b 0; 
  
   // Decode for 16-bit add & cmp major opcodes
   //
   assign i_p2b_opcode_16_addcmp_a = (i_p2b_opcode_r == OP_16_ADDCMP) ? 1'b 1 : 
          1'b 0; 

   // Decode for 16-bit arithmetic instructions
   //
   assign i_p2b_opcode_16_arith_a = (i_p2b_opcode_r == OP_16_ARITH) ? 1'b 1 : 
          1'b 0; 

   // Decode for 32-bit Load register + offset.
   //
   assign i_p2b_opcode_32_ld_a = (i_p2b_opcode_r == OP_LD) ? 1'b 1 : 
          1'b 0; 

   // Decode 32-bit St with signed 9-bit offset.
   //
   assign i_p2b_opcode_32_st_a = (i_p2b_opcode_r == OP_ST) ? 1'b 1 : 
          1'b 0; 

//------------------------------------------------------------------------------
// Subopcode decodes
//------------------------------------------------------------------------------
    
   // Decode for 32-bit single operand flag instruction
   //
   assign i_p2b_subopcode_flag_a = (i_p2b_subopcode_r == SO_FLAG) ? 1'b 1 : 
          1'b 0;
  
   // Decode for 32-bit auxiliary load
   //
   assign i_p2b_subopcode_lr_a = (i_p2b_subopcode_r == SO_LR) ? 1'b 1 : 
          1'b 0;
  
   // Decode for 32-bit auxiliary load
   //
   assign i_p2b_subopcode_sr_a = (i_p2b_subopcode_r == SO_SR) ? 1'b 1 : 
          1'b 0;
  
   // Decode for 32-bit jump with delay slot
   //
   assign i_p2b_subopcode_jd_a = (i_p2b_subopcode_r == SO_J_D) ? 1'b 1 : 
          1'b 0;

   // Decode for 32-bit jump&link with delay slot
   //
   assign i_p2b_subopcode_jld_a = (i_p2b_subopcode_r == SO_JL_D) ? 1'b 1 : 
          1'b 0;
  
   // Decode for 32-bit jump
   //
   assign i_p2b_subopcode_j_a = (i_p2b_subopcode_r == SO_J) ? 1'b 1 : 
          1'b 0;
  
   // Decode for 32-bit jump&link
   //
   assign i_p2b_subopcode_jl_a = (i_p2b_subopcode_r == SO_JL) ? 1'b 1 : 
          1'b 0;
 
   // Decode for 32-bit load
   //
   assign i_p2b_subopcode_ld_a = (i_p2b_subopcode_r == SO_LD) ? 1'b 1 : 
          1'b 0;
 
   // Decode for 32-bit load
   //
   assign i_p2b_subopcode_ldb_a = (i_p2b_subopcode_r == SO_LDB) ? 1'b 1 : 
          1'b 0;
   
   // Decode for 32-bit byte load with sign extension
   //
   assign i_p2b_subopcode_ldb_x_a = (i_p2b_subopcode_r == SO_LDB_X) ? 1'b 1 : 
          1'b 0;
  
   // Decode for 32-bit word load
   //
   assign i_p2b_subopcode_ldw_a = (i_p2b_subopcode_r == SO_LDW) ? 1'b 1 : 
          1'b 0;
   
   // Decode for 32-bit word load with sign extension
   //
   assign i_p2b_subopcode_ldw_x_a = (i_p2b_subopcode_r == SO_LDW_X) ? 1'b 1 : 
          1'b 0;
    
   // Decode for 16-bit single operand instructions
   //
   assign i_p2b_subop_16_sop_a = (i_p2b_subopcode2_r == SO16_SOP) ? 1'b 1 : 
          1'b 0;
  
   assign i_p2b_subop_16_mov_hi2_a = (i_p2b_subopcode1_r == SO16_MOV_HI2) ?
          1'b 1 : 
          1'b 0; 
     
     
   assign i_p2b_subop_16_push_u7_a = (i_p2b_subopcode3_r == SO16_PUSH_U7) ?
          1'b 1 : 
          1'b 0; 
     
   assign i_p2b_subop_16_pop_u7_a = (i_p2b_subopcode3_r == SO16_POP_U7) ?
          1'b 1 : 
          1'b 0; 

   assign i_p2b_subop_16_ld_a = (i_p2b_subopcode1_r == SO16_LD) ? 1'b 1 : 
        1'b 0; 
     
   assign i_p2b_subop_16_ldb_a = (i_p2b_subopcode1_r == SO16_LDB) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_subop_16_ldw_a = (i_p2b_subopcode1_r == SO16_LDW) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_subop_16_brk_a = (i_p2b_subopcode2_r == SO16_BRK) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_subop_16_st_sp_a = (i_p2b_subopcode3_r == SO16_ST_SP) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_subop_16_stb_sp_a = (i_p2b_subopcode3_r == SO16_STB_SP) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_subop_16_ld_sp_a = (i_p2b_subopcode3_r == SO16_LD_SP) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_subop_16_ldb_sp_a = (i_p2b_subopcode3_r == SO16_LDB_SP) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_subop_16_ld_gp_a = (i_p2b_subopcode7_r == SO16_LD_GP) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_subop_16_ldb_gp_a = (i_p2b_subopcode7_r == SO16_LDB_GP) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_subop_16_ldw_gp_a = (i_p2b_subopcode7_r == SO16_LDW_GP) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_c_field16_zop_a = (i_p2b_c_field16_r == SO16_SOP_ZOP) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_c_field16_sop_sub_a = (i_p2b_c_field16_r == SO16_SOP_SUB) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_c_field16_sop_jd_a = (i_p2b_c_field16_r == SO16_SOP_JD) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_c_field16_sop_jld_a = (i_p2b_c_field16_r == SO16_SOP_JLD) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_c_field16_sop_j_a = (i_p2b_c_field16_r == SO16_SOP_J) ? 1'b 1 : 
          1'b 0; 

   assign i_p2b_c_field16_sop_jl_a = (i_p2b_c_field16_r == SO16_SOP_JL) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_b_field16_zop_jeq_a = (i_p2b_b_field16_r == SO16_ZOP_JEQ) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_b_field16_zop_jne_a = (i_p2b_b_field16_r == SO16_ZOP_JNE) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_b_field16_zop_jd_a = (i_p2b_b_field16_r == SO16_ZOP_JD) ? 1'b 1 : 
          1'b 0; 
     
   assign i_p2b_b_field16_zop_j_a = (i_p2b_b_field16_r == SO16_ZOP_J) ? 1'b 1 : 
          1'b 0; 

   // Decode for 16-bit single operand subtract
   //
   assign i_p3_sop_sub_nxt = (i_p2b_opcode_16_alu_a & 
                              i_p2b_subop_16_sop_a & 
                              i_p2b_c_field16_sop_sub_a); 

   //  Auxiliary Load.
   // 
   assign i_p2b_lr_decode_a = (i_p2b_opcode_32_fmt1_a & 
                               i_p2b_subopcode_lr_a); 

   //  Auxiliary Store.
   // 
   assign i_p2b_sr_decode_a = (i_p2b_opcode_32_fmt1_a & i_p2b_subopcode_sr_a); 


   // Data cache bypass set when ".di" is spicified in the instruction word..
   //
   assign i_p2b_nocache_a = i_p2b_mop_e_a[DC_BYPASS]; 
   
   // Detect JMPs in stage 2b. Used for delaying actionpoint trigger until jmps resolve 
   assign p2b_jmp_holdup_a = i_p2b_holdup_stall_a & i_p2b_jmp_cc_a & i_p2b_iv_r; 

//------------------------------------------------------------------------------
// Ld/St information
//------------------------------------------------------------------------------
//
// The load instruction has two opcodes ldr (0x02) and OP_FMT1 (0x04). The
// auxiliary LR instruction is encoded on the OP_FMT1 instruction slot, so must
// be excluded when producing a signal which indicates that a load instruction
// is in stage 2.
//
   // The 32-bit Loads employ 2 opcode slots :
   //
   // [1] LD reg + 9-bit signed offset,
   // [2] LD reg + reg.
   //
   // The 16-bit Loads employ 7 opcode slots :
   //
   // [1] LD reg + reg, LDB reg + reg, LDW reg + reg,
   // [2] LD reg + unsigned 7-bit
   // [3] LDB reg + unsigned 5-bit
   // [4] LDW reg + unsigned 6-bit
   // [5] LDW.X reg + unsigned 6-bit
   // [6] LD  PC
   // [7] LD SP + unsigned 7-bit, LDB SP + unsigned 7-bit, PUSH
   // [8] LD GP + signed 9-bit.
   //
   assign i_p2b_ld_decode_a = (i_p2b_opcode_32_ld_a 
                        | 
                        i_p2b_opcode_32_fmt1_a & 
                        (i_p2b_subopcode_ld_a | 
                        i_p2b_subopcode_ldb_a | 
                        i_p2b_subopcode_ldb_x_a | 
                        i_p2b_subopcode_ldw_a | 
                        i_p2b_subopcode_ldw_x_a) 
                        | 
                        ((i_p2b_opcode_16_ld_add_a & 
                         (i_p2b_subop_16_ld_a | 
                          i_p2b_subop_16_ldb_a | 
                          i_p2b_subop_16_ldw_a) 
                         | 
                         i_p2b_ldo16_a 
                         | 
                         i_p2b_opcode_16_ld_pc_a 
                         | 
                         (i_p2b_opcode_16_sp_rel_a & 
                          (i_p2b_subop_16_ld_sp_a | 
                           i_p2b_subop_16_ldb_sp_a | 
                           i_p2b_subop_16_pop_u7_a))
                         | 
                         i_p2b_opcode_16_gp_rel_a & 
                         (i_p2b_subop_16_ld_gp_a | 
                          i_p2b_subop_16_ldb_gp_a | 
                          i_p2b_subop_16_ldw_gp_a)))); 

   //  The 16-bit Stores employ 4 opcode slots :
   // 
   //  [1] ST reg + unsigned 7-bit
   //  [2] STB reg + unsigned 5-bit
   //  [3] STW reg + unsigned 6-bit
   //  [4] ST SP + unsigned 7-bit, STB SP + unsigned 7-bit, POP
   // 
   assign i_p2b_st_decode_a = (i_p2b_opcode_32_st_a | 
                               (i_p2b_sto16_a       | 
                                i_p2b_opcode_16_sp_rel_a & 
                                (i_p2b_subop_16_st_sp_a | 
                                 i_p2b_subop_16_stb_sp_a | 
                                 i_p2b_subop_16_push_u7_a))); 

   //  16-bit LD register + offset instructions.
   // 
   assign i_p2b_ldo16_a = (i_p2b_opcode_16_ld_u7_a  | 
                           i_p2b_opcode_16_ldb_u5_a | 
                           i_p2b_opcode_16_ldw_u6_a | 
                           i_p2b_opc_16_ldwx_u6_a); 

   //  16-bit ST register + offset instructions.
   // 
   assign i_p2b_sto16_a = (i_p2b_opcode_r == OP_16_ST_U7 | 
                           i_p2b_opcode_r == OP_16_STB_U5 | 
                           i_p2b_opcode_r == OP_16_STW_U6) ?
          1'b 1 : 
          1'b 0; 

   //  Now extract the extra encoding information used for loads and
   //  stores. The signals are extracted and latched at the end of stage
   //  2.
   // 
   //  ** Note that the signals used, i_p2b_ldo and i_p2b_st, include the
   //  checks that exclude LR and SR. This is correct as LR and SR do not
   //  use the encoding information which is extracted here. **
   // 
   assign i_p2b_ldr_e_a = {i_p2b_iw_r[LDR_DC_BYPASS], 
                           i_p2b_iw_r[LDR_ADDR_WB_UBND:LDR_ADDR_WB_LBND], 
                           i_p2b_iw_r[LDR_SIZE_UBND:LDR_SIZE_LBND], 
                           i_p2b_iw_r[LDR_SIGN_EXT]}; 

   // This signal contains information used for the LD/ST operations. The
   // information contains bypass mode, address update, operation size and
   // sign-extension
   //
   assign i_p2b_mop_e_a = ((i_p2b_iw_r[LDO_EUBND:LDO_ELBND] & 
                     ({(MEMOP_ESZ+1){i_p2b_opcode_32_ld_a}})) 
                     |
                       (i_p2b_iw_r[ST_EUBND:ST_ELBND] & 
                     ({(MEMOP_ESZ+1){i_p2b_opcode_32_st_a}}))
                     |                     
                     (i_p2b_ldr_e_a & 
                     ({(MEMOP_ESZ+1){~(i_p2b_opcode_32_st_a | 
                                  i_p2b_opcode_32_ld_a)}}))); 

//------------------------------------------------------------------------------
// Ld/St size of memory operation
//------------------------------------------------------------------------------
//
   // Decode for implicitly implied longword ld/st
   //
   assign i_p2b_size_sel0_a = ((i_p2b_opcode_16_st_u7_a == 1'b 1) 
                        | 
                        (i_p2b_opcode_16_ld_u7_a == 1'b 1) 
                        | 
                        (i_p2b_opcode_16_ld_pc_a == 1'b 1) 
                        | 
                        ((i_p2b_opcode_16_ld_add_a == 1'b 1) & 
                        (i_p2b_subop_16_ld_a == 1'b 1)) 
                        | 
                        ((i_p2b_opcode_16_sp_rel_a == 1'b 1) & 
                        ((i_p2b_subop_16_st_sp_a == 1'b 1) | 
                         (i_p2b_subop_16_push_u7_a == 1'b 1) | 
                         (i_p2b_subop_16_ld_sp_a == 1'b 1) | 
                         (i_p2b_subop_16_pop_u7_a == 1'b 1))) 
                        | 
                        ((i_p2b_opcode_16_gp_rel_a == 1'b 1) & 
                        (i_p2b_subop_16_ld_gp_a == 1'b 1))) ? 1'b 1 : 
        1'b 0; 

   // Decode for implicitly implied byte ld/st
   //
   assign i_p2b_size_sel1_a = ((i_p2b_opcode_16_stb_u5_a == 1'b 1) 
                        | 
                        (i_p2b_opcode_16_ldb_u5_a == 1'b 1) 
                        | 
                        ((i_p2b_opcode_16_ld_add_a == 1'b 1) & 
                        (i_p2b_subop_16_ldb_a == 1'b 1)) 
                        | 
                        ((i_p2b_opcode_16_sp_rel_a == 1'b 1) & 
                        ((i_p2b_subop_16_stb_sp_a == 1'b 1) | 
                         (i_p2b_subopcode3_r == SO16_LDB_SP)))
                        | 
                        ((i_p2b_opcode_16_gp_rel_a == 1'b 1) & 
                        (i_p2b_subopcode7_r == SO16_LDB_GP))) ? 1'b 1 : 
        1'b 0; 

   // Decode for implicitly implied word ld/st
   //
   assign i_p2b_size_sel2_a = ((i_p2b_opcode_16_stw_u6_a == 1'b 1) 
                        | 
                        (i_p2b_opcode_16_ldw_u6_a == 1'b 1) 
                        | 
                        (i_p2b_opc_16_ldwx_u6_a == 1'b 1) 
                        | 
                        ((i_p2b_opcode_16_ld_add_a == 1'b 1) & 
                        (i_p2b_subop_16_ldw_a == 1'b 1))
                        | 
                        ((i_p2b_opcode_16_gp_rel_a == 1'b 1) & 
                        (i_p2b_subop_16_ldw_gp_a == 1'b 1))) ? 1'b 1 : 
        1'b 0; 

   // Decode for implicitly implied word ld/st
   //
   assign i_p2b_size_sel3_a = (~(i_p2b_size_sel0_a | 
                        i_p2b_size_sel1_a | 
                        i_p2b_size_sel2_a)); 


   // Select the correct size for the memory operation
   //
   assign i_p2b_size_a = (LDST_LWORD & {(TWO){i_p2b_size_sel0_a}} 
                          |
                          LDST_BYTE & {(TWO){i_p2b_size_sel1_a}} 
                          |
                          LDST_WORD & {(TWO){i_p2b_size_sel2_a}} 
                          |
                          i_p2b_mop_e_a[LDST_SIZE_UBND:LDST_SIZE_LBND] &
                          {(TWO){i_p2b_size_sel3_a}}); 

//------------------------------------------------------------------------------
// Sign-extension bit for ld/st
//------------------------------------------------------------------------------
//
// Decode for sign extension first two terms are used for the implicitly implied
// instructions and the last term is for the explicitly implied instructions.
//
   assign i_p2b_sex_a = (i_p2b_opc_16_ldwx_u6_a == 1'b 1) ? 
          1'b 1 : 
                        ((i_p2b_opcode_16_ld_add_a == 1'b 1) | 
                         (i_p2b_opcode_16_ld_u7_a  == 1'b 1) | 
                         (i_p2b_opcode_16_ld_pc_a  == 1'b 1) | 
                         (i_p2b_opcode_16_ldb_u5_a == 1'b 1) | 
                         (i_p2b_opcode_16_ldw_u6_a == 1'b 1) | 
                         (i_p2b_opcode_16_sp_rel_a == 1'b 1) | 
                         (i_p2b_opcode_16_gp_rel_a == 1'b 1)) ? 
          1'b 0 : 
          i_p2b_mop_e_a[LDST_SIGN_EXT]; 

//------------------------------------------------------------------------------
// Address write-back mode for ld/st
//------------------------------------------------------------------------------
//
   // 16-bit pre address update addressing mode.  Address = src1 and
   // writeback = (src1 + src2)
   // 
   assign i_p2b_awb_field_sel0_a = (i_p2b_opcode_16_sp_rel_a & 
                                    i_p2b_subop_16_pop_u7_a); 

   // 16-bit post address update addressing mode.  Address = (src1 + src2) and
   // writeback = (src1 + src2)
   // 
   assign i_p2b_awb_field_sel1_a = (i_p2b_opcode_16_sp_rel_a & 
                                    i_p2b_subop_16_push_u7_a); 

   // 16-bit NO address update addressing mode. Address = (src1 + src2)
   // 
   assign i_p2b_awb_field_sel2_a = ((i_p2b_opcode_16_ld_add_a |
                                     i_p2b_ldo16_a            |
                                     i_p2b_opcode_16_ld_pc_a  |
                                     i_p2b_sto16_a            |
                                     i_p2b_opcode_16_gp_rel_a | 
                                     (i_p2b_opcode_16_sp_rel_a & 
                                     (i_p2b_subop_16_stb_sp_a | 
                                      i_p2b_subop_16_st_sp_a  | 
                                      i_p2b_subop_16_ld_sp_a  | 
                                      i_p2b_subop_16_ldb_sp_a)))); 

   // Explictly implied update mode
   //
   assign i_p2b_awb_field_sel3_a = (~(i_p2b_awb_field_sel0_a | 
                                     i_p2b_awb_field_sel1_a | 
                                     i_p2b_awb_field_sel2_a)); 

   // Stage 3 pre decode for pre-update addressing.
   //
   assign i_p3_awb_pre_wb_nxt = ((i_p2b_awb_field_sel0_a == 1'b 1) | 
                         (i_p2b_mop_e_a[LDST_ADDR_WB_UBND:
                                    LDST_ADDR_WB_LBND] == LDST_PRE_WB) & 
                         (i_p2b_awb_field_sel3_a == 1'b 1)) ? 1'b 1 : 
        1'b 0; 


   // This is true when a memory operation (ld/ldo/st) requires an
   // address writeback. Note that p3iv is not explicitly included
   // here, as it is part of mload3 and mstore3.
   //
   assign i_p3_ldst_awb_nxt = (((i_p2b_st_decode_a == 1'b 1) | 
                               (i_p2b_ld_decode_a == 1'b 1)) & 
                        ((i_p3_awb_pre_wb_nxt == 1'b 1) | 
                         ((i_p2b_awb_field_sel1_a == 1'b 1) | 
                          (i_p2b_mop_e_a[LDST_ADDR_WB_UBND:
                                    LDST_ADDR_WB_LBND] == LDST_POST_WB) & 
                          (i_p2b_awb_field_sel3_a == 1'b 1)))) ? 1'b 1 : 
        1'b 0; 


   // Select the correct address mode for the current instruction.
   //
   assign i_p2b_awb_field_a = (LDST_PRE_WB &
                               ({(LDST_AWB_WIDTH){i_p2b_awb_field_sel0_a}}) 
                               |
                               LDST_POST_WB &
                               ({(LDST_AWB_WIDTH){i_p2b_awb_field_sel1_a}}) 
                               | 
                               LDST_NO_WB &
                               ({(LDST_AWB_WIDTH){i_p2b_awb_field_sel2_a}}) 
                               | 
                               i_p2b_mop_e_a[LDST_ADDR_WB_UBND:
                                             LDST_ADDR_WB_LBND] &
                               ({(LDST_AWB_WIDTH){i_p2b_awb_field_sel3_a}})); 

//------------------------------------------------------------------------------
// Destination address register field.
//------------------------------------------------------------------------------
//
// Here the destination field for writeback to the register is
// derived from the A-field or C-field when:
//
// [1] From the 16-bit instruction C-field when the instruction type
//     adds, subtracts, asl and asr with result writeback and opcode
//     is 0x0D.
//
// [2] From the 16-bit instruction Hi register-field (i_p2b_hi_reg16_r)
//     when the opcode is equal to 0x0E and the destination register
//     is between r0 - r63.
//
// [3] From the 16-bit instruction A-field (i_p2b_a_field16_r) when
//     the opcode is greater than 0x07.
//
// [4] Or from the 32-bit instruction (i_p2b_a_field_r).
//

   assign i_p2b_a_field_a_sel0_a = (i_p2b_opcode_16_mv_add_a & 
                                    i_p2b_subop_16_mov_hi2_a); 

   assign i_p2b_a_field_a_sel1_a = (~(i_p2b_opcode_16_arith_a | 
                                     i_p2b_a_field_a_sel0_a | 
                                     i_p2b_16_bit_instr_a)); 

   // Select the A field register.
   //
   assign i_p2b_a_field_a = (i_p2b_c_field16_2_r &
                             ({(OPERAND_WIDTH){i_p2b_opcode_16_arith_a}}) 
                             |
                             i_p2b_hi_reg16_r &
                             ({(OPERAND_WIDTH){i_p2b_a_field_a_sel0_a}}) 
                             |
                             i_p2b_a_field16_r &
                             ({(OPERAND_WIDTH){i_p2b_16_bit_instr_a}})
                             |
                             i_p2b_a_field_r &
                             ({(OPERAND_WIDTH){i_p2b_a_field_a_sel1_a}}));

//------------------------------------------------------------------------------
// Stage 3 pre-decode for destination address field.
//------------------------------------------------------------------------------
//
   // Select b field for ld instructions.
   //
  assign i_p3_sc_dest_nxt_sel1_a = (i_p2b_iv_r        & 
                                    i_p2b_ld_decode_a & 
                                    (~i_p3_sc_dest_nxt_sel2_a)); 

   // Select the stack pointer register for push/pop operations as they will
   // update the stack pointer.
   //
   assign i_p3_sc_dest_nxt_sel2_a = (i_p2b_iv_r & 
                                     i_p2b_opcode_16_sp_rel_a & 
                                     (i_p2b_subop_16_push_u7_a | 
                                      i_p2b_subop_16_pop_u7_a)); 

   // Select destination from stage 2b.
   //
   assign i_p3_sc_dest_nxt_sel3_a = (~(i_p3_sc_dest_nxt_sel1_a | 
                                      i_p3_sc_dest_nxt_sel2_a)); 


   assign i_p3_sc_dest_nxt = (i_p2b_b_field_r &
                              ({(OPERAND_WIDTH){i_p3_sc_dest_nxt_sel1_a}}) 
                              | 
                              RSTACKPTR &
                              ({(OPERAND_WIDTH){i_p3_sc_dest_nxt_sel2_a}}) 
                              | 
                              i_p2b_destination_r &
                              ({(OPERAND_WIDTH){i_p3_sc_dest_nxt_sel3_a}})); 



//------------------------------------------------------------------------------
// Jump condition code evaluation 
//------------------------------------------------------------------------------
//
   always @(aluflags_r or i_p2b_q_r)
    begin : p2b_ccunit_32_PROC

      i_p2b_ccunit_32_fz_a = aluflags_r[A_Z_N];   
      i_p2b_ccunit_32_fn_a = aluflags_r[A_N_N];   
      i_p2b_ccunit_32_fc_a = aluflags_r[A_C_N];   
      i_p2b_ccunit_32_fv_a = aluflags_r[A_V_N];   
      i_p2b_ccunit_32_nfz_a = ~aluflags_r[A_Z_N];   
      i_p2b_ccunit_32_nfn_a = ~aluflags_r[A_N_N];   
      i_p2b_ccunit_32_nfc_a = ~aluflags_r[A_C_N];   
      i_p2b_ccunit_32_nfv_a = ~aluflags_r[A_V_N];   

      case (i_p2b_q_r[CCUBND:0]) 
        CCZ:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_fz_a; //   Z,  EQ
         end
        CCNZ:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_nfz_a;//   NZ, NE
         end
        CCPL:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_nfn_a;//   PL, P
         end
        CCMI:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_fn_a; //   MI, N
         end
        CCCS:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_fc_a; //   CS, C
         end
        CCCC:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_nfc_a;//   CC, NC
         end
        CCVS:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_fv_a; //   VS, V
         end
        CCVC:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_nfv_a;//   VC, NV
         end
        CCGT:
         begin
            i_p2b_ccmatch32_a = ((i_p2b_ccunit_32_fn_a & 
                               i_p2b_ccunit_32_fv_a & 
                             i_p2b_ccunit_32_nfz_a)
                            | 
                            (i_p2b_ccunit_32_nfn_a & 
                             i_p2b_ccunit_32_nfv_a & 
                             i_p2b_ccunit_32_nfz_a));//   GT
         end
        CCGE:
         begin
            i_p2b_ccmatch32_a = ((i_p2b_ccunit_32_fn_a & i_p2b_ccunit_32_fv_a)
                            | 
                            (i_p2b_ccunit_32_nfn_a & 
                             i_p2b_ccunit_32_nfv_a)); //   GE
         end
        CCLT:
         begin
            i_p2b_ccmatch32_a = ((i_p2b_ccunit_32_fn_a & 
                             i_p2b_ccunit_32_nfv_a)
                            | 
                            (i_p2b_ccunit_32_nfn_a & 
                             i_p2b_ccunit_32_fv_a));  //   LT
         end
        CCLE:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_fz_a |
                                i_p2b_ccunit_32_fn_a & 
                                i_p2b_ccunit_32_nfv_a | 
                                i_p2b_ccunit_32_nfn_a & 
                                i_p2b_ccunit_32_fv_a; //   LE
         end
        CCHI:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_nfc_a & 
                                i_p2b_ccunit_32_nfz_a;//   HI
         end
        CCLS:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_fc_a | 
                                i_p2b_ccunit_32_fz_a; //   LS
         end
        CCPNZ:
         begin
            i_p2b_ccmatch32_a = i_p2b_ccunit_32_nfn_a & 
                                i_p2b_ccunit_32_nfz_a;//   PNZ
         end
        default:
         begin
            i_p2b_ccmatch32_a = 1'b 1;//   AL
         end
      endcase
    end 
   

   // Select the z flag for implicitly implied equal to zero condition code.
   //
   assign i_p2b_condtrue_sel0_a = ((i_p2b_opcode_16_alu_a     == 1'b 1) & 
                                   (i_p2b_subop_16_sop_a      == 1'b 1) & 
                                   (i_p2b_c_field16_zop_a     == 1'b 1) & 
                                   (i_p2b_b_field16_zop_jeq_a == 1'b 1)) ?
          1'b 1 : 
          1'b 0;

   // Select the z flag for implicitly implied not equal to zero condition code.
   //
   assign i_p2b_condtrue_sel1_a = ((i_p2b_opcode_16_alu_a     == 1'b 1) & 
                                   (i_p2b_subop_16_sop_a      == 1'b 1) & 
                                   (i_p2b_c_field16_zop_a     == 1'b 1) & 
                                   (i_p2b_b_field16_zop_jne_a == 1'b 1)) ?
          1'b 1 : 
          1'b 0; 


   // Set condition true for always execute control transfers.
   //
   assign i_p2b_condtrue_sel2_a = (((i_p2b_opcode_32_fmt1_a    == 1'b 1) & 
                                    (i_p2b_fmt_cond_reg_a      == 1'b 0))
                                   | 
                                   ((((i_p2b_16_sop_inst_a     == 1'b 1) &
                                      (i_p2b_c_field16_zop_a   == 1'b 1) &
                                      (i_p2b_b_field16_zop_j_a == 1'b 1))
                                     | 
                                     (i_p2b_jmp16_no_dly_sop_a | 
                                      (i_p2b_jmp16_delay_a)    == 1'b 1)))) ?
          1'b 1 : 
          1'b 0; 

   // Use condition code checking signal for all other types of instructions.
   //
   assign i_p2b_condtrue_sel3_a = ((i_p2b_opcode_32_fmt1_a == 1'b 1) | 
                                   (x_p2b_jump_decode == 1'b 1)) & 
                                   (i_p2b_fmt_cond_reg_a == 1'b 1) ?
          1'b 1 : 
          1'b 0; 

   // AND-ORcd Mux
   //
   assign i_p2b_condtrue_a = (aluflags_r[A_Z_N] & i_p2b_condtrue_sel0_a 
                       | 
                       (~aluflags_r[A_Z_N]) & i_p2b_condtrue_sel1_a
                       | 
                       i_p2b_condtrue_sel2_a 
                       | 
                       i_p2b_ccmatch_alu_ext_a & i_p2b_condtrue_sel3_a); 


   // This signal is true when an instruction in stage 2 that employs
   // an extension condition code has been set.
   //
   assign i_p2b_ccmatch_alu_ext_a = ((i_p2b_iw_r[CCXBPOS] == 1'b 0) | 
                                        (XT_JMPCC == 1'b 0)) ? 
          i_p2b_ccmatch32_a : 
          xp2bccmatch;

//------------------------------------------------------------------------------
// Stage 2b conditional instruction. 
//------------------------------------------------------------------------------
//
// This signal is true when the instruction in stage 2 is conditional and does
// not have an "always" condition.
//
   assign i_p2b_conditional_a = (((i_p2b_q_r != FIVE_ZERO) & 
                          (i_p2b_fmt_cond_reg_a == 1'b 1) & 
                          ((i_p2b_opcode_32_fmt1_a == 1'b 1) 
                           | 
                           (x_idecode2b == 1'b 1) 
                           | 
                           (x_p2b_jump_decode == 1'b 1)))
                         | 
                         (i_p2b_jmp16_cc_a | 
                          i_p3_sop_sub_nxt) == 1'b 1) ? i_p2b_iv_r : 
        1'b 0; 

//------------------------------------------------------------------------------
// STAGE 2B Jump Decodes
//------------------------------------------------------------------------------

   // Delay slot TRUE for J/JL
   //
   assign i_p2b_jmp32_delay_a = (i_p2b_opcode_32_fmt1_a & 
                                 (i_p2b_subopcode_jd_a |
                                  i_p2b_subopcode_jld_a)); 

   //  Delay slot FALSE for 32-bit J/JL
   // 
   assign i_p2b_jmp32_no_delay_a = (i_p2b_opcode_32_fmt1_a & 
                                    (i_p2b_subopcode_j_a | 
                                     i_p2b_subopcode_jl_a)); 

   //  Delay slot FALSE for SOP 16-bit J/JL
   // 
   assign i_p2b_jmp16_no_dly_sop_a = (i_p2b_16_sop_inst_a & 
                                        (i_p2b_c_field16_sop_j_a | 
                                         i_p2b_c_field16_sop_jl_a)); 

   //  Delay slot FALSE for 16-bit J/JL
   // 
   assign i_p2b_jmp16_no_delay_a = (i_p2b_jmp16_no_dly_sop_a | 
                                    i_p2b_16_sop_inst_a   & 
                                    i_p2b_c_field16_zop_a & 
                                    (i_p2b_b_field16_zop_jeq_a | 
                                     i_p2b_b_field16_zop_jne_a | 
                                     i_p2b_b_field16_zop_j_a)); 

   //  Delay slot TRUE for SOP 16-bit J/JL
   // 
   assign i_p2b_jmp16_delay_sop_a = (i_p2b_16_sop_inst_a & 
                                     (i_p2b_c_field16_sop_jd_a | 
                                      i_p2b_c_field16_sop_jld_a)); 

   //  Delay slot TRUE for 16-bit J/JL
   // 
   assign i_p2b_jmp16_delay_a = (i_p2b_jmp16_delay_sop_a 
                         | 
                         (i_p2b_16_sop_inst_a & 
                          i_p2b_c_field16_zop_a & 
                          i_p2b_b_field16_zop_jd_a)); 

   assign i_p2b_jmp32_niv_a = i_p2b_jmp32_delay_a | i_p2b_jmp32_no_delay_a; 

   //  Conditionally executed jump instructions.
   // 
   assign i_p2b_jmp32_cc_a = (i_p2b_opcode_32_fmt1_a & 
                              i_p2b_fmt_cond_reg_a & 
                              (i_p2b_jmp32_delay_a | 
                               i_p2b_jmp32_no_delay_a)); 

   assign i_p2b_jmp16_cc_a = (i_p2b_opcode_16_alu_a & 
                              i_p2b_subop_16_sop_a  & 
                              i_p2b_c_field16_zop_a & 
                              (i_p2b_b_field16_zop_jeq_a | 
                               i_p2b_b_field16_zop_jne_a)); 

   assign i_p2b_jmp16_niv_a = (i_p2b_jmp16_delay_a | 
                               i_p2b_jmp16_no_delay_a); 

   //  This includes both the 32-bit and 16-bit decodes for all branch
   //  and branch & link instructions.
   // 
   assign i_p2b_jmp_iv_a = i_p2b_jmp_niv_a & i_p2b_iv_r; 
   assign i_p2b_jmp_niv_a = i_p2b_jmp16_niv_a | i_p2b_jmp32_niv_a; 
   assign i_p2b_jmp_cc_a = i_p2b_jmp16_cc_a | i_p2b_jmp32_cc_a; 


//------------------------------------------------------------------------------
// Stage 2 Jump Not Taken
//------------------------------------------------------------------------------
//
   assign i_p2b_nojump_a = i_p2b_iv_r & (~i_p2b_condtrue_a) & i_p2b_jmp_cc_a; 

//------------------------------------------------------------------------------
// Stage 2 Jump Taken
//------------------------------------------------------------------------------
//
   // Do a jump indirect (but only when the instruction in pipeline stage 2 is
   // valid). Combine 32 and 16-bit relative jumps. Don't set this signal if the
   // machine is waiting for a LIMM or dslot or the PC will not be correct.
   // Without this signal the jump would place rubbish onto next_pc because it
   // has a higher priority then linear PC updates.
   //  
   assign i_p2b_dojcc_a = (~i_p2b_limm_dslot_stall_r) & (i_p2b_iv_r       & 
                                                       i_p2b_condtrue_a &
                                                       i_p2b_jmp_niv_a); 

//------------------------------------------------------------------------------
// Delay slot cancelling
//------------------------------------------------------------------------------
//
   // Jump instructions may kill the following instructions depending on the
   // delay slot mode and whether the instruction's condition is true.
   //  
   assign i_p2b_kill_p1_a = i_p2b_dojcc_a; 

   assign i_p2b_kill_p1_en_a = i_p2b_dojcc_a & i_p2b_enable_a;
 
   assign i_p2b_kill_p2_a = ((i_p2b_has_dslot_r == 1'b 0) &
                             (i_p2b_dojcc_a == 1'b 1)) ? 1'b 1 : 
          1'b 0; 

   assign i_p2b_kill_p2_en_a = i_p2b_kill_p2_a & i_p2b_enable_a; 


//------------------------------------------------------------------------------
// Store link register for branch and link.
//------------------------------------------------------------------------------
//
   // This signal is set true when a valid branch-and-link instruction is in
   // stage 2b, and the condition is valid, meaning that the register should be
   // passed down the pipeline to go into the register file. It is necessary to
   // latch this signal into p3dolink as the condition code may evaluate with a
   // different result when the instruction gets to stage 3.
   //
   assign i_p3_dolink_nxt = ((i_p2b_jlcc_iv_a & i_p2b_condtrue_a) | 
                             // There was a link instruction taken the cycle 
                             // before.
                             //.
                             i_p2b_dolink_iv_a);
   
  
//------------------------------------------------------------------------------
// Stage 2b Flag Setting
//------------------------------------------------------------------------------
//
// Stage 2b calculation to decide whether to set the flags.
//
// This uses either the .f bit of the instruction, the value implied by the
// short immediate data register number, or is set false if the instruction
// cannot set the flags (load/store, branches/jump).
//
// Special case flag-setters Jcc.F and FLAG are handled separately in flags.
// This signal does not include p3iv. For 16-bit instructions the flag
// setting capability is implied by the instruction type, i.e. CMP, BTST.
//
   // If a 3-operand extension instruction is being used, the flags are not
   // set.
   //
   assign i_p2b_setflags_nxt = (f_no_fset(i_p2_opcode_a, 
                               i_p2_subopcode_r, 
                               i_p2_subopcode3_r, 
                               i_p2_c_field_r, 
                               i_p2_format_r)               == 1'b 1) ? 
          1'b 0 : 
                               ((i_p2_opcode_16_mv_add_a     == 1'b 1) & 
                                (i_p2_subopcode1_r           == SO16_CMP))
                               | 
                               ((i_p2_opcode_16_alu_a        == 1'b 1) & 
                                (i_p2_subopcode2_r           == SO16_TST))
                               | 
                               ((i_p2_opcode_16_ssub_a       == 1'b 1) & 
                                (i_p2_subop_16_btst_u5_a == 1'b 1))
                               | 
                               ((i_p2_opcode_16_addcmp_a     == 1'b 1) & 
                                (i_p2_subopcode4_r           == SO16_CMP_U7)) ?
          1'b 1 : 
          i_p2_flag_bit_a;
  
//------------------------------------------------------------------------------
// Shifting Logic for ADD1/ADD2/ADD
//------------------------------------------------------------------------------
//
   // This signal is common to LD/STs where a shift of one/two place is
   // required left. This is needed to keep logic usage down.
   //
   assign i_p2b_ldst_shift_a = ((i_p2b_opcode_32_ld_a == 1'b 1) 
                        | 
                        ((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                         (i_p2b_subopcode_r[SUBOPCODE_MSB:
                                       SUBOPCODE_MSB_2] == SO16_SOP_SUB))
                        | 
                        (i_p2b_opcode_32_st_a == 1'b 1)) & 
                         (i_p2b_awb_field_a == LDST_SC_NO_WB) ? 1'b 1 : 
          1'b 0; 

   // Here the value for the source 2 operand is shifted by one place left
   // for LD/ST operation which accesses words, and when performing ADD1/
   // SUB1 arithmetic.
   //
   assign i_p2b_shift_by_one_a = (((i_p2b_ldst_shift_a == 1'b 1) & 
                           (i_p2b_size_a == LDST_WORD)) 
                          | 
                          ((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                           ((i_p2b_subopcode_r == SO_ADD1) | 
                           (i_p2b_subopcode_r == SO_SUB1)))
                          | 
                          ((i_p2b_opcode_16_alu_a == 1'b 1) & 
                           (i_p2b_subopcode_r[SUBOPCODE2_16_MSB:
                                        0] == SO16_ADD1))) ? 1'b 1 : 
          1'b 0; 

   // Here the value for the source 2 operand is shifted by two places left
   // for LD/ST operation which accesses longwords, and when performing
   // ADD2/SUB2 arithmetic.
   // 
   assign i_p2b_shift_by_two_a = (((i_p2b_ldst_shift_a == 1'b 1) & 
                           (i_p2b_size_a == LDST_LWORD))
                          | 
                          ((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                           ((i_p2b_subopcode_r == SO_ADD2) | 
                           (i_p2b_subopcode_r == SO_SUB2)))
                          | 
                          ((i_p2b_opcode_16_alu_a == 1'b 1) & 
                           (i_p2b_subopcode_r[SUBOPCODE2_16_MSB:
                                        0] == SO16_ADD2))) ? 1'b 1 : 
          1'b 0; 

   // Here the value for the source 2 operand is shifted by three places
   // left when performing ADD3/SUB3 arithmetic.
   // 
   assign i_p2b_shift_by_three_a = (((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                            ((i_p2b_subopcode_r == SO_ADD3) | 
                             (i_p2b_subopcode_r == SO_SUB3)))
                           | 
                           ((i_p2b_opcode_16_alu_a == 1'b 1) & 
                            (i_p2b_subopcode_r[SUBOPCODE2_16_MSB:
                                          0] == SO16_ADD3))) ? 1'b 1 : 
          1'b 0;    
  
   // No shift is required. Required for the sum-of-product multiplexer.
   //
   assign i_p2b_shift_by_zero_a = ((i_p2b_shift_by_one_a   == 1'b 0) & 
                                   (i_p2b_shift_by_two_a   == 1'b 0) & 
                                   (i_p2b_shift_by_three_a == 1'b 0)) ?
          1'b 1 : 
          1'b 0; 

//------------------------------------------------------------------------------
// Shortcut Control
//------------------------------------------------------------------------------
//
// The shortcut allows the 32-bit result of stage 3 calculations,
// including load, link stores etc, to be available to the instruction
// at stage 2b before the end of the cycle.
// The source registers of the instruction in stage 2b are compared with
// the destination register a register writeback in stage 3, and if
// they match, the appropriate shortcut-enable signals are set true,
// i.e. f_shcut(i_p2_b_field_r)
//
// Shortcutting is not allowed for the loop-count register as this does
// not have write-through, which means that the value written is not
// available to be read for two cycles following a write. If
// shortcutting was enabled, the new value would be available the cycle
// following the write, then on the cycle after that, the old value
// would be read, then on the third cycle following the write, the new
// value would be available direct from the loop count register.
//
// The immediate data registers are excluded from shortcutting here,
// but this is not strictly necessary as immediate data overrides a
// shortcut in coreregs. It will make the decode here easier however as
// loopcount, and the immediate data registers are in a nice 4-register
// block, on a 4-register boundary.
//
// ** Note that the check for registers on which shortcutting is not
// allowed (i.e. loop count, immediates) is done on each of the source
// registers rather than just on the destination register, as the source
// register number is available direct from a latch, so checking these
// values does not extend the critical path, as would a check on the
// destination register. This may of course not be the case, but we may
// as well be safe. **
//
// Extension logic can prevent registers from being shortcut by using
// the signals x_p2nosc1 and x_p2nosc2. This will allow core registers
// to be added which do not behave exactly as 3-port RAM, for example, a
// register which transfers data values to and from a circular buffer in
// a FIR filter system.
//
// Note that when returning loads always cause stalls, then shortcutting
// can never be performed from a returning load, hence no references to
// ldvalid are required. (p3_wb_req does not include ldvalid)
//
// Note that i_p2b_sc_reg1 includes en in order that host-interface reads
// from registers are not affected by instructions in p2 and p3 which
// would otherwise enable a shortcut.
//

   // Shortcut to source 1.
   //
   assign i_p2b_sc_reg1_nwb_a = ((i_p3_sc_wba_a == i_p2b_source1_addr_r) & 
                         (f_shcut(i_p2b_source1_addr_r) == 1'b 1) & 
                         (i_p2b_source1_en_r == 1'b 1) & 
                         ((x_p2nosc1 & XT_COREREG) == 1'b 0) & 
                         (en == 1'b 1)) ? 1'b 1 : 
          1'b 0; 

   //  Shortcut to source 2.
   // 
   assign i_p2b_sc_reg2_nwb_a = ((i_p3_sc_wba_a == i_p2b_source2_addr_r) & 
                                         (f_shcut(i_p2b_source2_addr_r) == 1'b 1) & 
                                 (i_p2b_source2_en_r == 1'b 1) & 
                                 ((x_p2nosc2 & XT_COREREG) == 1'b 0) & 
                                  (en == 1'b 1)) ? 1'b 1 : 
          1'b 0;

   assign i_p2b_sc_reg1_a = (i_p2b_sc_reg1_nwb_a & 
                             ((i_p3_wb_req_a & 
                               i_p3_destination_en_iv_a) 
                              | 
                              (x_multic_wben & 
                               XT_MULTIC_OP))); 

   assign i_p2b_sc_reg2_a = (i_p2b_sc_reg2_nwb_a & 
                             ((i_p3_wb_req_a & 
                               i_p3_destination_en_iv_a)
                              | 
                              (x_multic_wben & 
                               XT_MULTIC_OP))); 

 
// Detect a returning load causing a shortcut.
//
// A returning load will require a shortcut if:
//
//  a. The load target register matches a valid register in stage 2B.
//
//  b. The register is allowed to shortcut.
//
//  c. An extension core register with shortcutting disabled is not
//     being accessed.
//
//  d. The machine is running.
//
// A returning load cannot coincide with a register shortcut on the
// same source register since the load/store unit would stall the
// writing instruction at stage 2b, since a load would be pending on
// the register.
//
// !4p! Systems using a 4p register file use exactly the same logic as
// !4p! 3p regfile systems here. This is because the returning load
// !4p! will be stalling the pipeline, so must be shortcut through to
// !4p! stage 2b. The data will be written into the register file using
// !4p! the path appropriate for a 3p/4p register file system.
//

   assign i_p2b_sc_load1_a = regadr_eq_src1 
                             & (~(x_p2nosc1 & XT_COREREG))
                             ;
   assign i_p2b_sc_load2_a = regadr_eq_src2 
                             & (~(x_p2nosc2 & XT_COREREG))
                             ;

// Detect a returning load to a non-shortcuttable register, which
// would otherwise cause a shortcut. We want to stall stage 2b under
// this condition.
//
// This would be the case when:
//
//  a. The target register matches a valid register being used in
//     stage 2b.
//
//  b. The target register is not shortcuttable - either from
//     f_shcut() or from x_p2nosc1/2
//
//  c. A load is returning, and load-shortcutting is enabled.
//
// !4p! In the case of a 4-port register file, all r0-r31 writes are
// !4p! shortcuttable registers, so will always use the normal
// !4p! writeback path, rather than the direct path. Hence we do not
// !4p! need to alter this logic.
//
   // Returning load no-shortcut onto source 1.
   //
   assign i_p2b_ld_nsc1_a = regadr_eq_src1 & x_p2nosc1; 

   //  Returning load no-shortcut onto source 2.
   // 
   assign i_p2b_ld_nsc2_a = regadr_eq_src2 & x_p2nosc2; 

   //  Combine source 1 and source 2 stall signals.
   // 
   assign i_p2b_ld_nsc_a = (i_p2b_ld_nsc1_a | i_p2b_ld_nsc2_a) &  XT_COREREG; 
  
//------------------------------------------------------------------------------
//  Stall Shortcut to Jcc [Rn]
//------------------------------------------------------------------------------
//
// A common critical path in builds ends at the program counter.
// When there are long extension instruction paths present, the p3result
// signal can arrive very late. It is therefore not helpful to have a
// shortcut path to the program counter which is dependent on the ALU
// result.
//
// Here the ALU and Program counter logic have been adjusted such that
// they do not have a shortcut path from extension ALU results to the
// program counter.
//
// We must therefore generate a stage 2b stall when:
//
//   i. There is a Jump or Jump-and-link in stage 2b
//  ii. A stage 3->2b register shortcut has been detected
// iii. There is an operation in stage 3
//
// Currently, the stall will not occur if either the instruction in
// stage 3 will not write back, or if the jump in stage 2b will not be
// taken. This is clearly the best case, but we may have to extend the
// stall to more conditions if we want to reduce the logic depth.
//
   assign i_p2b_jcc_sc_stall_a = (i_p2b_jmp_niv_a            & 
                                  ((i_p2b_sc_reg2_nwb_a      &
                                    i_p3_destination_en_iv_a &
                                    i_p3_wb_instr_a)        | 
                                    i_p2b_sc_load2_a)); 
                          
//------------------------------------------------------------------------------
// Stage 2b flag setting calculation
//------------------------------------------------------------------------------  
//
   // p2bsetflags just comes from bit 16 of the instruction word. 
   //
   assign i_p2b_flag_bit_r = i_p2b_iw_r[SETFLGPOS]; 

//------------------------------------------------------------------------------  
// Branch Protection System
//------------------------------------------------------------------------------  
// 
//  In order to generate the stall, we also need to detect a valid
//  branch instruction present in stage 2 (i_p2_branch_cc_a).
// 
//  We generate a stall when the two conditions are present together:
// 
//   a. An instruction in stage 3 is attempting to set the flags
//   b. A branch instruction at stage 2 needs to use these new flags
// 
//  Note that it would be possible to detect the following conditions
//  to give theoretical improvements in performance. These are very
//  marginal, and have been left out here for the sake of simplicity,
//  and the fact it would be difficult for the compiler to take
//  advantage of these optimisations. Both cases remove the link
//  between setting the flags and the following branch, either because
//  the flags don't get set, or because the branch doesn't check the
//  flags.
// 
//   i. Conditional flag set instruction at stage 3 does not set flags
//       e.g.  add.cc.f r0,r0,r0, resulting in C=1
// 
//  ii. Branch at stage 2 uses the AL (always) condition code.
// 
   assign i_p2b_jump_holdup_a = (//  p3 setting flags
                                 i_p3_bch_flagset_a & 
                                 //  branch in p2
                                 i_p2b_jmp_cc_a); 

//------------------------------------------------------------------------------
// Stage 2b Instruction Valid
//------------------------------------------------------------------------------
//
// This signal is only true when the data held on p2iw is a valid instruction
// and should be treated as such.  The instruction may not be valid for a
// number of reasons which are stated below:
//
// (1) There is no instruction in the stage due to separation of instructions
//     caused by the stage earlier being held up whilst stage 2b is allowed to
//     continue.
// (2) The instruction that has just entered the stage is not part of the ISA
//     or an extension.
// (3) Stage 2 instruction is to be killed by control transfer instruction.
// (4) The branch in stage 2 did not take the branch.
// (5) Stage 2b is being killed by a control transfer (brcc) and the stage is
//     stalled.
//                          
   assign i_p2b_iv_nxt = (((i_p2b_enable_a == 1'b 1) & (i_p2_enable_a == 1'b 0))
                          | 
                          ((i_p2_no_arc_or_ext_instr_a == 1'b 1) &
                           (i_p2_enable_a == 1'b 1)) 
                          | 
                          ((i_kill_p2_en_a == 1'b 1) & (i_p2_enable_a == 1'b 1)) 
                          | 
                          ((i_p2_nojump_a == 1'b 1) & (i_p2_enable_a == 1'b 1)) 
                          | 
                          ((i_p4_kill_p2b_a == 1'b 1) &
                           (i_p2b_enable_a == 1'b 0))) ? 
          1'b 0 : 
                         ((i_p2b_enable_a == 1'b 0) & (i_p2b_iv_r == 1'b 1)) ? 
          1'b 1 : 
                         ((i_p2b_enable_a == 1'b 0) &
                          (i_p2_enable_a == 1'b 0)) ? 
          i_p2b_iv_r : 
          i_p2_iv_r; 

   always @(posedge clk or posedge rst_a)
   begin : p2b_iv_sync_PROC
      if (rst_a == 1'b 1)
      begin
        i_p2b_iv_r <= 1'b 0;   
      end
      else
      begin
        i_p2b_iv_r <= i_p2b_iv_nxt;   
      end
   end

//------------------------------------------------------------------------------
// Stage 2b Pipeline Stalls
//------------------------------------------------------------------------------
//
   // Hold up stalls are enforced when:
   //
   // (1) An extension instruction wants to hold up the pipeline.
   // (2) The Load Scoreboard Unit (lsu) is holding the stage due to a register
   //     interlock on an outstanding load destination.
   // (3) A flag setting instruction is stage 3 and a conditional jump is in
   //     stage 2b.
   // (4) There is a returning load to a non-shortcuttable register occurring
   // (5) Jumps through registers are not shortcuttable so a stall is enforced
   //     upon detection of the condition.
   //
   assign i_p2b_holdup_stall_a = ((xholdup2b & XT_ALUOP) | 
                                  holdup2b               | 
                                  (i_p2b_jump_holdup_a   | 
                                   i_p2b_ld_nsc_a        | 
                                   i_p2b_jcc_sc_stall_a) & 
                                  i_p2b_iv_r); 

   assign i_p2b_pwr_save_stall_a = (~i_p2b_iv_r) & (~p2bint); 

   assign i_p2b_enable_a = ((i_p2b_en_nopwr_save_a == 1'b 0) | 
                            (i_p2b_pwr_save_stall_a    == 1'b 1)) ?
          1'b 0 : 
          1'b 1; 

   assign i_p2b_en_nopwr_save_a = ((en                       == 1'b 0) | 
                                       (i_p3_enable_nopwr_save_a == 1'b 0) | 
                                       (i_p2b_limm_dslot_stall_r == 1'b 1) | 
                                       (i_p2b_holdup_stall_a     == 1'b 1)) ?
          1'b 0 : 
          1'b 1; 



//------------------------------------------------------------------------------
// Program Counter Enable
//------------------------------------------------------------------------------
//
// The program counter enable is set true when there is an instruction moving
// from stage1 to stage 2b or if there is a control transfer occurring.  For
// static timing reasons a simple expression including the above statements
// could not be used.    
//
   // Program counter enable with late arriving ivalid_aligned signal included.
   // This signal should not be used for timing critical expressions.
   //
   assign i_pcen_a = i_pcen_non_iv_a & ivalid_aligned; 


   // This signal contains part of stage 1 stalls that will prevent the PC from
   // being updated.
   // 
   assign i_pcen_p1_a = ((i_p1_ct_int_loop_stall_a |
                          i_p1_zero_loop_stall_a) &  
                         i_no_pc_stall_a);

   assign i_no_pc_stall_a = 
                         // Dont disable the PC due to a stage 1 stall if
                         // a control transfer wants to change the PC.
                         //
                         (~(i_p2_dorel_a             | 
                           i_p2b_brcc_pred_nxt      | 
                           i_p2b_dojcc_a            | 
                           i_p4_docmprel_a          | 
                           i_p2b_limm_dslot_stall_r | 
                           pcounter_jmp_restart_r)); 

   // Holds the interrupt in stage 2 when there is a hit to the loopend 
   // whilst there is an instruction in stage 3 that is writing to either 
   // LP_COUNT, LP_END or LP_START.
   // This ensures the PC gets updated correctly with the interrupt vector
   // address.
   //  
   assign i_hold_int_st2_a = i_p1_zero_loop_stall_a & i_no_pc_stall_a;
 
   // This signal contains part of stage 2 stalls that will prevent the PC from
   // being updated.
   //                    
   assign i_pcen_p2_a = (i_p2_holdup_stall_a         | 
                         i_p2_ct_brcc_stall_a        | 
                         i_p2_brk_sleep_swi_a |
                         i_p2_instr_err_stall_a) &               

                        // This is needed to prevent the pcen signal from
                        // being disabled when there is a flag setting jump in
                        // stage 2b and a conditional branch in stage 2 LIMM
                        // and delay slot stalls do not disable the PC as the
                        // data that is being waited for needs to be able to
                        // update the PC correctly.
                        //
                        (~(i_p2b_dojcc_a | 
                          i_p4_docmprel_a | 
                          i_p2b_limm_dslot_stall_r |
                          pcounter_jmp_restart_r)); 

   // Limm and dslot stalls do not disable the PC as the data that is being
   // waited for needs to be able to update the PC correctly.
   //
   assign i_pcen_p2b_a = (i_p2b_holdup_stall_a &

                          // Don't disable the PC when there is a stall in stage
                          // 2, 2b or 3 and a BRcc or a bubble squash will 
                          // update the PC.
                          //
                          (~(i_p4_docmprel_a          | 
                            i_p2b_limm_dslot_stall_r |
                            pcounter_jmp_restart_r))); 

   // Don't disable the PC when there is a stall in stage
   // 2, 2b or 3 and a brcc or a bubble squash will update the PC
   //
   assign i_pcen_p3_a = (i_p3_multic_wben_stall_a | 
                         i_p3_load_stall_a        | 
			 i_p3_sync_stalls_pipe_a  |
                         i_p3_holdup_stall_a) & 

                        // Don't disable the PC when there is a stall in stage
                        // 2, 2b or 3 and a brcc or a bubble squash will update
                        // the PC.
                        //
                        (~(i_p4_docmprel_a | 
                          i_p2b_limm_dslot_stall_r |
                          pcounter_jmp_restart_r)); 

   // As mwait is late arriving. The logic is designed to cause mwait to be used
   // as late as possible.
   //
   assign i_pcen_mwait_a = (mwait & 
                            (~(i_p4_docmprel_a          | 
                              i_p2b_limm_dslot_stall_r | 
                              pcounter_jmp_restart_r))); 

   // Combine all the stall signals from all the stages including the
   // instruction stepping PC disable.
   //
   assign i_pcen_non_iv_a = ((i_pcen_mwait_a    == 1'b 1) | 
                             (i_pcen_p1_a       == 1'b 1) | 
                             (i_pcen_p2_a       == 1'b 1) | 
                             (i_pcen_p2b_a      == 1'b 1) | 
                             (i_pcen_p3_a       == 1'b 1) | 
                             (i_inst_stepping_a == 1'b 1) | 
                             (en                == 1'b 0) ) ? 1'b 0 : 
          1'b 1; 

 
//------------------------------------------------------------------------------
// PC Disable for Single Instruction Step
//------------------------------------------------------------------------------
//
   // Instruction Stepping
   //
   // The signal i_inst_stepping prevents the PC from being updated, by
   // disabling the PC enable signal (pcen). The signal is set when a
   // single instruction step is being performed and the PC does not
   // need to be updated (i_pcen_step = '0').
   //
   assign i_inst_stepping_a = do_inst_step_r & (~i_pcen_step_a); 


   // The signal i_pcen_step is set when a single instruction step is
   // being executed if the PC needs to be updated. This happens in the
   // following cases:
   //
   // (1) A valid instruction in stage one is allowed to pass into stage 2.
   // (2) An interrupt has been detected and is now in stage 2.
   // (3) The instruction in the pipeline requires a:
   //    (i) Delay-slot
   //   (ii) Long immediate data
   // (4) The branch in stage 2 is updating the PC.
   // (5) The compare&branch is predicting in stage 2 and is updating the PC
   // (6) The jump in stage 2b is updating the PC
   // (7) The compare&branch in stage 4 is updating the PC
   // (8) There is a delayed control-transfer underway
   //
   assign i_pcen_step_a = ((do_inst_step_r == 1'b 1) &
                           (i_p2_step_a    == 1'b 0) | 
                           (p2int          == 1'b 1) | 
                           (i_p2_step_a    == 1'b 1) & 
                           ((i_p2_has_dslot_a        == 1'b 1) | 
                            (i_p2_long_immediate_a   == 1'b 1) | 
                            (i_p2_tag_nxt_p1_limm_r  == 1'b 1) | 
                            (i_p2_tag_nxt_p1_dslot_r == 1'b 1) | 
                            (i_p2_dorel_a            == 1'b 1) | 
                            (i_p2b_brcc_pred_nxt     == 1'b 1) | 
                            (i_p2b_dojcc_a           == 1'b 1) | 
                            (i_p4_docmprel_a         == 1'b 1) | 
                            (pcounter_jmp_restart_r  == 1'b 1))) ? 
          1'b 1 : 
          1'b 0; 
          
//------------------------------------------------------------------------------
// Stage 3 pre-latch decode
//------------------------------------------------------------------------------
//
   // This signal is set true for operations that require a writeback to the
   // register file and are conditional.
   //
   always @(i_p2b_opcode_r or i_p2b_subopcode_r or i_p2b_subopcode2_r or 
         i_p2b_subopcode3_r or i_p2b_subopcode7_r or i_p2b_a_field_r)
    begin : ccwbop_PROC

      case (i_p2b_opcode_r) 
        OP_FMT1:
         begin
            case (i_p2b_subopcode_r) 
             SO_ADD,  SO_ADC,  SO_SUB,  SO_SBC, 
             SO_AND,  SO_OR,   SO_BIC,  SO_XOR, 
             SO_MAX,  SO_MIN,  SO_MOV,  SO_BSET, 
                 SO_BCLR, SO_BMSK, SO_BXOR, SO_ADD1,
                 SO_ADD2, SO_ADD3, SO_SUB1, SO_SUB2, 
                 SO_SUB3, SO_RSUB:
               begin
                 i_p3_ccwbop_decode_nxt = 1'b 1;   
               end
             SO_SOP:
               begin
                 if (i_p2b_a_field_r == MO_ZOP)
                  begin
                     i_p3_ccwbop_decode_nxt = 1'b 0;   
                  end
                 else
                  begin
                     i_p3_ccwbop_decode_nxt = 1'b 1;   
                  end
               end
             default:
               begin
                 i_p3_ccwbop_decode_nxt = 1'b 0;   
               end
            endcase
         end
        OP_16_LD_ADD:
         begin
            case (i_p2b_subopcode2_r[SUBOPCODE_MSB_1:SUBOPCODE_MSB_2])
             SO16_ADD:
               begin
                 i_p3_ccwbop_decode_nxt = 1'b 1;   
               end
             default:
               begin
                 i_p3_ccwbop_decode_nxt = 1'b 0;   
               end
            endcase
         end
        OP_16_MV_ADD:
         begin
            if (i_p2b_subopcode_r[SUBOPCODE_MSB_1:SUBOPCODE_MSB_2] == SO16_CMP)
             begin
               i_p3_ccwbop_decode_nxt = 1'b 0;   
             end
            else
             begin
               i_p3_ccwbop_decode_nxt = 1'b 1;   
             end
         end
        OP_16_ARITH, OP_16_MV:
         begin
            i_p3_ccwbop_decode_nxt = 1'b 1;   
         end
        OP_16_ALU_GEN:
         begin
            case (i_p2b_subopcode2_r) 
             SO16_SUB_REG, SO16_AND,   SO16_OR, 
             SO16_BIC,     SO16_XOR,   SO16_SEXB, 
                 SO16_SEXW,    SO16_EXTB,  SO16_EXTW, 
                 SO16_ABS,     SO16_NOT,   SO16_NEG, 
                 SO16_ADD1,    SO16_ADD2,  SO16_ADD3,
                 SO16_ASL_M,   SO16_LSR_M, SO16_ASR_M, 
                 SO16_ASL_1,   SO16_ASR_1, SO16_LSR_1:
               begin
                 i_p3_ccwbop_decode_nxt = 1'b 1;   
               end
             SO16_SOP:
               begin
                 if (i_p2b_subopcode3_r == SO16_SOP_SUB)
                  begin
                     i_p3_ccwbop_decode_nxt = 1'b 1;   
                  end
                 else
                  begin
                     i_p3_ccwbop_decode_nxt = 1'b 0;   
                  end
               end
             default:
               begin
                 i_p3_ccwbop_decode_nxt = 1'b 0;   
               end
            endcase
         end
        OP_16_SSUB:
         begin
            if (i_p2b_subopcode3_r == SO16_BTST_U5)
             begin
               i_p3_ccwbop_decode_nxt = 1'b 0;   
             end
            else
             begin
               i_p3_ccwbop_decode_nxt = 1'b 1;   
             end
         end
        OP_16_SP_REL:
         begin
            case (i_p2b_subopcode3_r) 
             SO16_ADD_SP, SO16_SUB_SP, SO16_POP_U7, SO16_PUSH_U7:
               begin
                 i_p3_ccwbop_decode_nxt = 1'b 1;   
               end
             default:
               begin
                 i_p3_ccwbop_decode_nxt = 1'b 0;   
               end
            endcase
         end
        OP_16_GP_REL:
         begin
            if (i_p2b_subopcode7_r == SO16_ADD_GP)
             begin
               i_p3_ccwbop_decode_nxt = 1'b 1;   
             end
            else
             begin
               i_p3_ccwbop_decode_nxt = 1'b 0;   
             end
         end
        OP_16_ADDCMP:
         begin
            if (i_p2b_subopcode3_r[SUBOPCODE3_16_MSB] == SO16_ADD_U7)
             begin
               i_p3_ccwbop_decode_nxt = 1'b 1;   
             end
            else
             begin
               i_p3_ccwbop_decode_nxt = 1'b 0;   
             end
         end
        default:
         begin
            i_p3_ccwbop_decode_nxt = 1'b 0;   
         end
      endcase
    end    

//  Used in the EX stage for condition checking
//  
   assign i_p3_alu16_condtrue_nxt = (i_p2b_opcode_16_ld_add_a | 
                                     i_p2b_opcode_16_mov_a    | 
                                      i_p2b_opcode_16_arith_a  | 
                                      i_p2b_opcode_16_mv_add_a | 
                                      i_p2b_opcode_16_ld_u7_a  | 
                                      i_p2b_opcode_16_ldb_u5_a | 
                                      i_p2b_opcode_16_ldw_u6_a | 
                                      i_p2b_opc_16_ldwx_u6_a | 
                                      i_p2b_opcode_16_st_u7_a  | 
                                      i_p2b_opcode_16_stb_u5_a | 
                                      i_p2b_opcode_16_stw_u6_a | 
                                      i_p2b_opcode_16_ssub_a   | 
                                      i_p2b_opcode_16_sp_rel_a | 
                                      i_p2b_opcode_16_gp_rel_a | 
                                      i_p2b_opcode_16_ld_pc_a  | 
                                      i_p2b_opcode_16_addcmp_a | 
                                      i_p2b_opcode_16_alu_a   & 
                                      ((~i_p2b_subop_16_brk_a)  & 
                                       (~i_p2b_subop_16_sop_a))); 
  
   // Decode for type of operation that is entering the basecase ALU. This
   // signal partially controls the ALU to generate the correct result.
   //
   always @(i_p2b_minoropcode_r or i_p2b_opcode_r or 
            i_p2b_br_bl_subopcode_r or i_p2b_subopcode1_r or 
            i_p2b_subopcode2_r or i_p2b_subopcode3_r or 
            i_p2b_subopcode4_r or p2bint or i_p2b_subopcode_r or 
            i_p2b_b_field16_r)

    begin : op_decode_async_PROC

      i_p3_alu_arithiv_nxt  = 1'b 1;   
      i_p3_alu_logiciv_nxt  = 1'b 0;   
      i_p3_alu_snglopiv_nxt = 1'b 0;   
      i_p3_alu_absiv_nxt    = 1'b 0;   
      i_p3_alu_negiv_nxt    = 1'b 0;   
      i_p3_alu_notiv_nxt    = 1'b 0;   
      i_p3_alu_op_nxt       = SUBOP_SBC;   
      i_p3_alu_brne16_nxt   = 1'b 0;   
      i_p3_alu_breq16_nxt   = 1'b 0;   
      i_p3_alu_min_nxt      = 1'b 0;   
      i_p3_alu_max_nxt      = 1'b 0;   

      case (i_p2b_opcode_r) 
        OP_BLCC:
         begin
            case (i_p2b_br_bl_subopcode_r)
             SO_BCC_BBIT0, SO_BCC_BBIT1:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
             default:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
                 i_p3_alu_arithiv_nxt = 1'b 1;   
               end
            endcase
         end
        OP_LD, OP_ST, OP_16_LD_U7, OP_16_LDB_U5, 
        OP_16_LDW_U6, OP_16_LDWX_U6, OP_16_ST_U7,
        OP_16_STB_U5, OP_16_STW_U6, OP_16_LD_ADD, 
        OP_16_GP_REL, OP_16_LD_PC, OP_16_BCC:
         begin
            i_p3_alu_op_nxt = SUBOP_ADD;   
         end
        OP_16_ARITH:
         begin
            case (i_p2b_subopcode1_r) 
             SO16_SUB_U3:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
               end
             SO16_ADD_U3:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
               end
             default:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_snglopiv_nxt = 1'b 1;   
               end
            endcase
         end
        OP_16_MV_ADD:
         begin
            case (i_p2b_subopcode1_r) 
             SO16_CMP:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
               end
             SO16_ADD_HI:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
               end
             default:
               begin
                 i_p3_alu_op_nxt = OP_AND;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
            endcase
         end
        OP_FMT1:
         begin
            case (i_p2b_subopcode_r)  
             SO_J, SO_J_D, SO_JL, SO_JL_D:
               begin
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 0;   
               end
             SO_AND, SO_MOV, SO_BTST, SO_BMSK, SO_TST:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
             SO_ADD, SO_ADD1, SO_ADD2,  SO_ADD3, 
             SO_LD,  SO_LDB,  SO_LDB_X, SO_LDW, 
             SO_LDW_X:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
               end
             SO_ADC:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADC;   
               end
             SO_OR, SO_BSET:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADC;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
             SO_SUB, SO_SUB1, SO_SUB2, SO_SUB3, 
             SO_CMP, SO_RSUB, SO_RCMP:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
               end
             SO_BIC, SO_BCLR:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
             SO_MIN:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
                 i_p3_alu_arithiv_nxt = 1'b 1;   
                 i_p3_alu_min_nxt = 1'b 1;   
                 i_p3_alu_max_nxt = 1'b 0;   
               end
             SO_MAX:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
                 i_p3_alu_arithiv_nxt = 1'b 1;   
                 i_p3_alu_min_nxt = 1'b 0;   
                 i_p3_alu_max_nxt = 1'b 1;   
               end
             SO_SBC:
               begin
                 i_p3_alu_op_nxt = SUBOP_SBC;   
               end
             SO_SOP:
               begin
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 case (i_p2b_minoropcode_r)  
                  MO_ABS:
                    begin
                      i_p3_alu_op_nxt = SUBOP_ADD;   
                      i_p3_alu_absiv_nxt = 1'b 1;   
                      i_p3_alu_arithiv_nxt = 1'b 1;   
                      i_p3_alu_snglopiv_nxt = 1'b 0;   
                    end
                  MO_ASL, MO_ASR:
                    begin
                      i_p3_alu_op_nxt = SUBOP_SUB;   
                      i_p3_alu_snglopiv_nxt = 1'b 1;   
                    end
                  MO_RLC:
                    begin
                      i_p3_alu_op_nxt = SUBOP_ADC;   
                      i_p3_alu_snglopiv_nxt = 1'b 1;   
                    end
                  MO_RRC, MO_SEXB, MO_SEXW, MO_EXTB, MO_EXTW:
                    begin
                      i_p3_alu_op_nxt = SUBOP_ADC;   
                      i_p3_alu_snglopiv_nxt = 1'b 1;   
                    end
                  MO_NOT:
                    begin
                      i_p3_alu_op_nxt = SUBOP_SBC;   
                      i_p3_alu_notiv_nxt = 1'b 1;   
                      i_p3_alu_snglopiv_nxt = 1'b 1;   
                    end
                  MO_LSR, MO_ROR:
                    begin
                      i_p3_alu_snglopiv_nxt = 1'b 1;   
                    end
                  default:
                    begin
                      i_p3_alu_op_nxt = SUBOP_SUB;   
                      i_p3_alu_arithiv_nxt = 1'b 0;   
                    end
                 endcase
               end
             SO_LR:
               begin
                 i_p3_alu_arithiv_nxt = 1'b 0;   
               end
             default:
               begin
                 //  xor
                 i_p3_alu_op_nxt = SUBOP_SBC;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
            endcase
         end
        OP_16_ALU_GEN:
         begin
            case (i_p2b_subopcode2_r) 
             SO16_SOP:
               begin
                 if (i_p2b_subopcode3_r == SO16_SOP_SUB)
                  begin
                     i_p3_alu_op_nxt = SUBOP_SUB;   
                  end
                 else
                  begin
                     i_p3_alu_arithiv_nxt = 1'b 0;   
                  end
               end
             SO16_SUB_REG:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
               end
             SO16_NEG:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
                 i_p3_alu_negiv_nxt = 1'b 1;   
               end
             SO16_ABS:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
                 i_p3_alu_absiv_nxt = 1'b 1;   
               end
             SO16_BIC:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
             SO16_AND, SO16_TST:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
             SO16_ADD1, SO16_ADD2, SO16_ADD3:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
               end
             SO16_OR:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADC;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
             SO16_SEXB, SO16_SEXW, SO16_EXTB, SO16_EXTW:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADC;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_snglopiv_nxt = 1'b 1;   
               end
             SO16_XOR:
               begin
                 i_p3_alu_op_nxt = SUBOP_SBC;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
             default:
               begin
                 i_p3_alu_op_nxt = SUBOP_SBC;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_snglopiv_nxt = 1'b 1;   
               end
            endcase
         end
        OP_16_SSUB:
         begin
            case (i_p2b_subopcode3_r) 
             SO16_SUB_U5:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
               end
             SO16_BCLR_U5:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
             SO16_BSET_U5:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADC;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
             default:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
                 i_p3_alu_arithiv_nxt = 1'b 0;   
                 i_p3_alu_logiciv_nxt = 1'b 1;   
               end
            endcase
         end
        OP_16_SP_REL:
         begin
            case (i_p2b_subopcode3_r) 
             SO16_LD_SP, SO16_LDB_SP, SO16_ST_SP, 
             SO16_STB_SP, SO16_ADD_SP, SO16_POP_U7, 
             SO16_PUSH_U7:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
               end
             SO16_SUB_SP:
               begin
                 case (i_p2b_b_field16_r) 
                  THREE_ZERO:
                    begin
                      i_p3_alu_op_nxt = SUBOP_ADD;   
                    end
                  default:
                    begin
                      i_p3_alu_op_nxt = SUBOP_SUB;   
                    end
                 endcase
               end
             default:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
               end
            endcase
         end
        OP_16_BRCC:
         begin
            i_p3_alu_op_nxt = SUBOP_SUB;   
            if (i_p2b_subopcode4_r == SO16_BREQ_S8)
             begin
               i_p3_alu_brne16_nxt = 1'b 0;   
               i_p3_alu_breq16_nxt = 1'b 1;   
             end
            if (i_p2b_subopcode4_r == SO16_BRNE_S8)
             begin
               i_p3_alu_brne16_nxt = 1'b 1;   
               i_p3_alu_breq16_nxt = 1'b 0;   
             end
         end
        OP_16_MV:
         begin
            i_p3_alu_op_nxt = SUBOP_ADD;   
            i_p3_alu_arithiv_nxt = 1'b 0;   
            i_p3_alu_logiciv_nxt = 1'b 1;   
         end
        OP_16_ADDCMP:
         begin
            case (i_p2b_subopcode4_r) 
             SO16_ADD_U7:
               begin
                 i_p3_alu_op_nxt = SUBOP_ADD;   
               end
             default:
               begin
                 i_p3_alu_op_nxt = SUBOP_SUB;   
               end
            endcase
         end
        default:
         begin
            i_p3_alu_op_nxt = SUBOP_SBC;   
            i_p3_alu_arithiv_nxt = 1'b 0;   
         end
      endcase

      if (p2bint == 1'b 1)
        begin
          i_p3_alu_arithiv_nxt  = 1'b 0;   
          i_p3_alu_logiciv_nxt  = 1'b 0;   
          i_p3_alu_snglopiv_nxt = 1'b 0;   
          i_p3_alu_absiv_nxt    = 1'b 0;   
          i_p3_alu_negiv_nxt    = 1'b 0;   
          i_p3_alu_notiv_nxt    = 1'b 0;   
          i_p3_alu_op_nxt       = SUBOP_SBC;   
          i_p3_alu_brne16_nxt   = 1'b 0;   
          i_p3_alu_breq16_nxt   = 1'b 0;   
          i_p3_alu_min_nxt      = 1'b 0;   
          i_p3_alu_max_nxt      = 1'b 0;   
        end

    end
   
   assign i_p3_ashift_right_nxt = ((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                           (i_p2b_minoropcode_r == MO_ASR) | 
                           (i_p2b_opcode_16_alu_a == 1'b 1) & 
                           (i_p2b_subopcode2_r == SO16_ASR_1)) ? 1'b 1 : 
        1'b 0; 

   assign i_p3_sop_op_nxt_sel0_a = (((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                            ((i_p2b_minoropcode_r == MO_LSR) | 
                             (i_p2b_minoropcode_r == MO_ROR) | 
                             (i_p2b_minoropcode_r == MO_RRC))) 
                           | 
                           ((i_p2b_opcode_16_alu_a == 1'b 1) & 
                            (i_p2b_subopcode2_r == SO16_LSR_1)) 
                           | 
                           ((i_p3_ashift_right_nxt == 1'b 1))) ? 1'b 1 : 
        1'b 0; 

   assign i_p3_sop_op_nxt_sel1_a = (((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                            ((i_p2b_minoropcode_r == MO_ASL) | 
                             (i_p2b_minoropcode_r == MO_RLC))) 
                           | 
                           ((i_p2b_opcode_16_arith_a == 1'b 1) & 
                            (i_p2b_subopcode1_r == SO16_ASL))
                           |
                           ((i_p2b_opcode_16_alu_a == 1'b 1) & 
                            (i_p2b_subopcode2_r == SO16_ASL_M))
                           |
                           ((i_p2b_opcode_16_alu_a == 1'b 1) & 
                            (i_p2b_subopcode2_r == SO16_ASL_1))) ? 1'b 1 : 
        1'b 0; 

   assign i_p3_sop_op_nxt_sel2_a = (((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                            (i_p2b_minoropcode_r == MO_SEXB))
                           | 
                           ((i_p2b_opcode_16_alu_a == 1'b 1) & 
                            (i_p2b_subopcode2_r == SO16_SEXB))) ? 1'b 1 : 
        1'b 0; 

   assign i_p3_sop_op_nxt_sel3_a = (((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                            (i_p2b_minoropcode_r == MO_SEXW))
                           | 
                           ((i_p2b_opcode_16_alu_a == 1'b 1) & 
                            (i_p2b_subopcode2_r == SO16_SEXW))) ?  1'b 1 : 
        1'b 0; 

   assign i_p3_sop_op_nxt_sel4_a = (((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                            (i_p2b_minoropcode_r == MO_EXTB))
                           | 
                           ((i_p2b_opcode_16_alu_a == 1'b 1) & 
                            (i_p2b_subopcode2_r == SO16_EXTB))) ? 1'b 1 : 
        1'b 0; 

   assign i_p3_sop_op_nxt_sel5_a = (((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                            (i_p2b_minoropcode_r == MO_EXTW))
                           | 
                           ((i_p2b_opcode_16_alu_a == 1'b 1) & 
                            (i_p2b_subopcode2_r == SO16_EXTW))) ?  1'b 1 : 
        1'b 0; 

   assign i_p3_sop_op_nxt_sel6_a = (~(i_p3_sop_op_nxt_sel0_a | 
                            i_p3_sop_op_nxt_sel1_a | 
                            i_p3_sop_op_nxt_sel2_a | 
                            i_p3_sop_op_nxt_sel3_a | 
                            i_p3_sop_op_nxt_sel4_a |
                            i_p3_sop_op_nxt_sel5_a)); 

   // AND-OR Mux
   assign i_p3_sop_op_nxt = (OP_RIGHT_SHIFT & ({(SOPSIZE+1){i_p3_sop_op_nxt_sel0_a}}) 
                      | 
                      OP_LEFT_SHIFT &  ({(SOPSIZE+1){i_p3_sop_op_nxt_sel1_a}}) 
                      | 
                      OP_SEXB &        ({(SOPSIZE+1){i_p3_sop_op_nxt_sel2_a}}) 
                      | 
                      OP_SEXW &        ({(SOPSIZE+1){i_p3_sop_op_nxt_sel3_a}}) 
                      | 
                      OP_EXTB &        ({(SOPSIZE+1){i_p3_sop_op_nxt_sel4_a}}) 
                      | 
                      OP_EXTW &        ({(SOPSIZE+1){i_p3_sop_op_nxt_sel5_a}}) 
                      | 
                      OP_NOT &         ({(SOPSIZE+1){i_p3_sop_op_nxt_sel6_a}})); 

   always @(i_p2b_br_bl_subopcode_r or i_p2b_opcode_r or 
         i_p2b_subopcode_r or i_p2b_subopcode3_r)
    begin : bit_operand_async_PROC

      case (i_p2b_opcode_r) 
        OP_BLCC:
         begin
            case (i_p2b_br_bl_subopcode_r) 
             SO_BCC_BBIT0, SO_BCC_BBIT1:
               begin
                 i_p3_bit_operand_sel_nxt = 2'b 01;   
               end
             default:
               begin
                 i_p3_bit_operand_sel_nxt = 2'b 00;   
               end
            endcase
         end
        OP_FMT1:
         begin
            case (i_p2b_subopcode_r) 
             SO_BSET, SO_BCLR, SO_BTST, SO_BXOR:
               begin
                 i_p3_bit_operand_sel_nxt = 2'b01;   
               end
             SO_BMSK:
               begin
                 i_p3_bit_operand_sel_nxt = 2'b10;   
               end
             default:
               begin
                 i_p3_bit_operand_sel_nxt = 2'b00;   
               end
            endcase
         end
        OP_16_SSUB:
         begin
            case (i_p2b_subopcode3_r[SUBOPCODE3_16_MSB:0]) 
             SO16_BSET_U5, SO16_BCLR_U5, SO16_BTST_U5:
               begin
                 i_p3_bit_operand_sel_nxt = 2'b 01;   
               end
             SO16_BMSK_U5:
               begin
                 i_p3_bit_operand_sel_nxt = 2'b 10;   
               end
             default:
               begin
                 i_p3_bit_operand_sel_nxt = 2'b 00;   
               end
            endcase
         end
        default:
         begin
            i_p3_bit_operand_sel_nxt = 2'b 00;   
         end
      endcase
    end 
   

   assign i_p3_flag_instr_nxt = i_p2b_opcode_32_fmt1_a & 
                                i_p2b_subopcode_flag_a; 

   assign i_p3_shiftin_sel_nxt = (i_p3_ashift_right_nxt == 1'b 1) ?     
          2'b 01 : 
                                 ((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                                  (i_p2b_minoropcode_r == MO_ROR)) ? 
          2'b 10 : 
                                 ((i_p2b_opcode_32_fmt1_a == 1'b 1) & 
                                 ((i_p2b_minoropcode_r == MO_RLC) | 
                                  (i_p2b_minoropcode_r == MO_RRC))) ? 
          2'b 11 : 
          2'b 00; 
 
//------------------------------------------------------------------------------
// Stage 2b - Stage 3 registers
//------------------------------------------------------------------------------
//
   // The data to be used for input to stage 3 is latched here.
   //
   // Clock in the instruction from stage 2 when the i_enable2_a signal is
   // valid. Note that in stage 3, the instruction is latched in sections,
   // thus ignoring the two reserved bits left in non-short immediate ALU
   // instructions.
   //
   always @(posedge clk or posedge rst_a)
    begin : stage_3_sync_PROC
      if (rst_a == 1'b 1)
        begin
             i_p3_a_field_r              <= {(OPERAND_MSB + 1){1'b 0}};
             i_p3_alu16_condtrue_r       <= 1'b 0;
             i_p3_alu_absiv_r            <= 1'b 0;
             i_p3_alu_arithiv_r          <= 1'b 0;
             i_p3_alu_breq16_r           <= 1'b 0;
             i_p3_alu_brne16_r           <= 1'b 0;
             i_p3_alu_logiciv_r          <= 1'b 0;
             i_p3_alu_max_r              <= 1'b 0;
             i_p3_alu_min_r              <= 1'b 0;
             i_p3_alu_op_r               <= {(TWO){1'b 0}};
             i_p3_alu_snglopiv_r         <= 1'b 0;
             i_p3_awb_field_r            <= {(TWO){1'b 0}};
             i_p3_b_field_r              <= {(OPERAND_MSB + 1){1'b 0}};
             i_p3_bit_operand_sel_r      <= {(TWO){1'b 0}};
             i_p3_br_or_bbit32_r         <= 1'b 0;
             i_p3_br_or_bbit_r           <= 1'b 0;
             i_p3_c_field_r              <= {(OPERAND_MSB + 1){1'b 0}};
             i_p3_ccwbop_decode_r        <= 1'b 0;
             i_p3_dest_imm_r             <= 1'b 0;
             i_p3_dolink_r               <= 1'b 0;
             i_p3_flag_instr_r           <= 1'b 0;
             i_p3_fmt_cond_reg_r         <= 1'b 0;
             i_p3_format_r               <= {(FORMAT_MSB + 1){1'b 0}};
             i_p3_has_dslot_r            <= 1'b 0;
             i_p3_ld_decode_r            <= 1'b 0;
             i_p3_lr_decode_r            <= 1'b 0;
             i_p3_minoropcode_r          <= {(SUBOPCODE_MSB + 1){1'b 0}};
             i_p3_ni_wbrq_predec_r       <= 1'b 0;
             i_p3_nocache_r              <= 1'b 0;
             i_p3_opcode_32_fmt1_r       <= 1'b 0;
             i_p3_opcode_r               <= {(OPCODE_MSB + 1){1'b 0}};
             i_p3_q_r                    <= {(CONDITION_CODE_MSB + 1){1'b 0}};
             i_p3_sc_dest_r              <= {(OPERAND_MSB + 1){1'b 0}};
             i_p3_setflags_r             <= 1'b 0;
             i_p3_sex_r                  <= 1'b 0;
             i_p3_shiftin_sel_r          <= {(TWO){1'b 0}};
             i_p3_size_r                 <= {(TWO){1'b 0}};
             i_p3_sop_op_r               <= {(SOPSIZE + 1){1'b 0}};
             i_p3_sop_sub_r              <= 1'b 0;
             i_p3_special_flagset_r      <= 1'b 0;
             i_p3_sr_decode_r            <= 1'b 0;
             i_p3_st_decode_r            <= 1'b 0;
             i_p3_subopcode1_r           <= {(SUBOPCODE1_16_MSB + 1){1'b 0}};
             i_p3_subopcode2_r           <= {(SUBOPCODE2_16_MSB + 1){1'b 0}};
             i_p3_subopcode3_r           <= {(SUBOPCODE3_16_MSB + 1){1'b 0}};
             i_p3_subopcode4_r           <= 1'b 0;
             i_p3_subopcode5_r           <= {(SUBOPCODE1_16_MSB + 1){1'b 0}};
             i_p3_subopcode6_r           <= {(SUBOPCODE3_16_MSB + 1){1'b 0}};
             i_p3_subopcode7_r           <= {(SUBOPCODE1_16_MSB + 1){1'b 0}};
             i_p3_subopcode_r            <= {(SUBOPCODE_MSB + 1){1'b 0}};
             i_p3_destination_en_r       <= 1'b 0;
             i_p3_brcc_pred_r            <= 1'b 0;
             i_p3_sync_inst_r            <= 1'b 0;
        end
      else
        begin
          if (i_p2b_enable_a == 1'b 1)
            begin
              i_p3_a_field_r              <= i_p2b_a_field_a;   
              i_p3_alu16_condtrue_r       <= i_p3_alu16_condtrue_nxt;   
              i_p3_alu_absiv_r            <= i_p3_alu_absiv_nxt;   
              i_p3_alu_arithiv_r          <= i_p3_alu_arithiv_nxt;   
              i_p3_alu_breq16_r           <= i_p3_alu_breq16_nxt;   
              i_p3_alu_brne16_r           <= i_p3_alu_brne16_nxt;   
              i_p3_alu_logiciv_r          <= i_p3_alu_logiciv_nxt;   
              i_p3_alu_max_r              <= i_p3_alu_max_nxt;   
              i_p3_alu_min_r              <= i_p3_alu_min_nxt;   
              i_p3_alu_op_r               <= i_p3_alu_op_nxt;   
              i_p3_alu_snglopiv_r         <= i_p3_alu_snglopiv_nxt;   
              i_p3_awb_field_r            <= i_p2b_awb_field_a;   
              i_p3_b_field_r              <= i_p2b_b_field_r;   
              i_p3_bit_operand_sel_r      <= i_p3_bit_operand_sel_nxt;   
              i_p3_br_or_bbit32_r         <= i_p2b_br_or_bbit32_r;   
              i_p3_br_or_bbit_r           <= i_p2b_br_or_bbit_r;   
              i_p3_brcc_pred_r            <= i_p2b_brcc_pred_r;   
              i_p3_c_field_r              <= i_p2b_c_field_r;   
              i_p3_ccwbop_decode_r        <= (i_p3_ccwbop_decode_nxt &
                                              ~i_p2b_dest_imm_r);
              i_p3_dest_imm_r             <= i_p2b_dest_imm_r;   
              i_p3_destination_en_r       <= i_p2b_dest_en_iv_a;   
              i_p3_dolink_r               <= i_p3_dolink_nxt;   
              i_p3_flag_instr_r           <= i_p3_flag_instr_nxt;   
              i_p3_fmt_cond_reg_r         <= i_p2b_fmt_cond_reg_a;   
              i_p3_format_r               <= i_p2b_format_r;   
              i_p3_has_dslot_r            <= i_p2b_has_dslot_r;   
              i_p3_ld_decode_r            <= i_p2b_ld_decode_a;   
              i_p3_lr_decode_r            <= i_p2b_lr_decode_a;   
              i_p3_minoropcode_r          <= i_p2b_minoropcode_r;   
              i_p3_ni_wbrq_predec_r       <= (i_p3_ldst_awb_nxt |
                                              i_p3_dolink_nxt |
                                              i_p2b_lr_decode_a);   
              i_p3_nocache_r              <= i_p2b_nocache_a;   
              i_p3_opcode_32_fmt1_r       <= i_p2b_opcode_32_fmt1_a;
              i_p3_opcode_r               <= i_p2b_opcode_r;   
              i_p3_q_r                    <= i_p2b_q_r;   
              i_p3_sc_dest_r              <= i_p3_sc_dest_nxt;   
              i_p3_setflags_r             <= i_p2b_setflags_r;   
              i_p3_sex_r                  <= i_p2b_sex_a;   
              i_p3_shiftin_sel_r          <= i_p3_shiftin_sel_nxt;   
              i_p3_size_r                 <= i_p2b_size_a;   
              i_p3_sop_op_r               <= i_p3_sop_op_nxt;   
              i_p3_sop_sub_r              <= i_p3_sop_sub_nxt;   
              i_p3_special_flagset_r      <= i_p2b_special_flagset_a;
              i_p3_sr_decode_r            <= i_p2b_sr_decode_a;   
              i_p3_st_decode_r            <= i_p2b_st_decode_a;   
              i_p3_subopcode1_r           <= i_p2b_subopcode1_r;   
              i_p3_subopcode2_r           <= i_p2b_subopcode2_r;   
              i_p3_subopcode3_r           <= i_p2b_subopcode3_r;   
              i_p3_subopcode4_r           <= i_p2b_subopcode4_r;   
              i_p3_subopcode5_r           <= i_p2b_subopcode5_r;   
              i_p3_subopcode6_r           <= i_p2b_subopcode6_r;   
              i_p3_subopcode7_r           <= i_p2b_subopcode7_r;   
              i_p3_subopcode_r            <= i_p2b_subopcode_r; 
              i_p3_sync_inst_r            <= i_p2b_sync_inst_r;  
            end
        end
    end 

   assign i_p3_br_or_bbit_iv_a = i_p3_br_or_bbit_r & i_p3_iv_r; 
   assign i_p3_ccwbop_decode_iv_a = i_p3_ccwbop_decode_r & i_p3_iv_r; 
   assign i_p3_dolink_iv_a = i_p3_dolink_r & i_p3_iv_r; 
   assign i_p3_flag_instr_iv_a = i_p3_flag_instr_r & i_p3_iv_r; 
   assign i_p3_sync_instr_iv_a = i_p3_sync_inst_r & i_p3_iv_r;
   assign i_p3_ld_decode_iv_a = i_p3_ld_decode_r & i_p3_iv_r; 
   assign i_p3_lr_decode_iv_a = i_p3_lr_decode_r & i_p3_iv_r; 
   assign i_p3_ni_wbrq_predec_iv_a = i_p3_ni_wbrq_predec_r & i_p3_iv_r; 
   assign i_p3_sr_decode_iv_a = i_p3_sr_decode_r & i_p3_iv_r; 
   assign i_p3_st_decode_iv_a = i_p3_st_decode_r & i_p3_iv_r; 
   assign i_p3_destination_en_iv_a = i_p3_destination_en_r & i_p3_iv_r; 

//------------------------------------------------------------------------------
// Pipeline Stage 3 Instruction Valid
//------------------------------------------------------------------------------
//
   // This signal indicates that stage 3 contains a valid instruction. The
   // instruction in stage 3 may not be valid for a number of reasons:
   // (1) Stage 2b is stalled and stage 3 is not.  This will leave a hole in the
   //     pipeline.
   // (2) Stage 3 is being killed whilst it is stalled.
   // (3) Stage 2b is being killed as it enters stage 3
   // (4) The jump in stage 2b does not take the jump as it leaves stage 2b so
   //     kill it.
   //
   assign i_p3_iv_nxt = (((i_p3_enable_a == 1'b 1) & (i_p2b_enable_a == 1'b 0)) 
                   | 
                         ((i_p3_enable_a == 1'b 0) & (i_p4_kill_p3_a == 1'b 1)) 
                   | 
                         ((i_p2b_enable_a == 1'b 1) & (i_p4_kill_p2b_a == 1'b 1)) 
                   | 
                         ((i_p2b_nojump_a == 1'b 1) & (i_p2b_enable_a == 1'b 1))) ? 
          1'b 0 : 
                        ((i_p3_enable_a == 1'b 0) & (i_p3_iv_r == 1'b 1)) ? 
          1'b 1 : 
                        ((i_p3_enable_a == 1'b 0) & (i_p2b_enable_a == 1'b 0)) ? 
          i_p3_iv_r : 
          i_p2b_iv_r; 

   always @(posedge clk or posedge rst_a)
    begin : p3_iv_sync_PROC
      if (rst_a == 1'b 1)
        begin
          i_p3_iv_r <= 1'b 0;   
        end
      else
        begin
          i_p3_iv_r <= i_p3_iv_nxt;   
        end
    end


//------------------------------------------------------------------------------
// Stage 3 LR/SRs
//------------------------------------------------------------------------------
//
   // The signals for p3lr and p3sr are used by hostif to handle
   // auxiliary register accesses. Note that they include p3iv and kill signals
   // in their decodes.
   //
   assign i_p3_lr_a = i_p3_lr_decode_iv_a & i_p4_no_kill_p3_a; 
   assign i_p3_sr_a = i_p3_sr_decode_iv_a & i_p4_no_kill_p3_a;


//------------------------------------------------------------------------------
// Stage 3 LD/ST
//------------------------------------------------------------------------------
//
   // The signals for mload and mstore are used by hostif to handle
   // auxiliary register accesses. Note that they include p3iv and kill signals
   // in their decodes.
   //
   assign i_p3_mload_a = i_p3_ld_decode_iv_a & i_p4_no_kill_p3_a; 
   assign i_p3_mstore_a = i_p3_st_decode_iv_a & i_p4_no_kill_p3_a; 

//------------------------------------------------------------------------------
// Stage 3 Condition Codes evaluation
//------------------------------------------------------------------------------
//
   // Evalulate the flags against the current condition code.
   //
   always @(aluflags_r or i_p3_q_r)
    begin : i_p3_ccunit_PROC

      i_p3_ccunit_fz_a = aluflags_r[A_Z_N];   
      i_p3_ccunit_fn_a = aluflags_r[A_N_N];   
      i_p3_ccunit_fc_a = aluflags_r[A_C_N];   
      i_p3_ccunit_fv_a = aluflags_r[A_V_N];   
      i_p3_ccunit_nfz_a = ~aluflags_r[A_Z_N];   
      i_p3_ccunit_nfn_a = ~aluflags_r[A_N_N];   
      i_p3_ccunit_nfc_a = ~aluflags_r[A_C_N];   
      i_p3_ccunit_nfv_a = ~aluflags_r[A_V_N];   

      case (i_p3_q_r[CCUBND:0]) 
        CCZ:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_fz_a;//   Z,  EQ
         end
        CCNZ:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_nfz_a;//   NZ, NE
         end
        CCPL:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_nfn_a;//   PL, P
         end
        CCMI:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_fn_a;//   MI, N
         end
        CCCS:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_fc_a;//   CS, C
         end
        CCCC:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_nfc_a;//   CC, NC
         end
        CCVS:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_fv_a;//   VS, V
         end
        CCVC:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_nfv_a;//   VC, NV
         end
        CCGT:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_fn_a & i_p3_ccunit_fv_a & 
                         i_p3_ccunit_nfz_a | i_p3_ccunit_nfn_a & 
                         i_p3_ccunit_nfv_a & 
                         i_p3_ccunit_nfz_a;//   GT
         end
        CCGE:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_fn_a & i_p3_ccunit_fv_a | 
                         i_p3_ccunit_nfn_a & 
                         i_p3_ccunit_nfv_a;//   GE
         end
        CCLT:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_fn_a & i_p3_ccunit_nfv_a | 
                         i_p3_ccunit_nfn_a & 
                         i_p3_ccunit_fv_a;//   LT
         end
        CCLE:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_fz_a | i_p3_ccunit_fn_a & 
                         i_p3_ccunit_nfv_a | i_p3_ccunit_nfn_a & 
                         i_p3_ccunit_fv_a;//   LE
         end
        CCHI:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_nfc_a & 
                         i_p3_ccunit_nfz_a;  //   HI
         end
        CCLS:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_fc_a | 
                         i_p3_ccunit_fz_a;//   LS
         end
        CCPNZ:
         begin
            i_p3_ccmatch_a = i_p3_ccunit_nfn_a & 
                         i_p3_ccunit_nfz_a;  //   PNZ
         end
        default:
         begin
            i_p3_ccmatch_a = 1'b 1;//   AL
         end
      endcase
    end // block: i_p3_ccunit_PROC
   

   // Combine the signals for flagging the execution of an instruction when
   // condition is true for both 32-bit and 16-bit, i.e conditionally
   // executed instructions.
   //
   assign i_p3_condtrue_sel0_a = (i_p3_opcode_32_fmt1_r | 
                                  x_idecode3) & 
                                  (~i_p3_fmt_cond_reg_r)  | 
                                  i_p3_alu16_condtrue_r; 

   assign i_p3_condtrue_sel1_a = (i_p3_opcode_32_fmt1_r | 
                                  x_idecode3            | 
                                  i_p3_sop_sub_r); 

   assign i_p3_condtrue_a = (i_p3_condtrue_sel0_a      | 
                             (i_p3_condtrue_sel1_a        & 
                              i_p3_ccmatch_alu_ext_a)) & 
                              i_p4_no_kill_p3_a; 

   //  This signal is true when an ALU instruction in stage 3 that employs an
   //  extension conditon code has been set.
   // 
   assign i_p3_ccmatch_alu_ext_a = ((i_p3_q_r[CCXBPOS] == 1'b 0) | 
                                       (XT_INSCC == 1'b 0)) ? 
                                       i_p3_ccmatch_a : 
                                       xp3ccmatch; 


//------------------------------------------------------------------------------
// The loop count register hit
//------------------------------------------------------------------------------
//
   // We need to generate a load signal for the loop count logic. This
   // is true when wben indicates a load is to take place, and wba[]
   // points to the loop count register.
   //
   // Note that this signal may be true when the processor is halted,
   // as delayed load writebacks and host writes must still be able to
   // take place.
   //
   assign i_p3_loopcount_hit_a = ((i_p4_wben_nld_nxt == 1'b 1) & 
                                  (i_p3_wback_addr_nld_a == RLCNT)) ?
          1'b 1 : 
          1'b 0; 


//------------------------------------------------------------------------------
//  Request for a Writeback in Stage 4
//------------------------------------------------------------------------------
//
   // Generate signals which are used in the register writeback request
   // calculation.
   //
   assign i_p3_x_snglec_wben_iv_a = x_snglec_wben & i_p3_iv_r & XT_ALUOP; 

   //  This is true when an extension instruction wants to writeback.
   //  Fifo-type instructions suppress writeback by setting xnwb.
   // 
   assign i_p3_xwb_op_a = (i_p3_x_snglec_wben_iv_a & 
                           (~xnwb) & 
                           (~i_p3_dest_imm_r)); 


   // This is true when regular ARC instruction, which is conditional
   // and can writeback to the register file, wants to write back. This
   // will be the case when the stage 3 condition is true, and the
   // operation does not have an immediate register as its destination.
   //
   assign i_p3_cc_xwb_wb_op_a = (i_p3_ccwbop_decode_iv_a | i_p3_xwb_op_a) &
                                 i_p3_condtrue_a; 

   // Note that p3dolink is qualified with p3iv here, even though it 
   // was qualified with p2iv at stage 2. This is to take account of
   // killed instructions, and pipeline tearing where stage 2 is held
   // and stage 3 continues.
   // Also note that all the signals which are not explicity qualified
   // with p3iv have already included it.  This does not apply to p3int
   // as p3int is mutually exclusive with p3iv.
   //
   // A writeback will be requested under the following conditions:
   //
   //  a. BLcc link register writeback,
   //  b. Load/Store instruction address writeback (PUSH/POP etc),
   //  c. Extension instruction register writeback,
   //  d. LR fetch from auxiliary registers,
   //  e. Regular conditional ARC instruction register writeback,
   //  f. Interrupt link register writeback.
   //
   assign i_p3_wb_req_a = i_p3_ni_wbrq_a | p3int; 

   // This signal is the same as i_p3_wb_req_a, except that it does not
   // include an option for the interrupt unit to write back. It is used 
   // in certain extensions where an external register set is provided,
   // which are not allowed to accept loads, or fifo-type extension ALU
   // instructions.
   //
   // A writeback will be requested under the following conditions:
   //
   //  a. BLcc link register writeback,
   //  b. Load/Store instruction address writeback (PUSH/POP etc),
   //  c. Extension instruction register writeback,
   //  d. LR fetch from auxiliary registers,
   //  e. Regular conditional ARC instruction register writeback.
   //
   assign i_p3_ni_wbrq_a = (i_p3_ni_wbrq_predec_iv_a | 
                            i_p3_cc_xwb_wb_op_a); 

   // Generate request to reserve stage 4 for the instruction currently
   // in stage 3.
   //
   // This signal is set true when the instruction at stage 3 wants to
   // reserve the writeback stage for itself. This is required when a
   // FifO-type instruction wants to suppress writeback to the register
   // file, but needs the data and register address to be present in the
   // writeback stage so that it can be picked off and sent into the
   // FifO buffer. 
   //
   assign i_p3_wb_rsv_a = (i_p3_x_snglec_wben_iv_a & 
                           i_p3_condtrue_a & 
                           xnwb); 

   assign i_p4_ldvalid_wback_a =
                                 ldvalid; 

//------------------------------------------------------------------------------
//  Generate writeback register address
//------------------------------------------------------------------------------
//
// A register writeback will be derived in the following order:
//
//  a. The regadr[] from the Load sorebaord unit (lsu), for delayed load
//     writeback,
//  b. The h_regadr from host interface (hostif), for host writes to core
//     registers,
//  c. All other sources for witeback which include:
//      [i]  Multi-cycle extensions x_multic_wba for writing back results from
//           the XMAC,
//      [ii] Other conditions that have already been combined into
//           i_p3_sc_dest_r.
//
// Note that delayed load register writebacks override host writes, and
// the host is held off for a cycle using the hold_host signal,
// generated by hostif.
//
// Note also that the code below generates two writeback addresses, one
// which is used as the final writeback address (i_p3_wback_addr_a), and
// one which can be generated very near to the start of the cycle
// (i_p3_sc_wba_a). This signal is used to generate the shortcut enable
// signals, and is combined with test of regadr which is not dependent
// on ldvalid being true, which would be the case if i_p3_wback_addr was
// used.
//
// !4p! Note that we only put regadr onto the writeback path bus if
// !4p! we're going to do a load return via the writeback path (4-port
// !4p! register file load returns go direct to the port on the register
// !4p! file).
//
   assign i_p3_wback_addr_a = (i_p4_ldvalid_wback_a == 1'b 1) ? 
          regadr : 
                              (cr_hostw == 1'b 1) ? 
          h_regadr : 
          i_p3_sc_wba_a; 


// A register writeback for the early arriving logic is specified in the
// conditions below:
//
//  a. Multi-cycle extensions x_multic_wba for writing back results from
//     the XMAC,
//  b. Other conditions that have already been combined into
//     i_p3_sc_dest_r.
//
//     [1] Select 'B' field for LD instructions, i_p2b_b_field_r.
//     [2] Select the stack pointer register for push/pop operations as they
//         will update the stack pointer, RSTACKPTR.
//     [3] Select destination from stage 2b, i_p2b_destination_r.
//
   assign i_p3_sc_wba_a = ((x_multic_wben & XT_MULTIC_OP) == 1'b 1) ? 
          x_multic_wba : 
          i_p3_sc_dest_r; 

   // The signal is purely for used by the XY Memory when it is included 
   // into an design. The signal is almost identical to i_p3_wback_addr_a
   // except that the regadr input term has been omitted. This is because
   // the XY Memory cannot accept pointer as destination of loads. This
   // modification also removes long time path that eliminates from the 
   // arbiter. When XY Memory is not included, this output is removed via 
   // the boundary_optimation mode in Design Compiler.
   //
   assign i_p3_wback_addr_nld_a = (cr_hostw == 1'b 1) ? 
          h_regadr : 
          i_p3_sc_wba_a; 


//------------------------------------------------------------------------------
// Pipeline Stage 3 Multi-cycle writeback stall
//------------------------------------------------------------------------------
// 
   // The multi-cycle pipeline writeback will be stalled if a returning load or
   // a host write to a core register is performed on the next cycle.
   //
   assign i_p3_xmultic_nwb_a = (cr_hostw | i_p4_ldvalid_wback_a); 
  
   // Stall the ARC when instruction in stage 3 is :
   //
   // [1] Requesting a writeback                    OR
   // [2] Reserving the stage 4 writeback registers OR
   // [3] An interrupt (writes to ILINK)            OR
   // [4] A single cycle extension instruction wants to writeback
   //
   assign i_p3_wb_instr_a = (i_p3_wb_req_a |
                             i_p3_wb_rsv_a |
                             p3int         |
                             i_p3_x_snglec_wben_iv_a);
 
 
//------------------------------------------------------------------------------
//  Branch protection system
//------------------------------------------------------------------------------
//
// In order to reduce code size, we want to remove the need to have a
// NOP between setting the flags and taking the associated branch.
//
// e.g.         sub.f       0,r0,23         ; is r0=23?
//              nop                         ; padding instruction. <//
//              bz          r0_is_23        ;
//
// In order that the compiler does not have to generate these
// instructions, we can generate a stage 2 stall if an instruction in
// stage 3 is attempting to set the flags. Once this instruction has
// completed, and has passed out of stage 3, then stage 2 will continue.
//
// We need to detect the following types of valid instruction at stage
// three:
//
//   i. Any ALU instruction which sets the flags (p3setflags) 
//  ii. Jcc.F
// iii. A FLAG instruction.
//
   assign i_p2b_special_flagset_a = ((i_p2b_opcode_32_fmt1_a & 
                                 i_p2b_flag_bit_r & 
                                 (i_p2b_subopcode_j_a | 
                                 i_p2b_subopcode_jd_a)) 
                                 |
                                 //  FLAG
                                 (i_p2b_opcode_32_fmt1_a & 
                                 i_p2b_subopcode_flag_a)); 
                                 
   assign i_p2b_bch_flagset_a = i_p2b_iv_r & (i_p2b_setflags_r | 
                                i_p2b_special_flagset_a); 

   assign i_p3_bch_flagset_a = i_p3_iv_r & (i_p3_setflags_r | 
                               i_p3_special_flagset_r);
                                    
//------------------------------------------------------------------------------
// Compare & branch CC checking
//------------------------------------------------------------------------------
//
   // If the instruction entering stage 3 is a predicted BRcc then invert the
   // CC. This is carried out in this stage for static timing reasons
   //
   always @(i_p3_q_r)
    begin : p3_BRcc_q_async_PROC

      case (i_p3_q_r[STD_COND_CODE_MSB:0])
        BR_CCNE, BBIT1:
         begin
            i_p3_inv_br_q_32_a = BR_CCEQ;   
         end
        BR_CCLT:
         begin
            i_p3_inv_br_q_32_a = BR_CCGE;   
         end
        BR_CCGE:
         begin
            i_p3_inv_br_q_32_a = BR_CCLT;   
         end
        BR_CCLO:
         begin
            i_p3_inv_br_q_32_a = BR_CCHS;   
         end
        BR_CCHS:
         begin
            i_p3_inv_br_q_32_a = BR_CCLO;   
         end
        default:
         begin
            i_p3_inv_br_q_32_a = BR_CCNE;   
         end
      endcase

      // Transform BBIT1 into ccne and BBIT0 into cceq
      //
      case (i_p3_q_r[STD_COND_CODE_MSB:0])
        BR_CCNE, BBIT1:
         begin
            i_p3_no_inv_br_q_tmp = BR_CCNE;
         end
        BR_CCEQ, BBIT0:
         begin
            i_p3_no_inv_br_q_tmp = BR_CCEQ;   
         end
        default:
         begin
            i_p3_no_inv_br_q_tmp = i_p3_q_r[STD_COND_CODE_MSB:0];   
         end
      endcase
    end 
   
   // Select the correct inverted condition code for the 16-bit BRcc
   // instructions.
   //
   assign i_p3_inv_br_q_16_a = (BR_CCEQ &
                                {(CONDITION_CODE_MSB){i_p3_alu_brne16_r}} 
                                | 
                                BR_CCNE &
                                {(CONDITION_CODE_MSB){i_p3_alu_breq16_r}});

   // Select between the 32-bit and 16-bit inverted condition codes
   //
   assign i_p3_inv_br_q_a = (i_p3_br_or_bbit32_r == 1'b 1) ? 
          i_p3_inv_br_q_32_a : 
          i_p3_inv_br_q_16_a; 


   // Select between the non-inverted condition code
   //
   assign i_p3_no_inv_br_q_a = (BR_CCNE &
                                {(CONDITION_CODE_MSB){i_p3_alu_brne16_r}}
                                | 
                                BR_CCEQ &
                                {(CONDITION_CODE_MSB){i_p3_alu_breq16_r}} 
                                | 
                                i_p3_no_inv_br_q_tmp &
                                {(CONDITION_CODE_MSB){i_p3_br_or_bbit32_r}});

   // If the compare & branch has been predicted then the condtion code must be
   // inverted.
   //
   assign i_p3_br_q_a = (i_p3_brcc_pred_r == 1'b 0) ?
          i_p3_no_inv_br_q_a :
          i_p3_inv_br_q_a;

   // Do the condtion code / flag evaluation at the end of stage 3, ready to be
   // latched into stage 4.
   //
   always @(br_flags_a or i_p3_br_q_a)
    begin : br_ccunit_PROC

      i_p3_br_ccunit_fz_a = br_flags_a[A_Z_N];   
      i_p3_br_ccunit_fn_a = br_flags_a[A_N_N];   
      i_p3_br_ccunit_fc_a = br_flags_a[A_C_N];   
      i_p3_br_ccunit_fv_a = br_flags_a[A_V_N];   
      i_p3_br_ccunit_nfz_a = ~br_flags_a[A_Z_N];   
      i_p3_br_ccunit_nfn_a = ~br_flags_a[A_N_N];   
      i_p3_br_ccunit_nfc_a = ~br_flags_a[A_C_N];   
      i_p3_br_ccunit_nfv_a = ~br_flags_a[A_V_N];   

      case (i_p3_br_q_a) 
        BR_CCNE:
         begin
            i_p4_ccmatch_br_a = i_p3_br_ccunit_nfz_a;
                                                          //   NE/NZ
         end
        BR_CCLT:
         begin
            i_p4_ccmatch_br_a = i_p3_br_ccunit_fn_a  &
                                  i_p3_br_ccunit_nfv_a | 
                                  i_p3_br_ccunit_nfn_a &
                                  i_p3_br_ccunit_fv_a;
                                                          //   LT
         end
        BR_CCGE:
         begin
            i_p4_ccmatch_br_a = i_p3_br_ccunit_fn_a  &
                                  i_p3_br_ccunit_fv_a  | 
                                  i_p3_br_ccunit_nfn_a &
                                  i_p3_br_ccunit_nfv_a;
                                                          //   GE
         end
        BR_CCLO:
         begin
            i_p4_ccmatch_br_a = i_p3_br_ccunit_nfc_a;  //   LO
         end
        BR_CCHS:
         begin
            i_p4_ccmatch_br_a = i_p3_br_ccunit_fc_a &
                                i_p3_br_ccunit_nfz_a | 
                                i_p3_br_ccunit_fz_a;      //   HI
         end
        default:
         begin
            i_p4_ccmatch_br_a = i_p3_br_ccunit_fz_a;   //   EQ/Z           
         end
      endcase
   end // block: br_ccunit_PROC
   
//------------------------------------------------------------------------------
// Sync instruction present
//------------------------------------------------------------------------------

   // This signal stalls the pipe when a sync instruction is present and
   // keeps it stalled until all memory operations have finished.
   // If it is in the delay slot of a brcc then it can be canceled if
   // the delay slot is not taken (i_p4_no_kill_p3_a).
   //
   assign i_p3_sync_stalls_pipe = (i_p3_sync_instr_iv_a & 
                                   i_p4_no_kill_p3_a &
                                   ((lpending & ~i_sync_local_ld_r) 
	 
                                    | (~sync_queue_idle & ~i_ignore_debug_op_r)
                                    )) ? 1'b1 : 1'b0;
				      
   // actual stall signal, debug accesses will not stall the pipe.
   //				      
   assign i_p3_sync_stalls_pipe_a = i_p3_sync_stalls_pipe & i_ignore_debug_op_a;
				   
   always @(posedge clk or posedge rst_a)
    begin : sync_PROC
      if (rst_a == 1'b 1)
        begin
          i_sync_local_ld_r       <= 1'b 0;
	  i_p3_sync_stalls_pipe_r <= 1'b 0;
	  i_lpending_prev_r       <= 1'b 0;
	  i_ignore_debug_op_r     <= 1'b 0; 
	  i_store_in_progress_r   <= 1'b 0;
  
        end
      else
        begin
	  // Is a load in progress
	  //
	  i_lpending_prev_r <= lpending;
	  
	  // load is to local memory
	  //
          i_sync_local_ld_r <= (dmp_mload & is_local_ram & ~i_lpending_prev_r); 
	  
	  // Register the stall signal.
	  //
	  i_p3_sync_stalls_pipe_r <= i_p3_sync_stalls_pipe_a; 
	  
	  // We need to be aware of any non-debug stores that are
	  // in progress - we need to stall the pipe if a sync
	  // instruction later comes into stage 3 while they are in
	  // progress.
	  // 
	  if (dmp_mstore && ~debug_if_r)
	    i_store_in_progress_r <= 1'b1;
	  if (sync_queue_idle)
	    i_store_in_progress_r <= 1'b0;
	  
	  // Stores are issued by the debug port but debug_if_r
	  // can go low before they complete so we need to track
	  // them. 
	  // If a non-debug store is in progress or a debug store
	  // is in progress and a non-debug store comes along then 
	  // sync will need to stall the pipe.
	  //
	  if ((i_p3_sync_stalls_pipe_a == 1'b0 && i_store_in_progress_r == 1'b0)
	      && dmp_mstore && debug_if_r)
	    i_ignore_debug_op_r <= 1'b1;
	  if (sync_queue_idle || (dmp_mstore && ~debug_if_r && ~is_local_ram))
	    i_ignore_debug_op_r <= 1'b0;   
	       
        end
    end
    
    // Debug ops should be ignored if a pipe stall is under way.
    //
    assign i_ignore_debug_op_a = debug_if_r ?
                                   ( 
                                    i_p3_sync_stalls_pipe_r 
				    | i_store_in_progress_r
				   )
				   : 1'b1;

//------------------------------------------------------------------------------
// Stage 3 Instruction Completion Control
//------------------------------------------------------------------------------
//
// This signal is true when the processor is running, and the instruction in
// stage 3 can be allowed complete and set the flags if appropriate.
//
//  ** Note: Control of data from stage 3 to stage 4 is controlled by 
//           p3wb_en. **
//
//  Stage 3 may be prevented from completing for a number of reasons:
//
//  a. An extension multi-cycle ALU operation has requested extra time
//     to complete the operation (xholdop3). Note that this can only
//     be the case when extension alu operations are enabled with the
//     XT_ALUOP constant in extutil.
//
//  c. The ARC600 and an extension multicycle instruction  want to
//     write back during the same cycle (i_p3_multic_wben_stall_a).
//
//  d. The memory controller is busy and cannot accept any more load or
//     store operations. (mwait)
//
// Load return (no-stall returns enabled)
//
//  e. A delayed load writeback will happen on the next cycle and the 
//     instruction in stage 3 wants to write back to the register file.
//     (ldvalid = '1' and p3_wb_req = '1').
//
//  f. A delayed load writeback will happen on the next cycle and the 
//     instruction in stage 3 is suppressing writeback to the register
//     file, and wants the data & register address values from the
//     writeback stage. For this reason, the instruction must be stalled
//     to prevent the data/address from being overwritten by a returning
//     delayed load.
//     (i_ldvalid_wback = '1' and p3_wb_rsv = '1').
//
// Load return (loads always stall)
//
//  g. Delayed loads always cause stalls.
//
//  h. The actionpoint debug mechanism or the breakpoint instruction (in
//     debug_exts) is triggered and thus disables the instructions from
//     going into stage 4 since pipeline has been flushed.
//
//  i. There is a compare/branch in stage 3 and the instruction in stage
//     one is not valid.
//
   // Returning Load Stall
   //
   // A stage 3 instruction stall be generated under the following conditions:
   // (1) A delayed load writeback will happen on the next cycle and the 
   // instruction in stage 3 also may want to writeback.
   //
   assign i_p3_load_stall_a = i_p4_ldvalid_wback_a & i_p3_wb_instr_a; 

   // Multicycle instruction writeback stall
   //
   // A stage 3 instruction in stage 3 of the basecase pipeline may want to
   // write back at the end of the cycle, however a multicycle instruction also
   // wants to writeback.  The basecase pipeline is stalled to allow the
   // multicycle to complete first.
   //
   assign i_p3_multic_wben_stall_a = (x_multic_wben & 
                                      XT_MULTIC_OP &
                                      i_p3_wb_instr_a);

   // Extension holdup stall
   //
   // A stall can happen in stage 3 when:
   //
   // [1] An extension can stall stage 3 by asserting the xholdup3 signal.
   //
   assign i_p3_holdup_stall_a = (xholdup3 & XT_ALUOP)           |
                                1'b 0; 

   // Instruction step stall
   //
   // When instruction stepping a control transfer it will be possible for the
   // control transfer to complete without the PC from being updated, this
   // causes problems for instruction stepping logic.  This stall will stall any
   // control transfer in stage 3 if it has not completed fully.
   //
   assign i_p3_step_stall_a = pcounter_jmp_restart_r & do_inst_step_r;

   // The power saving stall prevents garbage data from moving down the pipeline
   // and causing spurious switching.
   //
   assign i_p3_pwr_save_stall_a = ~i_p3_iv_r & ~p3int; 

   assign i_p3_enable_a = ~((~en)                       |
                            (~i_p3_enable_nopwr_save_a) |
                            i_p3_pwr_save_stall_a);

   assign i_p3_enable_nopwr_save_a = ((mwait                    == 1'b 1) | 
                                      (i_p3_step_stall_a        == 1'b 1) | 
                                      (i_p3_multic_wben_stall_a == 1'b 1) | 
                                      (i_p3_load_stall_a        == 1'b 1) |
                                      (i_p3_sync_stalls_pipe_a  == 1'b 1) | 
                                      (i_p3_holdup_stall_a      == 1'b 1)) ?
          1'b 0 : 
          1'b 1; 

   assign i_p3_en_non_iv_mwait_a = ((en                       == 1'b 0) | 
                                        (i_p3_pwr_save_stall_a    == 1'b 1) | 
                                        (i_p3_multic_wben_stall_a == 1'b 1) |
                                        (i_p3_load_stall_a        == 1'b 1) | 
                                        (i_p3_step_stall_a        == 1'b 1) | 
                                        (i_p3_holdup_stall_a      == 1'b 1)) ?
          1'b 0 : 
          1'b 1; 


//------------------------------------------------------------------------------
// Stage 3 write-back enable
//------------------------------------------------------------------------------
//
// This signal is true when the processor is running, and a valid
// instruction stage 3 can be allowed to move on into stage 4. It is
// also true when a delayed load completes or a host write is taking
// place (these do not require the processor to be running).
//
// FIFO instructions which set i_p3_wb_rsv_a to reserve the writeback
// slot cause p3wb_en to be set true to allow the address and data
// values to flow into stage 4, although this type of instruction does 
// *NOT* set wben to enable writeback to the register file on the
// following instruction.
//
// Stage 3 instructions may be held up for a number of reasons:
// (same reasons as for en3)
//
//  a. The processor is halted.
//
//  b. A branch in stage 2 is held, and stage 3 must also be held to 
//     protect the flags used by the branch condition code unit.
//
//  c. An extension multi-cycle ALU operation has requested extra time
//     to complete the operation (xholdop123). Note that this can only
//     be the case when extension alu operations are enabled with the
//     XT_ALUOP constant in extutil.
//
//
//  d. The memory controller is busy and cannot accept any more load or
//     store operations. (mwait)
//
   // The i_p4_wben_nxt signal is set true when a register writeback will 
   // occur on the next cycle.
   //
   assign i_p4_wben_nxt = i_p4_wben_nld_nxt | i_p4_ldvalid_wback_a; 

   assign i_p3_wb_stall_a = ((en                    == 1'b 0) | 
                             (mwait                 == 1'b 1) | 
                             (i_p3_step_stall_a     == 1'b 1) | 
                             (i_p3_pwr_save_stall_a == 1'b 1) | 
                             (i_p3_holdup_stall_a   == 1'b 1)) ?
          1'b 1 : 
          1'b 0; 

   assign i_p4_wben_nld_nxt = ((cr_hostw == 1'b 1) | 
                              ((x_multic_wben & XT_MULTIC_OP) == 1'b 1)) ?
          1'b 1 : 
                              ((i_p3_wb_stall_a == 1'b 1) |
                               (i_p3_wb_req_a   == 1'b 0) | 
                               (i_p4_kill_p3_a  == 1'b 1)) ?
          1'b 0 : 
          1'b 1; 

   // The i_p3_wback_en signal is set true when a real register writeback will
   // happen, but also when the writeback slot is reserved for a FIFO
   // instruction.
   //
   assign i_p3_wback_en_a = i_p4_wben_nxt | i_p3_wb_rsv_a; 

   assign i_p3_wback_en_nld_a = i_p4_wben_nld_nxt | i_p3_wb_rsv_a; 

//------------------------------------------------------------------------------
// Stage 4 pipeline registers
//------------------------------------------------------------------------------
  
   // The stage 4 writeback control signal is latched from p3wb_en, and is true
   // whenever stage 4 contains a data value which is to be written into the
   // register address provided.
   //
   always @(posedge clk or posedge rst_a)
    begin : Stage_4_PROC
      if (rst_a == 1'b 1)
        begin
          i_p4_wben_r       <= 1'b 0;   
          i_p4_br_or_bbit_r <= 1'b 0;   
          i_p4_has_dslot_r  <= 1'b 0;   
          i_p4_ccmatch_br_r <= 1'b 0;   
          i_p4_wba_r        <= {(OPERAND_MSB + 1){1'b 0}};   
        end
      else
        begin
     
          i_p4_wben_r <= i_p4_wben_nxt;

//------------------------------------------------------------------------------
// Stage 4 Write-back address
//------------------------------------------------------------------------------
// The data to be used for input to stage 4 is latched in the ALU block.
//
// We only clock the register number for writeback, along with the
// actual data that is to be written back.
//
//  Note that the register address is produced from a number of sources,
//  and is not simply the A field from the instruction.
//    
//
          if (i_p3_wback_en_a == 1'b 1)
            begin                         
              i_p4_wba_r  <= i_p3_wback_addr_a;
            end
                        

          if (i_p3_enable_a == 1'b 1)
            begin
              i_p4_ccmatch_br_r <= i_p4_ccmatch_br_nxt;   
              i_p4_br_or_bbit_r <= i_p3_br_or_bbit_iv_a;   
              i_p4_has_dslot_r  <= i_p3_has_dslot_r;   
            end
        end
    end 
   
   assign i_p4_br_or_bbit_iv_a = i_p4_br_or_bbit_r & i_p4_iv_r; 
   assign i_p4_ccmatch_br_nxt =  i_p4_ccmatch_br_a & 
                                 i_p3_br_or_bbit_iv_a;

//------------------------------------------------------------------------------
// Stage 4 instruction valid 
//------------------------------------------------------------------------------
 
   assign i_p4_iv_nxt = ((i_p3_enable_a        == 1'b 0) | 
                         (i_p4_kill_p3_a       == 1'b 1) |
                         (i_p3_br_or_bbit_iv_a == 1'b 0)) ?
        1'b 0 : 
        i_p3_iv_r; 

   always @(posedge clk or posedge rst_a)
    begin : p4_iv_sync_PROC
      if (rst_a == 1'b 1)
        begin
          i_p4_iv_r <= 1'b 0;   
        end
      else
        begin
          i_p4_iv_r <= i_p4_iv_nxt;   
        end
    end


//------------------------------------------------------------------------------
// STAGE4  Branch Taken
//------------------------------------------------------------------------------
//
   // This signal is employed for operations that are conditionally
   // executed (32/16-bit).
   //
   assign i_p4_docmprel_a = i_p4_ccmatch_br_r & i_p4_iv_r; 

//------------------------------------------------------------------------------
// Delay Slot Cancelling
//------------------------------------------------------------------------------
//
// Compare & branch instructions may kill the following instructions depending
// on the delay slot mode and whether the instruction's condition is true.
//
   assign i_p4_kill_p1_a = i_p4_docmprel_a; 

   assign i_p4_kill_p2_a = (i_p4_docmprel_a & 
                            (~(i_p4_has_dslot_r & 
                              (~i_p2b_iv_r) & 
                              (~i_p3_iv_r)))); 

   assign i_p4_kill_p2b_a = (i_p4_docmprel_a & 
                             (~(i_p4_has_dslot_r & 
                               (~i_p3_iv_r)))); 

   // Only kill stage 3 instruction if there is no delay slot.
   //
   assign i_p4_kill_p3_a = (i_p4_docmprel_a & 
                            (~i_p4_has_dslot_r)); 

   // When true stage 4 will not kill stage 3.
   //
   assign i_p4_no_kill_p3_a = ((~i_p4_docmprel_a) | 
                               i_p4_has_dslot_r);
 
   assign kill_last = (i_p4_kill_p3_a & 
                       i_p3_ld_decode_iv_a); 


//------------------------------------------------------------------------------
// Interrupt Blockout logic
//------------------------------------------------------------------------------
//
// This logic holds off interrupts when there is a FLAG, Jcc.F in the
// pipeline.
//
// This is necessary in order to ensure that code which disables
// interrupts behaves intuitively. It was possible for the fact that the
// e1 and e2 flags are updated at stage 3 meant that two instructions
// could be fetched before interrupts were disabled.
//
// One of these two instructions would be killed by an incoming
// interrupt, but this still meant that it was possible for an interrupt
// to occur in two un-helpful places:
//
//  i. Immediately after the FLAG instruction
//
//     In this case the interrupts are disabled on entry to the ISR.
//     Whilst this should be fine in most circumstances, it appears that
//     some RTOS systems have options to reset the interrupt enable
//     level to a standard value on exit of the ISR. Clearly if this
//     were done, it would mean that interrupt would be re-enabeld on
//     returning to the code where the programmer expected that they be
//     disabled. 
//
//     This case requires us to block interrupts if there is any
//     instruction present in stage 2 which could set the e1 and e2
//     flags. This means either the FLAG instruction, Jcc.F
//
// ii. After the instruction following the FLAG instruction.
//
//     This is the case most likely to cause a problem if the programmer 
//     is not aware FLAG instruction's behaviour.
//      
//     The programmer might expect that no interrupts would be possible 
//     after the instruction which disabled interrupts. As such, the
//     first instruction could be part of the code which the programmer
//     intends to be an atomic sequence of instructions. Since an 
//     interrupt could be taken after this first instruction, it is
//     possible for bad things to happen.
//
//     This case requires us to block interrupts if there is any
//     instruction present in stage 3 which could set the e1 and e2
//     flags. This means either the FLAG instruction, Jcc.F.
//     Conceivably we could also test to see if the instruction was
//     attempting to disable the interrupts here, and check whether the
//     instruction was going to be executed. For simplicity and
//     consistency of the logic, we do not perform these tests.
//
   assign i_p2_flagu_block_a = (i_p2_iv_r              & 
                                (i_p2_opcode_32_fmt1_a & 
                                 i_p2_subopcode_flag_a |
                                 i_p2_opcode_32_fmt1_a & 
                                 i_p2_flag_bit_a & 
                                 (i_p2_subopcode_j_a | 
                                  i_p2_subopcode_jd_a)));

   assign i_p2b_flagu_block_a = (i_p2b_iv_r & i_p2b_special_flagset_a); 

   assign i_p3_flagu_block_a = (i_p3_iv_r & i_p3_special_flagset_r); 

   assign i_flagu_block_a = (i_p2_flagu_block_a | 
                             i_p2b_flagu_block_a | 
                             i_p3_flagu_block_a); 


//------------------------------------------------------------------------------
// Halt Single Instruction Step
//------------------------------------------------------------------------------
//
   // The stop_step signal halts the single instruction when it is completed.
   //
   assign i_stop_step_a = (((i_p2_step_a == 1'b 1) &
                     
                     // there is no instruction in normal pipeline
                     (i_p2_iv_r == 1'b 0) & 
                     (i_p2b_iv_r == 1'b 0) & 
                     (i_p3_iv_r == 1'b 0) & 
                     (i_p4_iv_r == 1'b 0) & 
                     
                     // there are no interrupts in pipeline
                     (p2int == 1'b 0) & 
                     (p2bint == 1'b 0) & 
                     (p3int == 1'b 0) & 
                     
                     // the pipeline is not waiting for a part of an
                     // intruction packet to arrive
                     (i_p2_tag_nxt_p1_limm_r == 1'b 0) & 
                     (i_p2_tag_nxt_p1_dslot_r == 1'b 0) & 
                     (pcounter_jmp_restart_r == 1'b 0) & 
                     
                     // there are no outstanding loads
                     (lpending == 1'b 0) & 
                     
                     // there are no multicycle instruction still
                     //  outstanding
                     (x_multic_busy == 1'b 0))
                     | 
                     ((i_p2_step_a == 1'b 1) & 

                     // if a BRK has arrived in stage 2 stop the
                     //  instrucution step
                     (i_p2_brk_inst_a == 1'b 1))) ? 1'b 1 : 
        1'b 0; 

//------------------------------------------------------------------------------
// Track Single Instruction Step
//------------------------------------------------------------------------------
//
// The step_tracker process keeps track on where in the pipeline the
// instruction is during single instruction step. It generates three
// tracking signals: i_p1_p2step, i_p2_step and i_p3_step_r. The signal
// i_p2_step is high when the instruction is in pipestage 2 and
// i_p3_step_r is high when the instruction is in pipestage3. As you see
// in the timing diagram below i_p2_step and i_p3_step_r stays high after
// being set until the cycle after the stop signal stop_step is issued,
// which means that the instruction has completed.
//
// Here is an example how the step tracker process works for an
// instruction with writeback and no long immediate. The pipeline
// is clean before the step starts.
//
//                   __    __    __    __    __
//   clk            /  \__/  \__/  \__/  \__/  \
//                   ____________________
//   do_inst_step_r /                    \______
//                   _____          
//   i_enable1      /      \____________________
//                   ___________________________
//   ivalid_aligned /                           
//                        _____________
//   i_p1p2step     _____/             \________
//                        
//                                  _____
//   stop_step      _______________/     \______
//
// The signal i_p1_p2step is set when a valid instruction has moved
// from stage 1 to stage2. This signal sets i_p2_step. But i_p2_step
// is not only set by i_p1_p2step but also if there is already an
// instruction in stage 2 that uses long immediate or has a killed
// delay slot or if an interrupt is in stage 2 (p2int is set). This
// can happen if the ARC was just halted after running in free
// -running. The pipeline can then be filled with anything in this
// situation. This can only happen on the first instruction step
// after free-running mode. On the second consecutive instruction
// step the pipeline will be clean.
//   
   assign i_p2_step_a = (i_p1p2step_r | 
                         do_inst_step_r & 
                         (i_p2_long_immediate_a | 
                          i_p2_kill_p1_a | 
                          p2int)); 

   assign i_start_step_a = (i_p1_enable_a & 
                            (ivalid_aligned | 
                             p1int) |
                            pcounter_jmp_restart_r); 

   always @(posedge clk or posedge rst_a)
    begin : step_tracker_PROC
      if (rst_a == 1'b 1)
        begin
          i_p1p2step_r <= 1'b 0;   
        end
      else
        begin
          if (i_stop_step_a == 1'b 1)
            begin
              i_p1p2step_r <= 1'b 0;   
            end
          else if (i_start_step_a == 1'b 1 )
            begin
              i_p1p2step_r <= do_inst_step_r;   
            end
        end
    end
   
//------------------------------------------------------------------------------
// Pipeline Flushing & Stalling Logic
//------------------------------------------------------------------------------
//
// The pipeline flushing mechanism has been introduced to support the
// breakpoint instruction, software interrupt and actionpoint hardware. Each
// stage of the pipeline is stalled explicitly, and once all stages 1, 2, 2b and
// 3 have been stalled the ARC600 is stalled via en bit (in flags).
//
   // The stalling signal for stalling en1 is defined by
   // i_p2_brk_sleep_swi_a, and this is set to '1' on the following conditions:
   //
   //  a. The breakpoint instruction has been detected at stage
   //     two, i.e. i_p2_brk_inst_a = '1' or an actionpoint has been
   //     triggered by a valid signal from the OR-plane, from
   //     debug_exts.
   //
   //  b. The instruction in stage one of the pipeline is to be
   //     executed, and not killed.
   //
   //  c. The sleep instruction has been detected in stage 2.
   //
   //  d. The ARC is sleeping already (sleeping = '1') due to a sleep
   //     instruction that was encountered earlier.
   //
   //  e. A swi instruction has entered stage 2. a SWI instruction will flush
   //     the pipeline to allow all instruction ahead to finish before it
   //     generates the interrupt. This is need to prevent a BRK from halting
   //     the processor before the interrupt has been serviced.
   //
   assign i_p2_brk_sleep_swi_a = (i_p2_sleep_inst_a | 
                                  i_p2_brk_inst_a   |
                                  i_p2_swi_inst_a   |
                                   actionpt_pc_brk_a |                                                                    
                                  sleeping_r2       |
                                  sleeping          |
                                  i_actionhalt_a); 

   // As the pipeline is flushed of instructions when the breakpoint
   // or swi instructions or a valid actionpoint is detected it is important to
   // disable each stage explicitly. These signals have to follow the
   // last instruction which is being allowed to complete. A normal
   // instruction in stage one will mean that instructions in stage two,two b
   // three and four will be allowed to complete. However, for an
   // instruction in stage one which is in the delay slot of a branch,
   // loop or jump instruction means that stage two has to be stalled as
   // well. Therefore, only stages three and four will be allowed to
   // complete.
   //
   // The qualifying valid signal for stage two is defined by
   // i_p2_disable_nxt, and this is set to '1' on the following
   // conditions:
   //
   //  a. There is an instruction in stage two which has a dependency in
   //     stage one, i.e. i_break_stage2 = '1'.
   //
   //  b. The breakpoint instruction or actionpoint has been detected,
   //     i.e. i_p2_brk_sleep_swi_a1 = '1' and the instruction in stage
   //     two is enabled, i_enable2 = '1', and the instruction is allowed to
   //     move on.
   //
   //  c. The breakpoint instruction or actionpoint has been detected,
   //     i.e. i_p2_brk_sleep_swi_a = '1' and the instruction in stage
   //     two is invalid, i_p2_iv_r = '0'.
   //
   assign i_p2b_disable_nxt = (i_p4_kill_p2b_a == 1'b 1) ? 
          1'b 0:
                              ((i_p2_brk_sleep_swi_a == 1'b 1) &
                               (((i_p2b_enable_a == 1'b 1) & 
                                 (i_p2b_iv_r == 1'b 1))    | 
                                (i_p2b_iv_r == 1'b 0))) ?
          1'b 1 : 
          1'b 0; 

   // The qualifying valid signal for stage three is defined by
   // i_p3_disable_nxt, and this is set to '1' on the following
   // conditions:
   //
   //  a. The instruction in stage two is invalid, i_p2bdisable_r = '1'.
   //     Also the instruction in stage three is enabled, en3 = '1', and 
   //     the instruction is allowed to move on, and there is no multicycle
   //     instruction in progress.
   //
   //  b. The instruction in stage two is invalid, i_p2bdisable_r = '1'.
   //     Also the instruction in stage three is invalid, i_p3_iv_r =
   //     '0' and there is no multicycle instruction in progress.
   //
   assign i_p3_disable_nxt = (i_p2_brk_sleep_swi_a == 1'b 0) ? 
          1'b 0 : 
                             ((i_p2b_disable_r == 1'b 1)  & 
                              (((i_p3_enable_a == 1'b 1)  & 
                                (i_p3_iv_r     == 1'b 1)  & 
                                (x_multic_busy == 1'b 0)) | 
                               ((x_multic_busy == 1'b 0) & 
                                (i_p3_iv_r     == 1'b 0)))) ?
          1'b 1 : 
          1'b 0; 

   assign i_p4_disable_nxt = (i_p2_brk_sleep_swi_a == 1'b 0) ?  
          1'b 0 : 
                             ((i_p3_disable_r == 1'b 1) & 
                              (i_p4_iv_r == 1'b 0)) ? 
          1'b 1 : 
          1'b 0; 

   always @(posedge clk or posedge rst_a)
    begin : pipe_disable_PROC
      if (rst_a == 1'b 1)
        begin
          i_p2b_disable_r <= 1'b 0;   
          i_p3_disable_r <= 1'b 0;   
          i_p4_disable_r <= 1'b 0;   
        end
      else
        begin
          i_p2b_disable_r <= i_p2b_disable_nxt;   
          i_p3_disable_r <= i_p3_disable_nxt;   
          i_p4_disable_r <= i_p4_disable_nxt;   
        end
    end 
   
//------------------------------------------------------------------------------
//  Kill signals
//------------------------------------------------------------------------------
//
   assign i_kill_p2_en_a = i_p4_kill_p2_a
                           | i_p2b_kill_p2_en_a
                     ;
                     
   assign i_kill_p2_a = i_p4_kill_p2_a
                        | i_p2b_kill_p2_a
                     ;
                     
   assign i_kill_p1_a = i_kill_p1_nlp_a
                        | loop_kill_p1_a
                  ;
                     
   assign i_kill_p1_en_a = i_kill_p1_nlp_en_a
                           | loop_kill_p1_a
                     ;
                     
   assign i_kill_p1_nlp_en_a = i_p4_kill_p1_a     | 
                               i_p2b_kill_p1_en_a | 
                               i_p2_kill_p1_en_a  | 
                               i_p2_brcc_pred_nds_en_a; 

   assign i_kill_p1_nlp_a = i_p4_kill_p1_a  | 
                            i_p2b_kill_p1_a | 
                            i_p2_kill_p1_a  | 
                            i_p2_brcc_pred_nds_a; 

//------------------------------------------------------------------------------
//  Stage 1 Output Drives
//------------------------------------------------------------------------------
//
   assign awake_a         = i_awake_a; 
   assign en1             = i_p1_enable_a; 
   assign ifetch_aligned  = i_ifetch_aligned_a; 
   assign instr_pending_r = i_instr_pending_r;
   assign inst_stepping   = i_inst_stepping_a; 
   assign pcen            = i_pcen_a; 
   assign pcen_niv        = i_pcen_non_iv_a; 
//------------------------------------------------------------------------------
// Stage 2 Output Drives
//------------------------------------------------------------------------------
// 
   assign en2 = i_p2_enable_a; 
   assign p2_a_field_r = i_p2_a_field_r; 
   assign p2_abs_neg_a = i_p2_abs_neg_decode_a; 
   assign p2_b_field_r = i_p2_b_field_r; 
   assign p2_brcc_instr_a = i_p2_br_or_bbit_iv_a; 
   assign p2_c_field_r = i_p2_c_field_r; 
   assign p2_dopred = i_p2b_brcc_pred_nxt; 
   assign p2_dopred_ds = i_p2b_brcc_pred_ds_nxt; 
   assign p2_dopred_nds = i_p2_brcc_pred_nds_a; 
   assign p2_dorel = i_p2_dorel_a; 
   assign p2_iw_r = i_p2_iw_r; 
   assign p2_jblcc_a = i_p2_jblcc_iv_a; 
   assign p2_lp_instr = i_p2_loop32_a; 
   assign p2_not_a = i_p2_not_decode_a; 
   assign p2_s1a = i_p2_source1_addr_a; 
   assign p2_s1en = i_p2_source1_en_a; 
   assign p2_s2a = i_p2_source2_addr_a; 
   assign p2_shimm_data = i_p2_short_immediate_a; 
   assign p2_shimm_s1_a = i_p2_shimm_s1_a & i_p2_iv_r; 
   assign p2_shimm_s2_a = i_p2_shimm_a & i_p2_iv_r; 
   assign p2bch = i_p2_branch_iv_a; 
   assign p2cc = i_p2_iw_r[CCUBND:CCLBND]; 
   assign p2conditional = i_p2_conditional_a; 
   assign p2condtrue = i_p2_condtrue_a; 
   assign p2delay_slot = i_p2_has_dslot_a; 
   assign p2format = i_p2_format_r; 
   assign p2iv = i_p2_iv_r; 
   assign p2limm = i_p2_limm_a; 
   assign p2lr = i_p2_lr_decode_iv_a; 
   assign p2minoropcode = i_p2_minoropcode_r; 
   assign p2offset = i_p2_offset_a; 
   assign p2opcode = i_p2_opcode_a; 
   assign p2setflags = i_p2_flag_bit_a; 
   assign p2sleep_inst = i_p2_sleep_inst_a; 
   assign p2st = i_p2_opcode_32_st_a & i_p2_iv_r; 
   assign p2subopcode = i_p2_subopcode_r; 
   assign p2subopcode1_r = i_p2_subopcode1_r; 
   assign p2subopcode2_r = i_p2_subopcode2_r; 
   assign p2subopcode3_r = i_p2_subopcode3_r; 
   assign p2subopcode4_r = i_p2_subopcode4_r; 
   assign p2subopcode5_r = i_p2_subopcode5_r; 
   assign p2subopcode6_r = i_p2_subopcode6_r; 
   assign p2subopcode7_r = i_p2_subopcode7_r; 

//------------------------------------------------------------------------------
// Stage 2b Output Drives 
//------------------------------------------------------------------------------

   assign dest = i_p2b_destination_r; 
   assign desten = i_p2b_dest_en_iv_a; 
   assign en2b = i_p2b_enable_a; 
   assign en2b_niv_a = i_p2b_en_nopwr_save_a; 
   assign fs2a = i_p2b_source2_addr_r; 
   assign mload2b = i_p2b_ld_decode_a & i_p2b_iv_r & ~i_p4_kill_p2b_a; 
   assign mstore2b = i_p2b_st_decode_a & i_p2b_iv_r & ~i_p4_kill_p2b_a; 
   assign p2b_a_field_r = i_p2b_a_field_r; 
   assign p2b_abs_op = i_p3_alu_absiv_nxt; 
   assign p2b_alu_op = i_p3_alu_op_nxt; 
   assign p2b_arithiv = i_p3_alu_arithiv_nxt; 
   assign p2b_awb_field = i_p2b_awb_field_a; 
   assign p2b_b_field_r = i_p2b_b_field_r; 
   assign p2b_bch = i_p2b_jmp_iv_a; 
   assign p2b_c_field_r = i_p2b_c_field_r; 
   assign p2b_cc = i_p2b_iw_r[CCUBND:CCLBND]; 
   assign p2b_conditional = i_p2b_conditional_a; 
   assign p2b_condtrue = i_p2b_condtrue_a; 
   assign p2b_delay_slot = i_p2b_has_dslot_r; 
   assign p2b_dojcc = i_p2b_dojcc_a; 
   assign p2b_format = i_p2b_format_r; 
   assign p2b_iv = i_p2b_iv_r; 
   assign p2b_jlcc_a = i_p2b_jlcc_iv_a; 
   assign p2b_blcc_a = i_p2b_dolink_iv_a; 
   assign p2b_dopred_ds = i_p2b_brcc_pred_ds_r; 
   assign p2b_limm = i_p2b_long_immediate_r & i_p2b_iv_r; 
   assign p2b_lr = i_p2b_lr_decode_a; 
   assign p2b_minoropcode = i_p2b_minoropcode_r; 
   assign p2b_neg_op = i_p3_alu_negiv_nxt; 
   assign p2b_not_op = i_p3_alu_notiv_nxt; 
   assign p2b_opcode = i_p2b_opcode_r; 
   assign p2b_setflags = i_p2b_flag_bit_r; 
   assign p2b_shift_by_one_a = i_p2b_shift_by_one_a; 
   assign p2b_shift_by_three_a = i_p2b_shift_by_three_a; 
   assign p2b_shift_by_two_a = i_p2b_shift_by_two_a; 
   assign p2b_shift_by_zero_a = i_p2b_shift_by_zero_a; 
   assign p2b_shimm_data = i_p2b_short_immediate_r; 
   assign p2b_shimm_s1_a = i_p2b_shimm_s1_r & i_p2b_iv_r; 
   assign p2b_shimm_s2_a = i_p2b_shimm_r & i_p2b_iv_r; 
   assign p2b_size = i_p2b_size_a; 
   assign p2b_st = i_p2b_opcode_32_st_a; 
   assign p2b_subopcode = i_p2b_subopcode_r; 
   assign p2b_subopcode1_r = i_p2b_subopcode1_r; 
   assign p2b_subopcode2_r = i_p2b_subopcode2_r; 
   assign p2b_subopcode3_r = i_p2b_subopcode3_r; 
   assign p2b_subopcode4_r = i_p2b_subopcode4_r; 
   assign p2b_subopcode5_r = i_p2b_subopcode5_r; 
   assign p2b_subopcode6_r = i_p2b_subopcode6_r; 
   assign p2b_subopcode7_r = i_p2b_subopcode7_r; 
   assign s1a = i_p2b_source1_addr_r; 
   assign s1en = i_p2b_source1_en_r & i_p2b_iv_r; 
   assign s2en = i_p2b_source2_en_r & i_p2b_iv_r; 

//------------------------------------------------------------------------------
// Stage 3 Output Drives
//------------------------------------------------------------------------------

   assign brk_inst_a = i_p2_brk_inst_a; 
   assign en3 = i_p3_enable_a; 
   assign en3_niv_a = i_p3_en_non_iv_mwait_a;
   assign loopcount_hit_a = i_p3_loopcount_hit_a;  
   assign mload = i_p3_mload_a; 
   assign mstore = i_p3_mstore_a; 
   assign nocache = i_p3_nocache_r; 
   assign p3_alu_absiv = i_p3_alu_absiv_r; 
   assign p3_alu_arithiv = i_p3_alu_arithiv_r; 
   assign p3_alu_logiciv = i_p3_alu_logiciv_r; 
   assign p3_alu_op = i_p3_alu_op_r; 
   assign p3_alu_snglopiv = i_p3_alu_snglopiv_r; 
   assign p3_bit_op_sel = i_p3_bit_operand_sel_r; 
   assign p3_brcc_instr_a = i_p3_br_or_bbit_iv_a; 
   assign p3_docmprel_a = i_p4_ccmatch_br_nxt;
   assign p3_flag_instr = i_p3_flag_instr_iv_a; 
   assign p3_sync_instr = i_p3_sync_instr_iv_a;
   assign p3_max_instr = i_p3_alu_max_r; 
   assign p3_min_instr = i_p3_alu_min_r; 
   assign p3_ni_wbrq = i_p3_ni_wbrq_a; 
   assign p3_shiftin_sel_r = i_p3_shiftin_sel_r; 
   assign p3_sop_op_r = i_p3_sop_op_r; 
   assign p3_xmultic_nwb = i_p3_xmultic_nwb_a; 
   assign p3a_field_r = i_p3_a_field_r; 
   assign p3awb_field_r = i_p3_awb_field_r; 
   assign p3b_field_r = i_p3_b_field_r; 
   assign p3c_field_r = i_p3_c_field_r; 
   assign p3cc = i_p3_q_r[CCUBND:0]; 
   assign p3condtrue = i_p3_condtrue_a; 
   assign p3destlimm = i_p3_dest_imm_r; 
   assign p3dolink = i_p3_dolink_iv_a; 
   assign p3format = i_p3_format_r; 
   assign p3iv = i_p3_iv_r; 
   assign p3lr = i_p3_lr_a; 
   assign p3minoropcode = i_p3_minoropcode_r; 
   assign p3opcode = i_p3_opcode_r; 
   assign p3q = i_p3_q_r; 
   assign p3setflags = i_p3_setflags_r; 
   assign p3sr = i_p3_sr_a; 
   assign p3subopcode = i_p3_subopcode_r; 
   assign p3subopcode1_r = i_p3_subopcode1_r; 
   assign p3subopcode2_r = i_p3_subopcode2_r; 
   assign p3subopcode3_r = i_p3_subopcode3_r; 
   assign p3subopcode4_r = i_p3_subopcode4_r; 
   assign p3subopcode5_r = i_p3_subopcode5_r; 
   assign p3subopcode6_r = i_p3_subopcode6_r; 
   assign p3subopcode7_r = i_p3_subopcode7_r; 
   assign p3wb_en = i_p3_wback_en_a; 
   assign p3wb_en_nld = i_p3_wback_en_nld_a; 
   assign p3wba = i_p3_wback_addr_a; 
   assign p3wba_nld = i_p3_wback_addr_nld_a; 
   assign sc_load1 = i_p2b_sc_load1_a; 
   assign sc_load2 = i_p2b_sc_load2_a; 
   assign sc_reg1 = i_p2b_sc_reg1_a; 
   assign sc_reg2 = i_p2b_sc_reg2_a; 
   assign sex = i_p3_sex_r; 
   assign size = i_p3_size_r; 

//------------------------------------------------------------------------------
// Stage 4 Output Drives
//------------------------------------------------------------------------------
//    
   assign wba = i_p4_wba_r; 
   assign wben = i_p4_wben_r; 
   assign wben_nxt = i_p4_wben_nxt; 
   assign p4_disable_r = i_p4_disable_r; 
   assign p4_docmprel = i_p4_docmprel_a;
   assign p4iv = i_p4_iv_r;
   assign ldvalid_wb = i_p4_ldvalid_wback_a;  
   
//------------------------------------------------------------------------------
// Interrupts
//------------------------------------------------------------------------------

   assign interrupt_holdoff = i_interrupt_holdoff_a; 
   assign flagu_block = i_flagu_block_a; 
   assign instruction_error = i_p2_instruction_error_a; 

//------------------------------------------------------------------------------
// Misc
//------------------------------------------------------------------------------

   assign kill_p1_a        = i_kill_p1_a; 
   assign kill_p1_en_a     = i_kill_p1_en_a; 
   assign kill_p1_nlp_a    = i_kill_p1_nlp_a; 
   assign kill_p1_nlp_en_a = i_kill_p1_nlp_en_a; 
   assign kill_p2_a        = i_kill_p2_a; 
   assign kill_p2_en_a     = i_kill_p2_en_a; 
   assign kill_p2b_a       = i_p4_kill_p2b_a; 
   assign kill_p3_a        = i_p4_kill_p3_a; 
   assign kill_tagged_p1   = i_tag_nxt_p1_killed_r; 
   assign stop_step        = i_stop_step_a;
   assign hold_int_st2_a   = i_hold_int_st2_a; 

endmodule // module rctl
// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module control(clk_ungated,
               en,
               rst_a,
               wd_clear,
               ctrl_cpu_start_sync_r,
               test_mode,
               clk,
               ibus_busy,
               mem_access,
               memory_error,
               s1bus,
               s2bus,
               aluflags_r,
               ext_s2val,
               aux_addr,
               aux_dataw,
               aux_write,
               h_addr,
               h_dataw,
               h_write,
               aux_access,
               ux_p2nosc1,
               ux_p2nosc2,
               uxp2bccmatch,
               uxp2ccmatch,
               uxp3ccmatch,
               uxholdup2,
               uxholdup2b,
               uxholdup3,
               ux_isop_decode2,
               ux_idop_decode2,
               ux_izop_decode2,
               uxnwb,
               uxp2idest,
               uxsetflags,
               ux_flgen,
               ux_multic_wba,
               ux_multic_wben,
               ux_multic_busy,
               ux_p1_rev_src,
               ux_p2_bfield_wb_a,
               ux_p2_jump_decode,
               ux_snglec_wben,
               actionhalt,
               actionpt_swi_a,
               actionpt_pc_brk_a,
               p2_ap_stall_a,
               br_flags_a,
               cr_hostw,
               do_inst_step_r,
               h_pcwr,
               h_pcwr32,
               h_regadr,
               ivalid_aligned,
               ivic,
               ldvalid,
               loop_kill_p1_a,
               loop_int_holdoff_a,
               loopend_hit_a,
               sync_queue_idle,
               debug_if_r,
               dmp_mload,
               dmp_mstore,
               is_local_ram,
               mwait,
               p1iw_aligned_a,
               sleeping,
               sleeping_r2,
               code_stall_ldst,
               mulatwork_r,
               dmp_holdup12,
               s2val,
               irq,
               int_vector_base_r,
               misaligned_int,
               e1flag_r,
               e2flag_r,
               q_ldvalid,
               loc_ldvalid,
               is_peripheral,
               dc_disable_r,
               q_busy,
               host_rw,
               ic_busy,
               cgm_queue_idle,
               pcp_rd_rq,
               pcp_wr_rq,
               aligner_do_pc_plus_8,
               aligner_pc_enable,
               ivalid,
               loopstart_r,
               p1inst_16,
               do_loop_a,
               qd_b,
               x2data_2_pc,
               step,
               inst_step,
               ck_disable,
               ck_dmp_gated,
               s1en,
               s2en,
               en2,
               mload2b,
               mstore2b,
               p2opcode,
               p2subopcode,
               p2subopcode2_r,
               p2_a_field_r,
               p2_b_field_r,
               p2_c_field_r,
               p2iv,
               p2cc,
               p2conditional,
               p2sleep_inst,
               p2setflags,
               p2st,
               p2format,
               p2bch,
               p2dop32_inst,
               p2sop32_inst,
               p2zop32_inst,
               p2dop16_inst,
               p2sop16_inst,
               p2zop16_inst,
               en2b,
               p2b_iv,
               p2b_conditional,
               p2b_cc,
               p2b_dop32_inst,
               p2b_sop32_inst,
               p2b_zop32_inst,
               p2b_dop16_inst,
               p2b_sop16_inst,
               p2b_zop16_inst,
               p2b_opcode,
               p2b_subopcode,
               p2b_a_field_r,
               p2b_b_field_r,
               p2b_c_field_r,
               en3,
               p3iv,
               p3opcode,
               p3subopcode,
               p3subopcode2_r,
               p3a_field_r,
               p3b_field_r,
               p3c_field_r,
               p3cc,
               p3condtrue,
               p3destlimm,
               p3format,
               p3setflags,
               x_idecode3,
               p3wb_en,
               p3wba,
               p3lr,
               p3sr,
               p3dop32_inst,
               p3sop32_inst,
               p3zop32_inst,
               p3dop16_inst,
               p3sop16_inst,
               p3zop16_inst,
               s1a,
               fs2a,
               wba,
               wben,
               dest,
               desten,
               sc_reg1,
               sc_reg2,
               p3_xmultic_nwb,
               lpending,
               p1int,
               p2int,
               p2bint,
               p3int,
               pcounter_jmp_restart_r,
               regadr,
               x_idecode2b,
               x_multic_busy,
               x_multic_wben,
               x_snglec_wben,
               en1,
               ifetch_aligned,
               inst_stepping,
               instr_pending_r,
               pcen,
               pcen_niv,
               brk_inst_a,
               p2_brcc_instr_a,
               p2_dopred,
               p2_dorel,
               p2_iw_r,
               p2_lp_instr,
               p2_s1a,
               p2_s2a,
               p2condtrue,
               p2limm,
               p2minoropcode,
               p2subopcode3_r,
               p2subopcode4_r,
               p2subopcode5_r,
               p2subopcode6_r,
               p2subopcode7_r,
               p2b_abs_op,
               p2b_alu_op,
               p2b_arithiv,
               p2b_blcc_a,
               p2b_condtrue,
               p2b_delay_slot,
               p2b_dojcc,
               p2b_jlcc_a,
               p2b_limm,
               p2b_lr,
               p2b_neg_op,
               p2b_not_op,
               p2b_setflags,
               p2b_shift_by_one_a,
               p2b_shift_by_three_a,
               p2b_shift_by_two_a,
               p2b_shift_by_zero_a,
               p2b_shimm_data,
               p2b_shimm_s1_a,
               p2b_shimm_s2_a,
               p2b_jmp_holdup_a,
               en3_niv_a,
               ldvalid_wb,
               mload,
               mstore,
               nocache,
               p3_alu_absiv,
               p3_alu_arithiv,
               p3_alu_logiciv,
               p3_alu_op,
               p3_alu_snglopiv,
               p3_bit_op_sel,
               p3_brcc_instr_a,
               p3_docmprel_a,
               p3_flag_instr,
               p3_sync_instr,
               p3_max_instr,
               p3_min_instr,
               p3_shiftin_sel_r,
               p3_sop_op_r,
               p3awb_field_r,
               p3dolink,
               p3minoropcode,
               p3subopcode3_r,
               p3subopcode4_r,
               p3subopcode5_r,
               p3subopcode6_r,
               p3subopcode7_r,
               sc_load1,
               sc_load2,
               sex,
               size,
               p4_docmprel,
               loopcount_hit_a,
               p4_disable_r,
               kill_p1_nlp_a,
               kill_p2_a,
               kill_tagged_p1,
               stop_step,
               barrel_type_r,
               x_p3_brl_decode_16_r,
               x_p3_brl_decode_32_r,
               x_p3_norm_decode_r,
               x_p3_snorm_decode_r,
               x_p3_swap_decode_r,
               x_flgen,
               xsetflags,
               x_set_sflag,
               p3ilev1,
               aux_lv12,
               aux_hint,
               aux_lev,
               max_one_lpend,
               ctrl_cpu_start_r,
               ck_gated,
               currentpc_r,
               misaligned_target,
               pc_is_linear_r,
               next_pc,
               last_pc_plus_len,
               p2b_pc_r,
               p2_target,
               p2_s1val_tmp_r,
               pcounter_jmp_restart_a);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "asmutil.v"
`include "xdefs.v"


input  clk_ungated;
input  en;
input  rst_a;
input  wd_clear;
input  ctrl_cpu_start_sync_r;
input  test_mode;
input  clk;
input  ibus_busy;
input  mem_access;
input  memory_error;
input  [31:0]  s1bus;
input  [31:0]  s2bus;
input  [3:0]  aluflags_r;
input  [31:0]  ext_s2val;
input  [31:0]  aux_addr;
input  [31:0]  aux_dataw;
input  aux_write;
input  [31:0]  h_addr;
input  [31:0]  h_dataw;
input  h_write;
input  aux_access;
input  ux_p2nosc1;
input  ux_p2nosc2;
input  uxp2bccmatch;
input  uxp2ccmatch;
input  uxp3ccmatch;
input  uxholdup2;
input  uxholdup2b;
input  uxholdup3;
input  ux_isop_decode2;
input  ux_idop_decode2;
input  ux_izop_decode2;
input  uxnwb;
input  uxp2idest;
input  uxsetflags;
input  ux_flgen;
input  [5:0]  ux_multic_wba;
input  ux_multic_wben;
input  ux_multic_busy;
input  ux_p1_rev_src;
input  ux_p2_bfield_wb_a;
input  ux_p2_jump_decode;
input  ux_snglec_wben;
input  actionhalt;
input  actionpt_swi_a;
input  actionpt_pc_brk_a;
input  p2_ap_stall_a;
input  [3:0]  br_flags_a;
input  cr_hostw;
input  do_inst_step_r;
input  h_pcwr;
input  h_pcwr32;
input  [5:0]  h_regadr;
input  ivalid_aligned;
input  ivic;
input  ldvalid;
input  loop_kill_p1_a;
input  loop_int_holdoff_a;
input  loopend_hit_a;
input  sync_queue_idle;
input  debug_if_r;
input  dmp_mload;
input  dmp_mstore;
input  is_local_ram;
input  mwait;
input  [DATAWORD_MSB:0]  p1iw_aligned_a;
input  sleeping;
input  sleeping_r2;
input  code_stall_ldst;
input  mulatwork_r;
input  dmp_holdup12;
input  [31:0]  s2val;
input  [31:3]  irq;
input  [PC_MSB:`INT_BASE_LSB]  int_vector_base_r;
input  misaligned_int;
input  e1flag_r;
input  e2flag_r;
input  q_ldvalid;
input  loc_ldvalid;
input  is_peripheral;
input  dc_disable_r;
input  q_busy;
input  host_rw;
input  ic_busy;
input  cgm_queue_idle;
input  pcp_rd_rq;
input  pcp_wr_rq;
input  aligner_do_pc_plus_8;
input  aligner_pc_enable;
input  ivalid;
input  [PC_MSB:0]  loopstart_r;
input  p1inst_16;
input  do_loop_a;
input  [31:0]  qd_b;
input  [31:0]  x2data_2_pc;
input  step;
input  inst_step;
output ck_disable;
output ck_dmp_gated;
output s1en;
output s2en;
output en2;
output mload2b;
output mstore2b;
output [4:0]  p2opcode;
output [5:0]  p2subopcode;
output [4:0]  p2subopcode2_r;
output [5:0]  p2_a_field_r;
output [5:0]  p2_b_field_r;
output [5:0]  p2_c_field_r;
output p2iv;
output [3:0]  p2cc;
output p2conditional;
output p2sleep_inst;
output p2setflags;
output p2st;
output [1:0]  p2format;
output p2bch;
output p2dop32_inst;
output p2sop32_inst;
output p2zop32_inst;
output p2dop16_inst;
output p2sop16_inst;
output p2zop16_inst;
output en2b;
output p2b_iv;
output p2b_conditional;
output [3:0]  p2b_cc;
output p2b_dop32_inst;
output p2b_sop32_inst;
output p2b_zop32_inst;
output p2b_dop16_inst;
output p2b_sop16_inst;
output p2b_zop16_inst;
output [4:0]  p2b_opcode;
output [5:0]  p2b_subopcode;
output [5:0]  p2b_a_field_r;
output [5:0]  p2b_b_field_r;
output [5:0]  p2b_c_field_r;
output en3;
output p3iv;
output [4:0]  p3opcode;
output [5:0]  p3subopcode;
output [4:0]  p3subopcode2_r;
output [5:0]  p3a_field_r;
output [5:0]  p3b_field_r;
output [5:0]  p3c_field_r;
output [3:0]  p3cc;
output p3condtrue;
output p3destlimm;
output [1:0]  p3format;
output p3setflags;
output x_idecode3;
output p3wb_en;
output [5:0]  p3wba;
output p3lr;
output p3sr;
output p3dop32_inst;
output p3sop32_inst;
output p3zop32_inst;
output p3dop16_inst;
output p3sop16_inst;
output p3zop16_inst;
output [5:0]  s1a;
output [5:0]  fs2a;
output [5:0]  wba;
output wben;
output [5:0]  dest;
output desten;
output sc_reg1;
output sc_reg2;
output p3_xmultic_nwb;
output lpending;
output p1int;
output p2int;
output p2bint;
output p3int;
output pcounter_jmp_restart_r;
output [5:0]  regadr;
output x_idecode2b;
output x_multic_busy;
output x_multic_wben;
output x_snglec_wben;
output en1;
output ifetch_aligned;
output inst_stepping;
output instr_pending_r;
output pcen;
output pcen_niv;
output brk_inst_a;
output p2_brcc_instr_a;
output p2_dopred;
output p2_dorel;
output [INSTR_UBND:0]  p2_iw_r;
output p2_lp_instr;
output [5:0]  p2_s1a;
output [5:0]  p2_s2a;
output p2condtrue;
output p2limm;
output [5:0]  p2minoropcode;
output [2:0]  p2subopcode3_r;
output p2subopcode4_r;
output [1:0]  p2subopcode5_r;
output [2:0]  p2subopcode6_r;
output [1:0]  p2subopcode7_r;
output p2b_abs_op;
output [1:0]  p2b_alu_op;
output p2b_arithiv;
output p2b_blcc_a;
output p2b_condtrue;
output p2b_delay_slot;
output p2b_dojcc;
output p2b_jlcc_a;
output p2b_limm;
output p2b_lr;
output p2b_neg_op;
output p2b_not_op;
output p2b_setflags;
output p2b_shift_by_one_a;
output p2b_shift_by_three_a;
output p2b_shift_by_two_a;
output p2b_shift_by_zero_a;
output [12:0]  p2b_shimm_data;
output p2b_shimm_s1_a;
output p2b_shimm_s2_a;
output p2b_jmp_holdup_a;
output en3_niv_a;
output ldvalid_wb;
output mload;
output mstore;
output nocache;
output p3_alu_absiv;
output p3_alu_arithiv;
output p3_alu_logiciv;
output [1:0]  p3_alu_op;
output p3_alu_snglopiv;
output [1:0]  p3_bit_op_sel;
output p3_brcc_instr_a;
output p3_docmprel_a;
output p3_flag_instr;
output p3_sync_instr;
output p3_max_instr;
output p3_min_instr;
output [1:0]  p3_shiftin_sel_r;
output [2:0]  p3_sop_op_r;
output [1:0]  p3awb_field_r;
output p3dolink;
output [5:0]  p3minoropcode;
output [2:0]  p3subopcode3_r;
output p3subopcode4_r;
output [1:0]  p3subopcode5_r;
output [2:0]  p3subopcode6_r;
output [1:0]  p3subopcode7_r;
output sc_load1;
output sc_load2;
output sex;
output [1:0]  size;
output p4_docmprel;
output loopcount_hit_a;
output p4_disable_r;
output kill_p1_nlp_a;
output kill_p2_a;
output kill_tagged_p1;
output stop_step;
output [1:0]  barrel_type_r;
output x_p3_brl_decode_16_r;
output x_p3_brl_decode_32_r;
output x_p3_norm_decode_r;
output x_p3_snorm_decode_r;
output x_p3_swap_decode_r;
output x_flgen;
output xsetflags;
output x_set_sflag;
output p3ilev1;
output [1:0]  aux_lv12;
output [4:0]  aux_hint;
output [31:3]  aux_lev;
output max_one_lpend;
output ctrl_cpu_start_r;
output ck_gated;
output [PC_MSB:0]  currentpc_r;
output misaligned_target;
output pc_is_linear_r;
output [PC_MSB:0]  next_pc;
output [PC_MSB:0]  last_pc_plus_len;
output [PC_MSB:0]  p2b_pc_r;
output [PC_MSB:0]  p2_target;
output [DATAWORD_MSB:0]  p2_s1val_tmp_r;
output pcounter_jmp_restart_a;

wire clk_ungated;
wire en;
wire rst_a;
wire wd_clear;
wire ctrl_cpu_start_sync_r;
wire test_mode;
wire clk;
wire ibus_busy;
wire mem_access;
wire memory_error;
wire  [31:0] s1bus;
wire  [31:0] s2bus;
wire  [3:0] aluflags_r;
wire  [31:0] ext_s2val;
wire  [31:0] aux_addr;
wire  [31:0] aux_dataw;
wire aux_write;
wire  [31:0] h_addr;
wire  [31:0] h_dataw;
wire h_write;
wire aux_access;
wire ux_p2nosc1;
wire ux_p2nosc2;
wire uxp2bccmatch;
wire uxp2ccmatch;
wire uxp3ccmatch;
wire uxholdup2;
wire uxholdup2b;
wire uxholdup3;
wire ux_isop_decode2;
wire ux_idop_decode2;
wire ux_izop_decode2;
wire uxnwb;
wire uxp2idest;
wire uxsetflags;
wire ux_flgen;
wire  [5:0] ux_multic_wba;
wire ux_multic_wben;
wire ux_multic_busy;
wire ux_p1_rev_src;
wire ux_p2_bfield_wb_a;
wire ux_p2_jump_decode;
wire ux_snglec_wben;
wire actionhalt;
wire actionpt_swi_a;
wire actionpt_pc_brk_a;
wire p2_ap_stall_a;
wire  [3:0] br_flags_a;
wire cr_hostw;
wire do_inst_step_r;
wire h_pcwr;
wire h_pcwr32;
wire  [5:0] h_regadr;
wire ivalid_aligned;
wire ivic;
wire ldvalid;
wire loop_kill_p1_a;
wire loop_int_holdoff_a;
wire loopend_hit_a;
wire sync_queue_idle;
wire debug_if_r;
wire dmp_mload;
wire dmp_mstore;
wire is_local_ram;
wire mwait;
wire  [DATAWORD_MSB:0] p1iw_aligned_a;
wire sleeping;
wire sleeping_r2;
wire code_stall_ldst;
wire mulatwork_r;
wire dmp_holdup12;
wire  [31:0] s2val;
wire  [31:3] irq;
wire  [PC_MSB:`INT_BASE_LSB] int_vector_base_r;
wire misaligned_int;
wire e1flag_r;
wire e2flag_r;
wire q_ldvalid;
wire loc_ldvalid;
wire is_peripheral;
wire dc_disable_r;
wire q_busy;
wire host_rw;
wire ic_busy;
wire cgm_queue_idle;
wire pcp_rd_rq;
wire pcp_wr_rq;
wire aligner_do_pc_plus_8;
wire aligner_pc_enable;
wire ivalid;
wire  [PC_MSB:0] loopstart_r;
wire p1inst_16;
wire do_loop_a;
wire  [31:0] qd_b;
wire  [31:0] x2data_2_pc;
wire step;
wire inst_step;
wire ck_disable;
wire ck_dmp_gated;
wire s1en;
wire s2en;
wire en2;
wire mload2b;
wire mstore2b;
wire  [4:0] p2opcode;
wire  [5:0] p2subopcode;
wire  [4:0] p2subopcode2_r;
wire  [5:0] p2_a_field_r;
wire  [5:0] p2_b_field_r;
wire  [5:0] p2_c_field_r;
wire p2iv;
wire  [3:0] p2cc;
wire p2conditional;
wire p2sleep_inst;
wire p2setflags;
wire p2st;
wire  [1:0] p2format;
wire p2bch;
wire p2dop32_inst;
wire p2sop32_inst;
wire p2zop32_inst;
wire p2dop16_inst;
wire p2sop16_inst;
wire p2zop16_inst;
wire en2b;
wire p2b_iv;
wire p2b_conditional;
wire  [3:0] p2b_cc;
wire p2b_dop32_inst;
wire p2b_sop32_inst;
wire p2b_zop32_inst;
wire p2b_dop16_inst;
wire p2b_sop16_inst;
wire p2b_zop16_inst;
wire  [4:0] p2b_opcode;
wire  [5:0] p2b_subopcode;
wire  [5:0] p2b_a_field_r;
wire  [5:0] p2b_b_field_r;
wire  [5:0] p2b_c_field_r;
wire en3;
wire p3iv;
wire  [4:0] p3opcode;
wire  [5:0] p3subopcode;
wire  [4:0] p3subopcode2_r;
wire  [5:0] p3a_field_r;
wire  [5:0] p3b_field_r;
wire  [5:0] p3c_field_r;
wire  [3:0] p3cc;
wire p3condtrue;
wire p3destlimm;
wire  [1:0] p3format;
wire p3setflags;
wire x_idecode3;
wire p3wb_en;
wire  [5:0] p3wba;
wire p3lr;
wire p3sr;
wire p3dop32_inst;
wire p3sop32_inst;
wire p3zop32_inst;
wire p3dop16_inst;
wire p3sop16_inst;
wire p3zop16_inst;
wire  [5:0] s1a;
wire  [5:0] fs2a;
wire  [5:0] wba;
wire wben;
wire  [5:0] dest;
wire desten;
wire sc_reg1;
wire sc_reg2;
wire p3_xmultic_nwb;
wire lpending;
wire p1int;
wire p2int;
wire p2bint;
wire p3int;
wire pcounter_jmp_restart_r;
wire  [5:0] regadr;
wire x_idecode2b;
wire x_multic_busy;
wire x_multic_wben;
wire x_snglec_wben;
wire en1;
wire ifetch_aligned;
wire inst_stepping;
wire instr_pending_r;
wire pcen;
wire pcen_niv;
wire brk_inst_a;
wire p2_brcc_instr_a;
wire p2_dopred;
wire p2_dorel;
wire  [INSTR_UBND:0] p2_iw_r;
wire p2_lp_instr;
wire  [5:0] p2_s1a;
wire  [5:0] p2_s2a;
wire p2condtrue;
wire p2limm;
wire  [5:0] p2minoropcode;
wire  [2:0] p2subopcode3_r;
wire p2subopcode4_r;
wire  [1:0] p2subopcode5_r;
wire  [2:0] p2subopcode6_r;
wire  [1:0] p2subopcode7_r;
wire p2b_abs_op;
wire  [1:0] p2b_alu_op;
wire p2b_arithiv;
wire p2b_blcc_a;
wire p2b_condtrue;
wire p2b_delay_slot;
wire p2b_dojcc;
wire p2b_jlcc_a;
wire p2b_limm;
wire p2b_lr;
wire p2b_neg_op;
wire p2b_not_op;
wire p2b_setflags;
wire p2b_shift_by_one_a;
wire p2b_shift_by_three_a;
wire p2b_shift_by_two_a;
wire p2b_shift_by_zero_a;
wire  [12:0] p2b_shimm_data;
wire p2b_shimm_s1_a;
wire p2b_shimm_s2_a;
wire p2b_jmp_holdup_a;
wire en3_niv_a;
wire ldvalid_wb;
wire mload;
wire mstore;
wire nocache;
wire p3_alu_absiv;
wire p3_alu_arithiv;
wire p3_alu_logiciv;
wire  [1:0] p3_alu_op;
wire p3_alu_snglopiv;
wire  [1:0] p3_bit_op_sel;
wire p3_brcc_instr_a;
wire p3_docmprel_a;
wire p3_flag_instr;
wire p3_sync_instr;
wire p3_max_instr;
wire p3_min_instr;
wire  [1:0] p3_shiftin_sel_r;
wire  [2:0] p3_sop_op_r;
wire  [1:0] p3awb_field_r;
wire p3dolink;
wire  [5:0] p3minoropcode;
wire  [2:0] p3subopcode3_r;
wire p3subopcode4_r;
wire  [1:0] p3subopcode5_r;
wire  [2:0] p3subopcode6_r;
wire  [1:0] p3subopcode7_r;
wire sc_load1;
wire sc_load2;
wire sex;
wire  [1:0] size;
wire p4_docmprel;
wire loopcount_hit_a;
wire p4_disable_r;
wire kill_p1_nlp_a;
wire kill_p2_a;
wire kill_tagged_p1;
wire stop_step;
wire  [1:0] barrel_type_r;
wire x_p3_brl_decode_16_r;
wire x_p3_brl_decode_32_r;
wire x_p3_norm_decode_r;
wire x_p3_snorm_decode_r;
wire x_p3_swap_decode_r;
wire x_flgen;
wire xsetflags;
wire x_set_sflag;
wire p3ilev1;
wire  [1:0] aux_lv12;
wire  [4:0] aux_hint;
wire  [31:3] aux_lev;
wire max_one_lpend;
wire ctrl_cpu_start_r;
wire ck_gated;
wire  [PC_MSB:0] currentpc_r;
wire misaligned_target;
wire pc_is_linear_r;
wire  [PC_MSB:0] next_pc;
wire  [PC_MSB:0] last_pc_plus_len;
wire  [PC_MSB:0] p2b_pc_r;
wire  [PC_MSB:0] p2_target;
wire  [DATAWORD_MSB:0] p2_s1val_tmp_r;
wire pcounter_jmp_restart_a;


// Intermediate signals
wire i_s1en;
wire i_s2en;
wire i_en2;
wire i_mload2b;
wire i_mstore2b;
wire  [4:0] i_p2opcode;
wire  [5:0] i_p2subopcode;
wire  [4:0] i_p2subopcode2_r;
wire  [5:0] i_p2_a_field_r;
wire  [5:0] i_p2_b_field_r;
wire  [5:0] i_p2_c_field_r;
wire i_p2iv;
wire  [3:0] i_p2cc;
wire i_p2conditional;
wire i_p2sleep_inst;
wire i_p2setflags;
wire i_p2st;
wire  [1:0] i_p2format;
wire i_p2bch;
wire i_en2b;
wire i_p2b_iv;
wire i_p2b_conditional;
wire  [3:0] i_p2b_cc;
wire  [4:0] i_p2b_opcode;
wire  [5:0] i_p2b_subopcode;
wire  [5:0] i_p2b_a_field_r;
wire  [5:0] i_p2b_b_field_r;
wire  [5:0] i_p2b_c_field_r;
wire i_en3;
wire i_p3iv;
wire  [4:0] i_p3opcode;
wire  [5:0] i_p3subopcode;
wire  [4:0] i_p3subopcode2_r;
wire  [5:0] i_p3a_field_r;
wire  [5:0] i_p3b_field_r;
wire  [5:0] i_p3c_field_r;
wire  [3:0] i_p3cc;
wire i_p3condtrue;
wire i_p3destlimm;
wire  [1:0] i_p3format;
wire i_p3setflags;
wire i_x_idecode3;
wire i_p3wb_en;
wire  [5:0] i_p3wba;
wire i_p3lr;
wire i_p3sr;
wire  [5:0] i_s1a;
wire  [5:0] i_fs2a;
wire  [5:0] i_dest;
wire i_desten;
wire i_sc_reg1;
wire i_sc_reg2;
wire i_p3_xmultic_nwb;
wire i_lpending;
wire i_p1int;
wire i_p2int;
wire i_p2bint;
wire i_p3int;
wire i_pcounter_jmp_restart_r;
wire  [5:0] i_regadr;
wire i_x_idecode2b;
wire i_x_multic_busy;
wire i_x_multic_wben;
wire i_x_snglec_wben;
wire i_en1;
wire i_instr_pending_r;
wire i_pcen;
wire i_pcen_niv;
wire i_p2_brcc_instr_a;
wire i_p2_dopred;
wire i_p2_dorel;
wire  [INSTR_UBND:0] i_p2_iw_r;
wire  [5:0] i_p2_s1a;
wire i_p2limm;
wire  [5:0] i_p2minoropcode;
wire  [2:0] i_p2subopcode3_r;
wire i_p2subopcode4_r;
wire  [1:0] i_p2subopcode5_r;
wire  [2:0] i_p2subopcode6_r;
wire  [1:0] i_p2subopcode7_r;
wire i_p2b_dojcc;
wire i_p2b_setflags;
wire  [12:0] i_p2b_shimm_data;
wire i_p2b_shimm_s2_a;
wire i_mload;
wire i_nocache;
wire  [5:0] i_p3minoropcode;
wire  [2:0] i_p3subopcode3_r;
wire i_p4_docmprel;
wire i_p4_disable_r;
wire i_kill_p2_a;
wire i_holdup2b;
wire i_p2ilev1;
wire i_regadr_eq_src1;
wire i_regadr_eq_src2;
wire i_x_idecode2;
wire i_x_idop_decode2;
wire i_x_isop_decode2;
wire  [5:0] i_x_multic_wba;
wire i_x_p1_rev_src;
wire i_x_p2_bfield_wb_a;
wire i_x_p2_jump_decode;
wire i_x_p2b_jump_decode;
wire i_x_p2nosc1;
wire i_x_p2nosc2;
wire i_x_p2shimm_a;
wire i_xholdup2;
wire i_xholdup2b;
wire i_xholdup3;
wire i_xnwb;
wire i_xp2bccmatch;
wire i_xp2ccmatch;
wire i_xp2idest;
wire i_xp3ccmatch;
wire i_awake_a;
wire i_p2_abs_neg_a;
wire i_p2_dopred_nds;
wire i_p2_jblcc_a;
wire i_p2_not_a;
wire i_p2_s1en;
wire i_p2delay_slot;
wire i_p2lr;
wire  [TARGSZ:0] i_p2offset;
wire  [1:0] i_p2subopcode1_r;
wire i_p2b_bch;
wire i_p2b_dopred_ds;
wire  [1:0] i_p2b_format;
wire  [5:0] i_p2b_minoropcode;
wire i_p2b_st;
wire  [1:0] i_p2b_subopcode1_r;
wire  [4:0] i_p2b_subopcode2_r;
wire  [2:0] i_p2b_subopcode3_r;
wire i_p2b_subopcode4_r;
wire  [1:0] i_p2b_subopcode5_r;
wire  [2:0] i_p2b_subopcode6_r;
wire  [1:0] i_p2b_subopcode7_r;
wire  [1:0] i_p3subopcode1_r;
wire i_flagu_block;
wire i_instruction_error;
wire i_interrupt_holdoff;
wire i_kill_last;
wire i_kill_p1_a;
wire i_kill_p2b_a;
wire i_kill_p3_a;
wire i_hold_int_st2_a;
wire  [PC_MSB:0] i_int_vec;
wire i_p123int;


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)
wire u_unconnected_0;
wire  [12:0] u_unconnected_1;
wire u_unconnected_2;
wire u_unconnected_3;
wire  [1:0] u_unconnected_4;
wire  [1:0] u_unconnected_5;
wire u_unconnected_6;
wire  [4:0] u_unconnected_7;
wire u_unconnected_8;
wire  [5:0] u_unconnected_9;
wire u_unconnected_10;
wire u_unconnected_11;
wire u_unconnected_12;
wire u_unconnected_13;
wire u_unconnected_14;
wire u_unconnected_15;
wire u_unconnected_16;
wire  [PC_MSB:PC_LSB] u_unconnected_17;
wire  [PC_MSB:0] u_unconnected_18;
wire  [PC_MSB:0] u_unconnected_19;


// Instantiation of module rctl
rctl irctl(
  .clk(clk),
  .rst_a(rst_a),
  .en(en),
  .aux_addr(aux_addr),
  .actionhalt(actionhalt),
  .actionpt_swi_a(actionpt_swi_a),
  .actionpt_pc_brk_a(actionpt_pc_brk_a),
  .p2_ap_stall_a(p2_ap_stall_a),
  .aluflags_r(aluflags_r),
  .br_flags_a(br_flags_a),
  .cr_hostw(cr_hostw),
  .do_inst_step_r(do_inst_step_r),
  .h_pcwr(h_pcwr),
  .h_pcwr32(h_pcwr32),
  .h_regadr(h_regadr),
  .holdup2b(i_holdup2b),
  .ivalid_aligned(ivalid_aligned),
  .ivic(ivic),
  .ldvalid(ldvalid),
  .loop_kill_p1_a(loop_kill_p1_a),
  .loop_int_holdoff_a(loop_int_holdoff_a),
  .loopend_hit_a(loopend_hit_a),
  .sync_queue_idle(sync_queue_idle),
  .lpending(i_lpending),
  .debug_if_r(debug_if_r),
  .dmp_mload(dmp_mload),
  .dmp_mstore(dmp_mstore),
  .is_local_ram(is_local_ram),
  .mwait(mwait),
  .p1int(i_p1int),
  .p1iw_aligned_a(p1iw_aligned_a),
  .p2ilev1(i_p2ilev1),
  .p2int(i_p2int),
  .p2bint(i_p2bint),
  .p3int(i_p3int),
  .pcounter_jmp_restart_r(i_pcounter_jmp_restart_r),
  .regadr(i_regadr),
  .regadr_eq_src1(i_regadr_eq_src1),
  .regadr_eq_src2(i_regadr_eq_src2),
  .sleeping(sleeping),
  .sleeping_r2(sleeping_r2),
  .x_idecode2(i_x_idecode2),
  .x_idecode2b(i_x_idecode2b),
  .x_idecode3(i_x_idecode3),
  .x_idop_decode2(i_x_idop_decode2),
  .x_isop_decode2(i_x_isop_decode2),
  .x_multic_busy(i_x_multic_busy),
  .x_multic_wba(i_x_multic_wba),
  .x_multic_wben(i_x_multic_wben),
  .x_p1_rev_src(i_x_p1_rev_src),
  .x_p2_bfield_wb_a(i_x_p2_bfield_wb_a),
  .x_p2_jump_decode(i_x_p2_jump_decode),
  .x_p2b_jump_decode(i_x_p2b_jump_decode),
  .x_p2nosc1(i_x_p2nosc1),
  .x_p2nosc2(i_x_p2nosc2),
  .x_p2shimm_a(i_x_p2shimm_a),
  .x_snglec_wben(i_x_snglec_wben),
  .xholdup2(i_xholdup2),
  .xholdup2b(i_xholdup2b),
  .xholdup3(i_xholdup3),
  .xnwb(i_xnwb),
  .xp2bccmatch(i_xp2bccmatch),
  .xp2ccmatch(i_xp2ccmatch),
  .xp2idest(i_xp2idest),
  .xp3ccmatch(i_xp3ccmatch),
  .awake_a(i_awake_a),
  .en1(i_en1),
  .ifetch_aligned(ifetch_aligned),
  .inst_stepping(inst_stepping),
  .instr_pending_r(i_instr_pending_r),
  .pcen(i_pcen),
  .pcen_niv(i_pcen_niv),
  .brk_inst_a(brk_inst_a),
  .dest(i_dest),
  .desten(i_desten),
  .en2(i_en2),
  .fs2a(i_fs2a),
  .p2_a_field_r(i_p2_a_field_r),
  .p2_abs_neg_a(i_p2_abs_neg_a),
  .p2_b_field_r(i_p2_b_field_r),
  .p2_brcc_instr_a(i_p2_brcc_instr_a),
  .p2_c_field_r(i_p2_c_field_r),
  .p2_dopred(i_p2_dopred),
  .p2_dopred_ds(u_unconnected_0),
  .p2_dopred_nds(i_p2_dopred_nds),
  .p2_dorel(i_p2_dorel),
  .p2_iw_r(i_p2_iw_r),
  .p2_jblcc_a(i_p2_jblcc_a),
  .p2_lp_instr(p2_lp_instr),
  .p2_not_a(i_p2_not_a),
  .p2_s1a(i_p2_s1a),
  .p2_s1en(i_p2_s1en),
  .p2_s2a(p2_s2a),
  .p2_shimm_data(u_unconnected_1),
  .p2_shimm_s1_a(u_unconnected_2),
  .p2_shimm_s2_a(u_unconnected_3),
  .p2bch(i_p2bch),
  .p2cc(i_p2cc),
  .p2conditional(i_p2conditional),
  .p2condtrue(p2condtrue),
  .p2delay_slot(i_p2delay_slot),
  .p2format(i_p2format),
  .p2iv(i_p2iv),
  .p2limm(i_p2limm),
  .p2lr(i_p2lr),
  .p2minoropcode(i_p2minoropcode),
  .p2offset(i_p2offset),
  .p2opcode(i_p2opcode),
  .p2setflags(i_p2setflags),
  .p2sleep_inst(i_p2sleep_inst),
  .p2st(i_p2st),
  .p2subopcode(i_p2subopcode),
  .p2subopcode1_r(i_p2subopcode1_r),
  .p2subopcode2_r(i_p2subopcode2_r),
  .p2subopcode3_r(i_p2subopcode3_r),
  .p2subopcode4_r(i_p2subopcode4_r),
  .p2subopcode5_r(i_p2subopcode5_r),
  .p2subopcode6_r(i_p2subopcode6_r),
  .p2subopcode7_r(i_p2subopcode7_r),
  .s1a(i_s1a),
  .s1en(i_s1en),
  .s2en(i_s2en),
  .en2b(i_en2b),
  .mload2b(i_mload2b),
  .mstore2b(i_mstore2b),
  .p2b_a_field_r(i_p2b_a_field_r),
  .p2b_abs_op(p2b_abs_op),
  .p2b_alu_op(p2b_alu_op),
  .p2b_arithiv(p2b_arithiv),
  .p2b_awb_field(u_unconnected_4),
  .p2b_b_field_r(i_p2b_b_field_r),
  .p2b_bch(i_p2b_bch),
  .p2b_blcc_a(p2b_blcc_a),
  .p2b_c_field_r(i_p2b_c_field_r),
  .p2b_cc(i_p2b_cc),
  .p2b_conditional(i_p2b_conditional),
  .p2b_condtrue(p2b_condtrue),
  .p2b_delay_slot(p2b_delay_slot),
  .p2b_dojcc(i_p2b_dojcc),
  .p2b_dopred_ds(i_p2b_dopred_ds),
  .p2b_format(i_p2b_format),
  .p2b_iv(i_p2b_iv),
  .p2b_jlcc_a(p2b_jlcc_a),
  .p2b_limm(p2b_limm),
  .p2b_lr(p2b_lr),
  .p2b_minoropcode(i_p2b_minoropcode),
  .p2b_neg_op(p2b_neg_op),
  .p2b_not_op(p2b_not_op),
  .p2b_opcode(i_p2b_opcode),
  .p2b_setflags(i_p2b_setflags),
  .p2b_shift_by_one_a(p2b_shift_by_one_a),
  .p2b_shift_by_three_a(p2b_shift_by_three_a),
  .p2b_shift_by_two_a(p2b_shift_by_two_a),
  .p2b_shift_by_zero_a(p2b_shift_by_zero_a),
  .p2b_shimm_data(i_p2b_shimm_data),
  .p2b_shimm_s1_a(p2b_shimm_s1_a),
  .p2b_shimm_s2_a(i_p2b_shimm_s2_a),
  .p2b_size(u_unconnected_5),
  .p2b_st(i_p2b_st),
  .p2b_subopcode(i_p2b_subopcode),
  .p2b_subopcode1_r(i_p2b_subopcode1_r),
  .p2b_subopcode2_r(i_p2b_subopcode2_r),
  .p2b_subopcode3_r(i_p2b_subopcode3_r),
  .p2b_subopcode4_r(i_p2b_subopcode4_r),
  .p2b_subopcode5_r(i_p2b_subopcode5_r),
  .p2b_subopcode6_r(i_p2b_subopcode6_r),
  .p2b_subopcode7_r(i_p2b_subopcode7_r),
  .p2b_jmp_holdup_a(p2b_jmp_holdup_a),
  .en3(i_en3),
  .en3_niv_a(en3_niv_a),
  .ldvalid_wb(ldvalid_wb),
  .mload(i_mload),
  .mstore(mstore),
  .nocache(i_nocache),
  .p3_alu_absiv(p3_alu_absiv),
  .p3_alu_arithiv(p3_alu_arithiv),
  .p3_alu_logiciv(p3_alu_logiciv),
  .p3_alu_op(p3_alu_op),
  .p3_alu_snglopiv(p3_alu_snglopiv),
  .p3_bit_op_sel(p3_bit_op_sel),
  .p3_brcc_instr_a(p3_brcc_instr_a),
  .p3_docmprel_a(p3_docmprel_a),
  .p3_flag_instr(p3_flag_instr),
  .p3_sync_instr(p3_sync_instr),
  .p3_max_instr(p3_max_instr),
  .p3_min_instr(p3_min_instr),
  .p3_ni_wbrq(u_unconnected_6),
  .p3_shiftin_sel_r(p3_shiftin_sel_r),
  .p3_sop_op_r(p3_sop_op_r),
  .p3_xmultic_nwb(i_p3_xmultic_nwb),
  .p3a_field_r(i_p3a_field_r),
  .p3awb_field_r(p3awb_field_r),
  .p3b_field_r(i_p3b_field_r),
  .p3c_field_r(i_p3c_field_r),
  .p3cc(i_p3cc),
  .p3condtrue(i_p3condtrue),
  .p3destlimm(i_p3destlimm),
  .p3dolink(p3dolink),
  .p3format(i_p3format),
  .p3iv(i_p3iv),
  .p3lr(i_p3lr),
  .p3minoropcode(i_p3minoropcode),
  .p3opcode(i_p3opcode),
  .p3q(u_unconnected_7),
  .p3setflags(i_p3setflags),
  .p3sr(i_p3sr),
  .p3subopcode(i_p3subopcode),
  .p3subopcode1_r(i_p3subopcode1_r),
  .p3subopcode2_r(i_p3subopcode2_r),
  .p3subopcode3_r(i_p3subopcode3_r),
  .p3subopcode4_r(p3subopcode4_r),
  .p3subopcode5_r(p3subopcode5_r),
  .p3subopcode6_r(p3subopcode6_r),
  .p3subopcode7_r(p3subopcode7_r),
  .p3wb_en(i_p3wb_en),
  .p3wb_en_nld(u_unconnected_8),
  .p3wba(i_p3wba),
  .p3wba_nld(u_unconnected_9),
  .sc_load1(sc_load1),
  .sc_load2(sc_load2),
  .sc_reg1(i_sc_reg1),
  .sc_reg2(i_sc_reg2),
  .sex(sex),
  .size(size),
  .wben_nxt(u_unconnected_10),
  .wba(wba),
  .wben(wben),
  .p4_docmprel(i_p4_docmprel),
  .loopcount_hit_a(loopcount_hit_a),
  .p4_disable_r(i_p4_disable_r),
  .p4iv(u_unconnected_11),
  .flagu_block(i_flagu_block),
  .instruction_error(i_instruction_error),
  .interrupt_holdoff(i_interrupt_holdoff),
  .kill_last(i_kill_last),
  .kill_p1_a(i_kill_p1_a),
  .kill_p1_en_a(u_unconnected_12),
  .kill_p1_nlp_a(kill_p1_nlp_a),
  .kill_p1_nlp_en_a(u_unconnected_13),
  .kill_p2_a(i_kill_p2_a),
  .kill_p2_en_a(u_unconnected_14),
  .kill_p2b_a(i_kill_p2b_a),
  .kill_p3_a(i_kill_p3_a),
  .kill_tagged_p1(kill_tagged_p1),
  .stop_step(stop_step),
  .hold_int_st2_a(i_hold_int_st2_a)
);


// Instantiation of module xrctl
xrctl ixrctl(
  .clk(clk),
  .rst_a(rst_a),
  .en(en),
  .s1en(i_s1en),
  .s2en(i_s2en),
  .code_stall_ldst(code_stall_ldst),
  .mulatwork_r(mulatwork_r),
  .ivalid_aligned(ivalid_aligned),
  .en2(i_en2),
  .p2_a_field_r(i_p2_a_field_r),
  .p2_b_field_r(i_p2_b_field_r),
  .p2_c_field_r(i_p2_c_field_r),
  .p2bch(i_p2bch),
  .p2cc(i_p2cc),
  .p2conditional(i_p2conditional),
  .p2format(i_p2format),
  .p2iv(i_p2iv),
  .p2minoropcode(i_p2minoropcode),
  .p2opcode(i_p2opcode),
  .p2sleep_inst(i_p2sleep_inst),
  .p2setflags(i_p2setflags),
  .p2st(i_p2st),
  .p2subopcode(i_p2subopcode),
  .p2subopcode1_r(i_p2subopcode1_r),
  .p2subopcode2_r(i_p2subopcode2_r),
  .p2subopcode3_r(i_p2subopcode3_r),
  .p2subopcode4_r(i_p2subopcode4_r),
  .p2subopcode5_r(i_p2subopcode5_r),
  .p2subopcode6_r(i_p2subopcode6_r),
  .p2subopcode7_r(i_p2subopcode7_r),
  .en2b(i_en2b),
  .mload2b(i_mload2b),
  .mstore2b(i_mstore2b),
  .p2bint(i_p2bint),
  .p2b_a_field_r(i_p2b_a_field_r),
  .p2b_b_field_r(i_p2b_b_field_r),
  .p2b_c_field_r(i_p2b_c_field_r),
  .p2b_bch(i_p2b_bch),
  .p2b_cc(i_p2b_cc),
  .p2b_conditional(i_p2b_conditional),
  .p2b_format(i_p2b_format),
  .p2b_iv(i_p2b_iv),
  .p2b_minoropcode(i_p2b_minoropcode),
  .p2b_opcode(i_p2b_opcode),
  .p2b_setflags(i_p2b_setflags),
  .p2b_st(i_p2b_st),
  .p2b_subopcode(i_p2b_subopcode),
  .p2b_subopcode1_r(i_p2b_subopcode1_r),
  .p2b_subopcode2_r(i_p2b_subopcode2_r),
  .p2b_subopcode3_r(i_p2b_subopcode3_r),
  .p2b_subopcode4_r(i_p2b_subopcode4_r),
  .p2b_subopcode5_r(i_p2b_subopcode5_r),
  .p2b_subopcode6_r(i_p2b_subopcode6_r),
  .p2b_subopcode7_r(i_p2b_subopcode7_r),
  .dmp_holdup12(dmp_holdup12),
  .fs2a(i_fs2a),
  .s1a(i_s1a),
  .s1bus(s1bus),
  .s2bus(s2bus),
  .sc_reg1(i_sc_reg1),
  .sc_reg2(i_sc_reg2),
  .ext_s2val(ext_s2val),
  .s2val(s2val),
  .p3a_field_r(i_p3a_field_r),
  .p3b_field_r(i_p3b_field_r),
  .p3c_field_r(i_p3c_field_r),
  .p3condtrue(i_p3condtrue),
  .p3format(i_p3format),
  .p3iv(i_p3iv),
  .p3destlimm(i_p3destlimm),
  .p3minoropcode(i_p3minoropcode),
  .p3opcode(i_p3opcode),
  .p3setflags(i_p3setflags),
  .p3subopcode(i_p3subopcode),
  .p3subopcode1_r(i_p3subopcode1_r),
  .p3subopcode2_r(i_p3subopcode2_r),
  .p3subopcode3_r(i_p3subopcode3_r),
  .p3wb_en(i_p3wb_en),
  .p3wba(i_p3wba),
  .en3(i_en3),
  .p3cc(i_p3cc),
  .dest(i_dest),
  .desten(i_desten),
  .aluflags_r(aluflags_r),
  .p3lr(i_p3lr),
  .p3sr(i_p3sr),
  .aux_addr(aux_addr),
  .kill_p1_a(i_kill_p1_a),
  .kill_p2_a(i_kill_p2_a),
  .kill_p2b_a(i_kill_p2b_a),
  .kill_p3_a(i_kill_p3_a),
  .p3_xmultic_nwb(i_p3_xmultic_nwb),
  .ux_p2nosc1(ux_p2nosc1),
  .ux_p2nosc2(ux_p2nosc2),
  .uxp2ccmatch(uxp2ccmatch),
  .uxp2bccmatch(uxp2bccmatch),
  .uxp3ccmatch(uxp3ccmatch),
  .uxholdup2(uxholdup2),
  .uxholdup2b(uxholdup2b),
  .uxholdup3(uxholdup3),
  .uxnwb(uxnwb),
  .uxp2idest(uxp2idest),
  .uxsetflags(uxsetflags),
  .ux_isop_decode2(ux_isop_decode2),
  .ux_idop_decode2(ux_idop_decode2),
  .ux_izop_decode2(ux_izop_decode2),
  .ux_flgen(ux_flgen),
  .ux_p1_rev_src(ux_p1_rev_src),
  .ux_multic_wba(ux_multic_wba),
  .ux_multic_wben(ux_multic_wben),
  .ux_multic_busy(ux_multic_busy),
  .ux_p2_bfield_wb_a(ux_p2_bfield_wb_a),
  .ux_p2_jump_decode(ux_p2_jump_decode),
  .ux_snglec_wben(ux_snglec_wben),
  .barrel_type_r(barrel_type_r),
  .x_p3_brl_decode_16_r(x_p3_brl_decode_16_r),
  .x_p3_brl_decode_32_r(x_p3_brl_decode_32_r),
  .x_p3_norm_decode_r(x_p3_norm_decode_r),
  .x_p3_snorm_decode_r(x_p3_snorm_decode_r),
  .x_p3_swap_decode_r(x_p3_swap_decode_r),
  .p2dop32_inst(p2dop32_inst),
  .p2sop32_inst(p2sop32_inst),
  .p2zop32_inst(p2zop32_inst),
  .p2dop16_inst(p2dop16_inst),
  .p2sop16_inst(p2sop16_inst),
  .p2zop16_inst(p2zop16_inst),
  .p2b_dop32_inst(p2b_dop32_inst),
  .p2b_sop32_inst(p2b_sop32_inst),
  .p2b_zop32_inst(p2b_zop32_inst),
  .p2b_dop16_inst(p2b_dop16_inst),
  .p2b_sop16_inst(p2b_sop16_inst),
  .p2b_zop16_inst(p2b_zop16_inst),
  .p3dop32_inst(p3dop32_inst),
  .p3sop32_inst(p3sop32_inst),
  .p3zop32_inst(p3zop32_inst),
  .p3dop16_inst(p3dop16_inst),
  .p3sop16_inst(p3sop16_inst),
  .p3zop16_inst(p3zop16_inst),
  .x_p1_rev_src(i_x_p1_rev_src),
  .xholdup2(i_xholdup2),
  .xholdup2b(i_xholdup2b),
  .xp2idest(i_xp2idest),
  .x_flgen(x_flgen),
  .x_idecode2(i_x_idecode2),
  .x_idecode2b(i_x_idecode2b),
  .x_isop_decode2(i_x_isop_decode2),
  .x_idop_decode2(i_x_idop_decode2),
  .x_izop_decode2(u_unconnected_15),
  .x_multic_wba(i_x_multic_wba),
  .x_multic_wben(i_x_multic_wben),
  .x_multic_busy(i_x_multic_busy),
  .x_p2_bfield_wb_a(i_x_p2_bfield_wb_a),
  .xp2ccmatch(i_xp2ccmatch),
  .xp2bccmatch(i_xp2bccmatch),
  .x_p2nosc1(i_x_p2nosc1),
  .x_p2nosc2(i_x_p2nosc2),
  .x_p2shimm_a(i_x_p2shimm_a),
  .x_p2_jump_decode(i_x_p2_jump_decode),
  .x_p2b_jump_decode(i_x_p2b_jump_decode),
  .x_snglec_wben(i_x_snglec_wben),
  .xsetflags(xsetflags),
  .xp3ccmatch(i_xp3ccmatch),
  .xholdup3(i_xholdup3),
  .x_idecode3(i_x_idecode3),
  .x_set_sflag(x_set_sflag),
  .xnwb(i_xnwb)
);


// Instantiation of module int_unit
int_unit iint_unit(
  .clk_ungated(clk_ungated),
  .rst_a(rst_a),
  .irq(irq),
  .instruction_error(i_instruction_error),
  .int_vector_base_r(int_vector_base_r),
  .memory_error(memory_error),
  .misaligned_int(misaligned_int),
  .en1(i_en1),
  .en2(i_en2),
  .en2b(i_en2b),
  .en3(i_en3),
  .interrupt_holdoff(i_interrupt_holdoff),
  .flagu_block(i_flagu_block),
  .e1flag_r(e1flag_r),
  .e2flag_r(e2flag_r),
  .aux_access(aux_access),
  .aux_addr(aux_addr),
  .aux_dataw(aux_dataw),
  .aux_write(aux_write),
  .h_write(h_write),
  .h_addr(h_addr),
  .h_dataw(h_dataw),
  .hold_int_st2_a(i_hold_int_st2_a),
  .int_vec(i_int_vec),
  .p1int(i_p1int),
  .p2int(i_p2int),
  .p2bint(i_p2bint),
  .p2ilev1(i_p2ilev1),
  .p2bilev1(u_unconnected_16),
  .p3int(i_p3int),
  .p3ilev1(p3ilev1),
  .p123int(i_p123int),
  .aux_lv12(aux_lv12),
  .aux_hint(aux_hint),
  .aux_lev(aux_lev)
);


// Instantiation of module lsu
lsu ilsu(
  .clk(clk),
  .rst_a(rst_a),
  .ldvalid(ldvalid),
  .q_ldvalid(q_ldvalid),
  .loc_ldvalid(loc_ldvalid),
  .is_local_ram(is_local_ram),
  .is_peripheral(is_peripheral),
  .s1a(i_s1a),
  .fs2a(i_fs2a),
  .dest(i_dest),
  .mload2b(i_mload2b),
  .s1en(i_s1en),
  .s2en(i_s2en),
  .desten(i_desten),
  .en2b(i_en2b),
  .kill_last(i_kill_last),
  .en3(i_en3),
  .mload(i_mload),
  .nocache(i_nocache),
  .dc_disable_r(dc_disable_r),
  .regadr(i_regadr),
  .regadr_eq_src1(i_regadr_eq_src1),
  .regadr_eq_src2(i_regadr_eq_src2),
  .holdup2b(i_holdup2b),
  .max_one_lpend(max_one_lpend),
  .lpending(i_lpending)
);


// Instantiation of module ck_ctrl
ck_ctrl ick_ctrl(
  .clk_ungated(clk_ungated),
  .rst_a(rst_a),
  .test_mode(test_mode),
  .ctrl_cpu_start_sync_r(ctrl_cpu_start_sync_r),
  .do_inst_step_r(do_inst_step_r),
  .sleeping_r2(sleeping_r2),
  .en(en),
  .q_busy(q_busy),
  .p123int(i_p123int),
  .host_rw(host_rw),
  .p4_disable_r(i_p4_disable_r),
  .mem_access(mem_access),
  .lpending(i_lpending),
  .instr_pending_r(i_instr_pending_r),
  .ic_busy(ic_busy),
  .wd_clear(wd_clear),
  .mload2b(i_mload2b),
  .mstore2b(i_mstore2b),
  .dmp_mload(dmp_mload),
  .dmp_mstore(dmp_mstore),
  .is_local_ram(is_local_ram),
  .debug_if_r(debug_if_r),
  .cgm_queue_idle(cgm_queue_idle),
  .ibus_busy(ibus_busy),
  .pcp_rd_rq(pcp_rd_rq),
  .pcp_wr_rq(pcp_wr_rq),
  .ctrl_cpu_start_r(ctrl_cpu_start_r),
  .ck_disable(ck_disable),
  .ck_gated(ck_gated),
  .ck_dmp_gated(ck_dmp_gated)
);


// Instantiation of module pcounter
pcounter ipcounter(
  .clk(clk),
  .rst_a(rst_a),
  .aligner_do_pc_plus_8(aligner_do_pc_plus_8),
  .aligner_pc_enable(aligner_pc_enable),
  .awake_a(i_awake_a),
  .en2(i_en2),
  .en2b(i_en2b),
  .en3(i_en3),
  .h_dataw(h_dataw),
  .h_pcwr(h_pcwr),
  .h_pcwr32(h_pcwr32),
  .int_vec(i_int_vec),
  .ivalid(ivalid),
  .ivalid_aligned(ivalid_aligned),
  .loopstart_r(loopstart_r),
  .p1inst_16(p1inst_16),
  .p2_jblcc_a(i_p2_jblcc_a),
  .p2_abs_neg_a(i_p2_abs_neg_a),
  .p2_brcc_instr_a(i_p2_brcc_instr_a),
  .p2_dorel(i_p2_dorel),
  .p2_iw_r(i_p2_iw_r),
  .p2_not_a(i_p2_not_a),
  .p2_s1a(i_p2_s1a),
  .p2_s1en(i_p2_s1en),
  .p2b_dojcc(i_p2b_dojcc),
  .p2b_shimm_data(i_p2b_shimm_data),
  .p2b_shimm_s2_a(i_p2b_shimm_s2_a),
  .p2delay_slot(i_p2delay_slot),
  .p2int(i_p2int),
  .p2limm(i_p2limm),
  .p2lr(i_p2lr),
  .p2offset(i_p2offset),
  .p4_docmprel(i_p4_docmprel),
  .pcen(i_pcen),
  .pcen_niv(i_pcen_niv),
  .fs2a(i_fs2a),
  .p2_dopred(i_p2_dopred),
  .p2_dopred_nds(i_p2_dopred_nds),
  .p2b_dopred_ds(i_p2b_dopred_ds),
  .do_loop_a(do_loop_a),
  .qd_b(qd_b),
  .x2data_2_pc(x2data_2_pc),
  .step(step),
  .inst_step(inst_step),
  .currentpc_nxt(u_unconnected_17),
  .currentpc_r(currentpc_r),
  .misaligned_target(misaligned_target),
  .pc_is_linear_r(pc_is_linear_r),
  .next_pc(next_pc),
  .running_pc(u_unconnected_18),
  .last_pc_plus_len(last_pc_plus_len),
  .p2_pc_r(u_unconnected_19),
  .p2b_pc_r(p2b_pc_r),
  .p2_target(p2_target),
  .p2_s1val_tmp_r(p2_s1val_tmp_r),
  .pcounter_jmp_restart_r(i_pcounter_jmp_restart_r),
  .pcounter_jmp_restart_a(pcounter_jmp_restart_a)
);


// Output drives
assign s1en                    = i_s1en;
assign s2en                    = i_s2en;
assign en2                     = i_en2;
assign mload2b                 = i_mload2b;
assign mstore2b                = i_mstore2b;
assign p2opcode                = i_p2opcode;
assign p2subopcode             = i_p2subopcode;
assign p2subopcode2_r          = i_p2subopcode2_r;
assign p2_a_field_r            = i_p2_a_field_r;
assign p2_b_field_r            = i_p2_b_field_r;
assign p2_c_field_r            = i_p2_c_field_r;
assign p2iv                    = i_p2iv;
assign p2cc                    = i_p2cc;
assign p2conditional           = i_p2conditional;
assign p2sleep_inst            = i_p2sleep_inst;
assign p2setflags              = i_p2setflags;
assign p2st                    = i_p2st;
assign p2format                = i_p2format;
assign p2bch                   = i_p2bch;
assign en2b                    = i_en2b;
assign p2b_iv                  = i_p2b_iv;
assign p2b_conditional         = i_p2b_conditional;
assign p2b_cc                  = i_p2b_cc;
assign p2b_opcode              = i_p2b_opcode;
assign p2b_subopcode           = i_p2b_subopcode;
assign p2b_a_field_r           = i_p2b_a_field_r;
assign p2b_b_field_r           = i_p2b_b_field_r;
assign p2b_c_field_r           = i_p2b_c_field_r;
assign en3                     = i_en3;
assign p3iv                    = i_p3iv;
assign p3opcode                = i_p3opcode;
assign p3subopcode             = i_p3subopcode;
assign p3subopcode2_r          = i_p3subopcode2_r;
assign p3a_field_r             = i_p3a_field_r;
assign p3b_field_r             = i_p3b_field_r;
assign p3c_field_r             = i_p3c_field_r;
assign p3cc                    = i_p3cc;
assign p3condtrue              = i_p3condtrue;
assign p3destlimm              = i_p3destlimm;
assign p3format                = i_p3format;
assign p3setflags              = i_p3setflags;
assign x_idecode3              = i_x_idecode3;
assign p3wb_en                 = i_p3wb_en;
assign p3wba                   = i_p3wba;
assign p3lr                    = i_p3lr;
assign p3sr                    = i_p3sr;
assign s1a                     = i_s1a;
assign fs2a                    = i_fs2a;
assign dest                    = i_dest;
assign desten                  = i_desten;
assign sc_reg1                 = i_sc_reg1;
assign sc_reg2                 = i_sc_reg2;
assign p3_xmultic_nwb          = i_p3_xmultic_nwb;
assign lpending                = i_lpending;
assign p1int                   = i_p1int;
assign p2int                   = i_p2int;
assign p2bint                  = i_p2bint;
assign p3int                   = i_p3int;
assign pcounter_jmp_restart_r  = i_pcounter_jmp_restart_r;
assign regadr                  = i_regadr;
assign x_idecode2b             = i_x_idecode2b;
assign x_multic_busy           = i_x_multic_busy;
assign x_multic_wben           = i_x_multic_wben;
assign x_snglec_wben           = i_x_snglec_wben;
assign en1                     = i_en1;
assign instr_pending_r         = i_instr_pending_r;
assign pcen                    = i_pcen;
assign pcen_niv                = i_pcen_niv;
assign p2_brcc_instr_a         = i_p2_brcc_instr_a;
assign p2_dopred               = i_p2_dopred;
assign p2_dorel                = i_p2_dorel;
assign p2_iw_r                 = i_p2_iw_r;
assign p2_s1a                  = i_p2_s1a;
assign p2limm                  = i_p2limm;
assign p2minoropcode           = i_p2minoropcode;
assign p2subopcode3_r          = i_p2subopcode3_r;
assign p2subopcode4_r          = i_p2subopcode4_r;
assign p2subopcode5_r          = i_p2subopcode5_r;
assign p2subopcode6_r          = i_p2subopcode6_r;
assign p2subopcode7_r          = i_p2subopcode7_r;
assign p2b_dojcc               = i_p2b_dojcc;
assign p2b_setflags            = i_p2b_setflags;
assign p2b_shimm_data          = i_p2b_shimm_data;
assign p2b_shimm_s2_a          = i_p2b_shimm_s2_a;
assign mload                   = i_mload;
assign nocache                 = i_nocache;
assign p3minoropcode           = i_p3minoropcode;
assign p3subopcode3_r          = i_p3subopcode3_r;
assign p4_docmprel             = i_p4_docmprel;
assign p4_disable_r            = i_p4_disable_r;
assign kill_p2_a               = i_kill_p2_a;

endmodule


// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2002-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// 
module eia_common(
   clk,
   rst_a,
                       
//Other input signals available from the core can be inserted here:      
            
   en,
   s1en,
   s2en,
   s1bus,
   s2bus,
   en2,
   mload2b,
   mstore2b,
   p2opcode,
   p2subopcode,
   p2subopcode2_r,
   p2_a_field_r,
   p2_b_field_r,
   p2_c_field_r,
   p2iv,
   p2cc,
   p2conditional,
   p2sleep_inst,
   p2setflags,
   p2st,
   p2format,
   p2bch,
   p2dop32_inst,
   p2sop32_inst,
   p2zop32_inst,
   p2dop16_inst,
   p2sop16_inst,
   p2zop16_inst,
   en2b,
   p2b_iv,
   p2b_conditional,
   p2b_cc,
   p2b_dop32_inst,
   p2b_sop32_inst,
   p2b_zop32_inst,
   p2b_dop16_inst,
   p2b_sop16_inst,
   p2b_zop16_inst,
   p2b_opcode,
   p2b_subopcode,
   p2b_a_field_r,
   p2b_b_field_r,
   p2b_c_field_r,
   en3,
   p3iv,
   p3opcode,
   p3subopcode,
   p3subopcode2_r,
   p3a_field_r,
   p3b_field_r,
   p3c_field_r,
   p3cc,
   p3condtrue,
   p3destlimm,
   p3format,
   p3setflags,
   x_idecode3,
   p3wb_en,
   p3wba,
   p3lr,
   p3sr,
   p3dop32_inst,
   p3sop32_inst,
   p3zop32_inst,
   p3dop16_inst,
   p3sop16_inst,
   p3zop16_inst,
   aluflags_r,
   ext_s1val,
   ext_s2val,
   aux_addr,
   aux_dataw,
   aux_write,
   aux_read,
   h_addr,
   h_dataw,
   h_write,
   h_read,
   aux_access,
   s1a,
   s2a,
   fs2a,
   wba,
   wbdata,
   wben,
   core_access,
   dest,
   desten,
   sc_reg1,
   sc_reg2,
   p3_xmultic_nwb,
   ap_param0,
   ap_param0_read,
   ap_param0_write,
   ap_param1,
   ap_param1_read,
   ap_param1_write,
   uxdrx_reg,
   uxreg_hit,
   ux_da_am,
   ux_dar,
   uxivic,
   uxhold_host,
   uxnoaccess,
   ux2data_2_pc,
   ux1data,
   ux2data,
   ux_p2nosc1,
   ux_p2nosc2,
   uxp2bccmatch,
   uxp2ccmatch,
   uxp3ccmatch,
   uxholdup2,
   uxholdup2b,
   uxholdup3,
   ux_isop_decode2,
   ux_idop_decode2,
   ux_izop_decode2,
   uxnwb,
   uxp2idest,
   uxsetflags,
   xflags_r,
   ux_flgen,
   ux_multic_wba,
   ux_multic_wben,
   ux_multic_busy,
   ux_p1_rev_src,
   ux_p2_bfield_wb_a,
   ux_p2_jump_decode,
   ux_snglec_wben,
   uxresult,
   uxflags,
   dummy);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "asmutil.v"
`include "extutil.v"
`include "che_util.v"
`include "xdefs.v"
`include "uxdefs.v"

// Extra include files required for extensions are inserted here.

input          clk; 
input          rst_a; 

//other input signals available from the core can be inserted here:      

input          en; 
input          s1en; 
input          s2en; 
input   [31:0] s1bus; 
input   [31:0] s2bus; 
//signals for alu and condition code extension:
input          en2; 
input          mload2b; 
input          mstore2b; 
input   [4:0]  p2opcode; 
input   [5:0]  p2subopcode; 
input   [4:0]  p2subopcode2_r; 
input   [5:0]  p2_a_field_r; 
input   [5:0]  p2_b_field_r; 
input   [5:0]  p2_c_field_r; 
input          p2iv; 
input   [3:0]  p2cc; 
input          p2conditional; 
input          p2sleep_inst; 
input          p2setflags; 
input          p2st; 
input   [1:0]  p2format; 
input          p2bch; 
input          p2dop32_inst; 
input          p2sop32_inst; 
input          p2zop32_inst; 
input          p2dop16_inst; 
input          p2sop16_inst; 
input          p2zop16_inst;
input          en2b; 
input          p2b_iv; 
input          p2b_conditional; 
input   [3:0]  p2b_cc;
input          p2b_dop32_inst;
input          p2b_sop32_inst;
input          p2b_zop32_inst;
input          p2b_dop16_inst;
input          p2b_sop16_inst;
input          p2b_zop16_inst;
input   [4:0]  p2b_opcode; 
input   [5:0]  p2b_subopcode; 
input   [5:0]  p2b_a_field_r; 
input   [5:0]  p2b_b_field_r; 
input   [5:0]  p2b_c_field_r; 
input          en3; 
input          p3iv; 
input   [4:0]  p3opcode; 
input   [5:0]  p3subopcode; 
input   [4:0]  p3subopcode2_r; 
input   [5:0]  p3a_field_r; 
input   [5:0]  p3b_field_r; 
input   [5:0]  p3c_field_r; 
input   [3:0]  p3cc; 
input          p3condtrue; 
input          p3destlimm; 
input   [1:0]  p3format; 
input          p3setflags; 
input          x_idecode3; 
input          p3wb_en; 
input   [5:0]  p3wba; 
input          p3lr; 
input          p3sr; 
input          p3dop32_inst; 
input          p3sop32_inst; 
input          p3zop32_inst; 
input          p3dop16_inst; 
input          p3sop16_inst; 
input          p3zop16_inst; 
input   [3:0]  aluflags_r; 
input   [31:0] ext_s1val; 
input   [31:0] ext_s2val;
//signals for xauxregs extension:
input   [31:0] aux_addr; 
input   [31:0] aux_dataw; 
input          aux_write; 
input          aux_read; 
input   [31:0] h_addr; 
input   [31:0] h_dataw; 
input          h_write; 
input          h_read; 
input          aux_access; 
//signals for xcoreregs extension:
input   [5:0]  s1a; 
input   [5:0]  s2a; 
input   [5:0]  fs2a; 
input   [5:0]  wba; 
input   [31:0] wbdata; 
input          wben; 
input          core_access; 
input   [5:0]  dest; 
input          desten; 
input          sc_reg1; 
input          sc_reg2; 
//signals for multi-cycle extension:
input          p3_xmultic_nwb; 

output  [31:0] ap_param0;
output         ap_param0_read;
output         ap_param0_write;
output  [31:0] ap_param1;
output         ap_param1_read;
output         ap_param1_write;

//output for xauxregs extension:
output  [31:0] uxdrx_reg; 
output         uxreg_hit; 
output         ux_da_am; 
output  [31:0] ux_dar; 
output         uxhold_host; 
output         uxnoaccess;
// output signals for xcoreregs extension:
output  [31:0] ux2data_2_pc; 
output  [31:0] ux1data; 
output  [31:0] ux2data; 
output         ux_p2nosc1; 
output         ux_p2nosc2;
// output signals for condition code extension:
output         uxp2ccmatch; 
output         uxp2bccmatch; 
output         uxp3ccmatch;
// output signals for stage 2 instruction decoding:
output         ux_isop_decode2; 
output         ux_idop_decode2; 
output         ux_izop_decode2;
// output signals for pipeline control:
output         uxholdup2; 
output         uxholdup2b; 
output         uxholdup3; 
// output signals for result write back control:
output         uxnwb; 
output         uxp2idest; 
output         uxsetflags; 
output         ux_flgen; 
output  [5:0]  ux_multic_wba; 
output         ux_multic_wben; 
output         ux_multic_busy; 
output         ux_p1_rev_src; 
output         ux_p2_bfield_wb_a; 
output         ux_p2_jump_decode; 
output         ux_snglec_wben; 
// output signal for alu extension results:
output  [31:0] uxresult; 
output  [3:0]  uxflags;
output  [3:0]  xflags_r;
// special instruction control signals:
output         uxivic; 
output                   dummy;
   
wire    [31:0] uxdrx_reg; 
wire           uxreg_hit; 
wire           ux_da_am; 
wire    [31:0] ux_dar; 
wire           uxivic; 
wire           uxhold_host; 
wire           uxnoaccess;
wire    [31:0] ux2data_2_pc; 
wire    [31:0] ux1data; 
wire    [31:0] ux2data; 
wire           ux_p2nosc1; 
wire           ux_p2nosc2;
wire           uxp2ccmatch; 
wire           uxp2bccmatch; 
wire           uxp3ccmatch;
wire           uxholdup2; 
wire           uxholdup2b; 
wire           uxholdup3; 
wire           uxnwb; 
wire           uxp2idest; 
wire           uxsetflags;   
wire           ux_flgen; 
wire           ux_isop_decode2; 
wire           ux_idop_decode2; 
wire           ux_izop_decode2;
wire           ux_p1_rev_src; 
wire    [5:0]  ux_multic_wba; 
wire           ux_multic_wben; 
wire           ux_multic_busy; 
wire           ux_p2_bfield_wb_a; 
wire           ux_p2_jump_decode; 
wire           ux_snglec_wben;
wire    [31:0] uxresult; 
wire    [3:0]  uxflags; 

wire           i_p3_xmultic_nwb;
assign         i_p3_xmultic_nwb = 
                                  p3_xmultic_nwb;

wire           dummy;

assign dummy = 1'b0;

//=================== X flags ========================================--
// The X flags are 4 bits shared between all EIA extensions, they may be
// set by EIA extension instructions with the .f assembler notation.
wire    [3:0]  i_xflags_a;
wire           i_xflags_hit_a;
wire    [3:0]  i_xflags_nxt;
reg     [3:0]  xflags_r;
wire           i_xflags_en_a;

assign i_xflags_a = 
                    4'h0;

assign i_xflags_hit_a = (aux_addr == AUX_EIA_FLAGS);
  
assign i_xflags_nxt = (i_xflags_hit_a && aux_write)
                         ? aux_dataw[3:0]
                         : i_xflags_a;

assign i_xflags_en_a = (i_xflags_hit_a && aux_write) | ux_flgen;

// Xflags register.
always @(posedge clk or posedge rst_a)
begin : xflags_sync_PROC
  if (rst_a) begin
    xflags_r <= 0;
    end
  else begin
    if (i_xflags_en_a) begin
      xflags_r <= i_xflags_nxt;
      end
    end
end


//=================== Actionpoints external parameters ===============--
// These signals can be connected to any external parameters
// to be monitored. _read and _write are qualifiers which affect
// which actionpoints mode would need to be set to trigger.
assign    ap_param0       = AP_TEST_PATTERN0;
assign    ap_param0_read  = 1'b1;
assign    ap_param0_write = 1'b1;
assign    ap_param1       = AP_TEST_PATTERN1;
assign    ap_param1_read  = 1'b1;
assign    ap_param1_write = 1'b1;

   
// ====================== Extension ALU Functionality =================--
      
//  ALU result selection 
assign uxresult = 
                           {32{1'b 0}};
 
assign uxflags =
                           {4{1'b 0}};
   
// ============= Extension Auxiliary Register Functionality ===========--
// Extension auxiliar register result selection:
assign uxdrx_reg = 
       ({28'h0000000, {4{i_xflags_hit_a}} & xflags_r});
   
assign uxreg_hit = 
                           i_xflags_hit_a;
   
// Dual access
assign ux_da_am = 
                           1'b 0;
   
assign ux_dar = 
                           {32{1'b 0}};
   
assign uxhold_host = 
                           1'b 0;
   
assign uxnoaccess = 
                           1'b 0;
   
assign uxivic = 
                           1'b 0;

// ============== Extension Core Register Functionality ===============--
// Core register result selection:
assign ux2data_2_pc = 
                           {32{1'b 0}};
   
assign ux1data = 
                           {32{1'b 0}};
   
assign ux2data = 
                           {32{1'b 0}};
   
// Extension core registers shortcut control
assign ux_p2nosc1 = 
                           1'b 0;
   
assign ux_p2nosc2 = 
                           1'b 0;
   
// ================ Extension Control Logic Functionality==============--
//  Pipeline stage 2 extension instruction decode
   
assign ux_idop_decode2 =
                           1'b 0;

   
assign ux_isop_decode2 =
                           1'b 0;

   
assign ux_izop_decode2 =
                           1'b 0;

// ======================= Condition Code Control =====================--
assign uxp2ccmatch = 
                           1'b 0;

assign uxp2bccmatch = 
                           1'b 0;

assign uxp3ccmatch = 
                           1'b 0;

// ===================== Pipeline Stall Conditions ====================--
   
assign uxholdup2 = 
                           1'b 0;
   
assign uxholdup2b = 
                           1'b 0;
   
assign uxholdup3 = 
                           1'b 0;

   
// ===================== Result Write Back Control ====================--
   
assign ux_snglec_wben = 
                           1'b 0;
   
assign ux_multic_wben = 
                           1'b 0;
   
assign ux_multic_busy = 
                           1'b 0;
   
assign ux_multic_wba = 
                           {6{1'b 0}};
   

assign ux_p2_bfield_wb_a = 
                           1'b 0;
   
assign uxnwb = 
                           1'b 0;

assign uxp2idest = 
                           1'b 0;

assign ux_flgen =
                           1'b 0;
   
// ================= Special Instruction Control Logic ================--
   
assign ux_p2_jump_decode = 
                           1'b 0;
   
assign ux_p1_rev_src = 
                           1'b 0;
    
assign uxsetflags = 
                           1'b 0;
   
   
// Extension Instantiations:

// ====================================================================--

endmodule // module eia_common
// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module userextensions(en,
                      rst_a,
                      clk,
                      s1en,
                      s2en,
                      s1bus,
                      s2bus,
                      en2,
                      mload2b,
                      mstore2b,
                      p2opcode,
                      p2subopcode,
                      p2subopcode2_r,
                      p2_a_field_r,
                      p2_b_field_r,
                      p2_c_field_r,
                      p2iv,
                      p2cc,
                      p2conditional,
                      p2sleep_inst,
                      p2setflags,
                      p2st,
                      p2format,
                      p2bch,
                      p2dop32_inst,
                      p2sop32_inst,
                      p2zop32_inst,
                      p2dop16_inst,
                      p2sop16_inst,
                      p2zop16_inst,
                      en2b,
                      p2b_iv,
                      p2b_conditional,
                      p2b_cc,
                      p2b_dop32_inst,
                      p2b_sop32_inst,
                      p2b_zop32_inst,
                      p2b_dop16_inst,
                      p2b_sop16_inst,
                      p2b_zop16_inst,
                      p2b_opcode,
                      p2b_subopcode,
                      p2b_a_field_r,
                      p2b_b_field_r,
                      p2b_c_field_r,
                      en3,
                      p3iv,
                      p3opcode,
                      p3subopcode,
                      p3subopcode2_r,
                      p3a_field_r,
                      p3b_field_r,
                      p3c_field_r,
                      p3cc,
                      p3condtrue,
                      p3destlimm,
                      p3format,
                      p3setflags,
                      x_idecode3,
                      p3wb_en,
                      p3wba,
                      p3lr,
                      p3sr,
                      p3dop32_inst,
                      p3sop32_inst,
                      p3zop32_inst,
                      p3dop16_inst,
                      p3sop16_inst,
                      p3zop16_inst,
                      aluflags_r,
                      ext_s1val,
                      ext_s2val,
                      aux_addr,
                      aux_dataw,
                      aux_write,
                      aux_read,
                      h_addr,
                      h_dataw,
                      h_write,
                      h_read,
                      aux_access,
                      s1a,
                      s2a,
                      fs2a,
                      wba,
                      wbdata,
                      wben,
                      core_access,
                      dest,
                      desten,
                      sc_reg1,
                      sc_reg2,
                      p3_xmultic_nwb,
                      ap_param0,
                      ap_param0_read,
                      ap_param0_write,
                      ap_param1,
                      ap_param1_read,
                      ap_param1_write,
                      uxdrx_reg,
                      uxreg_hit,
                      ux_da_am,
                      ux_dar,
                      uxivic,
                      uxhold_host,
                      uxnoaccess,
                      ux2data_2_pc,
                      ux1data,
                      ux2data,
                      ux_p2nosc1,
                      ux_p2nosc2,
                      uxp2bccmatch,
                      uxp2ccmatch,
                      uxp3ccmatch,
                      uxholdup2,
                      uxholdup2b,
                      uxholdup3,
                      ux_isop_decode2,
                      ux_idop_decode2,
                      ux_izop_decode2,
                      uxnwb,
                      uxp2idest,
                      uxsetflags,
                      ux_flgen,
                      ux_multic_wba,
                      ux_multic_wben,
                      ux_multic_busy,
                      ux_p1_rev_src,
                      ux_p2_bfield_wb_a,
                      ux_p2_jump_decode,
                      ux_snglec_wben,
                      uxresult,
                      uxflags);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "asmutil.v"
`include "extutil.v"
`include "che_util.v"
`include "xdefs.v"
`include "uxdefs.v"


input  en;
input  rst_a;
input  clk;
input  s1en;
input  s2en;
input  [31:0]  s1bus;
input  [31:0]  s2bus;
input  en2;
input  mload2b;
input  mstore2b;
input  [4:0]  p2opcode;
input  [5:0]  p2subopcode;
input  [4:0]  p2subopcode2_r;
input  [5:0]  p2_a_field_r;
input  [5:0]  p2_b_field_r;
input  [5:0]  p2_c_field_r;
input  p2iv;
input  [3:0]  p2cc;
input  p2conditional;
input  p2sleep_inst;
input  p2setflags;
input  p2st;
input  [1:0]  p2format;
input  p2bch;
input  p2dop32_inst;
input  p2sop32_inst;
input  p2zop32_inst;
input  p2dop16_inst;
input  p2sop16_inst;
input  p2zop16_inst;
input  en2b;
input  p2b_iv;
input  p2b_conditional;
input  [3:0]  p2b_cc;
input  p2b_dop32_inst;
input  p2b_sop32_inst;
input  p2b_zop32_inst;
input  p2b_dop16_inst;
input  p2b_sop16_inst;
input  p2b_zop16_inst;
input  [4:0]  p2b_opcode;
input  [5:0]  p2b_subopcode;
input  [5:0]  p2b_a_field_r;
input  [5:0]  p2b_b_field_r;
input  [5:0]  p2b_c_field_r;
input  en3;
input  p3iv;
input  [4:0]  p3opcode;
input  [5:0]  p3subopcode;
input  [4:0]  p3subopcode2_r;
input  [5:0]  p3a_field_r;
input  [5:0]  p3b_field_r;
input  [5:0]  p3c_field_r;
input  [3:0]  p3cc;
input  p3condtrue;
input  p3destlimm;
input  [1:0]  p3format;
input  p3setflags;
input  x_idecode3;
input  p3wb_en;
input  [5:0]  p3wba;
input  p3lr;
input  p3sr;
input  p3dop32_inst;
input  p3sop32_inst;
input  p3zop32_inst;
input  p3dop16_inst;
input  p3sop16_inst;
input  p3zop16_inst;
input  [3:0]  aluflags_r;
input  [31:0]  ext_s1val;
input  [31:0]  ext_s2val;
input  [31:0]  aux_addr;
input  [31:0]  aux_dataw;
input  aux_write;
input  aux_read;
input  [31:0]  h_addr;
input  [31:0]  h_dataw;
input  h_write;
input  h_read;
input  aux_access;
input  [5:0]  s1a;
input  [5:0]  s2a;
input  [5:0]  fs2a;
input  [5:0]  wba;
input  [31:0]  wbdata;
input  wben;
input  core_access;
input  [5:0]  dest;
input  desten;
input  sc_reg1;
input  sc_reg2;
input  p3_xmultic_nwb;
output [31:0]  ap_param0;
output ap_param0_read;
output ap_param0_write;
output [31:0]  ap_param1;
output ap_param1_read;
output ap_param1_write;
output [31:0]  uxdrx_reg;
output uxreg_hit;
output ux_da_am;
output [31:0]  ux_dar;
output uxivic;
output uxhold_host;
output uxnoaccess;
output [31:0]  ux2data_2_pc;
output [31:0]  ux1data;
output [31:0]  ux2data;
output ux_p2nosc1;
output ux_p2nosc2;
output uxp2bccmatch;
output uxp2ccmatch;
output uxp3ccmatch;
output uxholdup2;
output uxholdup2b;
output uxholdup3;
output ux_isop_decode2;
output ux_idop_decode2;
output ux_izop_decode2;
output uxnwb;
output uxp2idest;
output uxsetflags;
output ux_flgen;
output [5:0]  ux_multic_wba;
output ux_multic_wben;
output ux_multic_busy;
output ux_p1_rev_src;
output ux_p2_bfield_wb_a;
output ux_p2_jump_decode;
output ux_snglec_wben;
output [31:0]  uxresult;
output [3:0]  uxflags;

wire en;
wire rst_a;
wire clk;
wire s1en;
wire s2en;
wire  [31:0] s1bus;
wire  [31:0] s2bus;
wire en2;
wire mload2b;
wire mstore2b;
wire  [4:0] p2opcode;
wire  [5:0] p2subopcode;
wire  [4:0] p2subopcode2_r;
wire  [5:0] p2_a_field_r;
wire  [5:0] p2_b_field_r;
wire  [5:0] p2_c_field_r;
wire p2iv;
wire  [3:0] p2cc;
wire p2conditional;
wire p2sleep_inst;
wire p2setflags;
wire p2st;
wire  [1:0] p2format;
wire p2bch;
wire p2dop32_inst;
wire p2sop32_inst;
wire p2zop32_inst;
wire p2dop16_inst;
wire p2sop16_inst;
wire p2zop16_inst;
wire en2b;
wire p2b_iv;
wire p2b_conditional;
wire  [3:0] p2b_cc;
wire p2b_dop32_inst;
wire p2b_sop32_inst;
wire p2b_zop32_inst;
wire p2b_dop16_inst;
wire p2b_sop16_inst;
wire p2b_zop16_inst;
wire  [4:0] p2b_opcode;
wire  [5:0] p2b_subopcode;
wire  [5:0] p2b_a_field_r;
wire  [5:0] p2b_b_field_r;
wire  [5:0] p2b_c_field_r;
wire en3;
wire p3iv;
wire  [4:0] p3opcode;
wire  [5:0] p3subopcode;
wire  [4:0] p3subopcode2_r;
wire  [5:0] p3a_field_r;
wire  [5:0] p3b_field_r;
wire  [5:0] p3c_field_r;
wire  [3:0] p3cc;
wire p3condtrue;
wire p3destlimm;
wire  [1:0] p3format;
wire p3setflags;
wire x_idecode3;
wire p3wb_en;
wire  [5:0] p3wba;
wire p3lr;
wire p3sr;
wire p3dop32_inst;
wire p3sop32_inst;
wire p3zop32_inst;
wire p3dop16_inst;
wire p3sop16_inst;
wire p3zop16_inst;
wire  [3:0] aluflags_r;
wire  [31:0] ext_s1val;
wire  [31:0] ext_s2val;
wire  [31:0] aux_addr;
wire  [31:0] aux_dataw;
wire aux_write;
wire aux_read;
wire  [31:0] h_addr;
wire  [31:0] h_dataw;
wire h_write;
wire h_read;
wire aux_access;
wire  [5:0] s1a;
wire  [5:0] s2a;
wire  [5:0] fs2a;
wire  [5:0] wba;
wire  [31:0] wbdata;
wire wben;
wire core_access;
wire  [5:0] dest;
wire desten;
wire sc_reg1;
wire sc_reg2;
wire p3_xmultic_nwb;
wire  [31:0] ap_param0;
wire ap_param0_read;
wire ap_param0_write;
wire  [31:0] ap_param1;
wire ap_param1_read;
wire ap_param1_write;
wire  [31:0] uxdrx_reg;
wire uxreg_hit;
wire ux_da_am;
wire  [31:0] ux_dar;
wire uxivic;
wire uxhold_host;
wire uxnoaccess;
wire  [31:0] ux2data_2_pc;
wire  [31:0] ux1data;
wire  [31:0] ux2data;
wire ux_p2nosc1;
wire ux_p2nosc2;
wire uxp2bccmatch;
wire uxp2ccmatch;
wire uxp3ccmatch;
wire uxholdup2;
wire uxholdup2b;
wire uxholdup3;
wire ux_isop_decode2;
wire ux_idop_decode2;
wire ux_izop_decode2;
wire uxnwb;
wire uxp2idest;
wire uxsetflags;
wire ux_flgen;
wire  [5:0] ux_multic_wba;
wire ux_multic_wben;
wire ux_multic_busy;
wire ux_p1_rev_src;
wire ux_p2_bfield_wb_a;
wire ux_p2_jump_decode;
wire ux_snglec_wben;
wire  [31:0] uxresult;
wire  [3:0] uxflags;


// Intermediate signals


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)
wire  [3:0] u_unconnected_0;
wire u_unconnected_1;


// Instantiation of module eia_common
eia_common ieia_common(
  .clk(clk),
  .rst_a(rst_a),
  .en(en),
  .s1en(s1en),
  .s2en(s2en),
  .s1bus(s1bus),
  .s2bus(s2bus),
  .en2(en2),
  .mload2b(mload2b),
  .mstore2b(mstore2b),
  .p2opcode(p2opcode),
  .p2subopcode(p2subopcode),
  .p2subopcode2_r(p2subopcode2_r),
  .p2_a_field_r(p2_a_field_r),
  .p2_b_field_r(p2_b_field_r),
  .p2_c_field_r(p2_c_field_r),
  .p2iv(p2iv),
  .p2cc(p2cc),
  .p2conditional(p2conditional),
  .p2sleep_inst(p2sleep_inst),
  .p2setflags(p2setflags),
  .p2st(p2st),
  .p2format(p2format),
  .p2bch(p2bch),
  .p2dop32_inst(p2dop32_inst),
  .p2sop32_inst(p2sop32_inst),
  .p2zop32_inst(p2zop32_inst),
  .p2dop16_inst(p2dop16_inst),
  .p2sop16_inst(p2sop16_inst),
  .p2zop16_inst(p2zop16_inst),
  .en2b(en2b),
  .p2b_iv(p2b_iv),
  .p2b_conditional(p2b_conditional),
  .p2b_cc(p2b_cc),
  .p2b_dop32_inst(p2b_dop32_inst),
  .p2b_sop32_inst(p2b_sop32_inst),
  .p2b_zop32_inst(p2b_zop32_inst),
  .p2b_dop16_inst(p2b_dop16_inst),
  .p2b_sop16_inst(p2b_sop16_inst),
  .p2b_zop16_inst(p2b_zop16_inst),
  .p2b_opcode(p2b_opcode),
  .p2b_subopcode(p2b_subopcode),
  .p2b_a_field_r(p2b_a_field_r),
  .p2b_b_field_r(p2b_b_field_r),
  .p2b_c_field_r(p2b_c_field_r),
  .en3(en3),
  .p3iv(p3iv),
  .p3opcode(p3opcode),
  .p3subopcode(p3subopcode),
  .p3subopcode2_r(p3subopcode2_r),
  .p3a_field_r(p3a_field_r),
  .p3b_field_r(p3b_field_r),
  .p3c_field_r(p3c_field_r),
  .p3cc(p3cc),
  .p3condtrue(p3condtrue),
  .p3destlimm(p3destlimm),
  .p3format(p3format),
  .p3setflags(p3setflags),
  .x_idecode3(x_idecode3),
  .p3wb_en(p3wb_en),
  .p3wba(p3wba),
  .p3lr(p3lr),
  .p3sr(p3sr),
  .p3dop32_inst(p3dop32_inst),
  .p3sop32_inst(p3sop32_inst),
  .p3zop32_inst(p3zop32_inst),
  .p3dop16_inst(p3dop16_inst),
  .p3sop16_inst(p3sop16_inst),
  .p3zop16_inst(p3zop16_inst),
  .aluflags_r(aluflags_r),
  .ext_s1val(ext_s1val),
  .ext_s2val(ext_s2val),
  .aux_addr(aux_addr),
  .aux_dataw(aux_dataw),
  .aux_write(aux_write),
  .aux_read(aux_read),
  .h_addr(h_addr),
  .h_dataw(h_dataw),
  .h_write(h_write),
  .h_read(h_read),
  .aux_access(aux_access),
  .s1a(s1a),
  .s2a(s2a),
  .fs2a(fs2a),
  .wba(wba),
  .wbdata(wbdata),
  .wben(wben),
  .core_access(core_access),
  .dest(dest),
  .desten(desten),
  .sc_reg1(sc_reg1),
  .sc_reg2(sc_reg2),
  .p3_xmultic_nwb(p3_xmultic_nwb),
  .ap_param0(ap_param0),
  .ap_param0_read(ap_param0_read),
  .ap_param0_write(ap_param0_write),
  .ap_param1(ap_param1),
  .ap_param1_read(ap_param1_read),
  .ap_param1_write(ap_param1_write),
  .uxdrx_reg(uxdrx_reg),
  .uxreg_hit(uxreg_hit),
  .ux_da_am(ux_da_am),
  .ux_dar(ux_dar),
  .uxivic(uxivic),
  .uxhold_host(uxhold_host),
  .uxnoaccess(uxnoaccess),
  .ux2data_2_pc(ux2data_2_pc),
  .ux1data(ux1data),
  .ux2data(ux2data),
  .ux_p2nosc1(ux_p2nosc1),
  .ux_p2nosc2(ux_p2nosc2),
  .uxp2bccmatch(uxp2bccmatch),
  .uxp2ccmatch(uxp2ccmatch),
  .uxp3ccmatch(uxp3ccmatch),
  .uxholdup2(uxholdup2),
  .uxholdup2b(uxholdup2b),
  .uxholdup3(uxholdup3),
  .ux_isop_decode2(ux_isop_decode2),
  .ux_idop_decode2(ux_idop_decode2),
  .ux_izop_decode2(ux_izop_decode2),
  .uxnwb(uxnwb),
  .uxp2idest(uxp2idest),
  .uxsetflags(uxsetflags),
  .xflags_r(u_unconnected_0),
  .ux_flgen(ux_flgen),
  .ux_multic_wba(ux_multic_wba),
  .ux_multic_wben(ux_multic_wben),
  .ux_multic_busy(ux_multic_busy),
  .ux_p1_rev_src(ux_p1_rev_src),
  .ux_p2_bfield_wb_a(ux_p2_bfield_wb_a),
  .ux_p2_jump_decode(ux_p2_jump_decode),
  .ux_snglec_wben(ux_snglec_wben),
  .uxresult(uxresult),
  .uxflags(uxflags),
  .dummy(u_unconnected_1)
);


// Output drives

endmodule


// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module quarc(clk_ungated,
             code_ram_rdata,
             rst_a,
             ctrl_cpu_start_sync_r,
             l_irq_4,
             l_irq_5,
             l_irq_6,
             l_irq_7,
             l_irq_8,
             l_irq_9,
             l_irq_10,
             l_irq_11,
             l_irq_12,
             l_irq_13,
             l_irq_14,
             l_irq_15,
             l_irq_16,
             l_irq_17,
             l_irq_18,
             l_irq_19,
             test_mode,
             clk,
             clk_debug,
             ibus_busy,
             mem_access,
             memory_error,
             h_addr,
             h_dataw,
             h_write,
             h_read,
             aux_access,
             core_access,
             ldvalid,
             sync_queue_idle,
             debug_if_r,
             dmp_mload,
             dmp_mstore,
             is_local_ram,
             mwait,
             dmp_holdup12,
             misaligned_int,
             q_ldvalid,
             loc_ldvalid,
             is_peripheral,
             q_busy,
             cgm_queue_idle,
             pcp_rd_rq,
             pcp_wr_rq,
             drd,
             dmp_dwr,
             dmp_en3,
             dmp_addr,
             dmp_size,
             dmp_sex,
             hold_loc,
             is_code_ram,
             code_dmi_req,
             code_dmi_addr,
             code_dmi_wdata,
             code_dmi_wr,
             code_dmi_be,
             arc_start_a,
             debug_if_a,
             halt,
             xstep,
             misaligned_err,
             code_ram_addr,
             code_ram_wdata,
             code_ram_wr,
             code_ram_be,
             code_ram_ck_en,
             en,
             wd_clear,
             ck_disable,
             ck_dmp_gated,
             en_debug_r,
             en3,
             lpending,
             mload,
             mstore,
             nocache,
             sex,
             size,
             dc_disable_r,
             max_one_lpend,
             mc_addr,
             dwr,
             hold_host,
             code_drd,
             code_ldvalid_r,
             code_dmi_rdata,
             noaccess,
             en_misaligned,
             reset_applied_r,
             power_toggle,
             lram_base,
             pc_sel_r,
             h_datar);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "asmutil.v"
`include "extutil.v"
`include "che_util.v"
`include "xdefs.v"
`include "uxdefs.v"
`include "ext_msb.v"


input  clk_ungated;
input  [31:0]  code_ram_rdata;
input  rst_a;
input  ctrl_cpu_start_sync_r;
input  l_irq_4;
input  l_irq_5;
input  l_irq_6;
input  l_irq_7;
input  l_irq_8;
input  l_irq_9;
input  l_irq_10;
input  l_irq_11;
input  l_irq_12;
input  l_irq_13;
input  l_irq_14;
input  l_irq_15;
input  l_irq_16;
input  l_irq_17;
input  l_irq_18;
input  l_irq_19;
input  test_mode;
input  clk;
input  clk_debug;
input  ibus_busy;
input  mem_access;
input  memory_error;
input  [31:0]  h_addr;
input  [31:0]  h_dataw;
input  h_write;
input  h_read;
input  aux_access;
input  core_access;
input  ldvalid;
input  sync_queue_idle;
input  debug_if_r;
input  dmp_mload;
input  dmp_mstore;
input  is_local_ram;
input  mwait;
input  dmp_holdup12;
input  misaligned_int;
input  q_ldvalid;
input  loc_ldvalid;
input  is_peripheral;
input  q_busy;
input  cgm_queue_idle;
input  pcp_rd_rq;
input  pcp_wr_rq;
input  [31:0]  drd;
input  [31:0]  dmp_dwr;
input  dmp_en3;
input  [31:0]  dmp_addr;
input  [1:0]  dmp_size;
input  dmp_sex;
input  hold_loc;
input  is_code_ram;
input  code_dmi_req;
input  [31:0]  code_dmi_addr;
input  [31:0]  code_dmi_wdata;
input  code_dmi_wr;
input  [3:0]  code_dmi_be;
input  arc_start_a;
input  debug_if_a;
input  halt;
input  xstep;
input  misaligned_err;
output [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0]  code_ram_addr;
output [31:0]  code_ram_wdata;
output code_ram_wr;
output [3:0]  code_ram_be;
output code_ram_ck_en;
output en;
output wd_clear;
output ck_disable;
output ck_dmp_gated;
output en_debug_r;
output en3;
output lpending;
output mload;
output mstore;
output nocache;
output sex;
output [1:0]  size;
output dc_disable_r;
output max_one_lpend;
output [31:0]  mc_addr;
output [31:0]  dwr;
output hold_host;
output [31:0]  code_drd;
output code_ldvalid_r;
output [31:0]  code_dmi_rdata;
output noaccess;
output en_misaligned;
output reset_applied_r;
output power_toggle;
output [EXT_A_MSB:LDST_A_MSB+3]  lram_base;
output pc_sel_r;
output [31:0]  h_datar;

wire clk_ungated;
wire  [31:0] code_ram_rdata;
wire rst_a;
wire ctrl_cpu_start_sync_r;
wire l_irq_4;
wire l_irq_5;
wire l_irq_6;
wire l_irq_7;
wire l_irq_8;
wire l_irq_9;
wire l_irq_10;
wire l_irq_11;
wire l_irq_12;
wire l_irq_13;
wire l_irq_14;
wire l_irq_15;
wire l_irq_16;
wire l_irq_17;
wire l_irq_18;
wire l_irq_19;
wire test_mode;
wire clk;
wire clk_debug;
wire ibus_busy;
wire mem_access;
wire memory_error;
wire  [31:0] h_addr;
wire  [31:0] h_dataw;
wire h_write;
wire h_read;
wire aux_access;
wire core_access;
wire ldvalid;
wire sync_queue_idle;
wire debug_if_r;
wire dmp_mload;
wire dmp_mstore;
wire is_local_ram;
wire mwait;
wire dmp_holdup12;
wire misaligned_int;
wire q_ldvalid;
wire loc_ldvalid;
wire is_peripheral;
wire q_busy;
wire cgm_queue_idle;
wire pcp_rd_rq;
wire pcp_wr_rq;
wire  [31:0] drd;
wire  [31:0] dmp_dwr;
wire dmp_en3;
wire  [31:0] dmp_addr;
wire  [1:0] dmp_size;
wire dmp_sex;
wire hold_loc;
wire is_code_ram;
wire code_dmi_req;
wire  [31:0] code_dmi_addr;
wire  [31:0] code_dmi_wdata;
wire code_dmi_wr;
wire  [3:0] code_dmi_be;
wire arc_start_a;
wire debug_if_a;
wire halt;
wire xstep;
wire misaligned_err;
wire  [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] code_ram_addr;
wire  [31:0] code_ram_wdata;
wire code_ram_wr;
wire  [3:0] code_ram_be;
wire code_ram_ck_en;
wire en;
wire wd_clear;
wire ck_disable;
wire ck_dmp_gated;
wire en_debug_r;
wire en3;
wire lpending;
wire mload;
wire mstore;
wire nocache;
wire sex;
wire  [1:0] size;
wire dc_disable_r;
wire max_one_lpend;
wire  [31:0] mc_addr;
wire  [31:0] dwr;
wire hold_host;
wire  [31:0] code_drd;
wire code_ldvalid_r;
wire  [31:0] code_dmi_rdata;
wire noaccess;
wire en_misaligned;
wire reset_applied_r;
wire power_toggle;
wire  [EXT_A_MSB:LDST_A_MSB+3] lram_base;
wire pc_sel_r;
wire  [31:0] h_datar;


// Intermediate signals
wire i_en;
wire i_wd_clear;
wire i_ck_disable;
wire i_en_debug_r;
wire i_en3;
wire i_lpending;
wire i_mload;
wire i_mstore;
wire i_dc_disable_r;
wire  [31:0] i_mc_addr;
wire  [31:0] i_dwr;
wire i_hold_host;
wire i_s1en;
wire i_s2en;
wire  [31:0] i_s1bus;
wire  [31:0] i_s2bus;
wire i_en2;
wire i_mload2b;
wire i_mstore2b;
wire  [4:0] i_p2opcode;
wire  [5:0] i_p2subopcode;
wire  [4:0] i_p2subopcode2_r;
wire  [5:0] i_p2_a_field_r;
wire  [5:0] i_p2_b_field_r;
wire  [5:0] i_p2_c_field_r;
wire i_p2iv;
wire  [3:0] i_p2cc;
wire i_p2conditional;
wire i_p2sleep_inst;
wire i_p2setflags;
wire i_p2st;
wire  [1:0] i_p2format;
wire i_p2bch;
wire i_p2dop32_inst;
wire i_p2sop32_inst;
wire i_p2zop32_inst;
wire i_p2dop16_inst;
wire i_p2sop16_inst;
wire i_p2zop16_inst;
wire i_en2b;
wire i_p2b_iv;
wire i_p2b_conditional;
wire  [3:0] i_p2b_cc;
wire i_p2b_dop32_inst;
wire i_p2b_sop32_inst;
wire i_p2b_zop32_inst;
wire i_p2b_dop16_inst;
wire i_p2b_sop16_inst;
wire i_p2b_zop16_inst;
wire  [4:0] i_p2b_opcode;
wire  [5:0] i_p2b_subopcode;
wire  [5:0] i_p2b_a_field_r;
wire  [5:0] i_p2b_b_field_r;
wire  [5:0] i_p2b_c_field_r;
wire i_p3iv;
wire  [4:0] i_p3opcode;
wire  [5:0] i_p3subopcode;
wire  [4:0] i_p3subopcode2_r;
wire  [5:0] i_p3a_field_r;
wire  [5:0] i_p3b_field_r;
wire  [5:0] i_p3c_field_r;
wire  [3:0] i_p3cc;
wire i_p3condtrue;
wire i_p3destlimm;
wire  [1:0] i_p3format;
wire i_p3setflags;
wire i_x_idecode3;
wire i_p3wb_en;
wire  [5:0] i_p3wba;
wire i_p3lr;
wire i_p3sr;
wire i_p3dop32_inst;
wire i_p3sop32_inst;
wire i_p3zop32_inst;
wire i_p3dop16_inst;
wire i_p3sop16_inst;
wire i_p3zop16_inst;
wire  [3:0] i_aluflags_r;
wire  [31:0] i_ext_s1val;
wire  [31:0] i_ext_s2val;
wire  [31:0] i_aux_addr;
wire  [31:0] i_aux_dataw;
wire i_aux_write;
wire i_aux_read;
wire  [5:0] i_s1a;
wire  [5:0] i_s2a;
wire  [5:0] i_fs2a;
wire  [5:0] i_wba;
wire  [31:0] i_wbdata;
wire i_wben;
wire  [5:0] i_dest;
wire i_desten;
wire i_sc_reg1;
wire i_sc_reg2;
wire i_p3_xmultic_nwb;
wire  [31:0] i_ap_param0;
wire i_ap_param0_read;
wire i_ap_param0_write;
wire  [31:0] i_ap_param1;
wire i_ap_param1_read;
wire i_ap_param1_write;
wire  [31:0] i_uxdrx_reg;
wire i_uxreg_hit;
wire i_ux_da_am;
wire  [31:0] i_ux_dar;
wire i_uxivic;
wire i_uxhold_host;
wire i_uxnoaccess;
wire  [31:0] i_ux2data_2_pc;
wire  [31:0] i_ux1data;
wire  [31:0] i_ux2data;
wire i_ux_p2nosc1;
wire i_ux_p2nosc2;
wire i_uxp2bccmatch;
wire i_uxp2ccmatch;
wire i_uxp3ccmatch;
wire i_uxholdup2;
wire i_uxholdup2b;
wire i_uxholdup3;
wire i_ux_isop_decode2;
wire i_ux_idop_decode2;
wire i_ux_izop_decode2;
wire i_uxnwb;
wire i_uxp2idest;
wire i_uxsetflags;
wire i_ux_flgen;
wire  [5:0] i_ux_multic_wba;
wire i_ux_multic_wben;
wire i_ux_multic_busy;
wire i_ux_p1_rev_src;
wire i_ux_p2_bfield_wb_a;
wire i_ux_p2_jump_decode;
wire i_ux_snglec_wben;
wire  [31:0] i_uxresult;
wire  [3:0] i_uxflags;
wire i_actionhalt;
wire i_actionpt_swi_a;
wire i_actionpt_pc_brk_a;
wire i_p2_ap_stall_a;
wire  [3:0] i_br_flags_a;
wire i_cr_hostw;
wire i_do_inst_step_r;
wire i_h_pcwr;
wire i_h_pcwr32;
wire  [5:0] i_h_regadr;
wire i_ivalid_aligned;
wire i_ivic;
wire i_loop_kill_p1_a;
wire i_loop_int_holdoff_a;
wire i_loopend_hit_a;
wire  [DATAWORD_MSB:0] i_p1iw_aligned_a;
wire i_sleeping;
wire i_sleeping_r2;
wire i_code_stall_ldst;
wire i_mulatwork_r;
wire  [31:0] i_s2val;
wire  [31:3] i_irq;
wire  [PC_MSB:`INT_BASE_LSB] i_int_vector_base_r;
wire i_e1flag_r;
wire i_e2flag_r;
wire i_host_rw;
wire i_ic_busy;
wire i_aligner_do_pc_plus_8;
wire i_aligner_pc_enable;
wire i_ivalid;
wire  [PC_MSB:0] i_loopstart_r;
wire i_p1inst_16;
wire i_do_loop_a;
wire  [31:0] i_qd_b;
wire  [31:0] i_x2data_2_pc;
wire i_step;
wire i_inst_step;
wire i_p1int;
wire i_p2int;
wire i_p2bint;
wire i_p3int;
wire i_pcounter_jmp_restart_r;
wire  [5:0] i_regadr;
wire i_x_idecode2b;
wire i_x_multic_busy;
wire i_x_multic_wben;
wire i_x_snglec_wben;
wire i_en1;
wire i_ifetch_aligned;
wire i_inst_stepping;
wire i_instr_pending_r;
wire i_pcen;
wire i_pcen_niv;
wire i_brk_inst_a;
wire i_p2_brcc_instr_a;
wire i_p2_dopred;
wire i_p2_dorel;
wire  [INSTR_UBND:0] i_p2_iw_r;
wire i_p2_lp_instr;
wire  [5:0] i_p2_s1a;
wire  [5:0] i_p2_s2a;
wire i_p2condtrue;
wire i_p2limm;
wire  [5:0] i_p2minoropcode;
wire  [2:0] i_p2subopcode3_r;
wire i_p2subopcode4_r;
wire  [1:0] i_p2subopcode5_r;
wire  [2:0] i_p2subopcode6_r;
wire  [1:0] i_p2subopcode7_r;
wire i_p2b_abs_op;
wire  [1:0] i_p2b_alu_op;
wire i_p2b_arithiv;
wire i_p2b_blcc_a;
wire i_p2b_condtrue;
wire i_p2b_delay_slot;
wire i_p2b_dojcc;
wire i_p2b_jlcc_a;
wire i_p2b_limm;
wire i_p2b_lr;
wire i_p2b_neg_op;
wire i_p2b_not_op;
wire i_p2b_setflags;
wire i_p2b_shift_by_one_a;
wire i_p2b_shift_by_three_a;
wire i_p2b_shift_by_two_a;
wire i_p2b_shift_by_zero_a;
wire  [12:0] i_p2b_shimm_data;
wire i_p2b_shimm_s1_a;
wire i_p2b_shimm_s2_a;
wire i_p2b_jmp_holdup_a;
wire i_en3_niv_a;
wire i_ldvalid_wb;
wire i_p3_alu_absiv;
wire i_p3_alu_arithiv;
wire i_p3_alu_logiciv;
wire  [1:0] i_p3_alu_op;
wire i_p3_alu_snglopiv;
wire  [1:0] i_p3_bit_op_sel;
wire i_p3_brcc_instr_a;
wire i_p3_docmprel_a;
wire i_p3_flag_instr;
wire i_p3_sync_instr;
wire i_p3_max_instr;
wire i_p3_min_instr;
wire  [1:0] i_p3_shiftin_sel_r;
wire  [2:0] i_p3_sop_op_r;
wire  [1:0] i_p3awb_field_r;
wire i_p3dolink;
wire  [5:0] i_p3minoropcode;
wire  [2:0] i_p3subopcode3_r;
wire i_p3subopcode4_r;
wire  [1:0] i_p3subopcode5_r;
wire  [2:0] i_p3subopcode6_r;
wire  [1:0] i_p3subopcode7_r;
wire i_sc_load1;
wire i_sc_load2;
wire i_p4_docmprel;
wire i_loopcount_hit_a;
wire i_p4_disable_r;
wire i_kill_p1_nlp_a;
wire i_kill_p2_a;
wire i_kill_tagged_p1;
wire i_stop_step;
wire  [1:0] i_barrel_type_r;
wire i_x_p3_brl_decode_16_r;
wire i_x_p3_brl_decode_32_r;
wire i_x_p3_norm_decode_r;
wire i_x_p3_snorm_decode_r;
wire i_x_p3_swap_decode_r;
wire i_x_flgen;
wire i_xsetflags;
wire i_x_set_sflag;
wire i_p3ilev1;
wire  [1:0] i_aux_lv12;
wire  [4:0] i_aux_hint;
wire  [31:3] i_aux_lev;
wire i_ctrl_cpu_start_r;
wire i_ck_gated;
wire  [PC_MSB:0] i_currentpc_r;
wire i_misaligned_target;
wire i_pc_is_linear_r;
wire  [PC_MSB:0] i_next_pc;
wire  [PC_MSB:0] i_last_pc_plus_len;
wire  [PC_MSB:0] i_p2b_pc_r;
wire  [PC_MSB:0] i_p2_target;
wire  [DATAWORD_MSB:0] i_p2_s1val_tmp_r;
wire i_pcounter_jmp_restart_a;
wire  [31:0] i_aux_datar;
wire i_aux_pc32hit;
wire i_aux_pchit;
wire  [31:0] i_s1val;
wire i_s2val_inverted_r;
wire i_aux_st_mulhi_a;
wire  [3:0] i_alurflags;
wire  [31:0] i_p3res_sc;
wire  [31:0] i_p3result;
wire  [63:0] i_lmulres_r;
wire  [1:0] i_x_s_flag;
wire  [3:0] i_xflags;
wire i_cr_hostr;
wire i_h_status32;
wire  [31:0] i_h_rr_data;
wire  [PC_MSB:0] i_loopend_r;
wire i_sr_xhold_host_a;
wire  [31:0] i_p1iw;
wire i_actionpt_hit_a;
wire  [NUM_APS-1:0] i_actionpt_status_r;
wire  [31:0] i_ap_ahv0;
wire  [31:0] i_ap_ahv1;
wire  [31:0] i_ap_ahv2;
wire  [31:0] i_ap_ahv3;
wire  [31:0] i_ap_ahv4;
wire  [31:0] i_ap_ahv5;
wire  [31:0] i_ap_ahv6;
wire  [31:0] i_ap_ahv7;
wire  [31:0] i_ap_ahc0;
wire  [31:0] i_ap_ahc1;
wire  [31:0] i_ap_ahc2;
wire  [31:0] i_ap_ahc3;
wire  [31:0] i_ap_ahc4;
wire  [31:0] i_ap_ahc5;
wire  [31:0] i_ap_ahc6;
wire  [31:0] i_ap_ahc7;
wire  [31:0] i_ap_ahm0;
wire  [31:0] i_ap_ahm1;
wire  [31:0] i_ap_ahm2;
wire  [31:0] i_ap_ahm3;
wire  [31:0] i_ap_ahm4;
wire  [31:0] i_ap_ahm5;
wire  [31:0] i_ap_ahm6;
wire  [31:0] i_ap_ahm7;


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)


// Instantiation of module userextensions
userextensions iuserextensions(
  .en(i_en),
  .rst_a(rst_a),
  .clk(clk),
  .s1en(i_s1en),
  .s2en(i_s2en),
  .s1bus(i_s1bus),
  .s2bus(i_s2bus),
  .en2(i_en2),
  .mload2b(i_mload2b),
  .mstore2b(i_mstore2b),
  .p2opcode(i_p2opcode),
  .p2subopcode(i_p2subopcode),
  .p2subopcode2_r(i_p2subopcode2_r),
  .p2_a_field_r(i_p2_a_field_r),
  .p2_b_field_r(i_p2_b_field_r),
  .p2_c_field_r(i_p2_c_field_r),
  .p2iv(i_p2iv),
  .p2cc(i_p2cc),
  .p2conditional(i_p2conditional),
  .p2sleep_inst(i_p2sleep_inst),
  .p2setflags(i_p2setflags),
  .p2st(i_p2st),
  .p2format(i_p2format),
  .p2bch(i_p2bch),
  .p2dop32_inst(i_p2dop32_inst),
  .p2sop32_inst(i_p2sop32_inst),
  .p2zop32_inst(i_p2zop32_inst),
  .p2dop16_inst(i_p2dop16_inst),
  .p2sop16_inst(i_p2sop16_inst),
  .p2zop16_inst(i_p2zop16_inst),
  .en2b(i_en2b),
  .p2b_iv(i_p2b_iv),
  .p2b_conditional(i_p2b_conditional),
  .p2b_cc(i_p2b_cc),
  .p2b_dop32_inst(i_p2b_dop32_inst),
  .p2b_sop32_inst(i_p2b_sop32_inst),
  .p2b_zop32_inst(i_p2b_zop32_inst),
  .p2b_dop16_inst(i_p2b_dop16_inst),
  .p2b_sop16_inst(i_p2b_sop16_inst),
  .p2b_zop16_inst(i_p2b_zop16_inst),
  .p2b_opcode(i_p2b_opcode),
  .p2b_subopcode(i_p2b_subopcode),
  .p2b_a_field_r(i_p2b_a_field_r),
  .p2b_b_field_r(i_p2b_b_field_r),
  .p2b_c_field_r(i_p2b_c_field_r),
  .en3(i_en3),
  .p3iv(i_p3iv),
  .p3opcode(i_p3opcode),
  .p3subopcode(i_p3subopcode),
  .p3subopcode2_r(i_p3subopcode2_r),
  .p3a_field_r(i_p3a_field_r),
  .p3b_field_r(i_p3b_field_r),
  .p3c_field_r(i_p3c_field_r),
  .p3cc(i_p3cc),
  .p3condtrue(i_p3condtrue),
  .p3destlimm(i_p3destlimm),
  .p3format(i_p3format),
  .p3setflags(i_p3setflags),
  .x_idecode3(i_x_idecode3),
  .p3wb_en(i_p3wb_en),
  .p3wba(i_p3wba),
  .p3lr(i_p3lr),
  .p3sr(i_p3sr),
  .p3dop32_inst(i_p3dop32_inst),
  .p3sop32_inst(i_p3sop32_inst),
  .p3zop32_inst(i_p3zop32_inst),
  .p3dop16_inst(i_p3dop16_inst),
  .p3sop16_inst(i_p3sop16_inst),
  .p3zop16_inst(i_p3zop16_inst),
  .aluflags_r(i_aluflags_r),
  .ext_s1val(i_ext_s1val),
  .ext_s2val(i_ext_s2val),
  .aux_addr(i_aux_addr),
  .aux_dataw(i_aux_dataw),
  .aux_write(i_aux_write),
  .aux_read(i_aux_read),
  .h_addr(h_addr),
  .h_dataw(h_dataw),
  .h_write(h_write),
  .h_read(h_read),
  .aux_access(aux_access),
  .s1a(i_s1a),
  .s2a(i_s2a),
  .fs2a(i_fs2a),
  .wba(i_wba),
  .wbdata(i_wbdata),
  .wben(i_wben),
  .core_access(core_access),
  .dest(i_dest),
  .desten(i_desten),
  .sc_reg1(i_sc_reg1),
  .sc_reg2(i_sc_reg2),
  .p3_xmultic_nwb(i_p3_xmultic_nwb),
  .ap_param0(i_ap_param0),
  .ap_param0_read(i_ap_param0_read),
  .ap_param0_write(i_ap_param0_write),
  .ap_param1(i_ap_param1),
  .ap_param1_read(i_ap_param1_read),
  .ap_param1_write(i_ap_param1_write),
  .uxdrx_reg(i_uxdrx_reg),
  .uxreg_hit(i_uxreg_hit),
  .ux_da_am(i_ux_da_am),
  .ux_dar(i_ux_dar),
  .uxivic(i_uxivic),
  .uxhold_host(i_uxhold_host),
  .uxnoaccess(i_uxnoaccess),
  .ux2data_2_pc(i_ux2data_2_pc),
  .ux1data(i_ux1data),
  .ux2data(i_ux2data),
  .ux_p2nosc1(i_ux_p2nosc1),
  .ux_p2nosc2(i_ux_p2nosc2),
  .uxp2bccmatch(i_uxp2bccmatch),
  .uxp2ccmatch(i_uxp2ccmatch),
  .uxp3ccmatch(i_uxp3ccmatch),
  .uxholdup2(i_uxholdup2),
  .uxholdup2b(i_uxholdup2b),
  .uxholdup3(i_uxholdup3),
  .ux_isop_decode2(i_ux_isop_decode2),
  .ux_idop_decode2(i_ux_idop_decode2),
  .ux_izop_decode2(i_ux_izop_decode2),
  .uxnwb(i_uxnwb),
  .uxp2idest(i_uxp2idest),
  .uxsetflags(i_uxsetflags),
  .ux_flgen(i_ux_flgen),
  .ux_multic_wba(i_ux_multic_wba),
  .ux_multic_wben(i_ux_multic_wben),
  .ux_multic_busy(i_ux_multic_busy),
  .ux_p1_rev_src(i_ux_p1_rev_src),
  .ux_p2_bfield_wb_a(i_ux_p2_bfield_wb_a),
  .ux_p2_jump_decode(i_ux_p2_jump_decode),
  .ux_snglec_wben(i_ux_snglec_wben),
  .uxresult(i_uxresult),
  .uxflags(i_uxflags)
);


// Instantiation of module control
control icontrol(
  .clk_ungated(clk_ungated),
  .en(i_en),
  .rst_a(rst_a),
  .wd_clear(i_wd_clear),
  .ctrl_cpu_start_sync_r(ctrl_cpu_start_sync_r),
  .test_mode(test_mode),
  .clk(clk),
  .ibus_busy(ibus_busy),
  .mem_access(mem_access),
  .memory_error(memory_error),
  .s1bus(i_s1bus),
  .s2bus(i_s2bus),
  .aluflags_r(i_aluflags_r),
  .ext_s2val(i_ext_s2val),
  .aux_addr(i_aux_addr),
  .aux_dataw(i_aux_dataw),
  .aux_write(i_aux_write),
  .h_addr(h_addr),
  .h_dataw(h_dataw),
  .h_write(h_write),
  .aux_access(aux_access),
  .ux_p2nosc1(i_ux_p2nosc1),
  .ux_p2nosc2(i_ux_p2nosc2),
  .uxp2bccmatch(i_uxp2bccmatch),
  .uxp2ccmatch(i_uxp2ccmatch),
  .uxp3ccmatch(i_uxp3ccmatch),
  .uxholdup2(i_uxholdup2),
  .uxholdup2b(i_uxholdup2b),
  .uxholdup3(i_uxholdup3),
  .ux_isop_decode2(i_ux_isop_decode2),
  .ux_idop_decode2(i_ux_idop_decode2),
  .ux_izop_decode2(i_ux_izop_decode2),
  .uxnwb(i_uxnwb),
  .uxp2idest(i_uxp2idest),
  .uxsetflags(i_uxsetflags),
  .ux_flgen(i_ux_flgen),
  .ux_multic_wba(i_ux_multic_wba),
  .ux_multic_wben(i_ux_multic_wben),
  .ux_multic_busy(i_ux_multic_busy),
  .ux_p1_rev_src(i_ux_p1_rev_src),
  .ux_p2_bfield_wb_a(i_ux_p2_bfield_wb_a),
  .ux_p2_jump_decode(i_ux_p2_jump_decode),
  .ux_snglec_wben(i_ux_snglec_wben),
  .actionhalt(i_actionhalt),
  .actionpt_swi_a(i_actionpt_swi_a),
  .actionpt_pc_brk_a(i_actionpt_pc_brk_a),
  .p2_ap_stall_a(i_p2_ap_stall_a),
  .br_flags_a(i_br_flags_a),
  .cr_hostw(i_cr_hostw),
  .do_inst_step_r(i_do_inst_step_r),
  .h_pcwr(i_h_pcwr),
  .h_pcwr32(i_h_pcwr32),
  .h_regadr(i_h_regadr),
  .ivalid_aligned(i_ivalid_aligned),
  .ivic(i_ivic),
  .ldvalid(ldvalid),
  .loop_kill_p1_a(i_loop_kill_p1_a),
  .loop_int_holdoff_a(i_loop_int_holdoff_a),
  .loopend_hit_a(i_loopend_hit_a),
  .sync_queue_idle(sync_queue_idle),
  .debug_if_r(debug_if_r),
  .dmp_mload(dmp_mload),
  .dmp_mstore(dmp_mstore),
  .is_local_ram(is_local_ram),
  .mwait(mwait),
  .p1iw_aligned_a(i_p1iw_aligned_a),
  .sleeping(i_sleeping),
  .sleeping_r2(i_sleeping_r2),
  .code_stall_ldst(i_code_stall_ldst),
  .mulatwork_r(i_mulatwork_r),
  .dmp_holdup12(dmp_holdup12),
  .s2val(i_s2val),
  .irq(i_irq),
  .int_vector_base_r(i_int_vector_base_r),
  .misaligned_int(misaligned_int),
  .e1flag_r(i_e1flag_r),
  .e2flag_r(i_e2flag_r),
  .q_ldvalid(q_ldvalid),
  .loc_ldvalid(loc_ldvalid),
  .is_peripheral(is_peripheral),
  .dc_disable_r(i_dc_disable_r),
  .q_busy(q_busy),
  .host_rw(i_host_rw),
  .ic_busy(i_ic_busy),
  .cgm_queue_idle(cgm_queue_idle),
  .pcp_rd_rq(pcp_rd_rq),
  .pcp_wr_rq(pcp_wr_rq),
  .aligner_do_pc_plus_8(i_aligner_do_pc_plus_8),
  .aligner_pc_enable(i_aligner_pc_enable),
  .ivalid(i_ivalid),
  .loopstart_r(i_loopstart_r),
  .p1inst_16(i_p1inst_16),
  .do_loop_a(i_do_loop_a),
  .qd_b(i_qd_b),
  .x2data_2_pc(i_x2data_2_pc),
  .step(i_step),
  .inst_step(i_inst_step),
  .ck_disable(i_ck_disable),
  .ck_dmp_gated(ck_dmp_gated),
  .s1en(i_s1en),
  .s2en(i_s2en),
  .en2(i_en2),
  .mload2b(i_mload2b),
  .mstore2b(i_mstore2b),
  .p2opcode(i_p2opcode),
  .p2subopcode(i_p2subopcode),
  .p2subopcode2_r(i_p2subopcode2_r),
  .p2_a_field_r(i_p2_a_field_r),
  .p2_b_field_r(i_p2_b_field_r),
  .p2_c_field_r(i_p2_c_field_r),
  .p2iv(i_p2iv),
  .p2cc(i_p2cc),
  .p2conditional(i_p2conditional),
  .p2sleep_inst(i_p2sleep_inst),
  .p2setflags(i_p2setflags),
  .p2st(i_p2st),
  .p2format(i_p2format),
  .p2bch(i_p2bch),
  .p2dop32_inst(i_p2dop32_inst),
  .p2sop32_inst(i_p2sop32_inst),
  .p2zop32_inst(i_p2zop32_inst),
  .p2dop16_inst(i_p2dop16_inst),
  .p2sop16_inst(i_p2sop16_inst),
  .p2zop16_inst(i_p2zop16_inst),
  .en2b(i_en2b),
  .p2b_iv(i_p2b_iv),
  .p2b_conditional(i_p2b_conditional),
  .p2b_cc(i_p2b_cc),
  .p2b_dop32_inst(i_p2b_dop32_inst),
  .p2b_sop32_inst(i_p2b_sop32_inst),
  .p2b_zop32_inst(i_p2b_zop32_inst),
  .p2b_dop16_inst(i_p2b_dop16_inst),
  .p2b_sop16_inst(i_p2b_sop16_inst),
  .p2b_zop16_inst(i_p2b_zop16_inst),
  .p2b_opcode(i_p2b_opcode),
  .p2b_subopcode(i_p2b_subopcode),
  .p2b_a_field_r(i_p2b_a_field_r),
  .p2b_b_field_r(i_p2b_b_field_r),
  .p2b_c_field_r(i_p2b_c_field_r),
  .en3(i_en3),
  .p3iv(i_p3iv),
  .p3opcode(i_p3opcode),
  .p3subopcode(i_p3subopcode),
  .p3subopcode2_r(i_p3subopcode2_r),
  .p3a_field_r(i_p3a_field_r),
  .p3b_field_r(i_p3b_field_r),
  .p3c_field_r(i_p3c_field_r),
  .p3cc(i_p3cc),
  .p3condtrue(i_p3condtrue),
  .p3destlimm(i_p3destlimm),
  .p3format(i_p3format),
  .p3setflags(i_p3setflags),
  .x_idecode3(i_x_idecode3),
  .p3wb_en(i_p3wb_en),
  .p3wba(i_p3wba),
  .p3lr(i_p3lr),
  .p3sr(i_p3sr),
  .p3dop32_inst(i_p3dop32_inst),
  .p3sop32_inst(i_p3sop32_inst),
  .p3zop32_inst(i_p3zop32_inst),
  .p3dop16_inst(i_p3dop16_inst),
  .p3sop16_inst(i_p3sop16_inst),
  .p3zop16_inst(i_p3zop16_inst),
  .s1a(i_s1a),
  .fs2a(i_fs2a),
  .wba(i_wba),
  .wben(i_wben),
  .dest(i_dest),
  .desten(i_desten),
  .sc_reg1(i_sc_reg1),
  .sc_reg2(i_sc_reg2),
  .p3_xmultic_nwb(i_p3_xmultic_nwb),
  .lpending(i_lpending),
  .p1int(i_p1int),
  .p2int(i_p2int),
  .p2bint(i_p2bint),
  .p3int(i_p3int),
  .pcounter_jmp_restart_r(i_pcounter_jmp_restart_r),
  .regadr(i_regadr),
  .x_idecode2b(i_x_idecode2b),
  .x_multic_busy(i_x_multic_busy),
  .x_multic_wben(i_x_multic_wben),
  .x_snglec_wben(i_x_snglec_wben),
  .en1(i_en1),
  .ifetch_aligned(i_ifetch_aligned),
  .inst_stepping(i_inst_stepping),
  .instr_pending_r(i_instr_pending_r),
  .pcen(i_pcen),
  .pcen_niv(i_pcen_niv),
  .brk_inst_a(i_brk_inst_a),
  .p2_brcc_instr_a(i_p2_brcc_instr_a),
  .p2_dopred(i_p2_dopred),
  .p2_dorel(i_p2_dorel),
  .p2_iw_r(i_p2_iw_r),
  .p2_lp_instr(i_p2_lp_instr),
  .p2_s1a(i_p2_s1a),
  .p2_s2a(i_p2_s2a),
  .p2condtrue(i_p2condtrue),
  .p2limm(i_p2limm),
  .p2minoropcode(i_p2minoropcode),
  .p2subopcode3_r(i_p2subopcode3_r),
  .p2subopcode4_r(i_p2subopcode4_r),
  .p2subopcode5_r(i_p2subopcode5_r),
  .p2subopcode6_r(i_p2subopcode6_r),
  .p2subopcode7_r(i_p2subopcode7_r),
  .p2b_abs_op(i_p2b_abs_op),
  .p2b_alu_op(i_p2b_alu_op),
  .p2b_arithiv(i_p2b_arithiv),
  .p2b_blcc_a(i_p2b_blcc_a),
  .p2b_condtrue(i_p2b_condtrue),
  .p2b_delay_slot(i_p2b_delay_slot),
  .p2b_dojcc(i_p2b_dojcc),
  .p2b_jlcc_a(i_p2b_jlcc_a),
  .p2b_limm(i_p2b_limm),
  .p2b_lr(i_p2b_lr),
  .p2b_neg_op(i_p2b_neg_op),
  .p2b_not_op(i_p2b_not_op),
  .p2b_setflags(i_p2b_setflags),
  .p2b_shift_by_one_a(i_p2b_shift_by_one_a),
  .p2b_shift_by_three_a(i_p2b_shift_by_three_a),
  .p2b_shift_by_two_a(i_p2b_shift_by_two_a),
  .p2b_shift_by_zero_a(i_p2b_shift_by_zero_a),
  .p2b_shimm_data(i_p2b_shimm_data),
  .p2b_shimm_s1_a(i_p2b_shimm_s1_a),
  .p2b_shimm_s2_a(i_p2b_shimm_s2_a),
  .p2b_jmp_holdup_a(i_p2b_jmp_holdup_a),
  .en3_niv_a(i_en3_niv_a),
  .ldvalid_wb(i_ldvalid_wb),
  .mload(i_mload),
  .mstore(i_mstore),
  .nocache(nocache),
  .p3_alu_absiv(i_p3_alu_absiv),
  .p3_alu_arithiv(i_p3_alu_arithiv),
  .p3_alu_logiciv(i_p3_alu_logiciv),
  .p3_alu_op(i_p3_alu_op),
  .p3_alu_snglopiv(i_p3_alu_snglopiv),
  .p3_bit_op_sel(i_p3_bit_op_sel),
  .p3_brcc_instr_a(i_p3_brcc_instr_a),
  .p3_docmprel_a(i_p3_docmprel_a),
  .p3_flag_instr(i_p3_flag_instr),
  .p3_sync_instr(i_p3_sync_instr),
  .p3_max_instr(i_p3_max_instr),
  .p3_min_instr(i_p3_min_instr),
  .p3_shiftin_sel_r(i_p3_shiftin_sel_r),
  .p3_sop_op_r(i_p3_sop_op_r),
  .p3awb_field_r(i_p3awb_field_r),
  .p3dolink(i_p3dolink),
  .p3minoropcode(i_p3minoropcode),
  .p3subopcode3_r(i_p3subopcode3_r),
  .p3subopcode4_r(i_p3subopcode4_r),
  .p3subopcode5_r(i_p3subopcode5_r),
  .p3subopcode6_r(i_p3subopcode6_r),
  .p3subopcode7_r(i_p3subopcode7_r),
  .sc_load1(i_sc_load1),
  .sc_load2(i_sc_load2),
  .sex(sex),
  .size(size),
  .p4_docmprel(i_p4_docmprel),
  .loopcount_hit_a(i_loopcount_hit_a),
  .p4_disable_r(i_p4_disable_r),
  .kill_p1_nlp_a(i_kill_p1_nlp_a),
  .kill_p2_a(i_kill_p2_a),
  .kill_tagged_p1(i_kill_tagged_p1),
  .stop_step(i_stop_step),
  .barrel_type_r(i_barrel_type_r),
  .x_p3_brl_decode_16_r(i_x_p3_brl_decode_16_r),
  .x_p3_brl_decode_32_r(i_x_p3_brl_decode_32_r),
  .x_p3_norm_decode_r(i_x_p3_norm_decode_r),
  .x_p3_snorm_decode_r(i_x_p3_snorm_decode_r),
  .x_p3_swap_decode_r(i_x_p3_swap_decode_r),
  .x_flgen(i_x_flgen),
  .xsetflags(i_xsetflags),
  .x_set_sflag(i_x_set_sflag),
  .p3ilev1(i_p3ilev1),
  .aux_lv12(i_aux_lv12),
  .aux_hint(i_aux_hint),
  .aux_lev(i_aux_lev),
  .max_one_lpend(max_one_lpend),
  .ctrl_cpu_start_r(i_ctrl_cpu_start_r),
  .ck_gated(i_ck_gated),
  .currentpc_r(i_currentpc_r),
  .misaligned_target(i_misaligned_target),
  .pc_is_linear_r(i_pc_is_linear_r),
  .next_pc(i_next_pc),
  .last_pc_plus_len(i_last_pc_plus_len),
  .p2b_pc_r(i_p2b_pc_r),
  .p2_target(i_p2_target),
  .p2_s1val_tmp_r(i_p2_s1val_tmp_r),
  .pcounter_jmp_restart_a(i_pcounter_jmp_restart_a)
);


// Instantiation of module alu
alu ialu(
  .rst_a(rst_a),
  .clk(clk),
  .en2b(i_en2b),
  .p2b_iv(i_p2b_iv),
  .p2b_opcode(i_p2b_opcode),
  .p2b_subopcode(i_p2b_subopcode),
  .en3(i_en3),
  .p3iv(i_p3iv),
  .p3opcode(i_p3opcode),
  .p3subopcode(i_p3subopcode),
  .p3subopcode2_r(i_p3subopcode2_r),
  .p3a_field_r(i_p3a_field_r),
  .p3b_field_r(i_p3b_field_r),
  .p3c_field_r(i_p3c_field_r),
  .p3condtrue(i_p3condtrue),
  .x_idecode3(i_x_idecode3),
  .p3wb_en(i_p3wb_en),
  .p3lr(i_p3lr),
  .aluflags_r(i_aluflags_r),
  .ext_s1val(i_ext_s1val),
  .ext_s2val(i_ext_s2val),
  .aux_dataw(i_aux_dataw),
  .h_dataw(h_dataw),
  .uxsetflags(i_uxsetflags),
  .uxresult(i_uxresult),
  .uxflags(i_uxflags),
  .cr_hostw(i_cr_hostw),
  .p3int(i_p3int),
  .x_multic_wben(i_x_multic_wben),
  .x_snglec_wben(i_x_snglec_wben),
  .ldvalid_wb(i_ldvalid_wb),
  .p3_alu_absiv(i_p3_alu_absiv),
  .p3_alu_arithiv(i_p3_alu_arithiv),
  .p3_alu_logiciv(i_p3_alu_logiciv),
  .p3_alu_op(i_p3_alu_op),
  .p3_alu_snglopiv(i_p3_alu_snglopiv),
  .p3_bit_op_sel(i_p3_bit_op_sel),
  .p3_max_instr(i_p3_max_instr),
  .p3_min_instr(i_p3_min_instr),
  .p3_shiftin_sel_r(i_p3_shiftin_sel_r),
  .p3_sop_op_r(i_p3_sop_op_r),
  .p3awb_field_r(i_p3awb_field_r),
  .p3dolink(i_p3dolink),
  .p3minoropcode(i_p3minoropcode),
  .p3subopcode3_r(i_p3subopcode3_r),
  .p3subopcode4_r(i_p3subopcode4_r),
  .p3subopcode5_r(i_p3subopcode5_r),
  .p3subopcode6_r(i_p3subopcode6_r),
  .p3subopcode7_r(i_p3subopcode7_r),
  .s2val(i_s2val),
  .barrel_type_r(i_barrel_type_r),
  .x_p3_brl_decode_16_r(i_x_p3_brl_decode_16_r),
  .x_p3_brl_decode_32_r(i_x_p3_brl_decode_32_r),
  .x_p3_norm_decode_r(i_x_p3_norm_decode_r),
  .x_p3_snorm_decode_r(i_x_p3_snorm_decode_r),
  .x_p3_swap_decode_r(i_x_p3_swap_decode_r),
  .e1flag_r(i_e1flag_r),
  .e2flag_r(i_e2flag_r),
  .aux_datar(i_aux_datar),
  .aux_pc32hit(i_aux_pc32hit),
  .aux_pchit(i_aux_pchit),
  .drd(drd),
  .s1val(i_s1val),
  .s2val_inverted_r(i_s2val_inverted_r),
  .aux_st_mulhi_a(i_aux_st_mulhi_a),
  .wbdata(i_wbdata),
  .br_flags_a(i_br_flags_a),
  .mulatwork_r(i_mulatwork_r),
  .alurflags(i_alurflags),
  .mc_addr(i_mc_addr),
  .p3res_sc(i_p3res_sc),
  .p3result(i_p3result),
  .lmulres_r(i_lmulres_r),
  .x_s_flag(i_x_s_flag),
  .xflags(i_xflags)
);


// Instantiation of module registers
registers iregisters(
  .clk_ungated(clk_ungated),
  .code_ram_rdata(code_ram_rdata),
  .en(i_en),
  .rst_a(rst_a),
  .test_mode(test_mode),
  .ck_disable(i_ck_disable),
  .clk(clk),
  .s1en(i_s1en),
  .s2en(i_s2en),
  .en2(i_en2),
  .mstore2b(i_mstore2b),
  .p2opcode(i_p2opcode),
  .p2subopcode(i_p2subopcode),
  .p2iv(i_p2iv),
  .en2b(i_en2b),
  .p2b_iv(i_p2b_iv),
  .aux_addr(i_aux_addr),
  .aux_dataw(i_aux_dataw),
  .aux_write(i_aux_write),
  .h_addr(h_addr),
  .h_read(h_read),
  .s1a(i_s1a),
  .s2a(i_s2a),
  .fs2a(i_fs2a),
  .wba(i_wba),
  .wbdata(i_wbdata),
  .wben(i_wben),
  .core_access(core_access),
  .sc_reg1(i_sc_reg1),
  .sc_reg2(i_sc_reg2),
  .ux2data_2_pc(i_ux2data_2_pc),
  .ux1data(i_ux1data),
  .ux2data(i_ux2data),
  .do_inst_step_r(i_do_inst_step_r),
  .h_pcwr(i_h_pcwr),
  .h_pcwr32(i_h_pcwr32),
  .ivic(i_ivic),
  .ldvalid(ldvalid),
  .dmp_mload(dmp_mload),
  .dmp_mstore(dmp_mstore),
  .p1int(i_p1int),
  .p2int(i_p2int),
  .p2bint(i_p2bint),
  .pcounter_jmp_restart_r(i_pcounter_jmp_restart_r),
  .regadr(i_regadr),
  .x_idecode2b(i_x_idecode2b),
  .en1(i_en1),
  .ifetch_aligned(i_ifetch_aligned),
  .pcen(i_pcen),
  .pcen_niv(i_pcen_niv),
  .p2_dopred(i_p2_dopred),
  .p2_dorel(i_p2_dorel),
  .p2_iw_r(i_p2_iw_r),
  .p2_lp_instr(i_p2_lp_instr),
  .p2_s1a(i_p2_s1a),
  .p2_s2a(i_p2_s2a),
  .p2condtrue(i_p2condtrue),
  .p2limm(i_p2limm),
  .p2minoropcode(i_p2minoropcode),
  .p2subopcode3_r(i_p2subopcode3_r),
  .p2subopcode4_r(i_p2subopcode4_r),
  .p2subopcode5_r(i_p2subopcode5_r),
  .p2subopcode6_r(i_p2subopcode6_r),
  .p2subopcode7_r(i_p2subopcode7_r),
  .p2b_abs_op(i_p2b_abs_op),
  .p2b_alu_op(i_p2b_alu_op),
  .p2b_arithiv(i_p2b_arithiv),
  .p2b_blcc_a(i_p2b_blcc_a),
  .p2b_delay_slot(i_p2b_delay_slot),
  .p2b_dojcc(i_p2b_dojcc),
  .p2b_jlcc_a(i_p2b_jlcc_a),
  .p2b_limm(i_p2b_limm),
  .p2b_lr(i_p2b_lr),
  .p2b_neg_op(i_p2b_neg_op),
  .p2b_not_op(i_p2b_not_op),
  .p2b_shift_by_one_a(i_p2b_shift_by_one_a),
  .p2b_shift_by_three_a(i_p2b_shift_by_three_a),
  .p2b_shift_by_two_a(i_p2b_shift_by_two_a),
  .p2b_shift_by_zero_a(i_p2b_shift_by_zero_a),
  .p2b_shimm_data(i_p2b_shimm_data),
  .p2b_shimm_s1_a(i_p2b_shimm_s1_a),
  .p2b_shimm_s2_a(i_p2b_shimm_s2_a),
  .sc_load1(i_sc_load1),
  .sc_load2(i_sc_load2),
  .p4_docmprel(i_p4_docmprel),
  .loopcount_hit_a(i_loopcount_hit_a),
  .kill_p1_nlp_a(i_kill_p1_nlp_a),
  .kill_tagged_p1(i_kill_tagged_p1),
  .currentpc_r(i_currentpc_r),
  .misaligned_target(i_misaligned_target),
  .pc_is_linear_r(i_pc_is_linear_r),
  .next_pc(i_next_pc),
  .last_pc_plus_len(i_last_pc_plus_len),
  .p2b_pc_r(i_p2b_pc_r),
  .p2_target(i_p2_target),
  .p2_s1val_tmp_r(i_p2_s1val_tmp_r),
  .drd(drd),
  .p3res_sc(i_p3res_sc),
  .p3result(i_p3result),
  .lmulres_r(i_lmulres_r),
  .hold_host(i_hold_host),
  .cr_hostr(i_cr_hostr),
  .h_status32(i_h_status32),
  .dmp_dwr(dmp_dwr),
  .dmp_en3(dmp_en3),
  .dmp_addr(dmp_addr),
  .dmp_size(dmp_size),
  .dmp_sex(dmp_sex),
  .hold_loc(hold_loc),
  .is_code_ram(is_code_ram),
  .code_dmi_req(code_dmi_req),
  .code_dmi_addr(code_dmi_addr),
  .code_dmi_wdata(code_dmi_wdata),
  .code_dmi_wr(code_dmi_wr),
  .code_dmi_be(code_dmi_be),
  .code_ram_addr(code_ram_addr),
  .code_ram_wdata(code_ram_wdata),
  .code_ram_wr(code_ram_wr),
  .code_ram_be(code_ram_be),
  .code_ram_ck_en(code_ram_ck_en),
  .s1bus(i_s1bus),
  .s2bus(i_s2bus),
  .ext_s1val(i_ext_s1val),
  .ext_s2val(i_ext_s2val),
  .ivalid_aligned(i_ivalid_aligned),
  .loop_kill_p1_a(i_loop_kill_p1_a),
  .loop_int_holdoff_a(i_loop_int_holdoff_a),
  .loopend_hit_a(i_loopend_hit_a),
  .p1iw_aligned_a(i_p1iw_aligned_a),
  .code_stall_ldst(i_code_stall_ldst),
  .s2val(i_s2val),
  .ic_busy(i_ic_busy),
  .aligner_do_pc_plus_8(i_aligner_do_pc_plus_8),
  .aligner_pc_enable(i_aligner_pc_enable),
  .ivalid(i_ivalid),
  .loopstart_r(i_loopstart_r),
  .p1inst_16(i_p1inst_16),
  .do_loop_a(i_do_loop_a),
  .qd_b(i_qd_b),
  .x2data_2_pc(i_x2data_2_pc),
  .s1val(i_s1val),
  .s2val_inverted_r(i_s2val_inverted_r),
  .dwr(i_dwr),
  .h_rr_data(i_h_rr_data),
  .loopend_r(i_loopend_r),
  .sr_xhold_host_a(i_sr_xhold_host_a),
  .p1iw(i_p1iw),
  .code_drd(code_drd),
  .code_ldvalid_r(code_ldvalid_r),
  .code_dmi_rdata(code_dmi_rdata)
);


// Instantiation of module auxiliary
auxiliary iauxiliary(
  .clk_ungated(clk_ungated),
  .rst_a(rst_a),
  .l_irq_4(l_irq_4),
  .l_irq_5(l_irq_5),
  .l_irq_6(l_irq_6),
  .l_irq_7(l_irq_7),
  .l_irq_8(l_irq_8),
  .l_irq_9(l_irq_9),
  .l_irq_10(l_irq_10),
  .l_irq_11(l_irq_11),
  .l_irq_12(l_irq_12),
  .l_irq_13(l_irq_13),
  .l_irq_14(l_irq_14),
  .l_irq_15(l_irq_15),
  .l_irq_16(l_irq_16),
  .l_irq_17(l_irq_17),
  .l_irq_18(l_irq_18),
  .l_irq_19(l_irq_19),
  .en_debug_r(i_en_debug_r),
  .clk(clk),
  .en2(i_en2),
  .p2sleep_inst(i_p2sleep_inst),
  .en2b(i_en2b),
  .p2b_iv(i_p2b_iv),
  .p2b_opcode(i_p2b_opcode),
  .p2b_subopcode(i_p2b_subopcode),
  .en3(i_en3),
  .p3iv(i_p3iv),
  .p3condtrue(i_p3condtrue),
  .p3setflags(i_p3setflags),
  .x_idecode3(i_x_idecode3),
  .p3wba(i_p3wba),
  .p3lr(i_p3lr),
  .p3sr(i_p3sr),
  .h_addr(h_addr),
  .h_dataw(h_dataw),
  .h_write(h_write),
  .h_read(h_read),
  .aux_access(aux_access),
  .fs2a(i_fs2a),
  .core_access(core_access),
  .uxdrx_reg(i_uxdrx_reg),
  .uxreg_hit(i_uxreg_hit),
  .ux_da_am(i_ux_da_am),
  .ux_dar(i_ux_dar),
  .uxivic(i_uxivic),
  .uxhold_host(i_uxhold_host),
  .uxnoaccess(i_uxnoaccess),
  .actionpt_pc_brk_a(i_actionpt_pc_brk_a),
  .ldvalid(ldvalid),
  .lpending(i_lpending),
  .debug_if_r(debug_if_r),
  .p1int(i_p1int),
  .p2int(i_p2int),
  .p2bint(i_p2bint),
  .p3int(i_p3int),
  .x_multic_busy(i_x_multic_busy),
  .inst_stepping(i_inst_stepping),
  .instr_pending_r(i_instr_pending_r),
  .brk_inst_a(i_brk_inst_a),
  .p2b_condtrue(i_p2b_condtrue),
  .p2b_setflags(i_p2b_setflags),
  .en3_niv_a(i_en3_niv_a),
  .p3_docmprel_a(i_p3_docmprel_a),
  .p3_flag_instr(i_p3_flag_instr),
  .p3_sync_instr(i_p3_sync_instr),
  .p4_disable_r(i_p4_disable_r),
  .stop_step(i_stop_step),
  .s2val(i_s2val),
  .x_flgen(i_x_flgen),
  .xsetflags(i_xsetflags),
  .x_set_sflag(i_x_set_sflag),
  .p3ilev1(i_p3ilev1),
  .aux_lv12(i_aux_lv12),
  .aux_hint(i_aux_hint),
  .aux_lev(i_aux_lev),
  .ic_busy(i_ic_busy),
  .ctrl_cpu_start_r(i_ctrl_cpu_start_r),
  .ck_gated(i_ck_gated),
  .loopstart_r(i_loopstart_r),
  .currentpc_r(i_currentpc_r),
  .pcounter_jmp_restart_a(i_pcounter_jmp_restart_a),
  .s1val(i_s1val),
  .alurflags(i_alurflags),
  .x_s_flag(i_x_s_flag),
  .xflags(i_xflags),
  .h_rr_data(i_h_rr_data),
  .loopend_r(i_loopend_r),
  .sr_xhold_host_a(i_sr_xhold_host_a),
  .arc_start_a(arc_start_a),
  .debug_if_a(debug_if_a),
  .actionpt_hit_a(i_actionpt_hit_a),
  .actionpt_status_r(i_actionpt_status_r),
  .halt(halt),
  .xstep(xstep),
  .misaligned_err(misaligned_err),
  .ap_ahv0(i_ap_ahv0),
  .ap_ahv1(i_ap_ahv1),
  .ap_ahv2(i_ap_ahv2),
  .ap_ahv3(i_ap_ahv3),
  .ap_ahv4(i_ap_ahv4),
  .ap_ahv5(i_ap_ahv5),
  .ap_ahv6(i_ap_ahv6),
  .ap_ahv7(i_ap_ahv7),
  .ap_ahc0(i_ap_ahc0),
  .ap_ahc1(i_ap_ahc1),
  .ap_ahc2(i_ap_ahc2),
  .ap_ahc3(i_ap_ahc3),
  .ap_ahc4(i_ap_ahc4),
  .ap_ahc5(i_ap_ahc5),
  .ap_ahc6(i_ap_ahc6),
  .ap_ahc7(i_ap_ahc7),
  .ap_ahm0(i_ap_ahm0),
  .ap_ahm1(i_ap_ahm1),
  .ap_ahm2(i_ap_ahm2),
  .ap_ahm3(i_ap_ahm3),
  .ap_ahm4(i_ap_ahm4),
  .ap_ahm5(i_ap_ahm5),
  .ap_ahm6(i_ap_ahm6),
  .ap_ahm7(i_ap_ahm7),
  .en(i_en),
  .wd_clear(i_wd_clear),
  .aluflags_r(i_aluflags_r),
  .aux_addr(i_aux_addr),
  .aux_dataw(i_aux_dataw),
  .aux_write(i_aux_write),
  .aux_read(i_aux_read),
  .s2a(i_s2a),
  .actionhalt(i_actionhalt),
  .cr_hostw(i_cr_hostw),
  .do_inst_step_r(i_do_inst_step_r),
  .h_pcwr(i_h_pcwr),
  .h_pcwr32(i_h_pcwr32),
  .h_regadr(i_h_regadr),
  .ivic(i_ivic),
  .sleeping(i_sleeping),
  .sleeping_r2(i_sleeping_r2),
  .irq(i_irq),
  .int_vector_base_r(i_int_vector_base_r),
  .e1flag_r(i_e1flag_r),
  .e2flag_r(i_e2flag_r),
  .dc_disable_r(i_dc_disable_r),
  .host_rw(i_host_rw),
  .step(i_step),
  .inst_step(i_inst_step),
  .aux_datar(i_aux_datar),
  .aux_pc32hit(i_aux_pc32hit),
  .aux_pchit(i_aux_pchit),
  .aux_st_mulhi_a(i_aux_st_mulhi_a),
  .hold_host(i_hold_host),
  .cr_hostr(i_cr_hostr),
  .h_status32(i_h_status32),
  .noaccess(noaccess),
  .en_misaligned(en_misaligned),
  .reset_applied_r(reset_applied_r),
  .power_toggle(power_toggle),
  .lram_base(lram_base),
  .pc_sel_r(pc_sel_r),
  .h_datar(h_datar)
);


// Instantiation of module debug_exts
debug_exts idebug_exts(
  .clk(clk),
  .clk_debug(clk_debug),
  .clk_ungated(clk_ungated),
  .rst_a(rst_a),
  .ivic(i_ivic),
  .p2b_iv(i_p2b_iv),
  .p2_iw_r(i_p2_iw_r),
  .actionpt_pc_brk_a(i_actionpt_pc_brk_a),
  .p2_brcc_instr_a(i_p2_brcc_instr_a),
  .p3_brcc_instr_a(i_p3_brcc_instr_a),
  .p2_ap_stall_a(i_p2_ap_stall_a),
  .p2b_jmp_holdup_a(i_p2b_jmp_holdup_a),
  .en(i_en),
  .aux_access(aux_access),
  .aux_read(i_aux_read),
  .aux_write(i_aux_write),
  .core_access(core_access),
  .h_addr(h_addr),
  .h_dataw(h_dataw),
  .h_write(h_write),
  .h_read(h_read),
  .en1(i_en1),
  .en2(i_en2),
  .en2b(i_en2b),
  .en3(i_en3),
  .ivalid_aligned(i_ivalid_aligned),
  .mload2b(i_mload2b),
  .mstore2b(i_mstore2b),
  .mwait(mwait),
  .p2limm(i_p2limm),
  .p2iv(i_p2iv),
  .p2opcode(i_p2opcode),
  .p2subopcode(i_p2subopcode),
  .currentpc_r(i_currentpc_r),
  .p1iw(i_p1iw),
  .mc_addr(i_mc_addr),
  .dwr(i_dwr),
  .drd(drd),
  .aux_addr(i_aux_addr),
  .aux_dataw(i_aux_dataw),
  .aux_datar(i_aux_datar),
  .ap_param0(i_ap_param0),
  .ap_param1(i_ap_param1),
  .ivalid(i_ivalid),
  .kill_tagged_p1(i_kill_tagged_p1),
  .kill_p2_a(i_kill_p2_a),
  .mload(i_mload),
  .mstore(i_mstore),
  .ldvalid(ldvalid),
  .ap_param0_read(i_ap_param0_read),
  .ap_param0_write(i_ap_param0_write),
  .ap_param1_read(i_ap_param1_read),
  .ap_param1_write(i_ap_param1_write),
  .actionhalt(i_actionhalt),
  .actionpt_status_r(i_actionpt_status_r),
  .ap_ahv0(i_ap_ahv0),
  .ap_ahv1(i_ap_ahv1),
  .ap_ahv2(i_ap_ahv2),
  .ap_ahv3(i_ap_ahv3),
  .ap_ahv4(i_ap_ahv4),
  .ap_ahv5(i_ap_ahv5),
  .ap_ahv6(i_ap_ahv6),
  .ap_ahv7(i_ap_ahv7),
  .ap_ahc0(i_ap_ahc0),
  .ap_ahc1(i_ap_ahc1),
  .ap_ahc2(i_ap_ahc2),
  .ap_ahc3(i_ap_ahc3),
  .ap_ahc4(i_ap_ahc4),
  .ap_ahc5(i_ap_ahc5),
  .ap_ahc6(i_ap_ahc6),
  .ap_ahc7(i_ap_ahc7),
  .ap_ahm0(i_ap_ahm0),
  .ap_ahm1(i_ap_ahm1),
  .ap_ahm2(i_ap_ahm2),
  .ap_ahm3(i_ap_ahm3),
  .ap_ahm4(i_ap_ahm4),
  .ap_ahm5(i_ap_ahm5),
  .ap_ahm6(i_ap_ahm6),
  .ap_ahm7(i_ap_ahm7),
  .actionpt_hit_a(i_actionpt_hit_a),
  .actionpt_swi_a(i_actionpt_swi_a),
  .en_debug_r(i_en_debug_r)
);


// Output drives
assign en                      = i_en;
assign wd_clear                = i_wd_clear;
assign ck_disable              = i_ck_disable;
assign en_debug_r              = i_en_debug_r;
assign en3                     = i_en3;
assign lpending                = i_lpending;
assign mload                   = i_mload;
assign mstore                  = i_mstore;
assign dc_disable_r            = i_dc_disable_r;
assign mc_addr                 = i_mc_addr;
assign dwr                     = i_dwr;
assign hold_host               = i_hold_host;

endmodule


// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1995-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// L indicates a latched signal and U indicates a signal produced by
// logic.
// 
// ======================== Inputs to this block ========================--
// 
//  addr             Load/store address connected to the DMP sub-modules
//                   (e.g. the load/store queue) and the peripherals
//
//  size             Size of Transfer, connected to the DMP-submodules
//                   (e.g. the load/store queue).
//                              00 => long
//                              01 => byte
//                              10 => word
//                              11 => undefined.
// 
//  sex              Sign extend signal connected to the DMP-submodules
//                   (e.g. the load/store queue)
// 
//  d_in             U Read Data. This 32-bit data is valid on the cycle 
//                   when ldst_dlat is set to '1'.
// 
// ====================== Outputs from this block =======================--
// 
//  d_out            Load data return bus from the load/store queue.
// 
// ======================================================================--
//
module readsort (d_in,
                 addr,
                 size,
                 sex,

                 d_out);

`include "arcutil.v"

   input   [31:0] d_in; 
   input   [1:0]  addr; 
   input   [1:0]  size; 
   input          sex; 

   output  [31:0] d_out; 

   wire    [31:0] d_out; 

   wire    [31:0] i_longword_a; 
   wire    [15:0] i_word_a; 
   wire    [7:0]  i_byte_a; 
   reg     [31:0] i_sxtl_a; 
   reg     [31:0] i_extl_a; 

   //  Select which part of the longword is used.
   //
   assign      i_longword_a = d_in[31:0]; 

 //Little-endian byte ordering
   assign      i_word_a = 
               (addr[1] == 1'b 1) ?
               i_longword_a[31:16] : i_longword_a[15:0]; 

   assign      i_byte_a = 
               (addr[0] == 1'b 1) ? 
               i_word_a[15:8] : i_word_a[7:0]; 

   // Sign extended read data formatting
   always @(
            size
            or i_byte_a
            or i_word_a
            or i_longword_a
            )
      begin : i_sxtl_a_mux_PROC
         case(size)
           LDST_LWORD : i_sxtl_a = i_longword_a;
           LDST_BYTE  : i_sxtl_a = {{24{i_byte_a[7]}}, i_byte_a};
           default  : i_sxtl_a = {{16{i_word_a[15]}},i_word_a};
         endcase // case(size)
      end // block: i_sxtl_a_mux_PROC

   // Zero extended read data formatting
   always @(
            size
            or i_byte_a
            or i_word_a
            or i_longword_a
            )
      begin : i_extl_a_mux_PROC
         case(size)
           LDST_LWORD : i_extl_a = i_longword_a;
           LDST_BYTE  : i_extl_a = {{24{1'b 0}},i_byte_a};
           default  : i_extl_a = {{16{1'b 0}},i_word_a};
         endcase // case(size)
      end // block: i_extl_a_mux_PROC
            
   // Finally select whether results is sign extended or not.
   //   
   assign      d_out = 
               (sex == 1'b 1) ? 
               i_sxtl_a : i_extl_a;
   
endmodule

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1998-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains load/store RAM control logic. The load/store RAM
// is an on-chip memory that can be accessed from the ARC pipeline 
// using load (LD) or store (ST) instructions. It can also be accessed
// from the debug interface (i.e from the PC port or the JTAG port) or
// the LD/ST Direct Memory Interface (LD/ST DMI).
// 
//========================== Inputs from this module =========================--
//
// clk_ungated      Core ungated clock. The ungated clock is used
//                  here so that DMI requests issued when the clock
//                  is asleep are still serviced.
//
// rst_a            Global asynchronous reset signal.
//
// test_mode        Global production test mode signal.
//
// dmp_dwr          Load write data connected to the DMP sub-modules
//                  (e.g. the load/store RAM) and the peripherals. The
//                  write data can come from either the ARC pipeline or
//                  the debug interface, depending on which module 
//                  requests to write to memory.
//
// dmp_en3          U Pipeline stage 3 enable signal connected to the
//                  DMP sub-modules (e.g. the load/store RAM) and the
//                  peripherals. This signal is controlled by either the
//                  ARC pipeline or the debug access unit. When it is
//                  set, a DMP sub-module or a peripheral will service
//                  the load/store request.
//
// dmp_addr         Load/store address connected to the DMP sub-modules
//                  (e.g. the load/store RAM) and the peripherals. This
//                  address can come from either the ARC pipeline or the
//                  debug interface, depending on which module requests
//                  to access memory.
//
// dmp_mload        Load instruction indicator. When it is set either
//                  the ARC or the debug interface wish to load data
//                  from an address in the LD/ST memory space.
//
// dmp_mstore       Store instruction indicator. When it is set either
//                  the ARC or the debug interface wish to store data
//                  to an address in the LD/ST memory space.
//
// dmp_size         Size of Transfer, connected to the DMP-submodules
//                  (e.g. the load/store RAM) and the peripherals. This
//                  is always cleared in debug mode. In ARC access mode,
//                  it is controlled by the ARC pipeline.
//
// dmp_sex          Sign extend signal connected to the DMP-submodules
//                  (e.g. the load/store RAM) and the peripherals. It is
//                  always cleared in debug mode. In ARC access mode, it
//                  is controlled from the ARC pipeline.
//
// hold_loc         This is a hold signal for the load/store RAM. If the
//                  load/store RAM is trying to return a load
//                  (ldst_ldvalid = '1') on the same cycle as hold_loc 
//                  is set then the load/store RAM should stall.
//
// is_ldst_ram      This is set when the address (dmp_addr) is within
//                  the load/store RAM address range.
//
// is_peripheral    This is set when the address (dmp_addr) is within
//                  the peripherals address range.
//
// ldst_dmi_req     DMI request to the LD/ST RAM. When set the Direct
//                  Memory Interface (DMI) has immediate direct access
//                  to the LD/ST RAM. The other LD/ST RAM interfaces 
//                  the data memory pipeline interfaces is held off as 
//                  it has lower priority. During one access several 
//                  reads and writes can be performed. Access ends when
//                  this signal is again set low. 
//
// ldst_dmi_addr    Address for the LD/ST RAM Direct Memory Interface.
//
// ldst_dmi_wdata   Write data for the LD/ST RAM Direct Memory 
//                  Interface.
//
// ldst_dmi_wr      Write enable for the LD/ST RAM Direct Memory 
//                  Interface. Set means write and clear means read.
//
// ldst_dmi_be      Byte enables on the LD/ST RAM Direct Memory 
//                  Interface. There are four byte enables, one for each
//                  byte lane. The byte enable bus is little endian.
//
//========================= Outputs from this module =========================--
//
// ldst_drd         The load data return bus from the load/store RAM.   
//
// ldst_ldvalid     Indicates that the load/store RAM wishes to perform
//                  a writeback on the next cycle.This signal is set
//                  when ldst_drd contains valid data.
//
// ldst_dmi_rdata   Read data to the LD/ST RAM Direct Memory Interface.
//
// stored_ld_rtn    Set when a load return from the DCCM is held off
//                  due to a DMI request and a Dcache load return
//                  happening at the same time.
//
module dccm_control (
   clk_ungated,
   rst_a,
   test_mode,
   dmp_dwr,
   dmp_en3,
   dmp_addr,
   dmp_mload,
   dmp_mstore,
   dmp_size,
   dmp_sex,
   ldst_dmi_req,
   ldst_dmi_addr,
   ldst_dmi_wdata,
   ldst_dmi_wr,
   ldst_dmi_be,
   ldst_dout,
   hold_loc,
   is_ldst_ram,
   is_peripheral,

   ldst_addr,
   ldst_din,
   ldst_mask,
   ldst_wren,
   ldst_ck_en,
   ldst_dmi_rdata,
   ldst_drd,
   ldst_ldvalid,
   stored_ld_rtn);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"

input                       clk_ungated;
input                       rst_a;
input                       test_mode;

// Read/Write signals from the debug access unit
//
input   [31:0]              dmp_dwr; 
input                       dmp_en3;
input   [31:0]              dmp_addr; 
input                       dmp_mload; 
input                       dmp_mstore; 
input   [1:0]               dmp_size; 
input                       dmp_sex;

// LD/ST RAM Direct Memory Interface (LD/ST RAM DMI)
//
input                       ldst_dmi_req; 
input   [31:0]              ldst_dmi_addr; 
input   [31:0]              ldst_dmi_wdata; 
input                       ldst_dmi_wr; 
input   [3:0]               ldst_dmi_be; 

// DCCM RAM Interface
//
input   [31:0]              ldst_dout; 

// Hold signal from the load return arbitrator
//
input                       hold_loc; 

// Address decodes from the load/store queue
//
input                       is_ldst_ram; 
input                       is_peripheral;

// DCCM RAM Interface
//
output  [LDST_A_MSB:0]      ldst_addr;
output  [31:0]              ldst_din;
output  [3:0]               ldst_mask;
output                      ldst_wren;
output                      ldst_ck_en;

// DCCM RAM Direct Memory Interface (DCCM RAM DMI)
//
output  [31:0]              ldst_dmi_rdata;

// Load return to the load return arbitrator
//
output  [31:0]              ldst_drd;
output                      ldst_ldvalid; 
output                      stored_ld_rtn;

wire    [LDST_A_MSB:0]      ldst_addr;
wire    [31:0]              ldst_din;
wire    [3:0]               ldst_mask;
wire                        ldst_wren;
wire                        ldst_ck_en;
wire    [31:0]              ldst_dmi_rdata; 
wire    [31:0]              ldst_drd; 

//  Signals for LD/ST RAM
// 
reg     [1:0]               i_d_addr_r; 
reg     [1:0]               i_d_size_r; 
reg                         i_d_sex_r; 
wire                        i_ldst_wren_a; 
wire    [31:0]              i_ldst_d_wr_a; 
wire    [3:0]               i_ldst_mask_a; 
wire    [31:0]              i_ldst_d_rd; 
wire                        i_ldst_ck_en_a; 
reg                         i_ldst_dlat_r;
wire                        i_ldst_ld_a; 
wire    [LDST_A_MSB:0]      i_ldst_raddr_nxt; 
reg     [LDST_A_MSB:0]      i_ldst_raddr_r; 
wire    [LDST_A_MSB:0]      i_rldst_raddr_a; 
reg                         i_stored_ld_rtn_r; 
reg     [3:0]               i_dmp_be_a; 
wire    [1:0]               i_be_addr_a; 
wire    [1:0]               i_be_size_a; 
reg     [1:0]               i_wdata_shift_a; 
reg                         i_ldst_st_d;
wire                        i_ldst_st_a;
wire                        stored_ld_rtn_r;

// ============================== LD/ST RAM ================================--
// 
   //  This provides a useful on-chip memory in the load/store space. A
   //  register is provided to enable the user to select where in the
   //  memory map the LD/ST RAM is mapped.
   // 
   //  Note that contents of the LD/ST RAM do not and will not correspond
   //  to the values in external memory, at the location where the LD/ST
   //  RAM is mapped. It is not a cache. Writes to the LD/ST RAM do
   //  not 'write-through' to external memory.
   //
   //  The LD/ST RAM is a fast on-chip memory, which services stores and 
   //  loads in a single cycle, provided that no scoreboard or register 
   //  writeback stalls are generated.
   //
   //  The only time the LD/ST RAM stalls is when it cannot return a
   //  load because another module with higher priority is returning a
   //  load on the same cycle. If this happens the LD/ST RAM stalls for 
   //   one cycle and attempts to return the load on the following clock
   //  cycle.
   // 
   //  The LD/ST RAM can also be accessed using the Direct Memory 
   //  Interface (LD/ST RAM DMI). This interface can, typically, be used
   //  by another on-chip module that wishes to access the LD/ST RAM.
   //  As the DMI interface has higher priority than the DMP interface, 
   //  the DMI accesses will always be serviced immediately. 
   // 
   //  In this version (ARC4), the method for dealing with loads from the
   //  LD/ST RAM has been adjusted. Rather than stalling a LD/ST RAM
   //  load which cannot complete immediately we save the load address
   //  and its associated information and perform the access when all
   //  previous memory accesses have completed. If another load or
   //  store operation is attempted whilst we have an outstanding
   //  request for the LD/ST RAM, then that load or store will be stalled.
   // 
   //  Essentially, this allows us to simplify the stalling logic - we
   //  do not have to generate a stall as a result of an address match -
   //  where the address is valid at the very end of the cycle. We,
   //  simply, have to do the address match and store the load information
   //  for later - then stall any subsequent accesses.
   // 
   //  i_ldst_dlat_r  : Registered signal which indicates completion of 
   //                   the LD/ST RAM access. Used to generate 
   //                   ldst_ldvalid for immediate and temporarily 
   //                   held-off accesses. It is never set during DMI 
   //                   accesses.
   // 
   //  i_ldst_ld_a    : Late-arriving signal indicating a LD/ST RAM load
   //                   being requested.
   // 
   //  i_ldst_raddr_r : Register to store the dmp_addr value that is to be
   //                   re-applied to the LD/ST RAM once the unsatisified
   //                   load has passed out of stage 3.
   // 
   //  i_d_addr_r     : Stored bottom 2 bits of dmp_addr, for LD/ST RAM
   //                   access. Passed to readsort for correct
   //                   byte/word/long access. Now stored only when a
   //                   load is issued to the LD/ST RAM.
   // 
   //  i_d_size_r     : Stored size bits, for LD/ST RAM access. Now
   //                   stored only when a load is issued to the
   //                   LD/ST RAM.
   // 
   //  i_d_sex_r      : Store sign-extend bit, for LD/ST RAM access. Now
   //                   stored only when a load is issued to the
   //                   LD/ST RAM.
   //  
   //  This signal is set when a load is issued to the LD/ST RAM. It will
   //  be valid late in the cycle, owing to the signals is_ldst_ram and 
   //  is_peripheral decode from the ALU adder.
   // 
   assign i_ldst_ld_a = ((dmp_mload     == 1'b 1) & 
                         (is_ldst_ram   == 1'b 1) & 
                         (is_peripheral == 1'b 0)) ?
          1'b 1 : 
          1'b 0;

   //  Here we switch the LD/ST RAM's input address between the value that
   //  comes directly from stage 3, the value stored when a LD cannot be
   //  immediately serviced and the value on the DMI interface of the 
   //  LD/ST RAM.
   // 
   assign i_rldst_raddr_a = 
                            (ldst_dmi_req == 1'b 1) ?
          ldst_dmi_addr[LDST_A_MSB + 2:2] : 
                            ((i_stored_ld_rtn_r == 1'b 1) | 
                             ((hold_loc == 1'b 1) &
                              (i_ldst_dlat_r == 1'b 1))) ?
          i_ldst_raddr_r :

          i_ldst_raddr_nxt; 

   //  In this process, we deal with all stored information related to a
   //  LD/ST RAM access. We generate the signals used in readsort when a 
   //  load access returns. The i_ldst_dlat_r signal is generated, which 
   //  indicates that the load is returning.
   // 
   always @(posedge clk_ungated or posedge rst_a)
   begin : redo_ldst_PROC

   //  Reset condition
   // 
   if (rst_a == 1'b 1)
      begin
      i_ldst_dlat_r     <= 1'b 0;   
      i_ldst_raddr_r    <= {(LDST_A_WIDTH) {1'b 0}}; 
      i_d_addr_r        <= {2 {1'b 0}}; 
      i_d_size_r        <= {2 {1'b 0}}; 
      i_d_sex_r         <= 1'b 0;   
      i_stored_ld_rtn_r <= 1'b 0;   
      end

   //  Clocked region
   // 
   else
      begin

      //  When a LD/ST RAM load occurs, save the signals needed to
      //  pass to readsort when an access completes (ldst_ldvalid
      //  true).
      // 
      if (i_ldst_ld_a == 1'b 1 & dmp_en3 == 1'b 1)
         begin
         i_d_addr_r <= dmp_addr[1:0];   
         i_d_size_r <= dmp_size;    
         i_d_sex_r  <= dmp_sex; 
         end

      //  Register the LD/ST RAM address, so it can be used if the 
      //  load cannot return. Don't register during DMI accesses 
      //  because we want to preserve the last value of the last DMP
      //  access. The DMI access never needs to get stored, as this
      //  inteface has the highest priority and therefore always gets 
      //  immediate access.
      // 
      if (ldst_dmi_req == 1'b 0)
         begin
         i_ldst_raddr_r <= i_ldst_raddr_nxt; 
         end

      //  If a load cannot return and a request is issued at the same 
      //  time on the LD/ST DMI interface then store the load return.
      //  Re-issue the load when the DMI session is over.
      // 
      if ((ldst_dmi_req == 1'b 1) & 
          (((hold_loc     == 1'b 1) & 
          (i_ldst_dlat_r == 1'b 1)) |
          ((i_ldst_ld_a == 1'b1) & (dmp_en3 == 1'b1))))
         begin
         i_stored_ld_rtn_r <= 1'b 1;    
         end
      else if (ldst_dmi_req == 1'b 0 )
         begin
         i_stored_ld_rtn_r <= 1'b 0;    
         end

      //  Generation of ldst_ldvalid for load returns.
      // 
      //  The valid load return signal (ldst_ldvalid) is set on the 
      //  next cycle if:
      // 
      //     [1] A valid load to the LD/ST RAM is issued.
      // 
      //     [2] A load cannot return and needs to be returned on the
      //         next cycle.
      // 
      //     [3] A DMI access has just finished and a DMP load that 
      //         was interrupted when the DMI access started can now
      //         be issued.
      // 
      if (((i_ldst_ld_a      == 1'b 1) &
           (dmp_en3          == 1'b 1) &
           (ldst_dmi_req     == 1'b 0))    | 

         ((hold_loc          == 1'b 1) &
          (i_ldst_dlat_r     == 1'b 1) & 
          (ldst_dmi_req      == 1'b 0))    | 

         ((i_stored_ld_rtn_r == 1'b 1) &
          (ldst_dmi_req      == 1'b 0)))

         begin
         i_ldst_dlat_r <= 1'b 1;    
         end
      else
         begin
         i_ldst_dlat_r <= 1'b 0;    
         end
      end
   end

   //  This is the ARC addressing the LD/ST RAM.
   // 
   assign i_ldst_raddr_nxt = dmp_addr[LDST_A_MSB + 2:2];
 
   //  The write enable for the LD/ST RAM is set when ARC executes
   //  a store operation provided to the LD/ST RAM or when a LD/ST RAM
   //  DMI write operation occurs.
   // 

   assign i_ldst_st_a =    ((dmp_mstore    == 1'b 1) & 
                            (is_ldst_ram   == 1'b 1) & 
                            (is_peripheral == 1'b 0));

   always @(posedge clk_ungated or posedge rst_a)
   begin
   //  Reset condition
   if (rst_a == 1'b 1)
      begin
      i_ldst_st_d   <= 1'b 0; 
      end

   //  Clocked region
   else
      begin
      if ((i_ldst_st_a == 1'b 1) & (dmp_en3 == 1'b 1) &
          (ldst_dmi_req == 1'b 1))
         begin
         i_ldst_st_d  <= 1'b 1; 
         end
      else if (ldst_dmi_req == 1'b 0)
         begin
         i_ldst_st_d <= 1'b 0;
         end
      end
   end

   assign i_ldst_wren_a = (((ldst_dmi_req == 1'b 1) & 
                            (ldst_dmi_wr  == 1'b 1)) |

                           ((i_ldst_st_d  == 1'b 1) &
                            (ldst_dmi_req == 1'b 0))  |
 
                           ((dmp_mstore    == 1'b 1) & 
                            (is_ldst_ram   == 1'b 1) & 
                            (is_peripheral == 1'b 0) & 
                            (dmp_en3       == 1'b 1))) ?
         LDST_WR_ACTIVE : 
         ~LDST_WR_ACTIVE;


   // The LD/ST RAM write data must be shifted into the correct byte-lanes
   // according to the endianness. This is done by modifying the addresses
   // individual bytes and words are stored in for non long-word accesses.
   always @(dmp_addr)       
    begin : write_shift_calc_PROC
            // Little-endian shift = long word byte-offset
      i_wdata_shift_a = dmp_addr[1:0] ; 
   end // block: write_shift_calc
   
   //  The LD/ST RAM write data is set to the DMI interface write data
   //  during LD/ST RAM DMI accesses. Otherwise they are set to the 
   //  appropriate bytes of the DMP write data.
   // 
   assign i_ldst_d_wr_a = 
                          (ldst_dmi_req   == 1'b 1)  ?
          ldst_dmi_wdata : 
                          (i_wdata_shift_a == BYTE1) ?
          {dmp_dwr[23:0], dmp_dwr[31:24]} : 
                          (i_wdata_shift_a == BYTE2) ?
          {dmp_dwr[15:0], dmp_dwr[31:16]} : 
                          (i_wdata_shift_a == BYTE3) ?
          {dmp_dwr[7:0], dmp_dwr[31:8]} : 
          dmp_dwr; 

// ====================== LD/ST RAM Mask Calculation =======================--
// 
   //  Choose address and size to use for the mask calculation. Normally,
   //  these signals are taken directly from the ARC pipeline interface.
   //  The only exception is when a load from the LD/ST RAM has not been
   //  able to return to the processor because a DMP sub-module with
   //  higher priority has returned a load at the same time. In this
   //  special case the address and size are, instead, taken from a 
   //  registered value.
   // 
   assign i_be_addr_a = ((i_stored_ld_rtn_r == 1'b 1) | 
                         ((hold_loc         == 1'b 1) & 
                          (i_ldst_dlat_r    == 1'b 1))) ?
          i_d_addr_r : 
          dmp_addr[1:0];

   assign i_be_size_a = ((i_stored_ld_rtn_r == 1'b 1) | 
                         ((hold_loc         == 1'b 1) & 
                          (i_ldst_dlat_r    == 1'b 1))) ?
          i_d_size_r : 
          dmp_size;

   //  This process performs mask calculations for the LD/ST RAM for byte,
   //  word and longword accesses.
   // 
   always @(i_be_addr_a or i_be_size_a)
   begin : dmp_be_PROC

   case (i_be_size_a)

   //  byte mask
   LDST_BYTE:
     case (i_be_addr_a)
       BYTE0:  i_dmp_be_a = BYTE0_MASK;
       BYTE1:  i_dmp_be_a = BYTE1_MASK;    
       BYTE2:  i_dmp_be_a = BYTE2_MASK;    
       default:i_dmp_be_a = BYTE3_MASK;    
     endcase 
     
   //  word mask
   LDST_WORD:
      if (i_be_addr_a[1] == 1'b 0)
         i_dmp_be_a = WORD0_MASK;    
      else
         i_dmp_be_a = WORD1_MASK;    

   
   //  longword mask
   default:
      i_dmp_be_a = LONG_MASK;    
   endcase
   end

   //  Select whether to get the byte enables from the DMI interface
   //  or the DMP interface.
   // 
   assign i_ldst_mask_a = (ldst_dmi_req == 1'b 1) ?
          ldst_dmi_be :
          i_dmp_be_a; 

// ====================== Load return valid signal =========================--
//
   //  Generate the load valid signal for the ARC from ls_dlat or from
   //  the LD/ST RAM (i_ldst_dlat_r).
   // 
   assign ldst_ldvalid = i_ldst_dlat_r; 

// ================= Read data on the DMI interface ========================--
// 
   assign ldst_dmi_rdata = i_ldst_d_rd; 

// ======================== Clock Enable for RAMs ==========================--
// 
   //  The clock enable for the LD/ST RAM block is enabled in the
   //  following manner: It is enabled on loads, stores, when the ARC
   //  is in test mode, during LD/ST RAM DMI accesses or when there is 
   //  a registered load that is waiting to return. The test mode is 
   //  always disabled during normal operation and only enabled during 
   //  ATPG generation and during production test.
   // 
   //  This signal turns off the RAM when not in use to save power.
   //  Depending on the technology used this may cause delays on the 
   //  critical path. If this is the case and it is not acceptable, don't
   //  connect this signal to the LD/ST RAM instantiated below.
   // 
   assign i_ldst_ck_en_a = (((test_mode         == 1'b 1)  | 
                             (ldst_dmi_req      == 1'b 1)  | 
                             (i_stored_ld_rtn_r == 1'b 1) | 
                             (i_ldst_st_d == 1'b 1)) | 

                            (((dmp_mload    == 1'b 1) |
                              (dmp_mstore   == 1'b 1)) & 
                             (dmp_en3       == 1'b 1)  & 
                             (is_ldst_ram   == 1'b 1)  & 
                             (is_peripheral == 1'b 0))) ?
          LDST_CK_EN_ACTIVE : 

          ~LDST_CK_EN_ACTIVE;
 
// ====================== Interface to the LD/ST RAM =======================--
// 
   assign i_ldst_d_rd = ldst_dout;
   assign ldst_addr   = i_rldst_raddr_a;
   assign ldst_din    = i_ldst_d_wr_a;
   assign ldst_mask   = i_ldst_mask_a;
   assign ldst_wren   = i_ldst_wren_a;
   assign ldst_ck_en  = i_ldst_ck_en_a;
   assign stored_ld_rtn = i_stored_ld_rtn_r;

// ================= Instantiation of read/write buffers ===================--
// 
   //  Select the data from read stream and sign extend it if necessary.
   // 
   readsort U_readsort (   
          .d_in(i_ldst_d_rd),
          .addr(i_d_addr_r),
          .size(i_d_size_r),
          .sex(i_d_sex_r),
          .d_out(ldst_drd));

endmodule
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1998-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This version of the load/store queue has a two deep address queue
// for LOADS and STORES. It is capable of handling any combination of
// LOADS and STORES:
//
//  - 2 LOADS
//  - 2 STORES
//  - 1 LOAD followed by a STORE
//  - 1 STORE folowed by a LOAD
//   
// The addresses are stacked into the address queue regardless of
// whether it is a LOAD or STORE. This ensures that operations get sent
// to the the memory arbitrator in the correct order.
// 
// This also forms read/write data into the correct position in a 32 
// bit word and performs any sign extensions etc. It also generates an
// mwait signal (stall signal) to the ARC pipeline when the load/store
// queue cannot accept any further data.
// 
// The load/store queue only services loads (LD) or stores (ST) when 
// the data cache is disabled (or not in the build) or the .DI 
// extensions are used on the LD/ST instructions in the assembler code.
// Also the load/store queue does not service LD/ST instructions whose
// address is within the address ranges of the load/store RAM (if there
// is a load/store RAM in the build).
// 
// The memory arbitrator interface is fully BVCI compatible. BVCI
// stands for Basic Virtual Component Interface and is a standardised
// point to point protocol.
// 
// 
// L indicates a latched signal and U indicates a signal produced by
// logic.
//
// ======================== Inputs to this block ========================--
//
// clk_dmp          DMP clock domain.
//
// rst_a            U Global asynchronous reset signal.
//
// dmp_dwr[31:0]    U Load Store Write data. Data value to be stored to
//                  memory.
//
// dmp_en3          U Pipeline stage 3 enable. When this signal is true,
//                  a load or stor request will be serviced on the next
//                  clock edge.
//
// dmp_addr         U Load/store address connected to the DMP
//                  sub-modules (e.g. the load/store queue). The
//                  address can come from either the ARC pipeline or
//                  the debug interface depending on which module that
//                  is requesting to access memory.
//
// dmp_mload        U Load instruction indicator. When it is set either
//                  the ARC or the debug interface whish to load data
//                  from an address in the LD/ST memory space.
//
// dmp_mstore       U Store instruction indicator. When it is set either
//                  the ARC or the debug interface whish to store data
//                  to an address in the LD/ST memory space.
//
// dmp_nocache      U No cache signal. This is always set in debug
//                  access mode. In ARC access mode it is set to
//                  nocache. When the signal is set the load/store
//                  queue is servicing the load and store requests
//                  (unless they are within the address range of the
//                  LD/ST RAM).
//
// dmp_size         U Size of Transfer, connected to the DMP-submodules
//                  (e.g. the load/store queue). This is always cleared
//                  in debug mode. In ARC access mode it is controlled
//                  by the ARC pipeline.
//
// dmp_sex          U Sign extend signal connected to the DMP-submodules
//                  (e.g. the load/store queue). It is always cleared in
//                  debug mode. In ARC access mode it is controlled from
//                  the ARC pipeline.
//
// q_rdata          U Read Data. Response data (q_rdata) is the 
//                  data that is returned by the target (mem_arbitrator)
//                  to the initiator (ld/st_q) when the ld/st_q
//                  initiates a read-operation. This is a BVCI signal
//                  (read the header for information on BVCI).
//              
// lram_base        U Base address for the LD/ST RAM. The address of a
//                  memory request (dmp_addr) is compared to this
//                  auxiliary register (lram_base) in order to generate
//                  the signal is_local_ram.
//
// dc_disable_r     L The DC flag (dc_disable_r) is always set if there
//                  is no data cache in the build. If there is a data
//                  cache in the build this flag can be set from a
//                  program using LR/SR instructions. When the data
//                  cache is disabled the load/store queue will service
//                  the load and store requests (unless they are within
//                  the address range of the LD/ST RAM).
//
// q_rspack         U Response acknowledge is asserted by the 
//                  load/store queue when it is ready to receive 
//                  responses from the memory arbitrator. This signal 
//                  is permanently set as the load/store queue is always
//                  ready to recieve responses. This is a BVCI signal 
//                  (read the header for information on BVCI).
//
// q_rspval         U Response valid (q_rspval) indicates that the
//                  memory arbitrator has a valid response available.
//                  This valid response can either be returning read
//                  data or a data acknowledgement of a write data
//                  transfer. The response is transferred when q_rspval
//                  and the response acknowledgement signal q_rspack
//                  are set (q_rspack is always set). This is a BVCI 
//                  signal (read the header for information on BVCI).
//
// q_cmdack         U Command acknowledge is asserted by the memory
//                  arbitrator when a load or store command from the
//                  load/store queue has been acknowledged.
//
// q_reop           U Response end of packet is asserted by the
//                  memory arbitrator on the last cycle of a response
//                  burst. As the load/store queue never issues
//                  bursts this signal is is set whenever the valid
//                  response signal q_rspval is set. This is a BVCI
//                  signal (read the header for information on BVCI).
//
// ====================== Outputs from this block =======================--
//
// a_pc_en          U Enable for the first bank of latches for the LD
//                  queue. These latches are updated with the value of
//                  the PC of the instruction which requested each read
//                  memory transaction.
//
// b_pc_en          U Enable for the second bank of latches for the LD
//                  queue. These latches are updated with the value of
//                  the PC of the instruction which requested each read
//                  memory transaction.
//
// sel_dat          L Select the correct bank of latches for the LD/ST
//                  queue.
//
// q_drd            U Load data return bus from the load/store queue to
//                  the processor.
//
// q_ldvalid        U This signal is set when read data bus q_drd
//                  contains valid data. This signal is fed back to the
//                  processor.
//
// q_mwait          U Wait. This signal is set true by this module in
//                  order to hold up stages 1, 2, and 3 of the
//                  processor. It is used when the load/store queue
//                  cannot service a request for a memory access.
//
// q_busy           U This signal is true when there is a memory request
//                  in the queue that has not been serviced yet. It is
//                  used to generate the Data Memory Pipeline idle
//                  signal (dmp_idle) in the load return arbitrator.
//
// cgm_queue_idle   Set true when the DMP is idle and can it's clocks
//                  can be gated to save power.
//
// is_local_ram     This signal is true when the address (dmp_addr) is
//                  within the address range of the load/store RAM or 
//                  the code RAM.
// 
// is_peripheral    This signal is true when the address (dmp_addr) is
//                  within the address range of the peripherals.
// 
// q_address        U This address is issued by the load/store queue
//                  when it issues a request to the memory arbitrator.
//                  This is a BVCI signal (read the header for
//                  information on BVCI).
//
// q_eop            U End of packet (q_eop) is asserted on the last
//                  cycle of every burst request. As the load/store
//                  queue never request bursts, it is always asserted on
//                  requests. This is a BVCI signal (read the header for
//                  information on BVCI).
//
// q_plen           U BVCI packet length signal
//
// q_wdata[31:0]    L This is the write data issued by the load/store 
//                  to the memory arbitrator during a write command. 
//                  The actual data bits that are enabled during a 
//                  given cell transfer are defined by the byte enables
//                  (q_be). This is a BVCI signal (read the header for
//                  information on BVCI).
//
// q_be[3:0]        U These are the byte enables. They indicate to the
//                  memory arbitrator which bytes of the write data 
//                  are enabled. This is a BVCI signal (read the
//                  header for information on BVCI).
//                 
// q_cmd[1:0]       U This is the command bus, which defines whether
//                  a read/write operation is being requested by the
//                  load/store queue.
//
//                  The encoding is as follows according to the BVCI
//                  standard:
//
//                  01 = Read
//                  10 = Write
//                  11 = Locked read.  Optional, not supported here.
//                  00 = No operation. Optional, not supported here.
//
//                  Only the read and write operations are mandatory
//                  according to the BVCI standard. Only these two
//                  operation types are supported. Read the header for
//                  more information on BVCI.
//
// q_cmdval         U This is the request signal. When the load/store
//                  queue sets this signal it wants to perform a read
//                  or write operation depending on the value of q_cmd.
//                  The request is serviced when the command
//                  acknowledgement signal is set (q_cmdack). This is a
//                  BVCI signal (read the header for information on
//                  BVCI).
//
// q_rspack         L This is the response acknowledge signal that is
//                  used by the load/store queue to indicate to the
//                  memory arbitrator that it is prepared to receive a
//                  response. This will be permanently held high because
//                  the load/store queueu is always prepared to receive
//                  a response.
//
// ======================================================================--
//
module ldst_queue (clk_dmp,
                   rst_a,
                   dmp_dwr,
                   dmp_en3,
                   dmp_addr,
                   dmp_mload,
                   dmp_mstore,
                   dmp_nocache,
                   dmp_size,
                   dmp_sex,
                   is_local_ram,
                   is_peripheral,
                   q_cmdack,
                   q_rdata,
                   q_reop,
                   q_rspval,
                   dc_disable_r,

                   a_pc_en,
                   b_pc_en,
                   sel_dat,
                   cgm_queue_idle,
		   sync_queue_idle,
                   q_drd,
                   q_ldvalid,
                   q_mwait,
                   q_busy,
                   q_address,
                   q_wdata,
                   q_be,
                   q_cmdval,
                   q_eop,
                   q_plen,
                   q_rspack,
	           q_cache,
	           q_priv,
	           q_buffer,
	           q_mode,
		   
                   q_cmd 
                   );

`include "ext_msb.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"

// system clock
   input          clk_dmp; 

// system reset
   input          rst_a; 

// Interface to the ARC
//
   input   [31:0] dmp_dwr; 
   input          dmp_en3; 
   input   [31:0] dmp_addr; 
   input          dmp_mload; 
   input          dmp_mstore; 
   input          dmp_nocache; 
   input   [1:0]  dmp_size; 
   input          dmp_sex;

// Address range matches
//
   input          is_local_ram; 
   input          is_peripheral;


// Interface to memory arbitrator
//
   input          q_cmdack; 
   input   [31:0] q_rdata;
   input          q_reop;
   input          q_rspval;

// Auxillary Registers 
//
   input          dc_disable_r;

// Interface to the ARC
//
   output         a_pc_en; 
   output         b_pc_en; 
   output         sel_dat; 

// Clock Gating
   output         cgm_queue_idle;
   output         sync_queue_idle;
   

// Load return arbitrator interface
//
   output  [31:0] q_drd; 
   output         q_ldvalid; 
   output         q_mwait; 
   output         q_busy;

// Interface to memory arbitrator
//
   output  [EXT_A_MSB:0] q_address;
   output  [31:0] q_wdata; 
   output  [3:0] q_be; 
   output         q_cmdval;
   output         q_eop;
   output  [8:0]  q_plen;
   output         q_rspack;
   output  [1:0]  q_cmd; 
   output         q_cache;
   output         q_priv;
   output         q_buffer;
   output         q_mode;

// Internal signals
//
   wire           a_pc_en; 
   wire           b_pc_en; 
   wire           sel_dat; 

   wire    [31:0] q_drd; 
   wire           q_ldvalid; 
   wire           q_mwait; 
   wire           q_busy; 
   wire           cgm_queue_idle;
   wire           sync_queue_idle;
   wire    [EXT_A_MSB:0] q_address;
   wire    [31:0] q_wdata; 
   reg     [3:0] q_be; 
   wire           q_cmdval;
   wire           q_eop;
   wire    [8:0]  q_plen;
   wire           q_rspack;
   wire    [1:0]  q_cmd; 
   wire           q_cache;
   wire           q_priv;
   wire           q_buffer;
   wire           q_mode;

// ------------------------------------------------------------------------
   reg            i_sel_dat_r; 

   wire    [31:0] i_dwr;
   reg     [1:0]  i_wdata_shift;
// ------------------------------------------------------------------------
   reg            i_a_full_r; 
   reg            i_a_next_r; 
   reg     [EXT_A_MSB:0] i_a_addr_r; 
   reg     [1:0]  i_a_size_r; 
   reg            i_a_sex_r; 
   reg            i_a_load_r; 
   reg     [31:0] i_a_wdata_r;

// ------------------------------------------------------------------------
   reg            i_b_full_r; 
   reg            i_b_next_r; 
   reg     [EXT_A_MSB:0] i_b_addr_r; 
   reg     [1:0]  i_b_size_r; 
   reg            i_b_sex_r; 
   reg            i_b_load_r; 
   reg     [31:0] i_b_wdata_r;

// ------------------------------------------------------------------------
   wire           i_alat_full; 

// ------------------------------------------------------------------------
   wire    [1:0]  i_addr; 
   wire    [1:0]  i_size; 
   wire           i_sex;
   reg     [8:0]  i_plen; 
   reg     [1:0]  i_sel_addr; 
   reg     [1:0]  i_sel_size; 
   reg            i_sel_sex; 

// ------------------------------------------------------------------------
   wire    [EXT_A_MSB:0] i_q_address; 
   reg            i_ls_rd_rq; 
   reg            i_ls_wr_rq; 
   wire           is_queue; 
   wire           i_q_ldvalid;
   wire           i_queue_idle;

// ------------------------------------------------------------------------
   reg     [1:0]  i_fifo_addr0_r;
   reg     [1:0]  i_fifo_addr1_r;
   reg     [1:0]  i_fifo_size0_r;
   reg     [1:0]  i_fifo_size1_r;
   reg            i_fifo_sex0_r;
   reg            i_fifo_sex1_r;
   reg            i_fifo_valid0_r;
   reg            i_fifo_valid1_r;
   reg            i_fifo_store0_r;
   reg            i_fifo_store1_r;
   wire           i_st_response;

   reg     [1:0]  i_fifo_addr2_r;
   reg     [1:0]  i_fifo_addr3_r;
   reg     [1:0]  i_fifo_size2_r;
   reg     [1:0]  i_fifo_size3_r;
   reg            i_fifo_sex2_r;
   reg            i_fifo_sex3_r;
   reg            i_fifo_valid2_r;
   reg            i_fifo_valid3_r;
   reg            i_fifo_store2_r;
   reg            i_fifo_store3_r;

   assign          q_cache  = LDSTQ_AHB_CACHEABLE;
   assign          q_priv   = 1'b1;
   assign          q_buffer = LDSTQ_AHB_BUFFERABLE;
   assign          q_mode   = 1'b1;

// ============================== is_queue ==============================--
// 
//  The signal is_queue is set when the load/store queue should
//  service the load/store request from the ARC pipeline or the debug
//  interface.
//
//  If the address (dmp_addr) is not within the address range of the
//  LD/ST RAM (is_local_ram = '0') and the data cache is either
//  disabled or the .DI extensions are used, then the load/store
//  queue should service the request.
//   
assign is_queue = ((( dmp_nocache == 1'b 1 ) | ( dc_disable_r == 1'b 1 )) & 
                  ( is_local_ram == 1'b 0 ) & 
                  ( is_peripheral == 1'b 0 )) ? 1'b 1 : 
    1'b 0; 

// Pre-process write data (if on critical path might need to post-process
// after the buffering).
//
 always @(dmp_addr)
    begin : WRITE_SHIFT_CALC_PROC
  // Little-endian shift = long word byte-offset
  i_wdata_shift = dmp_addr[1:0];  
   end 
 // ------------------------------------------------------------------------
//  Write data generation
// 
//  The write data is sorted to ensure it lines up with the correct
//  position in the output word. This happens at the same time as the
//  store request from the processor is stored in the load/store
//  queue. On the following cycle the store request may be issued to
//  the memory arbitrator with the sorted write data available at the
//  same time. Sorting of the write data is generated
//  synchronously.
// 
assign i_dwr = (i_wdata_shift == BYTE1) ? {dmp_dwr[23:0], dmp_dwr[31:24]} :
               (i_wdata_shift == BYTE2) ? {dmp_dwr[15:0], dmp_dwr[31:16]} :
               (i_wdata_shift == BYTE3) ? {dmp_dwr[7:0], dmp_dwr[31:8]} :
               dmp_dwr;

// ============================ Set-Up LD/ST Queue ======================--
// 
//  This process loads a data bank for an access to memory, and
//  provides the address, burst size, etc to the memory system
//  based upon signals from the ARC. There are banks of latches, i.e.
//  bank 'a' and 'b'.
// 
//  It also determines when the controller should wait, i.e. during
//  a pending memory access.
// 
always @(posedge clk_dmp or posedge rst_a)
   begin : LOAD_DATA_BANKS_PROC
   if (rst_a == 1'b 1)
      begin
      i_a_full_r  <= 1'b 0;  
      i_a_load_r  <= 1'b 1;  
      i_a_sex_r   <= 1'b 0;   
      i_a_size_r  <= {2{1'b 0}}; 
      i_a_addr_r  <= {(EXT_A_MSB + 1){1'b 0}};   
      i_a_wdata_r <= 32'b 0;
      i_b_full_r  <= 1'b 0;  
      i_b_load_r  <= 1'b 0;  
      i_b_sex_r   <= 1'b 0;   
      i_b_size_r  <= {2{1'b 0}}; 
      i_b_addr_r  <= {(EXT_A_MSB + 1){1'b 0}};   
      i_b_wdata_r <= 32'b 0;
      i_a_next_r  <= 1'b 1;  
      i_b_next_r  <= 1'b 0;  
      i_sel_dat_r <= 1'b 0; 
      end
   else
      begin

      if ((( i_ls_rd_rq == 1'b 1 ) | ( i_ls_wr_rq == 1'b 1 )) &
         ( q_cmdack == 1'b 1 ))
         begin
           
         //  Once a bank has been reset invert the select data signal
         //  so that upon the next access the appropriate data is
         //  selected.
         //             
         i_sel_dat_r <= ~i_sel_dat_r;   
         end

      //  The appropriate bank of latches holding the appropriate 
      //  information upon the request, e.g. address, size, etc, are
      //  updated when the following conditions are met:
      // 
      //   [1] There is a load requested or a store has been requested
      //       and the queue is full,
      //   &
      //   [2] Stage 3 is enabled,
      //   &
      //   [3] The local LD/ST RAM is not being accessed.
      // 
      if ((( dmp_mload == 1'b 1 ) | ( dmp_mstore == 1'b 1 )) & 
            ( dmp_en3 == 1'b 1 ) & ( is_queue == 1'b 1 ))
         begin

         //  Bank 'a' is updated when this bank is empty, and a
         //  request for a memory transaction has completed when the
         //  current bank is full.
         //
         if (( i_a_next_r == 1'b 1 ) & (( i_a_full_r == 1'b 0 ) | 
         (( i_a_full_r == 1'b 1 ) & ((( i_ls_wr_rq == 1'b 1 ) | 
         ( i_ls_rd_rq == 1'b 1 )) & ( q_cmdack == 1'b 1 )))))

            begin
            i_a_addr_r <= dmp_addr[EXT_A_MSB:0];    
            i_a_size_r <= dmp_size; 
            i_a_sex_r  <= dmp_sex;  
            i_a_load_r <= dmp_mload;    
            i_a_wdata_r <= i_dwr;
            i_a_full_r <= 1'b 1;    
            i_a_next_r <= 1'b 0;    
            i_b_next_r <= 1'b 1;    

            if ((( i_ls_rd_rq == 1'b 1 ) | ( i_ls_wr_rq == 1'b 1 )) &
                (q_cmdack == 1'b 1)                         &
                (i_sel_dat_r == 1'b 1))
              begin
              i_b_full_r <= 1'b 0;    
              end

            end

         //  Bank 'b' is updated when this bank is empty, and a
         //  request for a memory transaction has completed when
         //  the current bank is full.
         // 
         else if (( i_b_next_r == 1'b 1 ) & (( i_b_full_r == 1'b 0 ) | 
                 (( i_b_full_r == 1'b 1 ) & ((( i_ls_rd_rq == 1'b 1 ) |
                 ( i_ls_wr_rq == 1'b 1 )) & ( q_cmdack == 1'b 1 )))))
            begin
            i_b_addr_r <= dmp_addr[EXT_A_MSB:0];    
            i_b_size_r <= dmp_size; 
            i_b_sex_r  <= dmp_sex;  
            i_b_load_r <= dmp_mload;    
            i_b_wdata_r <= i_dwr;
            i_b_full_r <= 1'b 1;    
            i_b_next_r <= 1'b 0;    
            i_a_next_r <= 1'b 1;

            if ((( i_ls_rd_rq == 1'b 1 ) | ( i_ls_wr_rq == 1'b 1 )) &
                (q_cmdack == 1'b 1)                         &
                (i_sel_dat_r == 1'b 0))
              begin
              i_a_full_r <= 1'b 0;    
              end

            end
         
     else if ((( i_ls_rd_rq == 1'b 1 ) | ( i_ls_wr_rq == 1'b 1 )) &
                 ( q_cmdack == 1'b 1 ))
           begin

           if (i_sel_dat_r == 1'b 0)
             begin
             i_a_full_r <= 1'b 0;    
             end
           else
             begin
             i_b_full_r <= 1'b 0;
             end
           end
     
         end

      // When a request has been acknowledged then one of the
      // banks is assumed to be ready for use. The 'i_sel_dat_r'
      // signal determines which of the two banks are to be
      // reset.
      //
      else if ((( i_ls_rd_rq == 1'b 1 ) | ( i_ls_wr_rq == 1'b 1 )) &
                 ( q_cmdack == 1'b 1 ))
         begin

          if (i_sel_dat_r == 1'b 0)
            begin
            i_a_full_r <= 1'b 0;    
            end
         else
            begin
            i_b_full_r <= 1'b 0;
            end
         end
      end
   end

//  This signal is true when both latch banks are full. 
// 
assign i_alat_full = ((i_a_next_r & i_a_full_r) | 
                     (i_b_next_r & i_b_full_r)) &
                     (~(i_ls_rd_rq & q_cmdack))   &
                     (~(i_ls_wr_rq & q_cmdack));

// =============================== MWAIT ================================--
// 
//  This signal is set true by this module in order to hold up stages
//  1, 2, and 3. It is used when the load/store queue cannot service
//  a request for a memory access. It will be produced from dmp_mload,
//  dmp_mstore and logic internal to the load/store queue.

assign q_mwait = ((dmp_mload | dmp_mstore) == 1'b 1 ) & 
                 ( i_alat_full == 1'b 1 ) & 
                 ((dmp_nocache | dc_disable_r) == 1'b 1 ) ? 1'b 1 : 

    1'b 0; 

// ============================ LD/ST Request ===========================--
// 
//  Here the read/write request signals to the memory arbitrator are
//  set depending upon the memory transaction. Depending on the
//  signal i_sel_dat_r the operation in either bank A or B is
//  performed, but only if this bank is full (indicated by
//  i_a_full_r and i_b_full_r).
// 
//  Both read and write operations generate responses. It is not
//  possible to detect whether it is a read or write response by
//  reading the BVCI interface signals so the load/store queue must
//  remember if it issued a read or write request. All responses
//  return in the same order they were requested. The load/store
//  queue can remember 3 outstanding requests in a dedicated FIFO. 
//  The signal i_fifo_valid1_r is set when the FIFO is full. If set,
//  then the load/store queue stops issueing more requests.
// 
always @(i_a_load_r or 
         i_a_full_r or 
         i_b_load_r or 
         i_b_full_r or 
         i_sel_dat_r or
         i_fifo_valid3_r)

   begin : REQUEST_RD_PROC

   if (( i_sel_dat_r == 1'b 0 ) & 
       ( i_a_full_r == 1'b 1 ) & 
       ( i_fifo_valid3_r == 1'b 0 ))
      begin
      i_ls_rd_rq = i_a_load_r;     
      end

   else if (( i_sel_dat_r == 1'b 1 ) & 
           ( i_b_full_r == 1'b 1 ) & 
           ( i_fifo_valid3_r == 1'b 0 ))
      begin
      i_ls_rd_rq = i_b_load_r;    
      end

   else
      begin
      i_ls_rd_rq = 1'b 0;    
      end
   end
   
// Performing the write request to memory.
//
always @(i_a_load_r or 
         i_a_full_r or 
         i_b_load_r or 
         i_b_full_r or 
         i_sel_dat_r or
         i_fifo_valid3_r)

   begin : REQUEST_WR_PROC

   if (( i_sel_dat_r == 1'b 0 ) & 
       ( i_a_full_r == 1'b 1 ) & 
       ( i_fifo_valid3_r == 1'b 0 ))
      begin 
      i_ls_wr_rq = ~i_a_load_r;    
      end

   else if (( i_sel_dat_r == 1'b 1 ) & 
           ( i_b_full_r == 1'b 1 ) & 
           ( i_fifo_valid3_r == 1'b 0 ))
      begin 
      i_ls_wr_rq = ~i_b_load_r;    
      end

   else
      begin  
      i_ls_wr_rq = 1'b 0;  
      end
   end

//  The command signal q_cmd is generated by concatenating the two
//  internal signals for read and write requests. The command
//  valid signal q_cmdval is set when there is either a read or write
//  request. The End Of Packet signal q_eop is set when q_cmdval 
//  is set, because the load/store queue never issues burst requests.
// 
  assign q_cmd    = {i_ls_wr_rq, i_ls_rd_rq};
  assign q_cmdval = i_ls_wr_rq | i_ls_rd_rq;
  assign q_eop    = i_ls_wr_rq | i_ls_rd_rq;

//  The response acknowledge signal is permanently set to indicate
//  that it is always ready to receive responses from the memory
//  arbitrator.
//  
  assign q_rspack = 1'b 1;

//  This FIFO keeps track of requests that has been acknowledged by
//  the memory arbitrator, but where the response has not yet come
//  back. The FIFO can keep track of up to 2 outstanding requests
//  of any type (i.e. either read or write requests).
//
//  The FIFO stores the following information about each outstanding
//  request:
//
//        --------------------------------------------------   
//     1. Whether it is a store or a load (i_fifo_store0_r).
//        --------------------------------------------------   
//        This information is used to filter out write
//        responses (q_rspval), so that they are not sent back
//        to the processor as read returns (q_ldvalid).
//
//        --------------------------------------------------   
//     2. The two lower address bits (i_fifo_addr0_r), 
//        The sign extend information (i_fifo_sex0_r),
//        The size information (i_fifo_size0_r),
//        --------------------------------------------------   
//        This information is only used for read responses. The
//        memory arbitrator interface always returns a long word.
//        For byte and word access as well as sign extension, the
//        load/store queue needs to process the returning data.
//
//  Each FIFO item is valid when the valid bit is set 
//  (e.g. i_fifo_valid0_r).
//
always @(posedge clk_dmp or posedge rst_a)
   begin : RESPONSE_FIFO_PROC
   if (rst_a == 1'b 1)
      begin
      i_fifo_addr0_r  <= {2{1'b 0}};
      i_fifo_addr1_r  <= {2{1'b 0}};
      i_fifo_addr2_r  <= {2{1'b 0}};
      i_fifo_addr3_r  <= {2{1'b 0}};
      i_fifo_size0_r  <= {2{1'b 0}};
      i_fifo_size1_r  <= {2{1'b 0}};
      i_fifo_size2_r  <= {2{1'b 0}};
      i_fifo_size3_r  <= {2{1'b 0}};
      i_fifo_sex0_r   <= 1'b 0;
      i_fifo_sex1_r   <= 1'b 0;
      i_fifo_sex2_r   <= 1'b 0;
      i_fifo_sex3_r   <= 1'b 0;
      i_fifo_valid0_r <= 1'b 0;
      i_fifo_valid1_r <= 1'b 0;
      i_fifo_valid2_r <= 1'b 0;
      i_fifo_valid3_r <= 1'b 0;
      i_fifo_store0_r <= 1'b 0;
      i_fifo_store1_r <= 1'b 0;
      i_fifo_store2_r <= 1'b 0;
      i_fifo_store3_r <= 1'b 0;
      end
   else
      //  Add a new outstanding request to the fifo
      //
      begin
      if ((( i_ls_wr_rq == 1'b 1 ) | ( i_ls_rd_rq == 1'b 1 )) &
         ( q_cmdack == 1'b 1 ))

          //  Simultaneous response
          //
          begin
          if (( q_rspval == 1'b 1 ) & ( i_fifo_valid0_r == 1'b 1 ))
             begin
             if (i_fifo_valid1_r == 1'b 0)
            // Only stage 0 valid, stage 0 takes new data.
                begin
                i_fifo_valid0_r <= 1'b 1;
                i_fifo_store0_r <= i_ls_wr_rq;
                i_fifo_addr0_r  <= i_addr;
                i_fifo_size0_r  <= i_size;
                i_fifo_sex0_r   <= i_sex;
                end

             else if (i_fifo_valid2_r == 1'b 0)
               begin
        // Stages 0 and 1 valid, shuffle stage 1 data into 0 and
        // put new input data into stage 1.
                i_fifo_valid0_r <= i_fifo_valid1_r;
                i_fifo_store0_r <= i_fifo_store1_r;
                i_fifo_addr0_r  <= i_fifo_addr1_r;
                i_fifo_size0_r  <= i_fifo_size1_r;
                i_fifo_sex0_r   <= i_fifo_sex1_r;

                i_fifo_valid1_r <= 1'b 1;
                i_fifo_store1_r <= i_ls_wr_rq;
                i_fifo_addr1_r  <= i_addr;
                i_fifo_size1_r  <= i_size;
                i_fifo_sex1_r   <= i_sex;
                end

             else if (i_fifo_valid3_r == 1'b 0)
                begin
                i_fifo_valid0_r <= i_fifo_valid1_r;
                i_fifo_store0_r <= i_fifo_store1_r;
                i_fifo_addr0_r  <= i_fifo_addr1_r;
                i_fifo_size0_r  <= i_fifo_size1_r;
                i_fifo_sex0_r   <= i_fifo_sex1_r;

                i_fifo_valid1_r <= i_fifo_valid2_r;
                i_fifo_store1_r <= i_fifo_store2_r;
                i_fifo_addr1_r  <= i_fifo_addr2_r;
                i_fifo_size1_r  <= i_fifo_size2_r;
                i_fifo_sex1_r   <= i_fifo_sex2_r;

                i_fifo_valid2_r <= 1'b 1;
                i_fifo_store2_r <= i_ls_wr_rq;
                i_fifo_addr2_r  <= i_addr;
                i_fifo_size2_r  <= i_size;
                i_fifo_sex2_r   <= i_sex;
                end

             else if (i_fifo_valid3_r == 1'b 1)
                begin
                i_fifo_valid0_r <= i_fifo_valid1_r;
                i_fifo_store0_r <= i_fifo_store1_r;
                i_fifo_addr0_r  <= i_fifo_addr1_r;
                i_fifo_size0_r  <= i_fifo_size1_r;
                i_fifo_sex0_r   <= i_fifo_sex1_r;

                i_fifo_valid1_r <= i_fifo_valid2_r;
                i_fifo_store1_r <= i_fifo_store2_r;
                i_fifo_addr1_r  <= i_fifo_addr2_r;
                i_fifo_size1_r  <= i_fifo_size2_r;
                i_fifo_sex1_r   <= i_fifo_sex2_r;

                i_fifo_valid2_r <= i_fifo_valid3_r;
                i_fifo_store2_r <= i_fifo_store3_r;
                i_fifo_addr2_r  <= i_fifo_addr3_r;
                i_fifo_size2_r  <= i_fifo_size3_r;
                i_fifo_sex2_r   <= i_fifo_sex3_r;

                i_fifo_valid3_r <= 1'b 1;
                i_fifo_store3_r <= i_ls_wr_rq;
                i_fifo_addr3_r  <= i_addr;
                i_fifo_size3_r  <= i_size;
                i_fifo_sex3_r   <= i_sex;
                end

             end

          //  No simultaneous response
          //
          else if (q_rspval == 1'b 0)
             begin
               
             if (i_fifo_valid0_r == 1'b 0)
            // FIFO is empty, fill stage 0
                begin
                i_fifo_valid0_r <= 1'b 1;
                i_fifo_store0_r <= i_ls_wr_rq;
                i_fifo_addr0_r  <= i_addr;
                i_fifo_size0_r  <= i_size;
                i_fifo_sex0_r   <= i_sex;
                end

             else if (i_fifo_valid1_r == 1'b 0)
            // Stage 0 full , fill stage 1.
                begin
                i_fifo_valid1_r <= 1'b 1;
                i_fifo_store1_r <= i_ls_wr_rq;
                i_fifo_addr1_r  <= i_addr;
                i_fifo_size1_r  <= i_size;
                i_fifo_sex1_r   <= i_sex;
                end
        
             else if (i_fifo_valid2_r == 1'b 0)
                begin
                i_fifo_valid2_r <= 1'b 1;
                i_fifo_store2_r <= i_ls_wr_rq;
                i_fifo_addr2_r  <= i_addr;
                i_fifo_size2_r  <= i_size;
                i_fifo_sex2_r   <= i_sex;
                end

             else if (i_fifo_valid3_r == 1'b 0)
                begin
                i_fifo_valid3_r <= 1'b 1;
                i_fifo_store3_r <= i_ls_wr_rq;
                i_fifo_addr3_r  <= i_addr;
                i_fifo_size3_r  <= i_size;
                i_fifo_sex3_r   <= i_sex;
                end
             end
          end

       //  Pop oldest item in fifo as a response is coming back.
       //  No request is added to the fifo in this case.
       //
       else if (( q_rspval == 1'b 1 ) & ( i_fifo_valid0_r == 1'b 1 ))
          begin
          i_fifo_valid0_r <= i_fifo_valid1_r;
          i_fifo_store0_r <= i_fifo_store1_r;
          i_fifo_addr0_r  <= i_fifo_addr1_r;
          i_fifo_size0_r  <= i_fifo_size1_r;
          i_fifo_sex0_r   <= i_fifo_sex1_r;

          i_fifo_valid1_r <= i_fifo_valid2_r;
          i_fifo_store1_r <= i_fifo_store2_r;
          i_fifo_addr1_r  <= i_fifo_addr2_r;
          i_fifo_size1_r  <= i_fifo_size2_r;
          i_fifo_sex1_r   <= i_fifo_sex2_r;

          i_fifo_valid2_r <= i_fifo_valid3_r;
          i_fifo_store2_r <= i_fifo_store3_r;
          i_fifo_addr2_r  <= i_fifo_addr3_r;
          i_fifo_size2_r  <= i_fifo_size3_r;
          i_fifo_sex2_r   <= i_fifo_sex3_r;

          i_fifo_valid3_r <= 1'b 0;
          end
      end
   end

// ================== Load Return from the LD/ST queue ==================--
// 
//  The signal i_q_ldvalid is set when a read response is returning.
//  It indicates that the return data bus q_drd contains valid read
//  data. The difference between i_q_ldvalid and q_rspval is that the
//  write responses have been filtered out by using the signal
//  i_st_reponse, which in turn is set when a store response occurs.
// 
assign i_st_response = (i_fifo_valid0_r & i_fifo_store0_r) |
                       ((~i_fifo_valid0_r) & i_ls_wr_rq);

assign i_q_ldvalid = 
                     (q_rspval &  ~i_st_response) 
                     ;

// ======================= Set LD/ST Parameters =========================--
// 
//  Select which bank that contains the data related to the current
//  request.
// 
assign i_addr = ( i_sel_dat_r == 1'b 1 ) ? i_b_addr_r[1:0] : 
    i_a_addr_r[1:0]; 

assign i_size = ( i_sel_dat_r == 1'b 1 ) ? i_b_size_r : 
    i_a_size_r; 

assign i_sex = ( i_sel_dat_r == 1'b 1 ) ? i_b_sex_r : 
    i_a_sex_r; 
 
// ========================= PLEN generation ============================--
//
// generate appropriate PLEN based on the size of transfer
//
always @ ( i_size or i_addr )
   begin : Q_PLEN_PROC
       case (i_size)
         LDST_BYTE : begin
                        i_plen = 9'b 000000001;
                     end // 1 byte
         LDST_WORD : begin
                        i_plen = 9'b 000000010;
                     end // 2 byte
         default   : begin
                        //i_plen = 9'b 000000100;
                        case (i_addr)            
                        BYTE0:                   
                          i_plen = 9'b 000000100;    
                        BYTE1:                   
                          i_plen = 9'b 000000001;    
                        BYTE2:                   
                          i_plen = 9'b 000000010;    
                        default:                 
                          i_plen = 9'b 000000001;    
                        endcase                  
                     end // 4 byte
       endcase
   end

assign q_plen = i_plen;
 
// =========================== Address Selection ========================--
// 
//  Select the correct buffer for the external memory requests.
// 
assign i_q_address[EXT_A_MSB: 0] = ( i_sel_dat_r == 1'b 1 ) ?
   
           i_b_addr_r[EXT_A_MSB:0]:
           i_a_addr_r[EXT_A_MSB:0];

assign q_address = i_q_address;

// ================ Instantiation of Read/Write Buffers =================--
//
//  Select the data needed to process the read response. This data 
//  is stored either in the response FIFO (when i_fifo_valid0_r is 
//  set) or in the request banks.
// 
always @(i_addr or 
         i_size or 
         i_sex  or 
         i_fifo_addr0_r or
         i_fifo_size0_r or 
         i_fifo_sex0_r or
         i_fifo_valid0_r)

   begin : SORT_SELECT_PROC

   if (i_fifo_valid0_r == 1'b 1)
      begin
      i_sel_addr = i_fifo_addr0_r; 
      i_sel_size = i_fifo_size0_r; 
      i_sel_sex  = i_fifo_sex0_r;
      end
   else
      begin
      i_sel_addr = i_addr; 
      i_sel_size = i_size; 
      i_sel_sex  = i_sex;
      end
   end

//  Process the returning data. This is necessary for byte and word
//  reads as well as sign extension.
//
readsort U_readsort (.d_in(q_rdata), 
                     .addr(i_sel_addr),
                     .size(i_sel_size),
                     .sex(i_sel_sex),

                     .d_out(q_drd));
   
//  The write data is sorted to ensure it lines up with the correct
//  position in the output word, and the appropriate byte read/write
//  controls are asserted. But only if the store request (dmp_mstore)
//  is going to be serviced by the load/store queue (is_queue = '1').
// 
assign q_wdata = ( i_sel_dat_r == 1'b 1 ) ? i_b_wdata_r : i_a_wdata_r;

// ------------------------------------------------------------------------
//  Mask calculation
// 
//  The mask is set asynchronously depending on the size of the
//  operation (byte, word or longword) and the position in the
//  longword.
// 
always @(i_addr or i_size)
begin : MASKING_PROC
   case (i_size)
 
   LDST_BYTE:
   begin
     case (i_addr)
     BYTE0:
       q_be = BYTE0_MASK;    
     BYTE1:
       q_be = BYTE1_MASK;    
     BYTE2:
       q_be = BYTE2_MASK;    
     default:
       q_be = BYTE3_MASK;    
     endcase
   end
    
   LDST_WORD:
     begin
     if (i_addr[1] == 1'b 0)
       q_be = WORD0_MASK;    
     else
       q_be = WORD1_MASK;    
     end

   //  Longword
   // 
   default:
     q_be = LONG_MASK;    
   endcase
end

// =========================== PC Tracking ==============================--
// 
//  PC tracking enables for Actionpoint Debugging system
// 
//  There are 2 banks of latches for the LD queue which are updated with
//  the value of the PC of the instruction which requested each read
//  memory transaction.
// 
//  The first bank of latches is updated with new value of
//  the PC when it obeys the following criterion:
// 
//  [1] It is ready for use,
//  [2] It is not full,
//  [3] It is full, but the memory transaction has just been
//      serviced

assign a_pc_en = 

           (( i_a_next_r == 1'b 1 ) & (( i_a_full_r == 1'b 0 ) | 
           (( i_a_full_r == 1'b 1 ) & ((( i_ls_rd_rq == 1'b 1 ) |
           ( i_ls_wr_rq == 1'b 1 )) & ( q_cmdack == 1'b 1 ))))) ? 1'b 1: 

    1'b 0;  

//  The second bank of latches is updated with new value of
//  the PC when it obeys the following criterion:
// 
//  [1] It is ready for use,
//  [2] It is not full,
//  [3] It is full, but the memory transaction has been
//      serviced (q_rspval),

assign b_pc_en = 

           (( i_b_next_r == 1'b 1 ) & (( i_b_full_r == 1'b 0 ) | 
           (( i_b_full_r == 1'b 1 ) & ((( i_ls_rd_rq == 1'b 1 ) | 
           ( i_ls_wr_rq == 1'b 1 )) & ( q_cmdack == 1'b 1 ))))) ? 1'b 1 : 
    1'b 0; 

// ============================= q_busy =================================--
// 
//  This signal is true when there is a memory request in the queue
//  that has not been serviced yet. The first condition is true when
//  both banks are full. The second condition is true when at least
//  one bank is full and the memory request has not yet been serviced.
//
assign q_busy = (( i_a_full_r == 1'b 1 ) & ( i_b_full_r == 1'b 1 )) | 
                ((( i_a_full_r == 1'b 1 ) | ( i_b_full_r == 1'b 1 )) & 
                (( i_ls_wr_rq == 1'b 0 ) | ( q_cmdack == 1'b 0 )) &
                (( i_ls_rd_rq == 1'b 0 ) | ( q_cmdack == 1'b 0 ))) ? 1'b 1 :
    1'b 0; 

// =========================== queue_idle ===============================--
// 
//  This isgnal is used for clock gating the DMP domain
//  when it's not in use.
//   
assign i_queue_idle = (// No outstanding memory requests in the queue.
                         ( q_busy == 1'b 0 ) &
                         // load/store queue can / has serviced all requests.
                         ( q_mwait == 1'b 0 ) &
                         // No loads to service.
                         ( dmp_mload == 1'b 0 ) &
                         // No stores to service.
                         ( dmp_mstore == 1'b 0 ) &
                         // Store has completed.
                         ( i_st_response == 1'b 0 )) ? 1'b 1 : 1'b 0;
  
assign cgm_queue_idle = ( 
                         i_queue_idle &
                         // No memory accesses in progress (bypassing the
                         // cache).
                         ( dmp_nocache == 1'b 0 )) ? 1'b 1 : 1'b 0;
			 
assign sync_queue_idle = i_queue_idle &
                         // No stores backed-up in the queue
                         (((i_fifo_valid0_r & i_fifo_store0_r) |
                           (i_fifo_valid1_r & i_fifo_store1_r) |
                           (i_fifo_valid2_r & i_fifo_store2_r) |
                           (i_fifo_valid3_r & i_fifo_store3_r)) == 1'b0);

// ============================= outputs ================================--


assign sel_dat         = i_sel_dat_r;
assign q_ldvalid       = i_q_ldvalid;			 

endmodule
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2000-2008 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// The memory alignment check module detects whether a non-naturall
// aligned load or store transaction from the ARC core has occured.
//
// L indicates a latched signal and U indicates a signal produced by
// logic.
// 
// ======================= Inputs to this block =======================--
// 
//  clk_dmp          DMP clock domain.
// 
//  rst_a            L Latched external reset signal. The rst_a signal is
//                   asynchronously applied and synchronously removed.
// 
//  en3              U Pipeline stage 3 enable. When this signal is true,
//                   the instruction in stage 3 can pass into stage 4 at
//                   the end of the cycle. When it is false, it will
//                   probably hold up stages one (pcen), two (en2), and
//                   three. It is also used to qualify mload & mstore.
// 
//  mc_addr[]        Load Store Address. The result of the adder unit. 
//                   This goes to LSU, to be latched by the memory
//                   controller. The address is valid when either mload 
//                   OR mstore is active.
// 
//  mload            U Load Data. This signal indicates to the LSU that
//                   there is a valid load instruction in stage 3. It is
//                   produced from a decode of p3i[4:0], p3iw(25) (to
//                   exclude LR) and the p3iv signal.
//  
//  mstore           U Store Data. This signal indicates to the LSU that
//                   there is a valid store instruction in stage 3. It is
//                   produced from a decode of p3i[4:0], p3iw(25) (to
//                   exclude SR) and the p3iv signal.
// 
//  size[1:0]        L Size of Transfer. This pair of signals are used to
//                   indicate to the LSU the size of the memory 
//                   transaction which is being requested by a LD or ST 
//                   instruction. It is produced during stage 2 and
//                   latched as the size information bits are encoded in 
//                   different places on the LD and ST instructions. It
//                   must be qualified by the mload/mstore signals as it
//                   does not include an opcode decode.
// 
//                   The encoding for the size of the transfer is as
//                   follows:
// 
//                       00 - Long word
//                       01 - byte
//                       10 - word
//                       11 - Reserved
//
//  en_misaligned    Enable the mis-alignment feature from the aux_regs.
//
// ====================== Outputs from this block =====================--
// 
//  misaligned_err   A single pulse asserted whenever a mis-aligned memory
//                   access to memory is detected
//
//  misaligned_int   A single pulse asserted whenever a mis-aligned memory
//                   access to memory is in detected and the feature is
//                   enabled.
//
// ====================================================================--
//
module mem_align_chk (clk_dmp,
   rst_a,
   en3,
   mc_addr,
   mload,
   mstore,
   size,
   en_misaligned,

   misaligned_int,
   misaligned_err);

`include "arcutil.v" 

input   clk_dmp; 
input   rst_a; 
input   en3; 
input   [31:0] mc_addr; 
input   mload; 
input   mstore; 
input   [1:0] size; 
input   en_misaligned; 

output   misaligned_int; 
output   misaligned_err; 

//  DMP interface
wire     i_misaligned_err_a; 
wire     i_misaligned_int_a; 

   // --------------------------------------------------------------
   //  Detect mis-aligned memory access from the ARC core
   // --------------------------------------------------------------
   //  during memory write or read (mload or mstore asserted during en3)
   //  the mc_addr bits are qualifed with the size bits to make sure
   //  word (16 bit) accesses are only to even addresses
   //  and dword (32 bit) access are only to quad address
   // 
   //  If a non-aligned access is detected, set the misaligned output bit

   assign i_misaligned_err_a = (mload || mstore) && en3 &&
                               (((size == LDST_LWORD) && (mc_addr[1:0] != 2'b00)) ||
                               ((size == LDST_WORD) && (mc_addr[0] != 1'b0)));

   //  Output signals used and generated in this module
   //

   assign misaligned_int  = i_misaligned_err_a && en_misaligned; 
   assign misaligned_err  = i_misaligned_err_a; 

endmodule

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2000-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// The Debug Access Unit allows access to the load/store memory space
// through the debug interface (i.e. the PC port or the JTAG port).
//
// L indicates a latched signal and U indicates a signal produced by
// logic.
// 
// ======================= Inputs to this block =======================--
// 
//  clk_dmp          DMP clock domain.
// 
//  rst_a            L Latched external reset signal. The rst_a signal is
//                   asynchronously applied and synchronously removed.
// 
//  en               L The global halt bit.
// 
//  pcp_wr_rq        U Debug interface write request. This is produced by
//                   the debug interface (PC/JTAG port). This signal is
//                   reset when the request has been acknowledged
//                   (pcp_ack ='1').
// 
//  pcp_rd_rq        U Debug interface read request. This is produced by
//                   the  debug interface (PC/JTAG port). This signal is
//                   reset when the request has been acknowledged
//                   (pcp_ack ='1').
// 
//  pcp_addr         U Debug interface address. The address to which the
//                   memory transaction is to take place and should be
//                   valid when the debug interface request signal is
//                   high. This address bus is 24 bits wide.
// 
//  pcp_d_wr         U Debug interface write data. The data must be valid
//                   when the write request is made (pcp_wr_rq = '1').
//   
//  dwr[31:0]        Load Store Write data. Data value to be stored to
//                   memory. It is latched stval from the ARC interface.
//                   The value is latched when en2='1', i.e. the pipeline
//                   is not stalled.
// 
//  en3              U Pipeline stage 3 enable. When this signal is true,
//                   the instruction in stage 3 can pass into stage 4 at
//                   the end of the cycle. When it is false, it will
//                   probably hold up stages one (pcen), two (en2), and
//                   three. It is also used to qualify mload & mstore.
// 
//  mc_addr[]        Load Store Address. The result of the adder unit. 
//                   This goes to LSU, to be latched by the memory
//                   controller. The address is valid when either mload 
//                   OR mstore is active.
// 
//  mload            U Load Data. This signal indicates to the LSU that
//                   there is a valid load instruction in stage 3. It is
//                   produced from a decode of p3i[4:0], p3iw(25) (to
//                   exclude LR) and the p3iv signal.
//  
//  mstore           U Store Data. This signal indicates to the LSU that
//                   there is a valid store instruction in stage 3. It is
//                   produced from a decode of p3i[4:0], p3iw(25) (to
//                   exclude SR) and the p3iv signal.
// 
//  nocache          L No Data Cache. This signal is used to indicate to
//                   the LSU whether the load/store operation is required
//                   to bypass the cache. It comes from bit 5 of the
//                   LD/ST control group which is found in different
//                   places in the LDO/LDR/ST instructions.
// 
//  sex              L Sign extend. This signal is used to indicate to
//                   the LSU whether a sign-extended load is required. It
//                   is produced during stage 2 and latched as the
//                   sign-extend bit in the two versions of the LD
//                   instruction (LDO/LDR) are in different places in the
//                   instruction word.
// 
//  size[1:0]        L Size of Transfer. This pair of signals are used to
//                   indicate to the LSU the size of the memory 
//                   transaction which is being requested by a LD or ST 
//                   instruction. It is produced during stage 2 and
//                   latched as the size information bits are encoded in 
//                   different places on the LD and ST instructions. It
//                   must be qualified by the mload/mstore signals as it
//                   does not include an opcode decode.
// 
//                   The encoding for the size of the transfer is as
//                   follows:
// 
//                       00 - Long word
//                       01 - byte
//                       10 - word
//                       11 - Reserved
// 
//  lpending         U Indicates to ARC that there is at least one load
//                   pending. It is the inverse of the empty flag from
//                   the scoreboard.
// 
//  max_one_lpend    L Indicates that the LSU contains zero or one
//                   pending load. It is generated from the inverse of
//                   the status flag of the second fifo item in the LSU.
//                   If the second fifo item is empty, then the LSU
//                   cannot contain more than at most one pending load.
//                   This signal is used by the DMP control logic.
// 
//  dmp_drd          Load return data. This is the 32 bit result of a
//                   load returned from any of the DMP sub-modules or a
//                   peripheral via the load return arbitrator.
// 
//  dmp_ldvalid      U Load data valid. This signal is set true when the
//                   load return data from the load return arbitrator
//                   (dmp_drd) is valid.
// 
//  mwait            U Wait. This signal is set true by a DMP sub-module
//                   or a peripheral in order to hold up stages 1, 2, and
//                   3. It is used when a DMP sub-module/peripheral
//                   cannot service a memory data request (LD/ST) in
//                   pipeline stage 3.
//
//  dmp_idle         U The DMP idle signal is set when all DMP
//                   sub-modules and peripherals are idle.
//   
// ====================== Outputs from this block =====================--
// 
// debug_if_r        Debug Memory Access. This is asserted true when a debug
//                   access to memory is in progress.
//
//  PC Port/JTAG Port interface
// 
//  pcp_d_rd         U Load return data. This is the 32 bit result of a
//                   load returned from any of the DMP sub-modules
//                   (except data-cache) or peripheral via the load
//                   return arbitrator. It comes as a result of a debug
//                   access read request (pcp_rd_rq = '1').
// 
//  pcp_ack          U Debug interface request acknowledge. This set
//                   to '1' for a single cycle to acknowledge the
//                   receipt of the request from the debug interface. On
//                   the cycle following the acknowledge being set the
//                   pcp_addr, pcp_wr_rq (or pcp_rd_rq) busses are no
//                   longer used by the arbitrator, hence the debug
//                   interface can therefore set up signals for the
//                   next request.
// 
//  pcp_dlat         U Load data valid for the debug interface. This
//                   signal is set true when the load return data from
//                   the load return arbitrator (pcp_d_rd) is valid.
// 
//  pcp_dak          L Write data acknowledge. This signal acknowledges
//                   the write data (pcp_d_wr). It is set in this file in
//                   debug access mode on the same cycle as the request
//                   acknowledge signal (pcp_ack).
//   
//  dmp_holdup12     U DMP hold signal for ARC pipeline stages 1-2. When
//                   the DMP receives a debug interface request this
//                   signal is set. It is used in the pipeline
//                   controller (rctl) to hold these pipeline stages if
//                   a load (LD) or store (ST) instruction enters
//                   pipeline stage 2. The reason for stalling is that 
//                   the DMP is busy servicing data memory accesses from
//                   the debug interface. However if the pipeline is
//                   free from LD/ST instructions it will continue to
//                   flow during debug access mode.
// 
//  drd              Load return data. This is the 32 bit result of a
//                   load returned from any of the DMP sub-modules or a
//                   peripheral via the load return arbitrator. This data
//                   bus is used in the ARC pipeline.
// 
//  ldvalid          U Load data valid. This signal is set true when the
//                   load return data from the load return arbitrator
//                   (drd) is valid. This signal is used in the ARC
//                   pipeline.
//  
//
//  dmp_dwr          Load Store Write data connected to the
//                   DMP/peripherals. In ARC access mode it is set to
//                   dwr and in debug access mode it is set to pcp_d_wr.
// 
//  dmp_en3          U Pipeline stage 3 enable signal connected to the
//                   DMP/peripherals. In ARC access mode it is set to
//                   en3 and in debug access mode it is high for one
//                   cycle.
// 
//  dmp_addr         Load/store address, connected to the DMP. It is set
//                   to mc_addr in ARC access mode and in debug access
//                   mode it is set to pcp_addr.
// 
//  dmp_mload        Load instruction indicator, connected to the DMP.
//                   It is set to mload in ARC access mode and to
//                   pcp_rd_rq in debug access mode.
// 
//  dmp_mstore       Store instruction indicator, connected to the DMP.
//                   It is set to mstore in ARC access mode and to
//                   pcp_wr_rq in debug access mode.
// 
//  dmp_nocache      No cache signal. This is always set in debug access
//                   mode. In ARC access mode it is set to nocache.
// 
//  dmp_sex          Sign extend signal connected to the DMP. This is
//                   always cleared in debug mode. In ARC access mode it
//                   is set to sex.
// 
//  dmp_size         Size of Transfer, connected to the DMP. This is
//                   always cleared in debug mode. In ARC access mode it
//                   is set to size.
// 
// ====================================================================--
//
module debug_access (clk_dmp,
   rst_a,
   en,
   pcp_wr_rq,
   pcp_rd_rq,
   pcp_addr,
   pcp_d_wr,
   is_local_ram,
   dwr,
   en3,
   mc_addr,
   mload,
   mstore,
   nocache,
   size,
   sex,
   lpending,
   max_one_lpend,
   dmp_drd,
   dmp_ldvalid,
   mwait,
   
   dmp_idle,
   debug_if_r,
   debug_if_a,
   pcp_d_rd,
   pcp_ack,
   pcp_dlat,
   pcp_dak,
   dmp_holdup12,
   drd,
   ldvalid,
   dmp_dwr,
   dmp_addr,
   dmp_mload,
   dmp_mstore,
   dmp_nocache,
   dmp_sex,
   dmp_size,
   dmp_en3);

`include "arcutil_pkg_defines.v" 
`include "arcutil.v" 
`include "extutil.v" 
`include "xdefs.v" 
`include "ext_msb.v"

input   clk_dmp; 
input   rst_a; 
input   en; 
input   pcp_wr_rq; 
input   pcp_rd_rq; 
input   is_local_ram; 
input   [EXT_A_MSB:0] pcp_addr;
input   [31:0] pcp_d_wr; 
input   [31:0] dwr; 
input   en3; 
input   [31:0] mc_addr; 
input   mload; 
input   mstore; 
input   nocache; 
input   [1:0] size; 
input   sex; 
input   lpending; 
input   max_one_lpend; 
input   [31:0] dmp_drd; 
input   dmp_ldvalid; 
input   mwait; 
input   dmp_idle; 

output   debug_if_r;
output   debug_if_a; 
output   [31:0] pcp_d_rd; 
output   pcp_ack; 
output   pcp_dlat; 
output   pcp_dak; 
output   dmp_holdup12; 
output   [31:0] drd; 
output   ldvalid; 
output   [31:0] dmp_dwr; 
output   [31:0] dmp_addr; 
output   dmp_mload; 
output   dmp_mstore; 
output   dmp_nocache; 
output   dmp_sex; 
output   [1:0] dmp_size; 
output   dmp_en3; 

wire    debug_if_r; 
reg     [31:0] pcp_d_rd; 
wire    pcp_ack; 
reg     pcp_dlat; 

//  ARC interface
wire    pcp_dak; 
wire    dmp_holdup12; 
reg     [31:0] drd; 

//  DMP interface
reg     ldvalid; 
reg     [31:0] dmp_dwr; 
reg     [31:0] dmp_addr; 
reg     dmp_mload; 
reg     dmp_mstore; 
reg     dmp_nocache; 
reg     dmp_sex; 
reg     [1:0] dmp_size; 
reg     dmp_en3; 

reg     i_debug_if_r; 
reg     i_pcp_ack_r; 
reg     i_pcp_dak_r; 
reg     do_access_r; 
wire    i_dmp_en3_a;
 
reg     dmp_lpending_r; 
wire    wait_for_ld; 
wire    is_host_access_local_ram; 
wire    debug_if_a; 
	


   // --------------------------------------------------------------
   //  Stall the ARC during debug access if it contains a LD/ST
   // --------------------------------------------------------------
   //  The signal dmp_holdup12 stalls pipeline stages 1-2 if there
   //  is a load (LD) or store (ST) in pipeline stage 2. This occurs
   //  when the debug interface is accessing the LD/ST memory space.
   //  The reason to stall pipeline stages 1-2 in this situation is
   //  that the Data Memory Pipeline (DMP) is busy servicing memory
   //  requests from the debug interface (i.e. PC Port or JTAG Port)
   //  and consequently no data memory request from the ARC can be
   //  serviced. Note that pipeline stage 1-2 are only stalled if
   //  pipeline stage 2 contains a LD or ST instruction. The ARC
   //  pipeline can continue to flow during debug access as long as
   //  it does not contain a LD or ST instruction.


   assign dmp_holdup12 = (pcp_rd_rq | pcp_wr_rq | i_debug_if_r); 

   // --------------------------------------------------------------
   //  Wait for pending loads
   // --------------------------------------------------------------
   //  Wait for all pending loads to complete (lpending = '1') with
   //  exception for one case. This exception occurs when there is a
   //  load in pipeline stage 3 and the ARC is halted. In this case
   //  the load has not yet been issued to the memory subsystem. The
   //  load will not complete until the pipeline is re-enabled.
   //  Conseqeuntly we cannot wait for it to complete as long as the
   //  ARC is halted. However the lpending signal is already set in
   //  pipeline stage 2. If the LSU contains only one pending load
   //  (max_one_lpend = '1' AND lpending = '1') and the ARC is
   //  halted (en = '0') and there is a load in pipeline stage 3,
   //  then we will not wait for the lpending signal to be cleared.

   assign wait_for_ld = ((lpending == 1'b 1) & 
                         (~((mload == 1'b 1) & 
                            (en == 1'b 0) & 
                            (max_one_lpend == 1'b 1)))) ? 
                        1'b 1 : 1'b 0; 

   // --------------------------------------------------------------
   //  Enter and exit the debug access mode
   // --------------------------------------------------------------
   //  When the debug interface (JTAG or PC port) requests to do a
   //  memory read (pcp_rd_rq = '1') or a memory write
   //  (pcp_wr_rq = '1') then pipeline stage 3, the DMP and the
   //  Load Scoreboard Unit (LSU) are checked before entering
   //  debug access mode. If there is a memory access to the data
   //  cache or load/store queue or peripheral (dmp_idle == '0') we
   //  wait for this to complete before entering debug access mode. 
   //  If there is no load or store in pipeline stage 3 (mload == '1'
   //  OR mstore == '1') or if the ARC is halted (en = '0') we don't
   //  wait for stage 3 to move on.
   // 
   //  We also wait for the DMP to be idle (dmp_idle = '1') and for
   //  all outstanding loads to complete (lpending = '0') before
   //  entering the debug access mode (i_debug_if_r = '1').
   // 
   //  We exit the debug access mode when there are no more requests
   //  (pcp_rd_rq = '0' AND pcp_wr_rq = '0) the DMP is idle
   //  (dmp_idle = '1') and there are no pending loads
   //  (dmp_lpending_r = '0'). Note that the ARC load pending signal
   //  (lpending) cannot be used when in debug mode because it is
   //  generated by the LSU which is not used during debug mode.

   always @(posedge clk_dmp or posedge rst_a)
     begin : debug_if_sync_PROC
        if (rst_a == 1'b 1)
          begin
             i_debug_if_r <= 1'b 0; 
          end
        else
          begin
             if (((pcp_rd_rq == 1'b 1) || (pcp_wr_rq == 1'b 1)) && 

                 (dmp_idle == 1'b 1) && 

		 
		
                 // ---------------------------------- //
                 // added condition to check for more  //
                 // than one pending loads in the LSU  //
                 // prior to giving access to the host //
                 // ---------------------------------- //

                 (wait_for_ld == 1'b 0) &&

                 (!(((mload == 1'b 1) || (mstore == 1'b 1)) &&
                   (en == 1'b 1)))) 
               begin
                  i_debug_if_r <= 1'b 1;    

               end
             else if ((pcp_rd_rq == 1'b 0) &&
                      (pcp_wr_rq == 1'b 0) && 
                      (dmp_idle  == 1'b 1) &&
                      (dmp_lpending_r == 1'b 0))
               begin
                  i_debug_if_r <= 1'b 0;    
               end
          end
     end // block: debug_if_proc

   assign is_host_access_local_ram  = (is_local_ram & pcp_wr_rq & i_debug_if_r);

   
   // --------------------------------------------------------------
   //  Servicing/acknowledging the request in debug mode
   // --------------------------------------------------------------
   //  When in debug mode (i_debug_if_r = '1') the Data Memory
   //  Pipeline (DMP) is told to service the incoming the
   //  request (i_dmp_en3_r = '1) on the same cycle as the
   //  request is acknowledged (i_pcp_ack_r = '1'). If the request
   //  is a write request the data is acknowledged on the same
   //  cycle as well. However all this only happens if no DMP
   //  sub-module is stalling incoming requests (mwait = '0'). 
   // 
   //  The cycle after all this has happened the debug
   //  interface can request a second access. If the debug
   //  interface does not request a second access the debug
   //  access will be closed (i_debug_if_r = '0') as soon as
   //  the DMP is idle and all loads have returned.

   always @(posedge clk_dmp or posedge rst_a)
     begin : serv_sync_PROC
        if (rst_a == 1'b 1)
          begin
             do_access_r <= 1'b 0;  
          end
        else
          begin

               //  Acknowledge the request (i_pcp_ack_r = '1') and tell
               //  If a write request has been issued then
               //  acknowledge the reception of the write data
               //
               if (((pcp_rd_rq == 1'b 1) | (pcp_wr_rq == 1'b 1)) & 
                  (i_debug_if_r == 1'b 1) & (i_dmp_en3_a == 1'b 0))
                 begin
                   do_access_r <= 1'b 1; 
                 end
              else if (i_dmp_en3_a == 1'b 1)
                 begin
                   do_access_r <= 1'b 0; 
                 end
	
          end
     end // block: serv_proc

   assign i_dmp_en3_a = do_access_r & !mwait;


   // --------------------------------------------------------------
   //  Access mode (either ARC or debug mode)
   // --------------------------------------------------------------
   //  Depending on the debug access control signal i_debug_if_r
   //  access to the Data Memory Pipeline is granted to either the
   //  ARC pipeline (i_debug_if_r = '0') or the debug interface
   //  (i_debug_if_r = '1'). The debug interface consists of either
   //  the PC Port or a JTAG port.

   always @(pcp_wr_rq or 
            pcp_rd_rq or pcp_addr or 
            pcp_d_wr or 
            dwr or 
            mc_addr or 
            mload or 
            mstore or 
            nocache or 
            size or 
            sex or 
            en3 or 
            dmp_drd or 
            dmp_ldvalid or 
            i_debug_if_r or 
            i_dmp_en3_a)
     
     begin : dbg_async_PROC
        if (i_debug_if_r == 1'b 0)
          begin
             //  arc access mode             
             dmp_dwr = dwr; 
             dmp_addr = mc_addr;    
             dmp_mload = mload; 
             dmp_mstore = mstore;   
             dmp_nocache = nocache; 
             dmp_sex = sex; 
             dmp_size = size;   
             dmp_en3 = en3; 
             ldvalid = dmp_ldvalid; 
             drd = dmp_drd; 
             pcp_dlat = 1'b 0;  
             pcp_d_rd = {32{1'b 0}};    
          end
        else
          begin
             //  debug access mode
             dmp_dwr = pcp_d_wr;    
             dmp_addr = {`EIGHT_ZEROS, pcp_addr};    
             dmp_mload = pcp_rd_rq; 
             dmp_mstore = pcp_wr_rq;    
             dmp_nocache = 1'b 1;   
             dmp_sex = 1'b 0;   
             dmp_size = LDST_LWORD; 
             dmp_en3 = i_dmp_en3_a; 	     
             ldvalid = 1'b 0;   
             drd = {32{1'b 0}}; 
             pcp_dlat = dmp_ldvalid;    
             pcp_d_rd = dmp_drd;    
          end
     end // block: dbg_proc

   // --------------------------------------------------------------
   //  DMP load pending signal (only used in debug mode)
   // --------------------------------------------------------------
   //  The signal dmp_lpending_r is a load pending signal that
   //  indicates when a load has been issued from the debug
   //  interface (PC/JTAG port) in debug access mode. The LSU
   //  generates a similar signal (lpending) but this is only valid
   //  for loads issued by the ARC.
   // 
   //  The signal dmp_lpending_r is set when a load is requested
   //  from the debug interface (pcp_rd_rq = '1'). The signal is
   //  cleared when the load returns (dmp_ldvalid = '1').

   always @(posedge clk_dmp or posedge rst_a)
     begin : lpending_sync_PROC
        if (rst_a == 1'b 1)
          begin
             dmp_lpending_r <= 1'b 0;   
          end
        else
          begin
             if (pcp_rd_rq == 1'b 1)
               begin
                  dmp_lpending_r <= 1'b 1;  
               end
             else if (dmp_ldvalid == 1'b 1 )
               begin
                  dmp_lpending_r <= 1'b 0;  
               end
          end
     end // block: lpending_proc

   //  Output signals used and generated in this module
   //
   assign pcp_ack    = i_dmp_en3_a; 
   assign pcp_dak    = i_dmp_en3_a & pcp_wr_rq;

			    
			    
   // Debug access signals - one synchronous the other asynchronous
   //
   assign debug_if_r = i_debug_if_r; 
   
   assign debug_if_a = (pcp_rd_rq|pcp_wr_rq) & dmp_idle & ~wait_for_ld &
                       ~i_debug_if_r &
		       ~((mload|mstore) & en);

		   
		   

endmodule

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2001-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This module decodes the address (dmp_addr) of the memory request
// and indicates which of the following modules that should service 
// that request:
// 
//    [1] LD/ST queue or data cache (mapped to the same address space)
//    [2] Peripherals
//    [3] DCCM RAM
//    [4] ICCM RAM
// 
// All of these modules are optional, but each build needs either a 
// LD/ST queue and/or a LD/ST RAM. Each build must also have either a 
// code RAM or an instruction cache (but not both).
//
// ======================= Inputs to this block ======================--
//
// dmp_addr         The load/store address is connected to the DMP
//                  sub-modules, the peripherals and the code RAM. This
//                  address can come from either the ARC pipeline or the
//                  debug interface depending on which module requests
//                  access to memory.
//
// lram_base        Base address for the LD/ST RAM. The address of a
//                  memory request (dmp_addr) is compared to this
//                  auxiliary register (lram_base) in order to generate
//                  the signal is_ldst_ram.
//
// ====================== Outputs from this block ====================--
//
// is_ldst_ram      This signal is true when the address (dmp_addr) is
//                  within the address range of the load/store RAM.
//
// is_code_ram      This signal is true when the address (dmp_addr) is
//                  within the address range of the code RAM.
//
// is_local_ram     This signal is true when the address (dmp_addr) is
//                  within the address ranges of either the code RAM or
//                  the LD/ST RAM.
//
// ===================================================================--
//
module decoder (dmp_addr,
    lram_base,


   is_ldst_ram,
   is_code_ram,
   is_local_ramx,
   is_local_ramy,
   is_local_ram,
   is_peripheral);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"
`include "ext_msb.v"

input   [31:0] dmp_addr;
input   [EXT_A_MSB:LDST_A_MSB+3] lram_base;


// Address range matches

output  is_ldst_ram;
output  is_code_ram; 
output  is_local_ramx;
output  is_local_ramy; 
output  is_local_ram; 
output  is_peripheral; 

wire    is_ldst_ram; 
wire    is_code_ram; 
wire    is_local_ramx; 
wire    is_local_ramy;
wire    is_local_ram; 
wire    is_peripheral; 

wire    i_is_ldst_ram; 
wire    i_is_code_ram;
wire    i_is_local_ramx; 
wire    i_is_local_ramy;

// ========================= is_ldst_ram =========================--
// 
//  This signal is set when the address (dmp_addr) is within the
//  address range of the LD/ST RAM. If there is no LD/ST RAM in the
//  build then this signal is always false (i.e. cleared).
// 
//  Support for XY Memory
//  
assign i_is_local_ramx = 
                         1'b 0;
                     
assign i_is_local_ramy = 
                         1'b 0;
                     
//  Support for DCCM
//
assign i_is_ldst_ram = 
                      (dmp_addr[EXT_A_MSB:LDST_A_MSB + 3] == lram_base) ?
       1'b 1 : 
      1'b 0;


assign is_ldst_ram   = i_is_ldst_ram; 
assign is_local_ramx = i_is_local_ramx; 
assign is_local_ramy = i_is_local_ramy; 

// ========================= is_code_ram =========================--
// 
//  This signal is set when the address (dmp_addr) is within the
//  address range of the code RAM. If there is no code in the
//  build then this signal is always false (i.e. cleared).
// 
assign i_is_code_ram = ~dmp_addr[EXT_A_MSB];

assign is_code_ram = i_is_code_ram;

// ========================= is_local_ram =========================--
// 
//  This signal is set when the address (dmp_addr) is within the
//  address ranges of either the LD/ST RAM or the code RAM. If none 
//  of these RAM's exist in this build then this signal is always 
//  false (i.e. cleared).
// 
assign is_local_ram = i_is_ldst_ram   |
                      i_is_code_ram   |
                      i_is_local_ramx |
                      i_is_local_ramy;

// ========================= is_peripheral =======================--
// 
//  The signal is_peripheral is set when the memory address (dmp_addr)
//  is within the address range of the peripherals. When this signal
//  is set only a peripheral should service the request.
//
assign is_peripheral = 

1'b 0; 


endmodule 
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2002-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains the load return arbitrator. It arbitrates
// between returning loads from different Data Memory Pipeline (DMP)
// sub-modules and peripherals. This file also generates the mwait
// signal used to stall the ARC pipeline if necessary. The idle signal
// dmp_idle (which is set if the DMP is idle) is also generated in this
// module.
//
// ========================== Inputs to this block ===========================--
//
// dmp_mload        The load instruction indicator is created in the
//                  Data Memory Pipeline (DMP). When this signal is set
//                  either the processor or the debug interface wish to
//                  load data from an address in the LD/ST memory space.
//
// dmp_mstore       The store instruction indicator is created in the
//                  Data Memory Pipeline (DMP). When this signal is set
//                  either the processor or the debug interface wish to
//                  store data to an address in the LD/ST memory space.
//
// q_drd            Load data return bus from the load/store queue.
//
// q_ldvalid        Indicates that the load/store queue wishes to
//                  perform a writeback on the next cycle. This signal
//                  is set when q_drd contains valid data.
//
// q_mwait          This signal holds pipeline stages 1-3 when the
//                  load/store queue is full and cannot service a
//                  LD/ST request in pipeline stage 3.
//
// q_busy           This signal is set when the load/store queue
//                  contains at least one load or store request. It is
//                  used to generate the DMP idle signal (dmp_idle).
//
// code_drd         The load data return bus from the code RAM.
//
// code_ldvalid_r   Indicates that the code RAM wishes to perform a
//                  writeback on the next cycle.This signal is set when
//                  code_drd contains valid data.
//
// code_dmi_req     The DMI request signal to the code RAM. When set the
//                  direct memory interface (DMI) has immediate access
//                  to the code RAM. The other code RAM interfaces
//                  (instruction fetch and data memory pipeline) are
//                  held off, as they have lower priority. All
//                  load/store instructions are held off when this
//                  signal is set. During a single access several reads
//                  and writes can be performed. The DMI access ends
//                  when this signal is again set low.
//
// ldst_drd         The load data return bus from the load/store RAM.
//
// ldst_ldvalid     Indicates that the load/store RAM wishes to perform
//                  a writeback on the next cycle.This signal is set
//                  when ldst_drd contains valid data.
//
// ldst_dmi_req     The DMI request to the LD/ST RAM. When set the
//                  Direct Memory Interface (DMI) has immediate access
//                  to the LD/ST RAM. All load/store instructions are
//                 held off when this signal is set. During a single
//                  access several reads and writes can be performed.
//                  The DMI access ends when this signal is again set
//                  low.
//
// p_drd            The load data return bus from the peripherals.
//
// p_ldvalid        Indicates that a peripheral wishes to perform a
//                  writeback on the next cycle.This signal is set when
//                  p_drd contains valid data.
//
// stored_ld_rtn    Set when a load return from the DCCM is held off
//                  due to a DMI request and a Dcache load return
//                  happening at the same time.
//
// ========================= Outputs from this block =========================--
//
// hold_loc         This is a hold signal for the load/store RAM and the
//                  code RAM. If either one of these RAM's are trying
//                  to return a load on the same cycle as hold_loc is
//                  set then the load return should be reissued on the
//                  next cycle.
//
// hold_p           This is a hold signal for the peripherals. If the
//                  load/store RAM is trying to return a load
//                  (p_ldvalid = '1') on the same cycle as hold_p is
//                  set then the load/store RAM should stall.
//
// dmp_drd          The load return data bus from the Data Memory
//                  Pipeline (DMP). This load return data bus returns
//                  data from one of the three DMP sub-modules, the code
//                  RAM or a peripheral. The three DMP sub-modules are
//                  the load/store queue, the data cache and the
//                  load/store RAM.
//
// loc_ldvalid      Indicates that the either the load/store RAM or
//                  the code RAM wishes to perform a writeback on the
//                  next cycle.
//
// dmp_ldvalid      Indicates that a DMP sub-module or a peripheral
//                  wish to perform a writeback on the next cycle. This
//                  signal is set when dmp_drd contains valid data.
//
// mwait            This signal holds pipeline stages 1-3 when one of
//                  the three DMP sub-modules or a perpiheral demands
//                  it. The three DMP sub-modules are the load/store
//                  queue, the data cache and the load/store RAM.
//
// dmp_idle         The Data Memory Pipeline (DMP) idle signal. This
//                  signal is set when the DMP is idle. It checks the
//                  data cache and the load/store queue. The other
//                  modules can only contain stalled load returns
//                  which are covered by the load pending signal
//                  (lpending).
//
// ===========================================================================--
//
module ld_arb (

   // From ARC pipeline stage 3
   dmp_mload,
   dmp_mstore,
  
   // from the load/store queue
   q_drd,
   q_ldvalid,
   q_mwait,
   q_busy,
 

               
   // from the DCCM
   ldst_dmi_req,
   ldst_drd,
   ldst_ldvalid,
   stored_ld_rtn,

   // from the ICCM
   code_dmi_req,
   code_ldvalid_r,
   code_drd,

               
   // to the DCCM
   hold_loc,

   // to the peripherals
   hold_p,

   // to arc pipeline
   dmp_drd,
   dmp_ldvalid,
   loc_ldvalid,
   mwait,

   // to the dmp
   dmp_idle);

`include "arcutil_pkg_defines.v" 
`include "arcutil.v" 

// From ARC pipeline stage 3
 input   dmp_mload; 
 input   dmp_mstore;

// from the load/store queue
 input   [31:0] q_drd; 
 input   q_ldvalid; 
 input   q_mwait; 
 input   q_busy; 



// from the DCCM
 input   ldst_dmi_req;
 input [31:0] ldst_drd;
 input   ldst_ldvalid; 
 input   stored_ld_rtn;

// from the ICCM
 input   code_dmi_req;
 input   code_ldvalid_r;
 input [31:0] code_drd;

// to the load/store ram
 output   hold_loc; 

// to the peripherals
 output   hold_p;

// to arc pipeline 
 output   [31:0] dmp_drd; 
 output   dmp_ldvalid;
 output   loc_ldvalid; 
 output   mwait;

// to the dmp 
 output   dmp_idle; 

// to the load/store ram
 wire    hold_loc; 

// to the peripherals
 wire    hold_p;

// to arc pipeline
 wire    [31:0] dmp_drd; 
 wire    dmp_ldvalid;
wire loc_ldvalid; 
 wire    mwait; 

//  to the dmp
 wire    dmp_idle; 

//load/store ram signals
 wire    loc_mwait; 
 wire    i_hold_loc; 

//  peripheral signals
 wire    i_hold_p; 

// =============================== Local RAM's ===============================--
//
// If there is a local RAM in the build (i.e. a DCCM RAM or a ICCM RAM), the
// following hold_loc is generated:
//
   // This signal is set if there is a returning load on this cycle from a
   // module that has higher priority than the load/store RAM and the ICCM RAM.
   // If this signal is set at the same time as any of these two CCM RAM's are
   // trying to return a load then both the processor pipeline and the concerned
   // DCCM RAM need to be stalled for one cycle to allow the data from the CCM
   // RAM to return on the next cycle. The stalling mechanisms of the CCM RAM's
   // are implemented in respective files.
   // Stalling of the pipeline is controlled by the signal loc_mwait (see below).
   //
   // The two modules with higher priority than the CCM RAM's are the load/store
   // queue and the data cache. 
   //
   assign i_hold_loc =
                     (q_ldvalid == 1'b 1) 
             ? 1'b 1 :
             1'b 0;

   assign hold_loc = i_hold_loc; 

   // The loc_mwait signal is set if there is a returning load on this cycle
   // from a module with higher priority than the DCCM RAM's at the same time
   // as a new load/store request is in pipeline stage 3 of the processor. This
   // signal is also set if a direct memory access (DMI) is occuring to the DCCM
   // RAM or the ICCM RAM at the same time as a new load/store request is in
   // pipeline stage 3 of the processor.
   //
   assign loc_mwait = 
                   (((dmp_mload == 1'b 1) | (dmp_mstore == 1'b 1)) & ( 
                   (code_dmi_req == 1'b 1) | 
                   (ldst_dmi_req == 1'b 1) |
                   (stored_ld_rtn == 1'b 1) |

                   ((i_hold_loc == 1'b 1) 
                                  &
                                (
                           (ldst_ldvalid == 1'b 1) 
                                     |
                           (code_ldvalid_r == 1'b 1) 
                                  )
                       ))) ? 1'b 1: 
           1'b 0;

   assign loc_ldvalid  = 
                            code_ldvalid_r |
                            ldst_ldvalid |  
                            1'b 0;

 // ============================= Peripherals ===============================--
 //
 // If there is a peripheral in the build, the following two signals are
 // generated:
 //
   // This signal is set if there is a returning load on this cycle from a
   // module that has higher priority than the peripherals. If this signal is
   // set at the same time as a peripheral is trying to return a load
   // (p_ldvalid = '1') then both the ARC pipeline and the peripherals need to
   // be stalled for one cycle to allow the load from the peripheral to return
   // on the next cycle.
   // All other modules have higher priority than the peripherals, i.e
   // the load/store queue, the data cache, the ICCM RAM and the
   // DCCM RAM.

   assign i_hold_p = 
                   
                   (q_ldvalid == 1'b 1) 
                   |
             (code_ldvalid_r == 1'b 1) 
                   | (ldst_ldvalid == 1'b 1) 
                   ? 1'b 1 :

            1'b 0;

   assign hold_p = i_hold_p; 


// ====================== Signals returning to the ARC =======================--
// 
//  The following signals return to the ARC. They are present in all
//  types of builds.
// 
   // The mwait signal stalls the ARC pipeline if any of the modules that
   // service LD/ST instructions demands it.
   // 
   assign mwait = 
                 (q_mwait == 1'b 1) 
                 | 
                 (loc_mwait == 1'b 1) 
          ? 1'b 1 : 1'b 0; 

   // The dmp_ldvalid is the valid signal of the load return data.
   // 
   assign dmp_ldvalid = 
                        (q_ldvalid == 1'b 1) 
                        | 
                  (code_ldvalid_r == 1'b 1)
                        | (ldst_ldvalid == 1'b 1 )

          ? 1'b 1 : 1'b 0; 

   // The dmp_drd signal is the load return data.
   //
   assign dmp_drd = 
                    (q_ldvalid == 1'b 1) ? q_drd : 
            (code_ldvalid_r == 1'b 1) ? code_drd: 
                    (ldst_ldvalid == 1'b 1) ? ldst_drd : 
      q_drd;

// ============================ DMP idle signal  =============================--
//
// 
   // The DMP idle signal is used in the debug access unit to check when the
   // Data Memory Pipeline (DMP) is idle. This signals is generated from the
   // busy signals from the load/store queue and the data cache (if there is a
   // data cache in the build). The other sub-modules that service LD/ST
   // requests (i.e the load/store RAM and peripherals) cannot queue incoming
   // requests and must consequently not be checked.
   // 
   // However these modules can have stalled load returns. All outstanding loads
   // are covered by the load pending signal lpending, which is checked in the
   // debug access unit as well. The DMP idle signal is generated in all types
   // of builds.
   //
   assign dmp_idle = 
                     (q_busy == 1'b 1) 
                             ? 1'b 0 : 
          1'b 1; 

endmodule 

// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module dmp(clk_ungated,
           ldst_dout,
           en,
           rst_a,
           test_mode,
           clk_dmp,
           q_cmdack,
           q_rdata,
           q_reop,
           q_rspval,
           en3,
           lpending,
           mload,
           mstore,
           nocache,
           sex,
           size,
           dc_disable_r,
           max_one_lpend,
           pcp_rd_rq,
           pcp_wr_rq,
           mc_addr,
           dwr,
           code_dmi_req,
           code_drd,
           code_ldvalid_r,
           en_misaligned,
           lram_base,
           ldst_dmi_req,
           pcp_addr,
           pcp_d_wr,
           ldst_dmi_addr,
           ldst_dmi_wdata,
           ldst_dmi_wr,
           ldst_dmi_be,
           ldst_addr,
           ldst_din,
           ldst_mask,
           ldst_wren,
           ldst_ck_en,
           q_address,
           q_be,
           q_cmd,
           q_cmdval,
           q_eop,
           q_rspack,
           q_wdata,
           q_plen,
           q_buffer,
           q_cache,
           q_mode,
           q_priv,
           ldvalid,
           sync_queue_idle,
           debug_if_r,
           dmp_mload,
           dmp_mstore,
           is_local_ram,
           mwait,
           dmp_holdup12,
           misaligned_int,
           q_ldvalid,
           loc_ldvalid,
           is_peripheral,
           q_busy,
           cgm_queue_idle,
           drd,
           dmp_dwr,
           dmp_en3,
           dmp_addr,
           dmp_size,
           dmp_sex,
           hold_loc,
           is_code_ram,
           debug_if_a,
           misaligned_err,
           pcp_d_rd,
           pcp_ack,
           pcp_dlat,
           pcp_dak,
           ldst_dmi_rdata);


// Includes found automatically in dependent files.
`include "ext_msb.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"
`include "arcutil_pkg_defines.v"


input  clk_ungated;
input  [31:0]  ldst_dout;
input  en;
input  rst_a;
input  test_mode;
input  clk_dmp;
input  q_cmdack;
input  [31:0]  q_rdata;
input  q_reop;
input  q_rspval;
input  en3;
input  lpending;
input  mload;
input  mstore;
input  nocache;
input  sex;
input  [1:0]  size;
input  dc_disable_r;
input  max_one_lpend;
input  pcp_rd_rq;
input  pcp_wr_rq;
input  [31:0]  mc_addr;
input  [31:0]  dwr;
input  code_dmi_req;
input  [31:0]  code_drd;
input  code_ldvalid_r;
input  en_misaligned;
input  [EXT_A_MSB:LDST_A_MSB+3]  lram_base;
input  ldst_dmi_req;
input  [EXT_A_MSB:0]  pcp_addr;
input  [31:0]  pcp_d_wr;
input  [31:0]  ldst_dmi_addr;
input  [31:0]  ldst_dmi_wdata;
input  ldst_dmi_wr;
input  [3:0]  ldst_dmi_be;
output [LDST_A_MSB:0]  ldst_addr;
output [31:0]  ldst_din;
output [3:0]  ldst_mask;
output ldst_wren;
output ldst_ck_en;
output [EXT_A_MSB:0]  q_address;
output [3:0]  q_be;
output [1:0]  q_cmd;
output q_cmdval;
output q_eop;
output q_rspack;
output [31:0]  q_wdata;
output [8:0]  q_plen;
output q_buffer;
output q_cache;
output q_mode;
output q_priv;
output ldvalid;
output sync_queue_idle;
output debug_if_r;
output dmp_mload;
output dmp_mstore;
output is_local_ram;
output mwait;
output dmp_holdup12;
output misaligned_int;
output q_ldvalid;
output loc_ldvalid;
output is_peripheral;
output q_busy;
output cgm_queue_idle;
output [31:0]  drd;
output [31:0]  dmp_dwr;
output dmp_en3;
output [31:0]  dmp_addr;
output [1:0]  dmp_size;
output dmp_sex;
output hold_loc;
output is_code_ram;
output debug_if_a;
output misaligned_err;
output [31:0]  pcp_d_rd;
output pcp_ack;
output pcp_dlat;
output pcp_dak;
output [31:0]  ldst_dmi_rdata;

wire clk_ungated;
wire  [31:0] ldst_dout;
wire en;
wire rst_a;
wire test_mode;
wire clk_dmp;
wire q_cmdack;
wire  [31:0] q_rdata;
wire q_reop;
wire q_rspval;
wire en3;
wire lpending;
wire mload;
wire mstore;
wire nocache;
wire sex;
wire  [1:0] size;
wire dc_disable_r;
wire max_one_lpend;
wire pcp_rd_rq;
wire pcp_wr_rq;
wire  [31:0] mc_addr;
wire  [31:0] dwr;
wire code_dmi_req;
wire  [31:0] code_drd;
wire code_ldvalid_r;
wire en_misaligned;
wire  [EXT_A_MSB:LDST_A_MSB+3] lram_base;
wire ldst_dmi_req;
wire  [EXT_A_MSB:0] pcp_addr;
wire  [31:0] pcp_d_wr;
wire  [31:0] ldst_dmi_addr;
wire  [31:0] ldst_dmi_wdata;
wire ldst_dmi_wr;
wire  [3:0] ldst_dmi_be;
wire  [LDST_A_MSB:0] ldst_addr;
wire  [31:0] ldst_din;
wire  [3:0] ldst_mask;
wire ldst_wren;
wire ldst_ck_en;
wire  [EXT_A_MSB:0] q_address;
wire  [3:0] q_be;
wire  [1:0] q_cmd;
wire q_cmdval;
wire q_eop;
wire q_rspack;
wire  [31:0] q_wdata;
wire  [8:0] q_plen;
wire q_buffer;
wire q_cache;
wire q_mode;
wire q_priv;
wire ldvalid;
wire sync_queue_idle;
wire debug_if_r;
wire dmp_mload;
wire dmp_mstore;
wire is_local_ram;
wire mwait;
wire dmp_holdup12;
wire misaligned_int;
wire q_ldvalid;
wire loc_ldvalid;
wire is_peripheral;
wire q_busy;
wire cgm_queue_idle;
wire  [31:0] drd;
wire  [31:0] dmp_dwr;
wire dmp_en3;
wire  [31:0] dmp_addr;
wire  [1:0] dmp_size;
wire dmp_sex;
wire hold_loc;
wire is_code_ram;
wire debug_if_a;
wire misaligned_err;
wire  [31:0] pcp_d_rd;
wire pcp_ack;
wire pcp_dlat;
wire pcp_dak;
wire  [31:0] ldst_dmi_rdata;


// Intermediate signals
wire i_dmp_mload;
wire i_dmp_mstore;
wire i_is_local_ram;
wire i_mwait;
wire i_q_ldvalid;
wire i_is_peripheral;
wire i_q_busy;
wire  [31:0] i_dmp_dwr;
wire i_dmp_en3;
wire  [31:0] i_dmp_addr;
wire  [1:0] i_dmp_size;
wire i_dmp_sex;
wire i_hold_loc;
wire i_dmp_nocache;
wire  [31:0] i_q_drd;
wire i_q_mwait;
wire  [31:0] i_ldst_drd;
wire i_ldst_ldvalid;
wire i_stored_ld_rtn;
wire  [31:0] i_dmp_drd;
wire i_dmp_ldvalid;
wire i_dmp_idle;
wire i_is_ldst_ram;


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)
wire u_unconnected_0;
wire u_unconnected_1;
wire u_unconnected_2;
wire u_unconnected_3;
wire u_unconnected_4;
wire u_unconnected_5;


// Instantiation of module ldst_queue
ldst_queue ildst_queue(
  .clk_dmp(clk_dmp),
  .rst_a(rst_a),
  .dmp_dwr(i_dmp_dwr),
  .dmp_en3(i_dmp_en3),
  .dmp_addr(i_dmp_addr),
  .dmp_mload(i_dmp_mload),
  .dmp_mstore(i_dmp_mstore),
  .dmp_nocache(i_dmp_nocache),
  .dmp_size(i_dmp_size),
  .dmp_sex(i_dmp_sex),
  .is_local_ram(i_is_local_ram),
  .is_peripheral(i_is_peripheral),
  .q_cmdack(q_cmdack),
  .q_rdata(q_rdata),
  .q_reop(q_reop),
  .q_rspval(q_rspval),
  .dc_disable_r(dc_disable_r),
  .a_pc_en(u_unconnected_0),
  .b_pc_en(u_unconnected_1),
  .sel_dat(u_unconnected_2),
  .cgm_queue_idle(cgm_queue_idle),
  .sync_queue_idle(sync_queue_idle),
  .q_drd(i_q_drd),
  .q_ldvalid(i_q_ldvalid),
  .q_mwait(i_q_mwait),
  .q_busy(i_q_busy),
  .q_address(q_address),
  .q_wdata(q_wdata),
  .q_be(q_be),
  .q_cmdval(q_cmdval),
  .q_eop(q_eop),
  .q_plen(q_plen),
  .q_rspack(q_rspack),
  .q_cache(q_cache),
  .q_priv(q_priv),
  .q_buffer(q_buffer),
  .q_mode(q_mode),
  .q_cmd(q_cmd)
);


// Instantiation of module ld_arb
ld_arb ild_arb(
  .dmp_mload(i_dmp_mload),
  .dmp_mstore(i_dmp_mstore),
  .q_drd(i_q_drd),
  .q_ldvalid(i_q_ldvalid),
  .q_mwait(i_q_mwait),
  .q_busy(i_q_busy),
  .ldst_dmi_req(ldst_dmi_req),
  .ldst_drd(i_ldst_drd),
  .ldst_ldvalid(i_ldst_ldvalid),
  .stored_ld_rtn(i_stored_ld_rtn),
  .code_dmi_req(code_dmi_req),
  .code_ldvalid_r(code_ldvalid_r),
  .code_drd(code_drd),
  .hold_loc(i_hold_loc),
  .hold_p(u_unconnected_3),
  .dmp_drd(i_dmp_drd),
  .dmp_ldvalid(i_dmp_ldvalid),
  .loc_ldvalid(loc_ldvalid),
  .mwait(i_mwait),
  .dmp_idle(i_dmp_idle)
);


// Instantiation of module decoder
decoder idecoder(
  .dmp_addr(i_dmp_addr),
  .lram_base(lram_base),
  .is_ldst_ram(i_is_ldst_ram),
  .is_code_ram(is_code_ram),
  .is_local_ramx(u_unconnected_4),
  .is_local_ramy(u_unconnected_5),
  .is_local_ram(i_is_local_ram),
  .is_peripheral(i_is_peripheral)
);


// Instantiation of module debug_access
debug_access idebug_access(
  .clk_dmp(clk_dmp),
  .rst_a(rst_a),
  .en(en),
  .pcp_wr_rq(pcp_wr_rq),
  .pcp_rd_rq(pcp_rd_rq),
  .pcp_addr(pcp_addr),
  .pcp_d_wr(pcp_d_wr),
  .is_local_ram(i_is_local_ram),
  .dwr(dwr),
  .en3(en3),
  .mc_addr(mc_addr),
  .mload(mload),
  .mstore(mstore),
  .nocache(nocache),
  .size(size),
  .sex(sex),
  .lpending(lpending),
  .max_one_lpend(max_one_lpend),
  .dmp_drd(i_dmp_drd),
  .dmp_ldvalid(i_dmp_ldvalid),
  .mwait(i_mwait),
  .dmp_idle(i_dmp_idle),
  .debug_if_r(debug_if_r),
  .debug_if_a(debug_if_a),
  .pcp_d_rd(pcp_d_rd),
  .pcp_ack(pcp_ack),
  .pcp_dlat(pcp_dlat),
  .pcp_dak(pcp_dak),
  .dmp_holdup12(dmp_holdup12),
  .drd(drd),
  .ldvalid(ldvalid),
  .dmp_dwr(i_dmp_dwr),
  .dmp_addr(i_dmp_addr),
  .dmp_mload(i_dmp_mload),
  .dmp_mstore(i_dmp_mstore),
  .dmp_nocache(i_dmp_nocache),
  .dmp_sex(i_dmp_sex),
  .dmp_size(i_dmp_size),
  .dmp_en3(i_dmp_en3)
);


// Instantiation of module mem_align_chk
mem_align_chk imem_align_chk(
  .clk_dmp(clk_dmp),
  .rst_a(rst_a),
  .en3(en3),
  .mc_addr(mc_addr),
  .mload(mload),
  .mstore(mstore),
  .size(size),
  .en_misaligned(en_misaligned),
  .misaligned_int(misaligned_int),
  .misaligned_err(misaligned_err)
);


// Instantiation of module dccm_control
dccm_control idccm_control(
  .clk_ungated(clk_ungated),
  .rst_a(rst_a),
  .test_mode(test_mode),
  .dmp_dwr(i_dmp_dwr),
  .dmp_en3(i_dmp_en3),
  .dmp_addr(i_dmp_addr),
  .dmp_mload(i_dmp_mload),
  .dmp_mstore(i_dmp_mstore),
  .dmp_size(i_dmp_size),
  .dmp_sex(i_dmp_sex),
  .ldst_dmi_req(ldst_dmi_req),
  .ldst_dmi_addr(ldst_dmi_addr),
  .ldst_dmi_wdata(ldst_dmi_wdata),
  .ldst_dmi_wr(ldst_dmi_wr),
  .ldst_dmi_be(ldst_dmi_be),
  .ldst_dout(ldst_dout),
  .hold_loc(i_hold_loc),
  .is_ldst_ram(i_is_ldst_ram),
  .is_peripheral(i_is_peripheral),
  .ldst_addr(ldst_addr),
  .ldst_din(ldst_din),
  .ldst_mask(ldst_mask),
  .ldst_wren(ldst_wren),
  .ldst_ck_en(ldst_ck_en),
  .ldst_dmi_rdata(ldst_dmi_rdata),
  .ldst_drd(i_ldst_drd),
  .ldst_ldvalid(i_ldst_ldvalid),
  .stored_ld_rtn(i_stored_ld_rtn)
);


// Output drives
assign dmp_mload        = i_dmp_mload;
assign dmp_mstore       = i_dmp_mstore;
assign is_local_ram     = i_is_local_ram;
assign mwait            = i_mwait;
assign q_ldvalid        = i_q_ldvalid;
assign is_peripheral    = i_is_peripheral;
assign q_busy           = i_q_busy;
assign dmp_dwr          = i_dmp_dwr;
assign dmp_en3          = i_dmp_en3;
assign dmp_addr         = i_dmp_addr;
assign dmp_size         = i_dmp_size;
assign dmp_sex          = i_dmp_sex;
assign hold_loc         = i_hold_loc;

endmodule


// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module arc600(clk_ungated,
              ldst_dout,
              code_ram_rdata,
              rst_a,
              ctrl_cpu_start_sync_r,
              l_irq_4,
              l_irq_5,
              l_irq_6,
              l_irq_7,
              l_irq_8,
              l_irq_9,
              l_irq_10,
              l_irq_11,
              l_irq_12,
              l_irq_13,
              l_irq_14,
              l_irq_15,
              l_irq_16,
              l_irq_17,
              l_irq_18,
              l_irq_19,
              test_mode,
              clk,
              clk_debug,
              clk_dmp,
              ibus_busy,
              q_cmdack,
              q_rdata,
              q_reop,
              q_rspval,
              mem_access,
              memory_error,
              h_addr,
              h_dataw,
              h_write,
              h_read,
              aux_access,
              core_access,
              pcp_rd_rq,
              pcp_wr_rq,
              code_dmi_req,
              code_dmi_addr,
              code_dmi_wdata,
              code_dmi_wr,
              code_dmi_be,
              arc_start_a,
              halt,
              xstep,
              ldst_dmi_req,
              pcp_addr,
              pcp_d_wr,
              ldst_dmi_addr,
              ldst_dmi_wdata,
              ldst_dmi_wr,
              ldst_dmi_be,
              ldst_addr,
              ldst_din,
              ldst_mask,
              ldst_wren,
              ldst_ck_en,
              code_ram_addr,
              code_ram_wdata,
              code_ram_wr,
              code_ram_be,
              code_ram_ck_en,
              en,
              wd_clear,
              ck_disable,
              ck_dmp_gated,
              en_debug_r,
              q_address,
              q_be,
              q_cmd,
              q_cmdval,
              q_eop,
              q_rspack,
              q_wdata,
              q_plen,
              q_buffer,
              q_cache,
              q_mode,
              q_priv,
              hold_host,
              code_dmi_rdata,
              noaccess,
              reset_applied_r,
              power_toggle,
              pc_sel_r,
              h_datar,
              pcp_d_rd,
              pcp_ack,
              pcp_dlat,
              pcp_dak,
              ldst_dmi_rdata);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "asmutil.v"
`include "extutil.v"
`include "che_util.v"
`include "xdefs.v"
`include "uxdefs.v"
`include "ext_msb.v"


input  clk_ungated;
input  [31:0]  ldst_dout;
input  [31:0]  code_ram_rdata;
input  rst_a;
input  ctrl_cpu_start_sync_r;
input  l_irq_4;
input  l_irq_5;
input  l_irq_6;
input  l_irq_7;
input  l_irq_8;
input  l_irq_9;
input  l_irq_10;
input  l_irq_11;
input  l_irq_12;
input  l_irq_13;
input  l_irq_14;
input  l_irq_15;
input  l_irq_16;
input  l_irq_17;
input  l_irq_18;
input  l_irq_19;
input  test_mode;
input  clk;
input  clk_debug;
input  clk_dmp;
input  ibus_busy;
input  q_cmdack;
input  [31:0]  q_rdata;
input  q_reop;
input  q_rspval;
input  mem_access;
input  memory_error;
input  [31:0]  h_addr;
input  [31:0]  h_dataw;
input  h_write;
input  h_read;
input  aux_access;
input  core_access;
input  pcp_rd_rq;
input  pcp_wr_rq;
input  code_dmi_req;
input  [31:0]  code_dmi_addr;
input  [31:0]  code_dmi_wdata;
input  code_dmi_wr;
input  [3:0]  code_dmi_be;
input  arc_start_a;
input  halt;
input  xstep;
input  ldst_dmi_req;
input  [EXT_A_MSB:0]  pcp_addr;
input  [31:0]  pcp_d_wr;
input  [31:0]  ldst_dmi_addr;
input  [31:0]  ldst_dmi_wdata;
input  ldst_dmi_wr;
input  [3:0]  ldst_dmi_be;
output [LDST_A_MSB:0]  ldst_addr;
output [31:0]  ldst_din;
output [3:0]  ldst_mask;
output ldst_wren;
output ldst_ck_en;
output [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0]  code_ram_addr;
output [31:0]  code_ram_wdata;
output code_ram_wr;
output [3:0]  code_ram_be;
output code_ram_ck_en;
output en;
output wd_clear;
output ck_disable;
output ck_dmp_gated;
output en_debug_r;
output [EXT_A_MSB:0]  q_address;
output [3:0]  q_be;
output [1:0]  q_cmd;
output q_cmdval;
output q_eop;
output q_rspack;
output [31:0]  q_wdata;
output [8:0]  q_plen;
output q_buffer;
output q_cache;
output q_mode;
output q_priv;
output hold_host;
output [31:0]  code_dmi_rdata;
output noaccess;
output reset_applied_r;
output power_toggle;
output pc_sel_r;
output [31:0]  h_datar;
output [31:0]  pcp_d_rd;
output pcp_ack;
output pcp_dlat;
output pcp_dak;
output [31:0]  ldst_dmi_rdata;

wire clk_ungated;
wire  [31:0] ldst_dout;
wire  [31:0] code_ram_rdata;
wire rst_a;
wire ctrl_cpu_start_sync_r;
wire l_irq_4;
wire l_irq_5;
wire l_irq_6;
wire l_irq_7;
wire l_irq_8;
wire l_irq_9;
wire l_irq_10;
wire l_irq_11;
wire l_irq_12;
wire l_irq_13;
wire l_irq_14;
wire l_irq_15;
wire l_irq_16;
wire l_irq_17;
wire l_irq_18;
wire l_irq_19;
wire test_mode;
wire clk;
wire clk_debug;
wire clk_dmp;
wire ibus_busy;
wire q_cmdack;
wire  [31:0] q_rdata;
wire q_reop;
wire q_rspval;
wire mem_access;
wire memory_error;
wire  [31:0] h_addr;
wire  [31:0] h_dataw;
wire h_write;
wire h_read;
wire aux_access;
wire core_access;
wire pcp_rd_rq;
wire pcp_wr_rq;
wire code_dmi_req;
wire  [31:0] code_dmi_addr;
wire  [31:0] code_dmi_wdata;
wire code_dmi_wr;
wire  [3:0] code_dmi_be;
wire arc_start_a;
wire halt;
wire xstep;
wire ldst_dmi_req;
wire  [EXT_A_MSB:0] pcp_addr;
wire  [31:0] pcp_d_wr;
wire  [31:0] ldst_dmi_addr;
wire  [31:0] ldst_dmi_wdata;
wire ldst_dmi_wr;
wire  [3:0] ldst_dmi_be;
wire  [LDST_A_MSB:0] ldst_addr;
wire  [31:0] ldst_din;
wire  [3:0] ldst_mask;
wire ldst_wren;
wire ldst_ck_en;
wire  [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] code_ram_addr;
wire  [31:0] code_ram_wdata;
wire code_ram_wr;
wire  [3:0] code_ram_be;
wire code_ram_ck_en;
wire en;
wire wd_clear;
wire ck_disable;
wire ck_dmp_gated;
wire en_debug_r;
wire  [EXT_A_MSB:0] q_address;
wire  [3:0] q_be;
wire  [1:0] q_cmd;
wire q_cmdval;
wire q_eop;
wire q_rspack;
wire  [31:0] q_wdata;
wire  [8:0] q_plen;
wire q_buffer;
wire q_cache;
wire q_mode;
wire q_priv;
wire hold_host;
wire  [31:0] code_dmi_rdata;
wire noaccess;
wire reset_applied_r;
wire power_toggle;
wire pc_sel_r;
wire  [31:0] h_datar;
wire  [31:0] pcp_d_rd;
wire pcp_ack;
wire pcp_dlat;
wire pcp_dak;
wire  [31:0] ldst_dmi_rdata;


// Intermediate signals
wire i_en;
wire i_ldvalid;
wire i_sync_queue_idle;
wire i_debug_if_r;
wire i_dmp_mload;
wire i_dmp_mstore;
wire i_is_local_ram;
wire i_mwait;
wire i_dmp_holdup12;
wire i_misaligned_int;
wire i_q_ldvalid;
wire i_loc_ldvalid;
wire i_is_peripheral;
wire i_q_busy;
wire i_cgm_queue_idle;
wire  [31:0] i_drd;
wire  [31:0] i_dmp_dwr;
wire i_dmp_en3;
wire  [31:0] i_dmp_addr;
wire  [1:0] i_dmp_size;
wire i_dmp_sex;
wire i_hold_loc;
wire i_is_code_ram;
wire i_debug_if_a;
wire i_misaligned_err;
wire i_en3;
wire i_lpending;
wire i_mload;
wire i_mstore;
wire i_nocache;
wire i_sex;
wire  [1:0] i_size;
wire i_dc_disable_r;
wire i_max_one_lpend;
wire  [31:0] i_mc_addr;
wire  [31:0] i_dwr;
wire  [31:0] i_code_drd;
wire i_code_ldvalid_r;
wire i_en_misaligned;
wire  [EXT_A_MSB:LDST_A_MSB+3] i_lram_base;


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)


// Instantiation of module quarc
quarc iquarc(
  .clk_ungated(clk_ungated),
  .code_ram_rdata(code_ram_rdata),
  .rst_a(rst_a),
  .ctrl_cpu_start_sync_r(ctrl_cpu_start_sync_r),
  .l_irq_4(l_irq_4),
  .l_irq_5(l_irq_5),
  .l_irq_6(l_irq_6),
  .l_irq_7(l_irq_7),
  .l_irq_8(l_irq_8),
  .l_irq_9(l_irq_9),
  .l_irq_10(l_irq_10),
  .l_irq_11(l_irq_11),
  .l_irq_12(l_irq_12),
  .l_irq_13(l_irq_13),
  .l_irq_14(l_irq_14),
  .l_irq_15(l_irq_15),
  .l_irq_16(l_irq_16),
  .l_irq_17(l_irq_17),
  .l_irq_18(l_irq_18),
  .l_irq_19(l_irq_19),
  .test_mode(test_mode),
  .clk(clk),
  .clk_debug(clk_debug),
  .ibus_busy(ibus_busy),
  .mem_access(mem_access),
  .memory_error(memory_error),
  .h_addr(h_addr),
  .h_dataw(h_dataw),
  .h_write(h_write),
  .h_read(h_read),
  .aux_access(aux_access),
  .core_access(core_access),
  .ldvalid(i_ldvalid),
  .sync_queue_idle(i_sync_queue_idle),
  .debug_if_r(i_debug_if_r),
  .dmp_mload(i_dmp_mload),
  .dmp_mstore(i_dmp_mstore),
  .is_local_ram(i_is_local_ram),
  .mwait(i_mwait),
  .dmp_holdup12(i_dmp_holdup12),
  .misaligned_int(i_misaligned_int),
  .q_ldvalid(i_q_ldvalid),
  .loc_ldvalid(i_loc_ldvalid),
  .is_peripheral(i_is_peripheral),
  .q_busy(i_q_busy),
  .cgm_queue_idle(i_cgm_queue_idle),
  .pcp_rd_rq(pcp_rd_rq),
  .pcp_wr_rq(pcp_wr_rq),
  .drd(i_drd),
  .dmp_dwr(i_dmp_dwr),
  .dmp_en3(i_dmp_en3),
  .dmp_addr(i_dmp_addr),
  .dmp_size(i_dmp_size),
  .dmp_sex(i_dmp_sex),
  .hold_loc(i_hold_loc),
  .is_code_ram(i_is_code_ram),
  .code_dmi_req(code_dmi_req),
  .code_dmi_addr(code_dmi_addr),
  .code_dmi_wdata(code_dmi_wdata),
  .code_dmi_wr(code_dmi_wr),
  .code_dmi_be(code_dmi_be),
  .arc_start_a(arc_start_a),
  .debug_if_a(i_debug_if_a),
  .halt(halt),
  .xstep(xstep),
  .misaligned_err(i_misaligned_err),
  .code_ram_addr(code_ram_addr),
  .code_ram_wdata(code_ram_wdata),
  .code_ram_wr(code_ram_wr),
  .code_ram_be(code_ram_be),
  .code_ram_ck_en(code_ram_ck_en),
  .en(i_en),
  .wd_clear(wd_clear),
  .ck_disable(ck_disable),
  .ck_dmp_gated(ck_dmp_gated),
  .en_debug_r(en_debug_r),
  .en3(i_en3),
  .lpending(i_lpending),
  .mload(i_mload),
  .mstore(i_mstore),
  .nocache(i_nocache),
  .sex(i_sex),
  .size(i_size),
  .dc_disable_r(i_dc_disable_r),
  .max_one_lpend(i_max_one_lpend),
  .mc_addr(i_mc_addr),
  .dwr(i_dwr),
  .hold_host(hold_host),
  .code_drd(i_code_drd),
  .code_ldvalid_r(i_code_ldvalid_r),
  .code_dmi_rdata(code_dmi_rdata),
  .noaccess(noaccess),
  .en_misaligned(i_en_misaligned),
  .reset_applied_r(reset_applied_r),
  .power_toggle(power_toggle),
  .lram_base(i_lram_base),
  .pc_sel_r(pc_sel_r),
  .h_datar(h_datar)
);


// Instantiation of module dmp
dmp idmp(
  .clk_ungated(clk_ungated),
  .ldst_dout(ldst_dout),
  .en(i_en),
  .rst_a(rst_a),
  .test_mode(test_mode),
  .clk_dmp(clk_dmp),
  .q_cmdack(q_cmdack),
  .q_rdata(q_rdata),
  .q_reop(q_reop),
  .q_rspval(q_rspval),
  .en3(i_en3),
  .lpending(i_lpending),
  .mload(i_mload),
  .mstore(i_mstore),
  .nocache(i_nocache),
  .sex(i_sex),
  .size(i_size),
  .dc_disable_r(i_dc_disable_r),
  .max_one_lpend(i_max_one_lpend),
  .pcp_rd_rq(pcp_rd_rq),
  .pcp_wr_rq(pcp_wr_rq),
  .mc_addr(i_mc_addr),
  .dwr(i_dwr),
  .code_dmi_req(code_dmi_req),
  .code_drd(i_code_drd),
  .code_ldvalid_r(i_code_ldvalid_r),
  .en_misaligned(i_en_misaligned),
  .lram_base(i_lram_base),
  .ldst_dmi_req(ldst_dmi_req),
  .pcp_addr(pcp_addr),
  .pcp_d_wr(pcp_d_wr),
  .ldst_dmi_addr(ldst_dmi_addr),
  .ldst_dmi_wdata(ldst_dmi_wdata),
  .ldst_dmi_wr(ldst_dmi_wr),
  .ldst_dmi_be(ldst_dmi_be),
  .ldst_addr(ldst_addr),
  .ldst_din(ldst_din),
  .ldst_mask(ldst_mask),
  .ldst_wren(ldst_wren),
  .ldst_ck_en(ldst_ck_en),
  .q_address(q_address),
  .q_be(q_be),
  .q_cmd(q_cmd),
  .q_cmdval(q_cmdval),
  .q_eop(q_eop),
  .q_rspack(q_rspack),
  .q_wdata(q_wdata),
  .q_plen(q_plen),
  .q_buffer(q_buffer),
  .q_cache(q_cache),
  .q_mode(q_mode),
  .q_priv(q_priv),
  .ldvalid(i_ldvalid),
  .sync_queue_idle(i_sync_queue_idle),
  .debug_if_r(i_debug_if_r),
  .dmp_mload(i_dmp_mload),
  .dmp_mstore(i_dmp_mstore),
  .is_local_ram(i_is_local_ram),
  .mwait(i_mwait),
  .dmp_holdup12(i_dmp_holdup12),
  .misaligned_int(i_misaligned_int),
  .q_ldvalid(i_q_ldvalid),
  .loc_ldvalid(i_loc_ldvalid),
  .is_peripheral(i_is_peripheral),
  .q_busy(i_q_busy),
  .cgm_queue_idle(i_cgm_queue_idle),
  .drd(i_drd),
  .dmp_dwr(i_dmp_dwr),
  .dmp_en3(i_dmp_en3),
  .dmp_addr(i_dmp_addr),
  .dmp_size(i_dmp_size),
  .dmp_sex(i_dmp_sex),
  .hold_loc(i_hold_loc),
  .is_code_ram(i_is_code_ram),
  .debug_if_a(i_debug_if_a),
  .misaligned_err(i_misaligned_err),
  .pcp_d_rd(pcp_d_rd),
  .pcp_ack(pcp_ack),
  .pcp_dlat(pcp_dlat),
  .pcp_dak(pcp_dak),
  .ldst_dmi_rdata(ldst_dmi_rdata)
);


// Output drives
assign en                     = i_en;

endmodule


// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1999-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file contains the latches for incoming external signals, like
// clear and interrupt.These are all supplied by external logic which
// ensures that all metastable states have been removed. These signals
// are only implemented as part of the ARCAngel or Generic system build.
// 
//======================= Inputs to this block =======================
//
// clk_ungated    Core Clock (Not Gated)
// rst_n_a        Global Reset (active low)
// xirq_n[]       External Interrupts (if present)
// testmode       Test mode signal for scan operation
// wd_clear       Watch dog reset from a timer
//
//====================== Output from this block ======================
//
// rst_a          Registered and synchronized external reset signal
// l_irq[7:5]     Latched external interrupts (if present)
//
//====================================================================
//
module io_flops (
	clk_ungated,
	rst_n_a,
	en,
	rst_a,
	wd_clear,
	ctrl_cpu_start_sync_r,
	ctrl_cpu_start,

// Signals required for the interrupts
xirq_n_4,
xirq_n_5,
xirq_n_6,
xirq_n_7,
xirq_n_8,
xirq_n_9,
xirq_n_10,
xirq_n_11,
xirq_n_12,
xirq_n_13,
xirq_n_14,
xirq_n_15,
xirq_n_16,
xirq_n_17,
xirq_n_18,
xirq_n_19,
l_irq_4,
l_irq_5,
l_irq_6,
l_irq_7,
l_irq_8,
l_irq_9,
l_irq_10,
l_irq_11,
l_irq_12,
l_irq_13,
l_irq_14,
l_irq_15,
l_irq_16,
l_irq_17,
l_irq_18,
l_irq_19,

   jtag_tck,
   jtag_trst_n,
   jtag_trst_a,
	test_mode);

input  clk_ungated; 
input  rst_n_a;
input  en;
input  test_mode;
input  ctrl_cpu_start;


// Signals required for the interrupts
input xirq_n_4;
input xirq_n_5;
input xirq_n_6;
input xirq_n_7;
input xirq_n_8;
input xirq_n_9;
input xirq_n_10;
input xirq_n_11;
input xirq_n_12;
input xirq_n_13;
input xirq_n_14;
input xirq_n_15;
input xirq_n_16;
input xirq_n_17;
input xirq_n_18;
input xirq_n_19;
output l_irq_4;
output l_irq_5;
output l_irq_6;
output l_irq_7;
output l_irq_8;
output l_irq_9;
output l_irq_10;
output l_irq_11;
output l_irq_12;
output l_irq_13;
output l_irq_14;
output l_irq_15;
output l_irq_16;
output l_irq_17;
output l_irq_18;
output l_irq_19;

input  jtag_tck;
input  jtag_trst_n;
output jtag_trst_a;
wire   jtag_trst_a;
output ctrl_cpu_start_sync_r; 
output rst_a;  
wire   rst_a; 
input  wd_clear;


// Signals required for the interrupts
reg l_irq_4;
reg l_irq_5;
reg l_irq_6;
reg l_irq_7;
reg l_irq_8;
reg l_irq_9;
reg l_irq_10;
reg l_irq_11;
reg l_irq_12;
reg l_irq_13;
reg l_irq_14;
reg l_irq_15;
reg l_irq_16;
reg l_irq_17;
reg l_irq_18;
reg l_irq_19;


reg   i_jtag_trst_synchro_r;
reg   i_jtag_trst_r1;

wire  i_rst_a; 

reg   ctrl_cpu_start_sync_r;
reg   i_start_synchro_r;

// Double flop the 'external start' signal to prevent metastability.
//
always @(posedge clk_ungated or posedge i_rst_a)
begin : ctrl_cpu_start_meta_PROC
  if (i_rst_a == 1'b1)
  begin
    i_start_synchro_r  <= 1'b0;
    ctrl_cpu_start_sync_r <= 1'b0;
  end
  else
  begin
    i_start_synchro_r  <= ctrl_cpu_start;
    ctrl_cpu_start_sync_r <= i_start_synchro_r;
  end
end

// The reset is clocked by the core clock and is asynchronously applied 
// and synchronously removed (double register synchronization)
// 
reg   i_rst_r1;         // dual sync FFs
reg   i_rst_synchro_r;

always @(posedge clk_ungated or negedge rst_n_a)
  begin : ext_clear_PROC
  if (rst_n_a == 1'b 0)
    begin
    i_rst_synchro_r <= 1'b 1;
    i_rst_r1      <= 1'b 1;        
    end
  else if (wd_clear == 1'b 1)
    begin
    i_rst_synchro_r <= 1'b 1;
    i_rst_r1      <= 1'b 1;
    end
  else
    begin
    i_rst_synchro_r <= 1'b 0;
    i_rst_r1      <= i_rst_synchro_r;        
    end
  end
assign i_rst_a = (test_mode == 1'b 1) ? ~rst_n_a : i_rst_r1;


assign rst_a   = 0 
            | i_rst_a;

// -------------------------------------------------------------------------
// External interrupt signals
// 
// Latch and invert external IRQ signals since the external interrupts
// active low, but the ARC services active high interrupts. It is clocked
// by the ungated clock.
// 
// -------------------------------------------------------------------------

always @(posedge clk_ungated or posedge i_rst_a)
  begin : ext_interrupt_PROC
  if (i_rst_a == 1'b 1)
     begin
		l_irq_4 <= 1'b 0;
		l_irq_5 <= 1'b 0;
		l_irq_6 <= 1'b 0;
		l_irq_7 <= 1'b 0;
		l_irq_8 <= 1'b 0;
		l_irq_9 <= 1'b 0;
		l_irq_10 <= 1'b 0;
		l_irq_11 <= 1'b 0;
		l_irq_12 <= 1'b 0;
		l_irq_13 <= 1'b 0;
		l_irq_14 <= 1'b 0;
		l_irq_15 <= 1'b 0;
		l_irq_16 <= 1'b 0;
		l_irq_17 <= 1'b 0;
		l_irq_18 <= 1'b 0;
		l_irq_19 <= 1'b 0;
    end
 else
    begin
		l_irq_4 <= ~xirq_n_4;
		l_irq_5 <= ~xirq_n_5;
		l_irq_6 <= ~xirq_n_6;
		l_irq_7 <= ~xirq_n_7;
		l_irq_8 <= ~xirq_n_8;
		l_irq_9 <= ~xirq_n_9;
		l_irq_10 <= ~xirq_n_10;
		l_irq_11 <= ~xirq_n_11;
		l_irq_12 <= ~xirq_n_12;
		l_irq_13 <= ~xirq_n_13;
		l_irq_14 <= ~xirq_n_14;
		l_irq_15 <= ~xirq_n_15;
		l_irq_16 <= ~xirq_n_16;
		l_irq_17 <= ~xirq_n_17;
		l_irq_18 <= ~xirq_n_18;
		l_irq_19 <= ~xirq_n_19;
     end
  end

// This process synchronizes the removal of the JTAG reset. It might go
// metastable because the external reset can be removed in any relationship to
// the clock, so it's resynchronized here.
always @(posedge jtag_tck or negedge jtag_trst_n)
  begin : JTAG_CLEAR_PROC
    if (jtag_trst_n == 1'b 0)
    begin
      i_jtag_trst_synchro_r <= 1'b 1;
      i_jtag_trst_r1      <= 1'b 1;
    end
    else
    begin
      i_jtag_trst_synchro_r <= 1'b 0;
      i_jtag_trst_r1      <= i_jtag_trst_synchro_r;
    end
  end

assign jtag_trst_a = test_mode==1'b 1 ? ~jtag_trst_n : i_jtag_trst_r1;


endmodule // module io_flops

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// Clock generation module
// 
// All clock gating in the ARC600 is done in this module. If the
// clock gating has not been selected this module is empty.
//  
//======================= Inputs to this block =======================--
//
//  clk_in             U Core input clock
//
//  clk_system_in      U System input clock
// 
//  test_mode          U Production test mode signal, which is only enabled
//                     during ATPG generation and production test in the
//                     factory. It is always disabled during operation.
// 
//  en_debug_r         L This flag is the Enable Debug flag (ED), bit 24 in the
//                     DEBUG register. It enables the debug extensions when it
//                     is set. When it is cleared the debug extensions are
//                     switched off by gating the debug clock, but only if the
//                     option clock gating has been selected.
// 
//====================== Output from this block ======================--
//
//  clk                U The main clock of ARC. It is connected to all modules
//                     except those connected that clk_debug and clk_system are
//                     connected to.
// 
//  clk_debug          U The debug clock is only connected to the debug
//                     extensions.
// 
//  clk_ungated        U The internal core clock which is always the same as
//                     clk_in. It is never gated even if clock gating has been
//                     selected. It is connected to the modules that control the ARC
//                     interfaces, the timer(s) the interrupt unit, the clock control
//                     module, the CCM(s) and their respective logic (CCMs must be able
//                     to respond in a single cycle to DMI requests, even when
//                     the clock gating is active), and in general to all the
//                     modules that have to stay "awake", even when the clock is
//                     "sleeping".
//
//  clk_system         U The External System Clock, that can be set to 1:1,
//                     2:1, 3:1, 4:1 ratios to the main clock clk
//                     (see glue module). By default it is set to 2:1
//                     This clock goes to the ibus_cksyn_sys block, and,
//                     depending on the connection scheme, might go to some
//                     peripherals.
//
//====================================================================--
//
module ck_gen (
   clk_in,
   clk_system_in,
//   test_mode,

// Clock controls

   ck_disable,
   ck_dmp_gated,
   en_debug_r,

// Generated clocks

   clk,
   clk_debug,
   clk_dmp,
   clk_ungated,
   clk_system);

`include "arcutil_pkg_defines.v" 
`include "extutil.v" 

   input   clk_in; 
   input   clk_system_in;
//   input   test_mode; 
   input   ck_disable; 
   input   ck_dmp_gated;

   input   en_debug_r; 

   output  clk; 
   output  clk_debug; 
   output  clk_dmp;
   output  clk_ungated;
   output  clk_system; 

   wire    clk; 
   wire    clk_debug; 
   wire    clk_system; 

   wire    i_ck_enable_a; 
   wire    i_debug_enable_a; 
// leda NTL_CLK07 off
   wire    i_ck_dft_a;
   wire    i_ck_dmp_dft_a;
// leda NTL_CLK07 on
   wire    ck_enable;
   wire     i_ck_dmp_enable_a ;
 
  
// -------------------------------------------------------------------------
//  The clock gating option
// 
//  **NOTE : All gates in this module must be instantiated in replacement RTL before going to synthesis and layout.
//  The replacement wrapper is generated via the SEIF iplib component in conjunction with ASIC iplib since the integrated clock
// gating cell that is to be targeted is technology/library specific

//   Therefore, regard the HDL in this module as a behavioural model that can be used for simulation purposes.
//  The behaviour of the clock gating is such as to gate off in low state and must use a deglitching of the enable (see ARS2104847)
//   If this behavioural RTL would be directly synthesised, it will result in a discrete latch + AND gate
// Preference is to use SEIF flow to replace this code with equivalent where technology specific clock gate is instantiated. 

//  All clocks, with the exception of the system and ungated clock may be gated.
//  This is an option controlled by the constant CK_GATING in the file extutil.v.
// 
//  If clock gating is selected the clocks are low when disabled.  This is the convention for pos-edge triggered systems and is the only one supportable
//  across all Synopsys libraries
//   
//  If clock gating is not selected the clock tree is totally free of
//  gates. 
// 

// -------------------------------------------------------------------------
// 
//  Ungated clock
// 
   //  The ungated clock is never disabled even if clock gating has been
   //  selected, because it clocks the interfaces of the ARC which need to
   //  react immediately to incoming events. The following modules are
   //  connected to the ungated clock:
   // 
   //     Module          Possible events
   //     ------          ---------------
   //     1.io_flops      Latches IRQ and clear signals
   //     2.int_unit      Services interrupt requests
   //     3.host port     Services host accesses
   //     4.timer(s)      Generates interrupt requests after delay
   //     5.ck_ctrl       Generates ck_disable
   //     6.pdisp         Pipeline Display
   //     7.CCMs          DMI access
   //     8.Clock sync    Synch with system clock
   // 

   assign clk_system  = clk_system_in; 
   assign clk_ungated = clk_in;
   assign  ck_enable  = ~ck_disable; 

// -------------------------------------------------------------------------
// 
//  Main clock
// 
   //  Provided that clock gating has been selected the clock is gated if
   // 
   //    1. The ARC is halted or sleeping
   //    2. There are no loads pending
   //    3. The main memory is not being accessed
   //    4. The host is not accessing the ARC
   //    5. There are no interrupt requests
   //    6. The ARC is not in production test mode
   // 
   //  The signal ck_disable is generated in the clock control module (ck_ctrl).
   //  It is high when cases 1-5 are all true. Case 6 is controlled by the
   //  SCANENABLE signal but this signal only exists after netlist has been generated.
   // 
   assign i_ck_enable_a = ck_enable; 
   
   reg i_ck_enable_a_latched;

   always @*
   begin
     if (!clk_in)
     begin
       i_ck_enable_a_latched <= i_ck_enable_a;
     end

   end


   assign i_ck_dft_a = (clk_in & i_ck_enable_a_latched);
   

   assign clk = i_ck_dft_a;

//--------------------------------------------------------------------------
//
// DMP Clock
//
   // Provided that clock gating has been selected the clock is gated if:
   //
   //   1. The conditions for gating the main clock are true, OR
   //   2. The DMP is idle (even though the main clock is still running).
   //
   
   assign  i_ck_dmp_enable_a  = ~ck_dmp_gated & i_ck_enable_a ;
   
    reg i_ck_dmp_enable_a_latched;    
    always @*
    begin
      if (!clk_in)
      begin
    	i_ck_dmp_enable_a_latched <= i_ck_dmp_enable_a;
      end

    end

   assign i_ck_dmp_dft_a = (clk_in & i_ck_dmp_enable_a_latched );
   

   assign clk_dmp = i_ck_dmp_dft_a;

// -------------------------------------------------------------------------
//  Debug clock
// 
   //  Provided that clock gating has been selected the debug clock is gated if
   // 
   //    1. The ARC is not in production test mode (test_mode = '0')
   //    2. The Enable Debug flag in the debug register (bit 24) is
   //       cleared (en_debug_r = '0').
   // 
   assign i_debug_enable_a = en_debug_r; 

   reg i_debug_enable_a_latched ;
      
   always @*
   begin
     if (!clk_in)
     begin
       i_debug_enable_a_latched <= i_debug_enable_a;
     end

   end

   assign clk_debug = (clk_in & i_debug_enable_a_latched);
   

endmodule // module ck_gen

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2001-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
//
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// The code RAM is instantiated in this file. It has 4 byte
// enables and and 4 clock enables. If your chosen RAM type does
// not have byte enables you need to instantiate 4 byte wide RAM's
// instead. If you only intend to access whole longwords in code
// RAM then byte enables are not necessary. If this is the case,
// it is sufficient to instantiate a single RAM without byte
// enables.
// 
module iccm_ram (
   clk_ungated,
   code_ram_addr,
   code_ram_wdata,
   code_ram_wr,
   code_ram_be,
   code_ram_ck_en,

   code_ram_rdata);

`include "arcutil_pkg_defines.v"
`include "extutil.v"
`include "che_util.v"

input   clk_ungated; 
input   [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] code_ram_addr; 
input   [31:0] code_ram_wdata; 
input   code_ram_wr; 
input   [3:0] code_ram_be; 
input   code_ram_ck_en; 
output  [31:0] code_ram_rdata;
 
wire    [31:0] code_ram_rdata; 
wire    [31:0] i_wdata; 
wire    [31:0] i_rdata; 
wire    [CODE_RAM_ADDR_MSB:CODE_RAM_ADDR_LSB] i_address; 
wire    [3:0] i_we; 
wire    [3:0] i_ck_en; 

//  Assign write data and address
// 
assign i_wdata   = code_ram_wdata; 
assign i_address = code_ram_addr; 

//  Write enables for each RAM (i.e. for each byte)
// 
assign i_we[3] = ((code_ram_wr == CODE_WR_ACTIVE) & 
                  (code_ram_be[3] == 1'b 1)) ? CODE_WR_ACTIVE : 
    CODE_RE_ACTIVE; 

assign i_we[2] = ((code_ram_wr == CODE_WR_ACTIVE) & 
                  (code_ram_be[2] == 1'b 1)) ? CODE_WR_ACTIVE : 
    CODE_RE_ACTIVE; 

assign i_we[1] = ((code_ram_wr == CODE_WR_ACTIVE) & 
                  (code_ram_be[1] == 1'b 1)) ? CODE_WR_ACTIVE : 
    CODE_RE_ACTIVE; 

assign i_we[0] = ((code_ram_wr == CODE_WR_ACTIVE) & 
                  (code_ram_be[0] == 1'b 1)) ? CODE_WR_ACTIVE : 
    CODE_RE_ACTIVE; 

//  Clock enables for each RAM (i.e. for each byte)
// 
assign i_ck_en[3] = ((code_ram_ck_en == CODE_CK_EN_ACTIVE) & 
                     (code_ram_be[3] == 1'b 1)) ? CODE_CK_EN_ACTIVE : 
    ~CODE_CK_EN_ACTIVE; 

assign i_ck_en[2] = ((code_ram_ck_en == CODE_CK_EN_ACTIVE) & 
                     (code_ram_be[2] == 1'b 1)) ? CODE_CK_EN_ACTIVE : 
    ~CODE_CK_EN_ACTIVE; 

assign i_ck_en[1] = ((code_ram_ck_en == CODE_CK_EN_ACTIVE) & 
                     (code_ram_be[1] == 1'b 1)) ? CODE_CK_EN_ACTIVE : 
    ~CODE_CK_EN_ACTIVE; 

assign i_ck_en[0] = ((code_ram_ck_en == CODE_CK_EN_ACTIVE) & 
                     (code_ram_be[0] == 1'b 1)) ? CODE_CK_EN_ACTIVE : 
    ~CODE_CK_EN_ACTIVE; 

assign code_ram_rdata = i_rdata; 

//  Instantiation of RAM
// 
//  Note that the fake RAM cells have
// 
//       * No capacitance
//       * Infinite drive capacity
// 
//  and hence timings should be taken with a pinch of salt.
// 
//  The clock enable signal turns off the RAM ports when not in use
//  to save power. Depending on technology, this may cause time 
//  delays on the critical path. If this is the case and this is not 
//  acceptable, don't connect this signal to the instantiation 
//  of the real RAM.
// 
//  If input signals, we and ck_en, of the real RAM are not active
//  low, as they are for the fake RAM, do not insert an inverter! 
//  Instead, change the code RAM constants in extutil.
// 


fake_iccm U_fake_iccm (.clk(clk_ungated),
                      .address(i_address),
                      .wr_data(i_wdata),
                      .we(i_we),
                      .ck_en(i_ck_en),
                      .rd_data(i_rdata));


endmodule

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// LD/ST RAM wrapper.
// 
// The fake RAM model used here has 4 byte enables. If byte 
// enables do not exist in your chosen technology, replace the 
// fake RAM model with four separate RAM's.
// 

module dccm_ram (clk_ungated,
                 ldst_addr,
                 ldst_din,
                 ldst_mask,
                 ldst_wren,
                 ldst_ck_en,

                 ldst_dout);

`include "arcutil_pkg_defines.v"
`include "extutil.v"
`include "xdefs.v"

input   clk_ungated; 
input   [LDST_A_MSB:0] ldst_addr; 
input   [31:0] ldst_din; 
input   [3:0] ldst_mask; 
input   ldst_wren; 
input   ldst_ck_en; 
output  [31:0] ldst_dout; 

wire    [31:0] ldst_dout;
wire    [LDST_A_MSB:0] i_address;
wire    [31:0] i_wr_data; 
wire    [31:0] i_rd_data; 
reg     [3:0] i_wren; 
wire    [3:0] i_mask; 
reg     [3:0] i_ck_en; 

//  Assign byte enables, address and write data
// 
assign i_mask    = ldst_mask;
assign i_address = ldst_addr; 
assign i_wr_data = ldst_din; 

//  Assign read data output
// 
assign ldst_dout = i_rd_data; 

//  Generate individual clock enable and write enable pins for
//  each byte.
// 
always @(i_mask or ldst_wren or ldst_ck_en)
   begin

   if (i_mask[0] == 1'b 1)
      begin
      i_wren[0]  = ldst_wren;   
      i_ck_en[0] = ldst_ck_en; 
      end
   else
      begin
      i_wren[0]  = ~LDST_WR_ACTIVE;  
      i_ck_en[0] = ~LDST_CK_EN_ACTIVE; 
      end

   if (i_mask[1] == 1'b 1)
      begin
      i_wren[1]  = ldst_wren;   
      i_ck_en[1] = ldst_ck_en; 
      end
   else
      begin
      i_wren[1]  = ~LDST_WR_ACTIVE; 
      i_ck_en[1] = ~LDST_CK_EN_ACTIVE; 
      end

   if (i_mask[2] == 1'b 1)
      begin
      i_wren[2]  = ldst_wren;   
      i_ck_en[2] = ldst_ck_en; 
      end
   else
      begin
      i_wren[2]  = ~LDST_WR_ACTIVE; 
      i_ck_en[2] = ~LDST_CK_EN_ACTIVE; 
      end

   if (i_mask[3] == 1'b 1)
      begin
      i_wren[3]  = ldst_wren;   
      i_ck_en[3] = ldst_ck_en; 
      end
   else
      begin
      i_wren[3]  = ~LDST_WR_ACTIVE; 
      i_ck_en[3] = ~LDST_CK_EN_ACTIVE; 
      end
   end

//  Instantiation of RAM
// 
//  Note that the fake RAM cells have
// 
//       * No capacitance
//       * Infinite drive capacity
// 
//  and hence timings should be taken with a pinch of salt.
// 
//  The clock enable signal turns off the RAM ports when they are not
//  in use to save power. Depending on technology, this may cause 
//  time delays on the critical path. If this is the case and this is
//  not acceptable, don't connect this signal to the instantiation 
//  of the real RAM.
// 
//  If the input signals we and ck_en, of the real RAM, are not active
//  low, as they are for the fake RAM, do not insert an inverter! 
//  Instead, change the RAM constants in extutil.
// 


fake_dccm U_fake_dccm (.clk(clk_ungated),
                      .address(i_address),
                      .wr_data(i_wr_data),
                      .we(i_wren),
                      .ck_en(i_ck_en),
                      .rd_data(i_rd_data));


endmodule

// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module arc_ram(clk_ungated,
               ldst_addr,
               ldst_din,
               ldst_mask,
               ldst_wren,
               ldst_ck_en,
               code_ram_addr,
               code_ram_wdata,
               code_ram_wr,
               code_ram_be,
               code_ram_ck_en,
               ldst_dout,
               code_ram_rdata);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "extutil.v"
`include "xdefs.v"
`include "che_util.v"


input  clk_ungated;
input  [LDST_A_MSB:0]  ldst_addr;
input  [31:0]  ldst_din;
input  [3:0]  ldst_mask;
input  ldst_wren;
input  ldst_ck_en;
input  [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0]  code_ram_addr;
input  [31:0]  code_ram_wdata;
input  code_ram_wr;
input  [3:0]  code_ram_be;
input  code_ram_ck_en;
output [31:0]  ldst_dout;
output [31:0]  code_ram_rdata;

wire clk_ungated;
wire  [LDST_A_MSB:0] ldst_addr;
wire  [31:0] ldst_din;
wire  [3:0] ldst_mask;
wire ldst_wren;
wire ldst_ck_en;
wire  [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] code_ram_addr;
wire  [31:0] code_ram_wdata;
wire code_ram_wr;
wire  [3:0] code_ram_be;
wire code_ram_ck_en;
wire  [31:0] ldst_dout;
wire  [31:0] code_ram_rdata;


// Intermediate signals


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)


// Instantiation of module dccm_ram
dccm_ram idccm_ram(
  .clk_ungated(clk_ungated),
  .ldst_addr(ldst_addr),
  .ldst_din(ldst_din),
  .ldst_mask(ldst_mask),
  .ldst_wren(ldst_wren),
  .ldst_ck_en(ldst_ck_en),
  .ldst_dout(ldst_dout)
);


// Instantiation of module iccm_ram
iccm_ram iiccm_ram(
  .clk_ungated(clk_ungated),
  .code_ram_addr(code_ram_addr),
  .code_ram_wdata(code_ram_wdata),
  .code_ram_wr(code_ram_wr),
  .code_ram_be(code_ram_be),
  .code_ram_ck_en(code_ram_ck_en),
  .code_ram_rdata(code_ram_rdata)
);


// Output drives

endmodule


// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2003-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
//
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// --------------------------------------------------------------- //
// The "bvci_to_ahb" bridge has two functions:                     //
//                                                                 //
// 1) BVCI-initiator to AHB-master protocol conversion             //
// 2) Data path registering (i.e. introducing a pipeline stage)    //
//                                                                 //
// It is important to note that bvci_to_ahb is not a general       //
// purpose protocol translator for BVCI to AHB since a number of   //
// simplications are made according to the known behaviour of      //
// the island internal BVCI initiators. In particular, the         //
// beats in BVCI initiator bursts are assumed to be back-to-back   //
// and so the bridge never needs to generate BUSY transactions     //
// on the AHB bus.                                                 //
//                                                                 //
// The bridge frontend port connects to an island internal BVCI    //
// initiator port. The BVCI signals of the frontend port are       //
// prefixed with "t_". The bridge backend port connects to an AHB  //
// subsytem master port. The AHB signals of the backend port are   //
// prefixed with letter "h". The AMBA specification states that    //
// AHB signal names should be in capital letters. However, in      //
// keeping with ARC's signal naming convention and to comply with  //
// RMM, lower case letters are used instead.                       //
//                                                                 //
// The bridge receives a BVCI cmd, translates it and passes it as  //
// an AHB command, waits to receives the AHB response, and finally //
// translate the response and passes it as a BVCI response. The    //
// bridge has no control over the operation of the BVCI protocol   //
// inside the island or the operation of AHB at the external       //
// memory controller. The AHB Error response is mapped and passed  //
// through to the processor as a BVCI rerror signal.               //
//                                                                 //
// Extension 1:                                                    //
//                                                                 //
// The AHB protocol does not have byte enable signals, instead     //
// HSIZE and the lower bits of the HADDR busses are used to encode //
// the size and offset of a cell transfer. Therefore, only bytes,  //
// halfwords, words and longwords can be written. The BVCI         //
// protocol supports byte enable signals and so is able to write   //
// cells with any byte patterns such as 0000_1110, 1000_0001 or    //
// even 0000_0000. The AHB bridge is extended to cater for such    //
// BVCI byte patterns by splitting the BVCI single cell accesses   //
// to two, three or four AHB accesses whenever required. There is  //
// a separate bus request/grant cycle for each of the split        //
// accesses on the AHB bus and so there is no guarantee that such  //
// AHB write accesses are carried atomically. However, BVCI Locked //
// accesses (resulting from Exchange instruction) are always       //
// carried out atomically - i.e. the HLOCK signal remains asserted //
// throughout the first read and any number of subsequent writes.  //
//                                                                 //
// Extension 2:                                                    //
//                                                                 //
// It is illegal in AHB for bursts to cross 1Kbyte address         //
// boundaries but there is no such restriction in the BVCI         //
// protocol. The AHB bridge is extended to detect 1KByte boundary  //
// crossing BVCI bursts and split them so that the first half runs //
// from the starting address to the boundary address. The AHB bus  //
// is then released and re-requested. Once re-granted the second   //
// half of the burst starts from the boundary address upto the end //
// address.                                                        //
//                                                                 //
// Extension 3:                                                    //
//                                                                 //
// Gate-keeper logic and a buffer is added between the original    //
// Gasket and the BVCI interface so as to handle the situation     //
// where rspack is set to low when a response is valid. The buffer //
// will simply buffer up these responses to be returned to the     //
// BVCI initiator later. In order to prevent the buffer from       //
// overflowing. The gatekeepr logic simply blocks any new packets  //
// from entering the Gasket when there is one or more item in the  //
// buffer. Hence the depth of the FIFO has to be at least the      //
// maximum packet length plus 2. The depth is set by the parameter //
// FIFO_DEPTH. FIFO_PTR_WIDTH has to be set to N such that         //
// 2^N > FIFO_DEPTH. For example, if FIFO_DEPTH = 4, then          //
// FIFO_PTR_WIDTH can be set to 3                                  //
//                                                                 //
// --------------------------------------------------------------- //
// --------------------------------------------------------------- //
// Input and output signals:                                       //
//                                                                 //
// iclk      : in  : module clock signal, processor clock          //
// hclk      : in  : module clock signal, bus clock                //
// rst_a     : in  : module reset signal, processor clock domain   //
// hresetn   : in  : module reset signal, bus clock domain         //
//                                                                 //
// Miscellaneous inputs:                                           //
//                                                                 //
// sync_r    : in  : Synchronization signal from ARC700 bridge     //
//                                                                 //
// BVCI port inputs:                                               //
//                                                                 //
// t_address : in  : BVCI address [31:0]                           //
// t_be      : in  : BVCI byte enables [byte-width:0]              //
// t_cmd     : in  : BVCI command [1:0]                            //
// t_eop     : in  : BVCI end of packet                            //
// t_plen    : in  : BVCI packet length [8:0] (in bytes)           //
// t_wdata   : in  : BVCI write data [data-width:0]                //
// t_cmdval  : in  : BVCI command valid                            //
// t_rspack  : in  : BVCI response acknowledge                     //
//                                                                 //
// AHB protocol port inputs:                                       //
//                                                                 //
// hgrant    : in  : AHB bus grant signal                          //
// hready    : in  : AHB bus ready signal                          //
// hresp     : in  : AHB bus response code [1:0]                   //
// hrdata    : in  : AHB bus read data [data-width:0]              //
//                                                                 //
// BVCI port outputs:                                              //
//                                                                 //
// t_cmdack  : out : BVCI command acknowledge                      //
// t_rdata   : out : BVCI read data [data-width:0]                 //
// t_reop    : out : BVCI response to end of packet                //
// t_rspval  : out : BVCI response valid                           //
// t_rerror  : out : BVCI error                                    //
//                                                                 //
// AHB protocol port outputs:                                      //
//                                                                 //
// hlock     : out : AHB locked access                             //
// htrans    : out : AHB transaction type [1:0]                    //
// haddr     : out : AHB address bus [31:0]                        //
// hwrite    : out : AHB read/write signal                         //
// hsize     : out : AHB data single transfer size [2:0]           //
// hburst    : out : AHB burst type [2:0]                          //
// hprot     : out : AHB protection bus [3:0]                      //
// hwdata    : out : AHB write data bus [data_width:0]             //
//                                                                 //
// Miscellaneous outputs:                                          //
//                                                                 //
// busy      : out : indicates if the bridge is in idle state      //
// --------------------------------------------------------------- //

module ibus_cbri_ahb(
  iclk,
  hclk,
  rst_a,
  hresetn,
  sync_r,
  t_address,
  t_be,
  t_cmd,
  t_eop,
  t_plen,
  t_wdata,
  t_cmdval,
  t_rspack,
  t_mode,
  t_priv,
  t_buffer,
  t_cache,
  hgrant,
  hready,
  hresp,
  hrdata,
  t_cmdack,
  t_rdata,
  t_reop,
  t_rspval,
  t_rerror,
  hbusreq,
  hlock,
  htrans,
  haddr,
  hwrite,
  hsize,
  hburst,
  hprot,
  hwdata,
  busy);

// External parameter
//
parameter C_DATA_WIDTH     = 64;
parameter FIFO_DEPTH       = 8;
parameter FIFO_PTR_WIDTH   = 4;
parameter EXT_A_MSB        = 31;

// Inputs
//
input                      iclk;
input                      hclk;
input                      rst_a;
input                      hresetn;
input                      sync_r;
input   [EXT_A_MSB:0]      t_address;
input   [(C_DATA_WIDTH/8)-1:0] t_be;
input   [1:0]              t_cmd;
input                      t_eop;
input   [8:0]              t_plen;
input   [C_DATA_WIDTH-1:0] t_wdata;
input                      t_cmdval;
input                      t_rspack;
input                      t_mode;
input                      t_priv;
input                      t_buffer;
input                      t_cache;
input                      hgrant;
input                      hready;
input   [1:0]              hresp;
input   [C_DATA_WIDTH-1:0] hrdata;

// Outputs
//
output                     t_cmdack;
output  [C_DATA_WIDTH-1:0] t_rdata;
output                     t_reop;
output                     t_rspval;
output                     t_rerror;
output                     hbusreq;
output                     hlock;
output  [1:0]              htrans;
output  [31:0]             haddr;
output                     hwrite;
output  [2:0]              hsize;
output  [2:0]              hburst;
output  [3:0]              hprot;
output  [C_DATA_WIDTH-1:0] hwdata;
output                     busy;

// Output wires
//
wire                       t_cmdack;
wire    [C_DATA_WIDTH-1:0] t_rdata;
wire                       t_reop;
wire                       t_rspval;
wire                       t_rerror;
wire                       hbusreq;
wire                       hlock;
wire    [1:0]              htrans;
wire    [31:0]             haddr;
wire                       hwrite;
wire    [2:0]              hsize;
wire    [2:0]              hburst;
wire    [3:0]              hprot;
wire    [C_DATA_WIDTH-1:0] hwdata;
wire                       busy;

// Internal parameters
//

// FSM state constants
//
parameter IDLE_STATE = 4'b 0000;
parameter GRNT_STATE = 4'b 0001;
parameter INIT_STATE = 4'b 0010;
parameter ACKN_STATE = 4'b 0011;
parameter WAIT_STATE = 4'b 0100;
parameter LAST_STATE = 4'b 0101;
parameter RTY0_STATE = 4'b 0110;
parameter RTY1_STATE = 4'b 0111;
parameter RTY2_STATE = 4'b 1000;
parameter RSPS_STATE = 4'b 1001;
parameter TRMT_STATE = 4'b 1010;

// AHB parameters
//
parameter AHB_RSP_OKAY    = 2'b 00;
parameter AHB_RSP_ERR     = 2'b 01;
parameter AHB_RSP_SPLIT   = 2'b 11;
parameter AHB_RSP_RETRY   = 2'b 10;

parameter AHB_SNGL_ACC    = 3'b 000;
parameter AHB_UNDF_BRST   = 3'b 001;
parameter AHB_WRAP4_BRST  = 3'b 010;
parameter AHB_INCR4_BRST  = 3'b 011;
parameter AHB_WRAP8_BRST  = 3'b 100;
parameter AHB_INCR8_BRST  = 3'b 101;
parameter AHB_WRAP16_BRST = 3'b 110;
parameter AHB_INCR16_BRST = 3'b 111;

parameter AHB_SIZE_8      = 3'b 000;
parameter AHB_SIZE_16     = 3'b 001;
parameter AHB_SIZE_32     = 3'b 010;
parameter AHB_SIZE_64     = 3'b 011;

parameter AHB_TRANS_IDLE  = 2'b 00;
parameter AHB_TRANS_NSEQ  = 2'b 10;
parameter AHB_TRANS_SEQ   = 2'b 11;

// Non-cacheable, non-bufferable, privileged data access
//
parameter AHB_PROT_NNPD   = 4'b 0011;

// BVCI commands
//
parameter BVCI_WR_CMD     = 2'b 10; // WRITE
parameter BVCI_LR_CMD     = 2'b 11; // LOCKED_READ

// Parameters to define the number of separate AHB single cell 
// writes for each single cell BVCI write
//
parameter SGL_0_AHB       = 3'b 000; // no    ahb accesses
parameter SGL_1_AHB       = 3'b 001; // one   ahb access
parameter SGL_2_AHB       = 3'b 010; // two   ahb accesses
parameter SGL_3_AHB       = 3'b 011; // three ahb accesses
parameter SGL_4_AHB       = 3'b 100; // four  ahb accesses

// Parameters to define the size of single cell AHB wirtes
//
parameter SGL_0_BYTE      = 2'b 00;  // no    bytes
parameter SGL_1_BYTE      = 2'b 01;  // one   byte
parameter SGL_2_BYTE      = 2'b 10;  // two   bytes
parameter SGL_4_BYTE      = 2'b 11;  // four  bytes
parameter SGL_8_BYTE      = 3'b 100; // eight bytes

parameter FIFO_WIDTH = C_DATA_WIDTH + 2;

// All internal signals have the "i_" prefix. This should not 
// be confused with "i_" prefix that is sometimes used for BVCI 
// initiator signals. There are no BVCI initiator signals in this
// module.

// Control signals
//
wire                    i_t_cmdval_sync;   //  synchronised version
wire                    i_bvci_cmd_a;      //  BVCI cmd received
wire                    i_ahb_rsp_a;       //  AHB rsp received
wire                    i_ahb_grant_a;     //  AHB bus granted

// FSM current state
//
reg  [3:0]              i_state_r;
reg  [3:0]              i_state_nxt;

// t_cmdack and t_rspval flipflops (not synchronised)
//
reg                     i_t_cmdack_r;
reg                     i_t_cmdack_nxt;
reg                     i_t_rspval_r;
reg                     i_t_rspval_nxt;

// Bus request, hwrite, hlock, reop, old buffer valid, 
// top buffer valid, restarted, wrap burst, last access,
// htrans type, hsize, and burst type flip flops
//
reg                     i_hbusreq_r;
reg                     i_hbusreq_nxt;
reg                     i_hwrite_r;
reg                     i_hwrite_nxt;
reg                     i_t_reop_r;
reg                     i_t_reop_nxt;
reg                     i_last_nxt;
reg                     i_last_r;
reg                     i_old_valid_r;
reg                     i_old_valid_nxt;
reg                     i_top_valid_r;
reg                     i_top_valid_nxt;
reg                     i_restarted_r;
reg                     i_restarted_nxt;
wire                    i_wrap_a;
reg                     i_wrap_r;
reg                     i_wrap_nxt;
reg  [1:0]              i_htrans_r;
reg  [1:0]              i_htrans_nxt;
reg  [2:0]              i_hsize_r;
reg  [2:0]              i_hsize_nxt;
reg  [2:0]              i_hburst_r;
reg  [2:0]              i_hburst_nxt;
reg                     i_hlock_r;
reg                     i_hlock_nxt;
reg                     i_atomic_r;
reg                     i_atomic_nxt;

// Signals for mapping BVCI to AHB signals
//
reg  [31:0]             i_haddr_a;
wire [C_DATA_WIDTH-1:0] i_hwdata_a;
wire [3:0]              i_hprot_a;
reg  [2:0]              i_hburst_a;

// Registers for storing the outstanding (translated) BVCI 
// signals
//
reg  [31:0]             i_haddr_top_r;
reg  [C_DATA_WIDTH-1:0] i_hwdata_top_r;
reg                     i_eop_top_r;
reg  [3:0]              i_hprot_r;
reg  [31:0]             i_haddr_top_nxt;
reg  [C_DATA_WIDTH-1:0] i_hwdata_top_nxt;
reg                     i_eop_top_nxt;
reg  [3:0]              i_hprot_nxt;

// Registers for keeping the current (translated) BVCI 
// signals
//
reg  [31:0]             i_haddr_out_r;
reg  [C_DATA_WIDTH-1:0] i_hwdata_out_r;
reg                     i_eop_out_r;
reg  [31:0]             i_haddr_out_nxt;
reg  [C_DATA_WIDTH-1:0] i_hwdata_out_nxt;
reg                     i_eop_out_nxt;

// Registers for saving the previous (translated) BVCI 
// signals
//
reg  [31:0]             i_haddr_old_r;
reg  [C_DATA_WIDTH-1:0] i_hwdata_old_r;
reg                     i_eop_old_r;
reg  [31:0]             i_haddr_old_nxt;
reg  [C_DATA_WIDTH-1:0] i_hwdata_old_nxt;
reg                     i_eop_old_nxt;

// Signals for mapping AHB to BVCI signals
//
wire [C_DATA_WIDTH-1:0] i_t_rdata_a;
wire                    i_t_rerror_a;

// Registers for keeping the current (translated) AHB 
// signal
//
reg  [C_DATA_WIDTH-1:0] i_t_rdata_r;
reg  [C_DATA_WIDTH-1:0] i_t_rdata_nxt;
reg                     i_t_rerror_r;
reg                     i_t_rerror_nxt;

// AHB transaction return response signals
//
wire                    i_okay_rsp_a;
wire                    i_err_rsp_a;
wire                    i_retry_rsp_a;
wire                    i_retry_a; // not qualified with hready

// Asserted if a bvci write command
//
wire                    i_bvci_write_a;

// Signals to detect the next sequential AHB address value and
// if a wrapped burst is re-started
//
wire [10:0]             i_addr_inc_a;
wire                    i_wrap_restart_a;

// Signals to indicate if the next address from various sources
// to go on the bus is non-sequential to the last address
//
wire                    i_bvci_nseq_a;
wire                    i_top_nseq_a;
wire                    i_old_nseq_a;

// The write data lags one cycle behind the write address
// and control signals
//
reg  [C_DATA_WIDTH-1:0] i_hwdata_lagged_r;

// Registers and wires for converting single cell BVCI writes to 
// one to four AHB single cell writes
//
wire [1:0]              i_num_lo_wr_a;
wire [2:0]              i_num_ahb_wr_a;
wire [2:0]              i_outstanding_a;
wire [1:0]              i_outstand_wr_a;
reg  [1:0]              i_outstand_wr_r;
reg  [1:0]              i_outstand_wr_nxt;
wire [1:0]              i_outstand_wr_minus1_a;
reg                     i_null_byte_r;
reg                     i_null_byte_nxt;
wire [1:0]              i_1st_id_sz_a;
wire [2:0]              i_1st_wr_sz_a;
wire [1:0]              i_1st_wr_off_a;
wire [1:0]              i_2nd_id_sz_a;
wire [1:0]              i_2nd_wr_sz_a;
reg  [1:0]              i_2nd_wr_sz_r;
reg  [1:0]              i_2nd_wr_sz_nxt;
wire [1:0]              i_2nd_wr_off_a;
reg  [1:0]              i_2nd_wr_off_r;
reg  [1:0]              i_2nd_wr_off_nxt;
reg                     i_byte_split_r;
reg                     i_byte_split_nxt;


// Wires for detecting 1K byte boundary crossing - illegal in AHB
// but allowed in BVCI - the BVCI burst is split
//
wire   [8:0]            i_brst_end_addr_a;
wire                    i_1k_bnd_cross_a;
reg                     i_1k_sbrst_r;
reg                     i_1k_sbrst_nxt;

// Wires and registers to implement the Response buffer
wire                    b_t_cmdval;
wire                    b_t_cmdack;
wire                    b_t_rspval;
wire                    b_t_reop;
wire                    b_t_rerror;
wire [C_DATA_WIDTH-1:0] b_t_rdata;

wire [FIFO_WIDTH - 1:0] fifo_in_a;     //  input to fifo
wire                    fifo_ld_a;     //  load fifo
wire                    fifo_unld_a;   //  unload fifo
reg                     fifo_empty_r;  //  fifo empty status bit
reg                     fifo_full_r;   //  fifo full status bit
wire [FIFO_WIDTH - 1:0] fifo_out_a;    //  fifo output

reg  [((FIFO_DEPTH * FIFO_WIDTH) - 1):0] fifo_regs_r;  // array of fifo regs
reg  [FIFO_PTR_WIDTH - 1:0] fifo_wr_ptr_ctr_r;  // counter for write ptr
wire [FIFO_PTR_WIDTH - 1:0] fifo_wr_ptr;        // write pointer
reg                     cmd_pass_r;
integer                 ilp; 
integer                 jlp; 
integer                 klp;

// Function to determine the number of AHB writes for 32 bit of a 
// single cell BVCI write
//
function [1:0] num_ahb32_wr;
input [3:0] be;
  begin
  case (be)
    4'b 0000: num_ahb32_wr = 2'b 00;
    4'b 0001,
    4'b 0010,
    4'b 0100,
    4'b 1000,
    4'b 0011,
    4'b 1100,
    4'b 1111: num_ahb32_wr = 2'b 01;
    default : num_ahb32_wr = 2'b 10;
  endcase
  end
endfunction

// Function to determine the size of the first AHB write resulting
// from a single cell BVCI write
//
function [1:0] size_1st_wr;
input [3:0] be;
  begin
  case (be)
    4'b 0000: size_1st_wr = SGL_0_BYTE;
    4'b 1111: size_1st_wr = SGL_4_BYTE;
    4'b 0011,
    4'b 1100,
    4'b 1011,
    4'b 0111: size_1st_wr = SGL_2_BYTE;
    default:  size_1st_wr = SGL_1_BYTE;
  endcase
  end
endfunction

// Function to determine the size of the second AHB write 
// resulting from a single cell BVCI write
//
function [1:0] size_2nd_wr;
input [3:0] be;
  begin
  case (be)
    4'b 1101,
    4'b 1110: size_2nd_wr = SGL_2_BYTE;
    4'b 0101,
    4'b 0110,
    4'b 0111,
    4'b 1001,
    4'b 1010,
    4'b 1011: size_2nd_wr = SGL_1_BYTE;
    default:  size_2nd_wr = SGL_0_BYTE;
  endcase
  end
endfunction

// Function to determine the offset of the first AHB write 
// resulting from a single cell BVCI write
//
function [1:0] off_1st_wr;
input [3:0] be;
  begin
  case (be)
  4'b 0010,
  4'b 0110,
  4'b 1010,
  4'b 1110: off_1st_wr = 2'b 01;
  4'b 0100,
  4'b 1100: off_1st_wr = 2'b 10;
  4'b 1000: off_1st_wr = 2'b 11;
  default:  off_1st_wr = 2'b 00;
  endcase
  end
endfunction

// Function to determine the offset of the second AHB write 
// resulting from a single cell BVCI write
//
function [1:0] off_2nd_wr;
input [3:0] be;
  begin
  case (be)
  4'b 0101,
  4'b 0110,
  4'b 0111,
  4'b 1101,
  4'b 1110: off_2nd_wr = 2'b 10;
  4'b 1001,
  4'b 1010,
  4'b 1011: off_2nd_wr = 2'b 11;
  default:  off_2nd_wr = 2'b 00;
  endcase
  end
endfunction



// function to convert internal size encoding to AHB HSIZE
//
function [2:0] to_ahb_size;
input [2:0] size;
  begin
  case (size)
    {1'b 0, SGL_1_BYTE}: to_ahb_size = AHB_SIZE_8;
    {1'b 0, SGL_2_BYTE}: to_ahb_size = AHB_SIZE_16;
    {1'b 0, SGL_4_BYTE}: to_ahb_size = AHB_SIZE_32;
    default:             to_ahb_size = AHB_SIZE_64;
  endcase
  end
endfunction

// function to evaluate the size of AHB read access
//
function [2:0] ahb_read_size;
input [8:0] plen;
input [1:0] offset;
  begin
  case (plen)
    9'b 000000001: ahb_read_size = AHB_SIZE_8;
    9'b 000000010:
      case (offset)
        2'b 00,
        2'b 10:  ahb_read_size = AHB_SIZE_16;
        default: ahb_read_size = AHB_SIZE_32;
      endcase
    default: ahb_read_size = AHB_SIZE_32;
  endcase
  end
endfunction

// function to evaluate the offset of AHB read access
//
function [1:0] ahb_read_offset;
input [8:0] plen;
input [1:0] offset;
  begin
  case (plen)
    9'b 000000001: ahb_read_offset = offset;
    9'b 000000010:
      case (offset)
        2'b 00,
        2'b 10:  ahb_read_offset = offset;
        default: ahb_read_offset = 2'b 00;
      endcase
    default: ahb_read_offset = 2'b 00;
  endcase
  end
endfunction

//  asynchronous part of FSM
//
always @(
  i_eop_top_r     or
  i_haddr_top_r   or
  i_hwdata_top_r  or
  i_eop_out_r     or
  i_haddr_out_r   or
  i_hwdata_out_r  or
  i_eop_old_r     or
  i_haddr_old_r   or
  i_hwdata_old_r  or
  i_t_rdata_r     or
  i_t_rerror_r    or
  i_last_r        or
  i_t_reop_r      or
  i_hsize_r       or
  i_hwrite_r      or
  i_hlock_r       or
  i_hprot_r       or  
  i_atomic_r      or
  i_htrans_r      or
  i_hburst_r      or
  i_hbusreq_r     or
  i_old_valid_r   or
  i_top_valid_r   or
  i_wrap_r        or
  i_restarted_r   or
  i_t_cmdack_r    or
  i_t_rspval_r    or
  i_1k_sbrst_r    or
  i_null_byte_r   or
  i_outstand_wr_r or
  i_2nd_wr_sz_r   or
  i_2nd_wr_off_r  or
  i_byte_split_r  or
  i_state_r       or
  t_priv          or
  t_mode          or
  t_cache         or
  t_buffer        or
  hgrant          or
  hready          or
  t_cmd           or
  t_eop           or
  t_plen          or
  i_t_rdata_a     or
  i_t_rerror_a    or
  i_haddr_a       or
  i_hwdata_a      or
  i_hburst_a      or
  i_bvci_cmd_a    or
  i_wrap_a        or
  i_bvci_nseq_a   or
  i_top_nseq_a    or
  i_old_nseq_a    or
  i_ahb_rsp_a     or
  i_ahb_grant_a   or
  i_retry_a       or
  i_retry_rsp_a   or
  i_bvci_write_a  or
  i_num_ahb_wr_a  or
  i_1st_wr_sz_a   or
  i_1st_wr_off_a  or
  i_2nd_wr_sz_a   or
  i_2nd_wr_off_a  or
  i_outstand_wr_a or
  i_outstand_wr_minus1_a)

  begin : ASYNC_FSM_PROC

  // keep current values unless explicitly updated later
  // in this block
  //
  i_eop_top_nxt     = i_eop_top_r;
  i_haddr_top_nxt   = i_haddr_top_r;
  i_hwdata_top_nxt  = i_hwdata_top_r;
  i_eop_out_nxt     = i_eop_out_r;
  i_haddr_out_nxt   = i_haddr_out_r;
  i_hwdata_out_nxt  = i_hwdata_out_r;
  i_eop_old_nxt     = i_eop_old_r;
  i_haddr_old_nxt   = i_haddr_old_r;
  i_hwdata_old_nxt  = i_hwdata_old_r;
  i_t_rdata_nxt     = i_t_rdata_r;
  i_t_rerror_nxt    = i_t_rerror_r;
  i_t_reop_nxt      = i_t_reop_r;
  i_last_nxt        = i_last_r;
  i_restarted_nxt   = i_restarted_r;
  i_wrap_nxt        = i_wrap_r;
  i_hsize_nxt       = i_hsize_r;
  i_hwrite_nxt      = i_hwrite_r;
  i_hlock_nxt       = i_hlock_r;
  i_atomic_nxt      = i_atomic_r;
  i_htrans_nxt      = i_htrans_r;
  i_hprot_nxt       = i_hprot_r;  
  i_hburst_nxt      = i_hburst_r;
  i_hbusreq_nxt     = i_hbusreq_r;
  i_old_valid_nxt   = i_old_valid_r;
  i_top_valid_nxt   = i_top_valid_r;
  i_t_cmdack_nxt    = i_t_cmdack_r;
  i_t_rspval_nxt    = i_t_rspval_r;
  i_1k_sbrst_nxt    = i_1k_sbrst_r;
  i_null_byte_nxt   = i_null_byte_r;
  i_outstand_wr_nxt = i_outstand_wr_r;
  i_2nd_wr_sz_nxt   = i_2nd_wr_sz_r;
  i_2nd_wr_off_nxt  = i_2nd_wr_off_r;
  i_byte_split_nxt  = i_byte_split_r;
  i_state_nxt       = i_state_r;

  case (i_state_r)

  // ---------- //
  // IDLE state //
  // ---------- //
  //
  // wait until there is a bvci cmd and if so register
  // the translated details of the transaction, put it on
  // the local AHB bus and request access to the slave AHB
  // bus. There are three sets of registers; "top" stores
  // any outstanding transactions that can not go on the AHB
  // bus immediately, "out" keeps the current transaction
  // that is on the AHB bus and "old" saves the previously
  // translated transaction that was on the AHB. When there
  // is a new BVCI command and no AHB response then the
  // new transaction will stored in "top". Whenever "out"
  // changes then its old value is stored in "old" to be
  // reused in case of an AHB retry.
  // Extension 1: check if any outstanding access remaining 
  // from the previous BVCI write access and if so handle 
  // then first.
  // 
  IDLE_STATE:
    begin
    if (i_outstand_wr_r == 2'b 0)
      begin
      i_byte_split_nxt = 1'b 0;
      if (i_bvci_cmd_a == 1'b 1)
        begin
	  i_hprot_nxt = {t_cache, t_buffer, t_priv, t_mode};
        if (t_eop == 1'b 1)
          begin
          i_hburst_nxt = AHB_SNGL_ACC;
          end
        else
          begin
          i_hburst_nxt = i_hburst_a;
          end
        if (t_cmd == BVCI_LR_CMD)
          begin
          i_hlock_nxt  = 1'b 1;
          i_atomic_nxt = 1'b 1;
          end
        i_eop_out_nxt    = t_eop;        //  out <- BVCI
        i_hwdata_out_nxt = i_hwdata_a;   //  out <- BVCI
        i_hwrite_nxt     = i_bvci_write_a;
        i_t_cmdack_nxt   = 1'b 0;
        i_1k_sbrst_nxt   = i_haddr_a[10];// starting addr bit 10
        if (i_bvci_write_a == 1'b 1)
          begin
          if (i_num_ahb_wr_a == 3'b 0)
            begin
            i_hbusreq_nxt     = 1'b 0;
            i_haddr_out_nxt   = i_haddr_a;  //  out <- BVCI
            i_null_byte_nxt   = 1'b 1;
            i_outstand_wr_nxt = 2'b 0;
            i_state_nxt       = LAST_STATE;            
            end
          else
            begin
            i_hbusreq_nxt     = 1'b 1;
            i_haddr_out_nxt   = {i_haddr_a[31:2],i_1st_wr_off_a}; //  out <- BVCI
            i_hsize_nxt       = to_ahb_size(i_1st_wr_sz_a);
            i_2nd_wr_sz_nxt   = i_2nd_wr_sz_a;
            i_2nd_wr_off_nxt  = i_2nd_wr_off_a;
            i_outstand_wr_nxt = i_outstand_wr_a;
            i_byte_split_nxt  = i_outstand_wr_a != 2'b 0; 
            i_state_nxt       = GRNT_STATE;
            end
          end
        else
          begin
          i_haddr_out_nxt   = {i_haddr_a[31:2],         //  out <- BVCI
                               ahb_read_offset(t_plen, i_haddr_a[1:0])};  
          i_hsize_nxt       =    ahb_read_size(t_plen, i_haddr_a[1:0]);
          i_hbusreq_nxt     = 1'b 1;
          i_outstand_wr_nxt = SGL_0_AHB;
          i_state_nxt       = GRNT_STATE;
          end
        end
      else
        begin
        i_hbusreq_nxt   = i_hlock_r;
        i_last_nxt      = 1'b 0;
        i_t_reop_nxt    = 1'b 0;
        i_t_cmdack_nxt  = 1'b 1;
        i_old_valid_nxt = 1'b 0;
        i_top_valid_nxt = 1'b 0;
        i_t_rspval_nxt  = 1'b 0;
        i_t_rerror_nxt  = 1'b 0;
        end
      end
    else // if there are outstanding writes
      begin
      i_outstand_wr_nxt = i_outstand_wr_minus1_a;
      if (i_2nd_wr_sz_r != 2'b 0)
        begin
        i_hsize_nxt     = to_ahb_size(i_2nd_wr_sz_r);
        i_haddr_out_nxt = {i_haddr_out_r[31:2], i_2nd_wr_off_r};
        i_2nd_wr_sz_nxt = 2'b 0;
        end
      i_hburst_nxt   = AHB_SNGL_ACC;
      i_hwrite_nxt   = 1'b 1;
      i_hbusreq_nxt  = 1'b 1;
      i_eop_out_nxt  = 1'b 1;
      i_t_cmdack_nxt = 1'b 0;
      i_state_nxt    = GRNT_STATE;
      end
    i_htrans_nxt    = AHB_TRANS_IDLE;
    i_restarted_nxt = 1'b 0;
    i_wrap_nxt      = i_wrap_a;
    end // case: IDLE_STATE

  // ----------- //
  // GRANT state //
  // ----------- //
  //
  // wait until granted the bus and then start the first
  // non sequential transaction on AHB.
  //
  GRNT_STATE:
    begin
    if ((i_ahb_grant_a == 1'b 1) ||
        ((i_atomic_r   == 1'b 0) &&
         (i_hlock_r    == 1'b 1)))
      begin
      if (i_top_valid_r == 1'b 1)
        begin
        i_t_cmdack_nxt = 1'b 0;
        end
      else
        begin
        i_t_cmdack_nxt = ~i_eop_out_r;
        end
      i_htrans_nxt = AHB_TRANS_NSEQ;
      i_state_nxt  = INIT_STATE;
      if ((i_hburst_r != AHB_UNDF_BRST) &&
          (i_hlock_r  == 1'b 0))
        begin
        i_hbusreq_nxt = 1'b 0;
        end
      end
    else
      begin
      i_t_cmdack_nxt = 1'b 0;
      end
    i_t_rspval_nxt = 1'b 0;
    end // case: GRNT_STATE

  // --------------- //
  // INITIAL 0 state //
  // --------------- //
  //
  // if hready is high then for single accesses go to LAST
  // state else for bursts either put out the new BVCI 
  // command or put out the saved BVCI command. if grant
  // has gone low then go to TRMT state.
  // 
  INIT_STATE:
    begin
    if (hready == 1'b 1)
      begin
      if (i_eop_out_r == 1'b 1)
        begin
        i_hbusreq_nxt = i_hlock_r;
        i_last_nxt    = 1'b 1;
        i_htrans_nxt  = AHB_TRANS_IDLE;
        i_state_nxt   = LAST_STATE;
        end
      else
        begin
        if (i_bvci_cmd_a == 1'b 1)
          begin
          i_eop_out_nxt    = t_eop;      //  out <- BVCI
          i_haddr_out_nxt  = i_haddr_a;  //  out <- BVCI
          i_hwdata_out_nxt = i_hwdata_a; //  out <- BVCI
          i_t_cmdack_nxt   = ~t_eop;
          end
        else
          begin
          i_eop_out_nxt    = i_eop_top_r;    //  out <- top
          i_haddr_out_nxt  = i_haddr_top_r;  //  out <- top
          i_hwdata_out_nxt = i_hwdata_top_r; //  out <- top
          i_t_cmdack_nxt   = ~i_eop_top_r;
          i_top_valid_nxt  = 1'b 0;
          end
        i_eop_old_nxt    = i_eop_out_r;    //  old <- out
        i_haddr_old_nxt  = i_haddr_out_r;  //  old <- out
        i_hwdata_old_nxt = i_hwdata_out_r; //  old <- out
        i_old_valid_nxt  = 1'b 1;
        if ((hgrant == 1'b 0)                                     ||
            ((i_bvci_cmd_a == 1'b 1) && (i_bvci_nseq_a == 1'b 1)) ||
            ((i_bvci_cmd_a == 1'b 0) && (i_top_nseq_a  == 1'b 1)) )
          begin
          i_hbusreq_nxt   = 1'b 0;
          i_t_cmdack_nxt  = 1'b 0;
          i_htrans_nxt    = AHB_TRANS_IDLE;
          i_state_nxt     = TRMT_STATE;
          end
        else
          begin
          i_htrans_nxt = AHB_TRANS_SEQ;
          i_state_nxt  = ACKN_STATE;
          end
        end
      end
    else
      begin
      if (i_bvci_cmd_a == 1'b 1)
        begin
        i_eop_top_nxt    = t_eop;      //  top <- BVCI
        i_haddr_top_nxt  = i_haddr_a;  //  top <- BVCI
        i_hwdata_top_nxt = i_hwdata_a; //  top <- BVCI
        i_top_valid_nxt  = 1'b 1;
        end
      i_t_cmdack_nxt = 1'b 0;
      end
    end // case: INIT_STATE
     
  // --------------------- //
  // ACKNOWLEDGEMENT state //
  // --------------------- //
  //
  // if there is a retry response then start the RTY
  // sequence else if early burst termination then goto
  // the TRMT state. Else take suitable action depending
  // on whether there is a new bvci command or a new AHB
  // response. Note that if there is no AHB response and
  // grant has gone away then will go to TRMT via RSPS
  // state.
  //
  ACKN_STATE:
    begin
    if (i_retry_a == 1'b 1)
      begin
      if (i_bvci_cmd_a == 1'b 1)
        begin
        i_eop_top_nxt    = t_eop;      //  top <- BVCI
        i_haddr_top_nxt  = i_haddr_a;  //  top <- BVCI
        i_hwdata_top_nxt = i_hwdata_a; //  top <- BVCI
        i_top_valid_nxt  = 1'b 1;
        end
      i_hbusreq_nxt  = 1'b 0;
      i_t_cmdack_nxt = 1'b 0;
      i_t_rspval_nxt = 1'b 0;
      i_htrans_nxt   = AHB_TRANS_IDLE;
      i_state_nxt    = RTY0_STATE;
      end
    else // i_retry_a='0'
      begin
      if (i_ahb_rsp_a == 1'b 1)
        begin
        i_t_rdata_nxt  = i_t_rdata_a;
        i_t_rerror_nxt = i_t_rerror_a;
        if (i_bvci_cmd_a == 1'b 1)
          begin
          i_eop_out_nxt    = t_eop;          //  out <- BVCI
          i_haddr_out_nxt  = i_haddr_a;      //  out <- BVCI
          i_hwdata_out_nxt = i_hwdata_a;     //  out <- BVCI
          i_eop_old_nxt    = i_eop_out_r;    //  old <- out
          i_haddr_old_nxt  = i_haddr_out_r;  //  old <- out
          i_hwdata_old_nxt = i_hwdata_out_r; //  old <- out
          i_old_valid_nxt  = 1'b 1;
          end
        if ((hgrant == 1'b 0) ||
           ((i_bvci_cmd_a == 1'b 1) && (i_bvci_nseq_a == 1'b 1)))
          begin
          if (i_bvci_cmd_a == 1'b 0)
            begin
            i_last_nxt = i_eop_out_r;
            end
          i_hbusreq_nxt   = 1'b 0;
          i_t_cmdack_nxt  = 1'b 0;
          i_htrans_nxt    = AHB_TRANS_IDLE;
          i_state_nxt     = TRMT_STATE;
          end
        else //  hgrant='1'
          begin
          if (i_bvci_cmd_a == 1'b 1)
            begin
            i_t_cmdack_nxt = ~t_eop;
            i_state_nxt = ACKN_STATE;
            end
          else //  i_bvci_cmd_a='0'
            begin
            if (i_eop_out_r == 1'b 1)
              begin
              i_hbusreq_nxt = 1'b 0;
              i_last_nxt    = 1'b 1;
              i_htrans_nxt  = AHB_TRANS_IDLE;
              i_state_nxt   = LAST_STATE;
              end
            else
              begin
              i_state_nxt = ACKN_STATE;
              end
            i_t_cmdack_nxt = 1'b 0;
            end
          end
        end
      else //  i_ahb_rsp_a=0
        begin
        if (i_bvci_cmd_a == 1'b 1)
          begin
          i_eop_top_nxt    = t_eop;      //  top <- BVCI
          i_haddr_top_nxt  = i_haddr_a;  //  top <- BVCI
          i_hwdata_top_nxt = i_hwdata_a; //  top <- BVCI
          i_top_valid_nxt  = 1'b 1;
          end
        if (hgrant == 1'b 0)
          begin
          i_hbusreq_nxt  = 1'b 0;
          i_t_cmdack_nxt = 1'b 0;
          i_state_nxt    = RSPS_STATE;
          end
        else //  hgrant='1'
          begin
          if (i_bvci_cmd_a == 1'b 1)
            begin
            i_t_cmdack_nxt = 1'b 0;
            i_state_nxt    = WAIT_STATE;
            end
          else //  i_bvci_cmd_a='0'
            begin
            i_t_cmdack_nxt = ~i_eop_out_r;
            end
          end
        end

        i_t_rspval_nxt = i_ahb_rsp_a;
      end
    end // case: ACKN_STATE

  // ---------- //
  // WAIT STATE //
  // ---------- //
  //
  //  if there is a retry response then start the RTY
  //  sequence. if early bus termination then goto 
  //  TRMT state, else wait until receive AHB response
  //  and go back to ACKN state. Note that if there is no
  //  AHB response and grant has gone away then will go
  //  to TRMT via RSPS state.
  // 
  WAIT_STATE:
    begin
    if (i_retry_a == 1'b 1)
      begin
      i_hbusreq_nxt = 1'b 0;
      i_htrans_nxt  = AHB_TRANS_IDLE;
      i_state_nxt   = RTY0_STATE;
      end
    else //  i_retry_a='0'
      begin
      if (i_ahb_rsp_a == 1'b 1)
        begin
        i_eop_out_nxt    = i_eop_top_r;    //  out <- top
        i_haddr_out_nxt  = i_haddr_top_r;  //  out <- top
        i_hwdata_out_nxt = i_hwdata_top_r; //  out <- top
        i_eop_old_nxt    = i_eop_out_r;    //  old <- out
        i_haddr_old_nxt  = i_haddr_out_r;  //  old <- out
        i_hwdata_old_nxt = i_hwdata_out_r; //  old <- out
        i_old_valid_nxt  = 1'b 1;
        i_top_valid_nxt  = 1'b 0;
        i_t_rdata_nxt    = i_t_rdata_a;
        i_t_rerror_nxt   = i_t_rerror_a;
        if ((hgrant == 1'b 0) || (i_top_nseq_a == 1'b 1))
          begin
          i_hbusreq_nxt   = 1'b 0;
          i_t_cmdack_nxt  = 1'b 0;
          i_htrans_nxt    = AHB_TRANS_IDLE;
          i_state_nxt     = TRMT_STATE;
          end
        else //  hgrant='1'
          begin
          i_t_cmdack_nxt = ~i_eop_top_r;
          i_state_nxt = ACKN_STATE;
          end
        end
      else
        begin
        if (hgrant == 1'b 0)
          begin
          i_hbusreq_nxt = 1'b 0;
          i_state_nxt = RSPS_STATE;
          end
        end
      i_t_rspval_nxt = i_ahb_rsp_a;
      end
    end // case: WAIT_STATE

  // ---------- //
  // LAST STATE //
  // ---------- //
  //
  // if there is a retry response then start the retry
  // sequence else for either single accesses or bursts
  // wait for the final response before going back to  
  // the IDLE state.
  // Extension 1: Do not signal the end of BVCI response
  // if there are outstanding AHB access remaining from the
  // current BVCI access
  //
  LAST_STATE:
    begin
    if (i_null_byte_r == 1'b 1)
      begin
      i_t_reop_nxt    = 1'b 1;
      i_t_rspval_nxt  = 1'b 1;
      i_t_rerror_nxt  = 1'b 0;
      i_null_byte_nxt = 1'b 0;
      i_state_nxt     = IDLE_STATE;
      end
    else
      begin
      if (i_retry_a == 1'b 1)
        begin
        i_hbusreq_nxt  = i_hlock_r;
        i_t_rspval_nxt = 1'b 0;
        i_htrans_nxt   = AHB_TRANS_IDLE;
        i_state_nxt    = RTY0_STATE;
        end
      else //  i_retry_a='0'
        begin
        if (i_ahb_rsp_a == 1'b 1)
          begin
          if (i_atomic_r == 1'b 1)
            begin
            i_atomic_nxt  = 1'b 0;
            end
          else
            begin
            i_hbusreq_nxt = 1'b 0;
            if (i_outstand_wr_r == 2'b 0)
              begin
              if (i_hlock_r == 1'b 1)
                begin
                i_hlock_nxt = 1'b 0;
                end
              end
            end
          if (i_outstand_wr_r == 2'b 0)
            begin
            i_t_reop_nxt   = i_eop_out_r;
            i_t_rspval_nxt = 1'b 1;
            end
          else
            begin
            i_t_reop_nxt   = 1'b 0;
            i_t_rspval_nxt = 1'b 0;
            end
          if (i_byte_split_r == 1'b 0)
            begin
            i_t_rerror_nxt = i_t_rerror_a;
            end
          else
            begin
            i_t_rerror_nxt = i_t_rerror_a | i_t_rerror_r;
            end
          i_t_rdata_nxt  = i_t_rdata_a;
          i_state_nxt    = IDLE_STATE;
          end
        else
          begin
          i_t_rspval_nxt = 1'b 0;  
          end
        end
      end
    end // case: LAST_STATE

  // ------------- //
  // RETRY 0 state //
  // ------------- //
  //
  // wait for the slave retry response final cycle before
  // swapping "old" and "out" buffers (if necessary) and
  // re-requesting the bus.
  //  
  RTY0_STATE:
    begin
    i_restarted_nxt = 1'b 1;
    if (i_retry_rsp_a == 1'b 1)
      begin
      if ((i_old_valid_r == 1'b 1) && (i_last_r == 1'b 0))
        begin
        i_eop_out_nxt    = i_eop_old_r;    //  out <- old
        i_haddr_out_nxt  = i_haddr_old_r;  //  out <- old
        i_hwdata_out_nxt = i_hwdata_old_r; //  out <- old
        i_eop_old_nxt    = i_eop_out_r;    //  old <- out
        i_haddr_old_nxt  = i_haddr_out_r;  //  old <- out
        i_hwdata_old_nxt = i_hwdata_out_r; //  old <- out
        end
      if (i_hburst_r != AHB_SNGL_ACC)
        begin
        i_hburst_nxt = AHB_UNDF_BRST;
        end
      i_hbusreq_nxt = 1'b 1;
      i_state_nxt   = RTY1_STATE;
      end
    end // case: RTY0_STATE

  // ------------- //
  // RETRY 1 state //
  // ------------- //
  //
  // wait until re-granted the bus and start the 
  // re-try transfer before moving to the final retry 
  // sequence state.
  // 
  RTY1_STATE:
    begin
    if (i_ahb_grant_a == 1'b 1)
      begin
      i_htrans_nxt = AHB_TRANS_NSEQ;
      i_state_nxt  = RTY2_STATE;
      end
    end

  // ------------- //
  // RETRY 2 state //
  // ------------- //
  //
  // if single access then goto LAST state else swap "old"
  // and "out" buffers (if necessary). if there is an 
  // outstanding transaction in "top" the go the WAIT else
  // to ACKN state. If grant has gone away then go to TRMT
  // state.
  //
  RTY2_STATE:
    begin
    if (hready == 1'b 1)
      begin
      if (i_last_r == 1'b 1)
        begin
        i_hbusreq_nxt = i_hlock_r;   
        i_htrans_nxt  = AHB_TRANS_IDLE;   
        i_state_nxt   = LAST_STATE;   
        end
      else
        begin
        i_eop_out_nxt    = i_eop_old_r;    //  out <- old
        i_haddr_out_nxt  = i_haddr_old_r;  //  out <- old
        i_hwdata_out_nxt = i_hwdata_old_r; //  out <- old
        i_eop_old_nxt    = i_eop_out_r;    //  old <- out
        i_haddr_old_nxt  = i_haddr_out_r;  //  old <- out
        i_hwdata_old_nxt = i_hwdata_out_r; //  old <- out
        i_old_valid_nxt   = 1'b 1;
        if ((hgrant == 1'b 0) || (i_old_nseq_a == 1'b 1))
          begin
          i_hbusreq_nxt   = 1'b 0;
          i_htrans_nxt    = AHB_TRANS_IDLE;   
          i_state_nxt     = TRMT_STATE;   
          end
        else //  hgrant='1'
          begin
          i_htrans_nxt = AHB_TRANS_SEQ;   
          if (i_top_valid_r == 1'b 1)
            begin
            i_t_cmdack_nxt = 1'b 0;   
            i_state_nxt    = WAIT_STATE;   
            end
          else
            begin
            i_t_cmdack_nxt = ~i_eop_old_r;   
            i_state_nxt    = ACKN_STATE;   
            end
          end
        end
      end
    end // case: RTY2_STATE

  // -------------- //
  // RESPONSE state //
  // -------------- //
  //
  // Start a retry sequence if there is a retry response
  // else wait for response for the previous access before 
  // moving to TRMT state.
  //
  RSPS_STATE:
    begin
    if (i_retry_a == 1'b 1)
      begin
      i_htrans_nxt = AHB_TRANS_IDLE;  
      i_state_nxt = RTY0_STATE;
      end
    else
      begin
      if (i_ahb_rsp_a == 1'b 1)
        begin
        if (i_top_valid_r == 1'b 1)
          begin
          i_eop_out_nxt    = i_eop_top_r;    //  out <- top
          i_haddr_out_nxt  = i_haddr_top_r;  //  out <- top
          i_hwdata_out_nxt = i_hwdata_top_r; //  out <- top
          i_eop_old_nxt    = i_eop_out_r;    //  old <- out
          i_haddr_old_nxt  = i_haddr_out_r;  //  old <- out
          i_hwdata_old_nxt = i_hwdata_out_r; //  old <- out
          i_old_valid_nxt  = 1'b 1;   
          i_top_valid_nxt  = 1'b 0;   
          end
        else
          begin
          i_old_valid_nxt = 1'b 0;
          i_last_nxt      = i_eop_out_r;
          end
        i_t_rdata_nxt   = i_t_rdata_a;
        i_t_rerror_nxt  = i_t_rerror_a;
        i_t_rspval_nxt  = 1'b 1;
        i_t_cmdack_nxt  = 1'b 0;
        i_htrans_nxt    = AHB_TRANS_IDLE;
        i_state_nxt     = TRMT_STATE;
        end
      end
    end // case: RSPS_STATE

  // -------------------- //
  // BUS TERMINATED state //
  // -------------------- //
  //
  // if retry then start a retry sequence else wait for
  // a response and move to IDLE if it was the last state
  // else re-request the bus and move to GRNT state. Note
  // that if a retry then that means the previous access 
  // did not go through so the sequence of events would 
  // be identical to a normal retry sequence.
  //
  TRMT_STATE:
    begin
    i_restarted_nxt = 1'b 1;
    if (i_retry_a == 1'b 1)
      begin
      i_t_rspval_nxt = 1'b 0;
      i_htrans_nxt   = AHB_TRANS_IDLE;
      i_state_nxt    = RTY0_STATE;
      end
    else
      begin
      if (i_ahb_rsp_a == 1'b 1)
        begin
        i_t_rdata_nxt   = i_t_rdata_a;
        i_t_rerror_nxt  = i_t_rerror_a;
        i_old_valid_nxt = 1'b 0;
        if (i_last_r == 1'b 1)
          begin
          i_t_reop_nxt = 1'b 1;
          i_state_nxt  = IDLE_STATE;
          end
        else
          begin
          if (i_hburst_r != AHB_SNGL_ACC)
            begin
            i_hburst_nxt = AHB_UNDF_BRST;
            end
          i_hbusreq_nxt = 1'b 1;
          i_state_nxt   = GRNT_STATE;
          end
        end
      i_t_rspval_nxt = i_ahb_rsp_a;
      end
    end // case: TRMT_STATE

  // ------------- //
  // default state //
  // ------------- //
  //
  default:
    begin
    i_t_rerror_nxt = 1'b 1;
    i_state_nxt    = IDLE_STATE;
    end

  endcase
  end // block: ASYNC_FSM_PROC
   
// synchronous part of FSM
//
always @(posedge hclk or negedge hresetn)
  begin : SYNC_FSM_PROC
  if (hresetn == 1'b 0)
    begin
    i_eop_top_r     <= 1'b 0;
    i_haddr_top_r   <= {32 {1'b 0}};
    i_hwdata_top_r  <= {(C_DATA_WIDTH){1'b 0}};
    i_eop_out_r     <= 1'b 0;
    i_haddr_out_r   <= {32 {1'b 0}};
    i_hwdata_out_r  <= {(C_DATA_WIDTH){1'b 0}};
    i_eop_old_r     <= 1'b 0;
    i_haddr_old_r   <= {32 {1'b 0}};
    i_hwdata_old_r  <= {(C_DATA_WIDTH){1'b 0}};
    i_t_rerror_r    <= 1'b 0;
    i_t_rdata_r     <= {(C_DATA_WIDTH){1'b 0}};
    i_t_reop_r      <= 1'b 0;
    i_last_r        <= 1'b 0;
    i_restarted_r   <= 1'b 0;
    i_wrap_r        <= 1'b 0;
    i_hsize_r       <= 3'b 000;
    i_hwrite_r      <= 1'b 0;
    i_hlock_r       <= 1'b 0;
    i_hprot_r       <= 4'b 0000;
    i_atomic_r      <= 1'b 0;
    i_htrans_r      <= 2'b 00;
    i_hburst_r      <= 3'b 000;
    i_hbusreq_r     <= 1'b 0;
    i_old_valid_r   <= 1'b 0;
    i_top_valid_r   <= 1'b 0;
    i_t_cmdack_r    <= 1'b 0;
    i_t_rspval_r    <= 1'b 0;
    i_1k_sbrst_r    <= 1'b 0;
    i_null_byte_r   <= 1'b 0;
    i_outstand_wr_r <= 2'b 00;
    i_2nd_wr_sz_r   <= 2'b 00;
    i_2nd_wr_off_r  <= 2'b 00;
    i_byte_split_r  <= 1'b 0;
    i_state_r       <= IDLE_STATE;   
    end
  else
    begin
    //  update the FSM flipflops with new values from
    //  the async part of FSM.
    //
    i_eop_top_r     <= i_eop_top_nxt;
    i_haddr_top_r   <= i_haddr_top_nxt;
    i_hwdata_top_r  <= i_hwdata_top_nxt;
    i_eop_out_r     <= i_eop_out_nxt;
    i_haddr_out_r   <= i_haddr_out_nxt;
    i_hwdata_out_r  <= i_hwdata_out_nxt;
    i_eop_old_r     <= i_eop_old_nxt;
    i_haddr_old_r   <= i_haddr_old_nxt;
    i_hwdata_old_r  <= i_hwdata_old_nxt;
    i_t_rdata_r     <= i_t_rdata_nxt;
    i_t_rerror_r    <= i_t_rerror_nxt;
    i_t_reop_r      <= i_t_reop_nxt;
    i_last_r        <= i_last_nxt;
    i_restarted_r   <= i_restarted_nxt;
    i_wrap_r        <= i_wrap_nxt;
    i_hsize_r       <= i_hsize_nxt;
    i_hwrite_r      <= i_hwrite_nxt;
    i_hlock_r       <= i_hlock_nxt;
    i_hprot_r       <= i_hprot_nxt;
    i_atomic_r      <= i_atomic_nxt;
    i_htrans_r      <= i_htrans_nxt;
    i_hburst_r      <= i_hburst_nxt;
    i_hbusreq_r     <= i_hbusreq_nxt;
    i_old_valid_r   <= i_old_valid_nxt;
    i_top_valid_r   <= i_top_valid_nxt;
    i_t_cmdack_r    <= i_t_cmdack_nxt;
    i_t_rspval_r    <= i_t_rspval_nxt;
    i_1k_sbrst_r    <= i_1k_sbrst_nxt;
    i_null_byte_r   <= i_null_byte_nxt;
    i_outstand_wr_r <= i_outstand_wr_nxt;
    i_2nd_wr_sz_r   <= i_2nd_wr_sz_nxt;
    i_2nd_wr_off_r  <= i_2nd_wr_off_nxt;
    i_byte_split_r  <= i_byte_split_nxt;
    i_state_r       <= i_state_nxt;
    end
  end // block: SYNC_FSM_PROC

// --------------------------------------------- //
// register process to ensure that the data lags //
// one cycle behind the the write address and    //
// controll signals                              //
// --------------------------------------------- //
//
always @(posedge hclk or negedge hresetn)
  begin : WDATA_LAG_PROC
  if (hresetn == 1'b 0)
    begin
    i_hwdata_lagged_r <= {(C_DATA_WIDTH){1'b 0}};
    end
  else
    begin
    if (hready == 1'b 1)
      begin
      i_hwdata_lagged_r <= i_hwdata_out_r;
      end
    end
  end // block: WDATA_LAG_PROC

// ---------------------- //
// control/output signals //
// ---------------------- //

// Evaluate the number of AHB writes for the BVCI single cell 
// write and work out their sizes and offsets
//
assign i_num_lo_wr_a  = num_ahb32_wr (t_be[3:0]);
assign i_1st_id_sz_a  = size_1st_wr  (t_be[3:0]);
assign i_2nd_id_sz_a  = size_2nd_wr  (t_be[3:0]);
assign i_1st_wr_off_a = off_1st_wr   (t_be[3:0]);
assign i_2nd_wr_off_a = off_2nd_wr   (t_be[3:0]);

assign i_num_ahb_wr_a = {1'b 0, i_num_lo_wr_a};
assign i_1st_wr_sz_a  = (i_1st_id_sz_a == 2'b 00) ? 
                        {1'b 0, i_2nd_id_sz_a}:
                        {1'b 0, i_1st_id_sz_a};
assign i_2nd_wr_sz_a  =  (i_1st_id_sz_a == 2'b 00)  ? 2'b 00:
                        i_2nd_id_sz_a;

assign i_outstanding_a = i_num_ahb_wr_a - 3'b 1;
assign i_outstand_wr_a = i_outstanding_a[1:0];
assign i_outstand_wr_minus1_a = i_outstand_wr_r - 2'b 1;

//  BVCI input/output signal synchronization
//
assign i_t_cmdval_sync = b_t_cmdval & sync_r;

//  FSM control input signals
//
assign i_okay_rsp_a  = (hresp == AHB_RSP_OKAY) ? 1'b 1 : 1'b 0; 
assign i_err_rsp_a   = (hresp == AHB_RSP_ERR ) ? 1'b 1 : 1'b 0; 
assign i_retry_rsp_a = ((hready == 1'b 1) && 
                        ((hresp == AHB_RSP_SPLIT) || 
                         (hresp == AHB_RSP_RETRY))) ? 
                       1'b 1 : 1'b 0;
 
assign i_retry_a     = ((hresp == AHB_RSP_SPLIT) ||
                        (hresp == AHB_RSP_RETRY)) 
                       ? 1'b 1 : 1'b 0;

assign i_bvci_cmd_a   = i_t_cmdval_sync & i_t_cmdack_r;
assign i_bvci_write_a = (t_cmd == BVCI_WR_CMD) ? 1'b 1 : 1'b 0;
assign i_ahb_grant_a  = hgrant & hready;
assign i_ahb_rsp_a    = hready & (i_okay_rsp_a | i_err_rsp_a);

//  BVCI to AHB signal mapping
//
assign i_hprot_a  = AHB_PROT_NNPD;
assign i_hwdata_a = t_wdata;

// assign ahb address and clear unused address bits
//
always @(t_address)
   begin : ADDR_ASSIGN_PROC
   i_haddr_a[EXT_A_MSB:0] = t_address[EXT_A_MSB:0];   
   for (klp = 31; klp > EXT_A_MSB; klp = klp - 1)
     begin
     i_haddr_a[klp] = 1'b 0;   
     end
   end

// map BVCI PLEN signal to AHB HBUSRT signal
//
always @(t_plen or t_address or i_1k_bnd_cross_a)
  begin : AHB_BURST_PROC
  if (i_1k_bnd_cross_a == 1'b 1)
    begin
    i_hburst_a = AHB_UNDF_BRST;
    end
  else
    begin
    case (t_plen)
      9'b 000010000: 
        begin 
        i_hburst_a = AHB_INCR4_BRST;
        end
      9'b 000100000: 
        begin 
        i_hburst_a = AHB_INCR8_BRST;
        end
      9'b 001000000: 
        begin 
        i_hburst_a = AHB_INCR16_BRST; 
        end
      default:       
        begin 
        i_hburst_a = AHB_UNDF_BRST;
        end
    endcase
    end
  end // block: AHB_BURST_PROC

assign i_brst_end_addr_a = i_haddr_a[10:2]+({2'b 0, t_plen[8:2]}-9'b 1);
assign i_1k_bnd_cross_a  = i_haddr_a[10] != i_brst_end_addr_a[8];
assign i_addr_inc_a      = {(i_haddr_out_r [10:2] + 9'b 1), 2'b 00};

assign i_wrap_a         = ((i_hburst_a == AHB_WRAP4_BRST) ||
                           (i_hburst_a == AHB_WRAP8_BRST) ||
                           (i_hburst_a == AHB_WRAP16_BRST))
                           ? 1'b 1 : 1'b 0;

assign i_wrap_restart_a = i_wrap_r & i_restarted_r;

assign i_bvci_nseq_a    = (((i_addr_inc_a[6:0] != i_haddr_a[6:0]) &&
                            (i_wrap_restart_a  == 1'b 1))          ||
                           (i_1k_sbrst_r       != i_haddr_a[10]))
                          ? 1'b 1 : 1'b 0;
assign i_top_nseq_a     = (((i_addr_inc_a[6:0] != i_haddr_top_r[6:0]) &&
                            (i_wrap_restart_a  == 1'b 1))             ||
                           (i_1k_sbrst_r       != i_haddr_top_r[10]))
                          ? 1'b 1 : 1'b 0;
assign i_old_nseq_a     = (((i_addr_inc_a[6:0] != i_haddr_old_r[6:0]) &&
                            (i_wrap_restart_a  == 1'b 1))             ||
                           (i_1k_sbrst_r       != i_haddr_old_r[10]))
                          ? 1'b 1 : 1'b 0;

//  AHB to BVCI signal mapping
//
assign i_t_rdata_a  = hrdata; 
assign i_t_rerror_a = i_err_rsp_a;

//  BVCI target outputs
//
assign b_t_cmdack = i_t_cmdack_r & sync_r;
assign b_t_rspval = i_t_rspval_r & sync_r;
assign b_t_reop   = i_t_reop_r   & sync_r;
assign b_t_rerror = i_t_rerror_r & sync_r;
assign b_t_rdata  = i_t_rdata_r;

//  AHB master outputs
//
assign haddr    = i_haddr_out_r;
assign hwdata   = i_hwdata_lagged_r;
assign hsize    = i_hsize_r;
assign hwrite   = i_hwrite_r;
assign hburst   = i_hburst_r;
assign htrans   = i_htrans_r;
assign hbusreq  = i_hbusreq_r;
assign hlock    = i_hlock_r;
//assign hprot    = i_hprot_a; //  constant
assign hprot    = i_hprot_r; //  constant

//  bridge busy when FSM not in idle state
//
assign busy = ((i_state_r    == IDLE_STATE) &&
               (i_outstand_wr_r == 2'b 00 ) &&
               (i_bvci_cmd_a == 1'b 0     ) &&
               (fifo_empty_r == 1'b 1     ) &&
               (i_t_rspval_r == 1'b 0     )) ? 1'b 0 : 1'b 1; 

// -----------------------------------------------------------------------------
// Buffer to deal with rsp_ack issue
// -----------------------------------------------------------------------------

  // ---- Registers ------------------------------------------------------------

  always @(posedge iclk or posedge rst_a)
  begin
    if (rst_a == 1'b1)
    begin
      cmd_pass_r        <= 1'b0;
      fifo_wr_ptr_ctr_r <= {(FIFO_PTR_WIDTH){1'b0}};
      fifo_full_r       <= 1'b0;
      fifo_empty_r      <= 1'b1;
      for (ilp = FIFO_DEPTH - 1; ilp >= 0; ilp = ilp - 1)
        for (jlp = FIFO_WIDTH - 1; jlp >= 0; jlp = jlp - 1)
          fifo_regs_r[(ilp * FIFO_WIDTH) + jlp] <= 1'b 0;   
    end
    else
    begin

      // unload fifo
      if ((fifo_unld_a == 1'b1)&&(fifo_empty_r == 1'b0))
      begin
        for (ilp = FIFO_DEPTH - 2; ilp >= 0; ilp = ilp - 1)
          for (jlp = FIFO_WIDTH - 1; jlp >= 0; jlp = jlp - 1)
            fifo_regs_r[(ilp*FIFO_WIDTH)+jlp] 
              <= fifo_regs_r[(ilp*FIFO_WIDTH)+FIFO_WIDTH+jlp];
      end
      
      // load fifo
      if (   (fifo_ld_a == 1'b1)
          && (   (fifo_unld_a == 1'b0)
              || (fifo_empty_r == 1'b0)))
      begin
        for (ilp = FIFO_DEPTH - 1; ilp >= 0; ilp = ilp - 1)
        begin
          if (ilp == fifo_wr_ptr)//  Formality 2002.05 workaround
            for (jlp = FIFO_WIDTH - 1; jlp >= 0; jlp = jlp - 1)
              fifo_regs_r[(ilp * FIFO_WIDTH) + jlp] <= fifo_in_a[jlp];   
        end
      end

      // FIFO write pointer register
      if ((fifo_ld_a == 1'b1)&&(fifo_unld_a == 1'b0))
        fifo_wr_ptr_ctr_r <= fifo_wr_ptr_ctr_r + 1'b1;
      else if (   (fifo_ld_a == 1'b0)
               && (fifo_unld_a == 1'b1)
               && ((|fifo_wr_ptr_ctr_r) == 1'b1))
        fifo_wr_ptr_ctr_r <= fifo_wr_ptr_ctr_r - 1'b1;
      
      // Full signal
      if (   (fifo_wr_ptr_ctr_r == (FIFO_DEPTH - 1'b1))
          && (fifo_ld_a == 1'b1)
          && (fifo_unld_a == 1'b0))
        fifo_full_r <= 1'b1;
      else if (   (fifo_ld_a == 1'b0)
               && (fifo_unld_a == 1'b1))
        fifo_full_r <= 1'b0;
      
      // Empty Signal
      if (   (fifo_wr_ptr_ctr_r == 1)
          && (fifo_ld_a == 1'b0) 
          && (fifo_unld_a == 1'b1))
        fifo_empty_r <= 1'b1;
      else if (   (fifo_ld_a == 1'b1)
               && (fifo_unld_a == 1'b0))
        fifo_empty_r <= 1'b0;
      
      // ---- Command bus pass signal register -----
      //      the 'cmd_pss_r' signal is normally high to allow command
      //      bus to flow. However, if buffer starts filling because 
      //      rspack == 0 and the current command is
      //      the last cell of a packet, this register is cleared and is only
      //      reset when rspack == 1 and FIFO is empty
      if (   (cmd_pass_r == 1'b1)
          && (fifo_empty_r == 1'b0)
          && (   (t_cmdval == 1'b0)
              || ((t_eop == 1'b1) && (b_t_cmdack == 1'b1))))
        cmd_pass_r <= 1'b0;
      else if (   (cmd_pass_r == 1'b0)
               && (fifo_empty_r == 1'b1))
        cmd_pass_r <= 1'b1;
       
    end
  end

  // ---- assigns --------------------------------------------------------------

  assign fifo_out_a  = (fifo_empty_r == 1'b0)? fifo_regs_r[FIFO_WIDTH -1 : 0]:
                                               fifo_in_a;

  assign fifo_wr_ptr = ((fifo_ld_a == 1'b1)&&(fifo_unld_a == 1'b1))? 
                            fifo_wr_ptr_ctr_r - 1'b1 : fifo_wr_ptr_ctr_r;

  assign fifo_in_a   = {b_t_reop, b_t_rerror, b_t_rdata};  

  assign fifo_ld_a   = b_t_rspval;

  assign fifo_unld_a = t_rspack;
  
  assign t_cmdack    = b_t_cmdack & cmd_pass_r;
  
  assign t_rspval    = b_t_rspval | ~fifo_empty_r;

  assign t_reop      = fifo_out_a[FIFO_WIDTH -1];

  assign t_rerror    = fifo_out_a[FIFO_WIDTH -2];

  assign t_rdata     = fifo_out_a[FIFO_WIDTH -3 : 0];
  
  assign b_t_cmdval  = t_cmdval & cmd_pass_r;

endmodule // module ibus_cbri_ahb
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
module ibus_isyn (

//  INPUTS ========================================================

//  System Bus Error Inputs ---------------------------------------

  sys_bus_error,

//  Internal Bus Error Inputs -------------------------------------
  iarb_rerror,
  iarb_rspval,
  iarb_rspack,

//  OUTPUTS =======================================================

//  Re-Sync and Extended Bus Error Interrupt ----------------------

  ext_bus_error

);

input   sys_bus_error; 
input   iarb_rerror; 
input   iarb_rspval; 
input   iarb_rspack; 
output  ext_bus_error; 

wire    ext_bus_error; 

//  ============================================================================
//  SIGNAL DECLARATIONS 
//  ============================================================================

wire    comb_bus_error; 

//  ============================================================================
//  ARCHITECTURE
//  ============================================================================

//  Re-synchronisation is not required
//  instead, this module will now only combine the exception signals.

//  Combining all bus errors -------------------------------------------------

assign comb_bus_error = sys_bus_error | 
                        (iarb_rerror & iarb_rspval & iarb_rspack); 
assign ext_bus_error  = comb_bus_error; 

endmodule // module ibus_isyn

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
module ibus_iarb (

   // INPUTS =========================================================
    
   // clocks and resets ----------------------------------------------

   clk,
   rst_a,

   // Target Port 0 with Highest Prioirty ----------------------------
   t0_address,
   t0_be,
   t0_cmd,
   t0_eop,
   t0_plen,
   t0_wdata,
   t0_cmdval,
   t0_rspack,
   t0_priv,
   t0_buffer,
   t0_cache,
   t0_mode,
   // Target Port 1 with High Priority -------------------------------
   t1_address,
   t1_be,
   t1_cmd,
   t1_eop,
   t1_plen,
   t1_wdata,
   t1_cmdval,
   t1_rspack,
   t1_priv,
   t1_buffer,
   t1_cache,
   t1_mode,
   // Target Port 2 with Medium Priority -----------------------------
   t2_address,
   t2_be,
   t2_cmd,
   t2_eop,
   t2_plen,
   t2_wdata,
   t2_cmdval,
   t2_rspack,
   t2_priv,
   t2_buffer,
   t2_cache,
   t2_mode,
   // Target Port 3 with Low Priority --------------------------------
   t3_address,
   t3_be,
   t3_cmd,
   t3_eop,
   t3_plen,
   t3_wdata,
   t3_cmdval,
   t3_rspack,
   t3_priv,
   t3_buffer,
   t3_cache,
   t3_mode,

   // Target Port 4 with Lowest Priority -----------------------------
   t4_address,
   t4_be,
   t4_cmd,
   t4_eop,
   t4_plen,
   t4_wdata,
   t4_cmdval,
   t4_rspack,
   t4_priv,
   t4_buffer,
   t4_cache,
   t4_mode,

   // Initiator Port -------------------------------------------------
   i_cmdack,
   i_rdata,
   i_reop,
   i_rspval,

   // OUTPUTS ========================================================

   // Target Port 0 with Highest Prioirty ----------------------------
   t0_cmdack,
   t0_rdata,
   t0_reop,
   t0_rspval,

   // Target Port 0 with High Prioirty -------------------------------
   t1_cmdack,
   t1_rdata,
   t1_reop,
   t1_rspval,

   // Target Port 0 with Medium Prioirty -----------------------------
   t2_cmdack,
   t2_rdata,
   t2_reop,
   t2_rspval,

   // Target Port 0 with Low Prioirty --------------------------------
   t3_cmdack,
   t3_rdata,
   t3_reop,
   t3_rspval,

   // Target Port 0 with Lowest Priority -----------------------------
   t4_cmdack,
   t4_rdata,
   t4_reop,
   t4_rspval,

   // Initiator Port -------------------------------------------------
   i_address,
   i_be,
   i_cmd,
   i_eop,
   i_plen,
   i_wdata,
   i_cmdval,
   i_rspack,
   i_buffer,
   i_priv,
   i_cache,
   i_mode,
   // Busy signal ----------------------------------------------------
   iarb_busy

);

parameter ADDR_WIDTH = 32;
parameter DATA_WIDTH = 64;
parameter BE_WIDTH   = 8;
parameter FIFO_DEPTH = 4;


//  INPUTS =========================================================

//  clocks and resets ----------------------------------------------
input   clk; 
input   rst_a; 
//  Target Port 0 with Highest Priority ----------------------------
input   [ADDR_WIDTH - 1:0] t0_address; 
input   [BE_WIDTH-1:0] t0_be; 
input   [1:0] t0_cmd; 
input   t0_eop; 
input   [8:0] t0_plen; 
input   [DATA_WIDTH - 1:0] t0_wdata; 
input   t0_cmdval; 
input   t0_rspack; 
input   t0_cache; 
input   t0_priv; 
input   t0_buffer; 
input   t0_mode; 
 
//  Target Port 1 with High Priority -------------------------------
input   [ADDR_WIDTH - 1:0] t1_address; 
input   [BE_WIDTH-1:0] t1_be; 
input   [1:0] t1_cmd; 
input   t1_eop; 
input   [8:0] t1_plen; 
input   [DATA_WIDTH - 1:0] t1_wdata; 
input   t1_cmdval; 
input   t1_rspack; 
input   t1_cache; 
input   t1_priv; 
input   t1_buffer; 
input   t1_mode; 
 
//  Target Port 2 with Medium Priority -----------------------------
input   [ADDR_WIDTH - 1:0] t2_address; 
input   [BE_WIDTH-1:0] t2_be; 
input   [1:0] t2_cmd; 
input   t2_eop; 
input   [8:0] t2_plen; 
input   [DATA_WIDTH - 1:0] t2_wdata; 
input   t2_cmdval; 
input   t2_rspack; 
input   t2_cache; 
input   t2_priv; 
input   t2_buffer; 
input   t2_mode; 
 
//  Target Port 3 with Low Priority --------------------------------
input   [ADDR_WIDTH - 1:0] t3_address; 
input   [BE_WIDTH-1:0] t3_be; 
input   [1:0] t3_cmd; 
input   t3_eop; 
input   [8:0] t3_plen; 
input   [DATA_WIDTH - 1:0] t3_wdata; 
input   t3_cmdval; 
input   t3_rspack; 
input   t3_cache; 
input   t3_priv; 
input   t3_buffer; 
input   t3_mode; 
 
//  Target Port 4 with Lowest Priority -----------------------------
input   [ADDR_WIDTH - 1:0] t4_address; 
input   [BE_WIDTH-1:0] t4_be; 
input   [1:0] t4_cmd; 
input   t4_eop; 
input   [8:0] t4_plen; 
input   [DATA_WIDTH - 1:0] t4_wdata; 
input   t4_cmdval; 
input   t4_rspack; 
input   t4_cache; 
input   t4_priv; 
input   t4_buffer; 
input   t4_mode; 
 
//  Initiator Port -------------------------------------------------
input   i_cmdack; 
input   [DATA_WIDTH - 1:0] i_rdata; 
input   i_reop; 
input   i_rspval; 

//  OUTPUTS ========================================================

//  Target Port 0 with Highest Priority ----------------------------
output   t0_cmdack; 
output   [DATA_WIDTH - 1:0] t0_rdata; 
output   t0_reop; 
output   t0_rspval; 
//  Target Port 2 with Medium Priority -----------------------------
output   t1_cmdack; 
output   [DATA_WIDTH - 1:0] t1_rdata; 
output   t1_reop; 
output   t1_rspval; 
//  Target Port 2 with Medium Priority -----------------------------
output   t2_cmdack; 
output   [DATA_WIDTH - 1:0] t2_rdata; 
output   t2_reop; 
output   t2_rspval; 
//  Target Port 3 with Low Priority --------------------------------
output   t3_cmdack; 
output   [DATA_WIDTH - 1:0] t3_rdata; 
output   t3_reop; 
output   t3_rspval; 
//  Target Port 4 with Lowest Priority -----------------------------
output   t4_cmdack; 
output   [DATA_WIDTH - 1:0] t4_rdata; 
output   t4_reop; 
output   t4_rspval; 
//  Initiator Port -------------------------------------------------
output   [ADDR_WIDTH - 1:0] i_address; 
output   [BE_WIDTH-1:0] i_be; 
output   [1:0] i_cmd; 
output   i_eop; 
output   [8:0] i_plen; 
output   [DATA_WIDTH - 1:0] i_wdata; 
output   i_cmdval; 
output   i_rspack; 
//  Busy signal ----------------------------------------------------
output   iarb_busy; 
output   i_cache; 
output   i_priv; 
output   i_buffer; 
output   i_mode; 
 
reg     t0_cmdack; 
wire    [DATA_WIDTH - 1:0] t0_rdata; 
wire    t0_reop; 
reg     t0_rspval; 
reg     t1_cmdack; 
wire    [DATA_WIDTH - 1:0] t1_rdata; 
wire    t1_reop; 
reg     t1_rspval; 
reg     t2_cmdack; 
wire    [DATA_WIDTH - 1:0] t2_rdata; 
wire    t2_reop; 
reg     t2_rspval; 
reg     t3_cmdack; 
wire    [DATA_WIDTH - 1:0] t3_rdata; 
wire    t3_reop; 
reg     t3_rspval; 
reg     t4_cmdack; 
wire    [DATA_WIDTH - 1:0] t4_rdata; 
wire    t4_reop; 
reg     t4_rspval; 
reg     [ADDR_WIDTH - 1:0] i_address; 
reg     [BE_WIDTH-1:0] i_be; 
wire    [1:0] i_cmd; 
wire    i_eop; 
reg     [8:0] i_plen; 
reg     [DATA_WIDTH - 1:0] i_wdata; 
wire    i_cmdval; 
wire    i_rspack; 
wire    iarb_busy; 
reg    i_cache; 
reg    i_priv; 
reg    i_buffer; 
reg    i_mode; 
 

// ============================================================================
// CONSTANT DECLARATIONS 
// ============================================================================

parameter FIFO_WIDTH     = 3;    //  Width of FIFO. 
parameter FIFO_PTR_WIDTH = 3;    //  Pointer counter width.
parameter CMD_ST_ARB     = 1'b0; //  Command Control ARB state
parameter CMD_ST_HOLD    = 1'b1; //  Command Control HOLD state

//  ============================================================================
//  SIGNAL DECLARATIONS 
//  ============================================================================

//  Command Arbitrator
wire    [FIFO_WIDTH - 1:0] cmd_arb; 
reg     [FIFO_WIDTH - 1:0] cmd_arb_hold_r; 
reg     [FIFO_WIDTH - 1:0] cmd_sel; 
reg                        cmd_state_r; 
reg                        cmd_lock_r; 
reg                        cmd_inhibit_n; 
reg                        cmd_load; 
reg                        cmd_state_next;
reg                        cmd_lock_next; 
reg     [FIFO_WIDTH - 1:0] cmd_arb_hold_next; 
reg                        i_eop_int; 
reg                        i_cmdval_int_r; 
reg     [1:0]              i_cmd_int;   

//  Packet Tracking FIFO
wire                                    fifo_full; 
wire                                    fifo_load; 
wire                                    fifo_unload;
reg     [FIFO_DEPTH * FIFO_WIDTH - 1:0] fifo_regs_r; 
wire    [FIFO_WIDTH - 1:0]              fifo_in; 
wire    [FIFO_WIDTH - 1:0]              fifo_out;
reg     [FIFO_PTR_WIDTH - 1:0]          fifo_ptr_r; 
wire    [FIFO_PTR_WIDTH - 1:0]          fifo_ptr_m1; 
wire    [FIFO_PTR_WIDTH - 1:0]          fifo_ptr_p1; 
wire    [FIFO_PTR_WIDTH - 1:0]          fifo_ptr_muxed; 
wire                                    fifo_empty_n;

//  Response Switch
wire    [FIFO_WIDTH - 1:0] rsp_sel; 
wire                       rsp_unload; 
reg                        i_rspack_int_r; 

integer  dcnt; 
integer  wcnt;

//  ============================================================================
//  ARCHITECTURE
//  ============================================================================

//  ------------------------------------------------------------------------
//  Command Arbitrartor ----------------------------------------------------
//  ------------------------------------------------------------------------

//  Arbitration Logic ------------------------------------------------------
//  t0 has highest priority
//  t2 has lowest priority
//                                          T4  T3  T2  T1  T0  cmd_arb

assign cmd_arb[0] =  (   t1_cmdval 
                      & ~t0_cmdval)      //  X   X   X   1   0     001
                    |(   t3_cmdval
                      & ~t2_cmdval
                      & ~t1_cmdval
                      & ~t0_cmdval);     //  X   1   0   0   0     011

assign cmd_arb[1] =  (   t2_cmdval
                      & ~t1_cmdval
                      & ~t0_cmdval)      //  X   X   1   0   0     010
                    |(   t3_cmdval
                      & ~t2_cmdval
                      & ~t1_cmdval
                      & ~t0_cmdval);     //  X   1   0   0   0     011

assign cmd_arb[2] =  (   t4_cmdval
                      & ~t3_cmdval
                      & ~t2_cmdval
                      & ~t1_cmdval
                      & ~t0_cmdval);     //  1   0   0   0   0     100

//  Command cell mulitplexer and inhibitor ---------------------------------

always @(    t0_address
          or t0_be
          or t0_cmd
          or t0_eop
          or t0_plen
          or t0_wdata
          or t0_cache 
          or t0_priv
          or t0_buffer 
          or t0_mode 
 	  
          or t1_address 	  
          or t1_be 
          or t1_cmd 
          or t1_eop
          or t1_plen 
          or t1_wdata
          or t1_cache 
          or t1_priv
          or t1_buffer 
          or t1_mode 
 	  
          or t2_address 
          or t2_be 
          or t2_cmd
          or t2_eop 
          or t2_plen 
          or t2_wdata
          or t2_cache 
          or t2_priv
          or t2_buffer 
          or t2_mode 
	   
          or t3_address 
          or t3_be
          or t3_cmd 
          or t3_eop 
          or t3_plen 
          or t3_wdata
          or t3_cache 
          or t3_priv
          or t3_buffer 
          or t3_mode 
	   
          or t4_address
          or t4_be 
          or t4_cmd 
          or t4_eop 
          or t4_plen 
          or t4_wdata
          or t4_cache 
          or t4_priv
          or t4_buffer 
          or t4_mode 
	  
          or cmd_sel
         )
begin : CMDMUX_PROC
  case (cmd_sel)
    3'b000,
    3'b101,
    3'b110,
    3'b111:
    begin
       i_address = t0_address;   
       i_be      = t0_be;   
       i_cmd_int = t0_cmd;   
       i_eop_int = t0_eop;   
       i_plen    = t0_plen;   
       i_wdata   = t0_wdata;
       i_cache   = t0_cache; 
       i_priv    = t0_priv;
       i_buffer  = t0_buffer; 
       i_mode    = t0_mode; 
           
    end
    3'b001:
    begin
       i_address = t1_address;   
       i_be      = t1_be;   
       i_cmd_int = t1_cmd;   
       i_eop_int = t1_eop;   
       i_plen    = t1_plen;   
       i_wdata   = t1_wdata; 
       i_cache   = t1_cache; 
       i_priv    = t1_priv;
       i_buffer  = t1_buffer; 
       i_mode    = t1_mode; 
          
    end
    3'b010:
    begin
       i_address = t2_address;   
       i_be      = t2_be;   
       i_cmd_int = t2_cmd;   
       i_eop_int = t2_eop;   
       i_plen    = t2_plen;   
       i_wdata   = t2_wdata; 
       i_cache   = t2_cache; 
       i_priv    = t2_priv;
       i_buffer  = t2_buffer; 
       i_mode    = t2_mode; 
          
    end
    3'b011:
    begin
       i_address = t3_address;   
       i_be      = t3_be;   
       i_cmd_int = t3_cmd;   
       i_eop_int = t3_eop;   
       i_plen    = t3_plen;   
       i_wdata   = t3_wdata; 
       i_cache   = t3_cache; 
       i_priv    = t3_priv;
       i_buffer  = t3_buffer; 
       i_mode    = t3_mode; 
           
    end
    3'b100:
    begin
       i_address = t4_address;   
       i_be      = t4_be;   
       i_cmd_int = t4_cmd;   
       i_eop_int = t4_eop;   
       i_plen    = t4_plen;   
       i_wdata   = t4_wdata; 
       i_cache   = t4_cache; 
       i_priv    = t4_priv;
       i_buffer  = t4_buffer; 
       i_mode    = t4_mode; 
           
    end
    default;
  endcase
end

//  Command Valid Handshake Muliplexer and inhibitor -----------------------
always @(   t0_cmdval
         or t1_cmdval
         or t2_cmdval
         or t3_cmdval
         or t4_cmdval
         or cmd_sel
         or cmd_inhibit_n
        )
begin : CMVLMI_PROC
  if (cmd_inhibit_n == 1'b0)
  begin
    i_cmdval_int_r = 1'b0;   
  end
  else
  begin
    case (cmd_sel)
      3'b000,
      3'b101,
      3'b110,
      3'b111:
      begin
        i_cmdval_int_r = t0_cmdval;   
      end
      3'b001:
      begin
        i_cmdval_int_r = t1_cmdval;   
      end
      3'b010:
      begin
        i_cmdval_int_r = t2_cmdval;   
      end
      3'b011:
      begin
        i_cmdval_int_r = t3_cmdval;   
      end
      3'b100:
      begin
        i_cmdval_int_r = t4_cmdval;   
      end
      default;
    endcase
  end
end

//  Command Acknowleddement Handshake Switch and inhibitor ------------
always @(   i_cmdack 
         or cmd_inhibit_n
         or cmd_sel
        )
  begin : CMAKMI_PROC
  if (cmd_inhibit_n == 1'b0)
  begin
    t0_cmdack = 1'b0;   
    t1_cmdack = 1'b0;   
    t2_cmdack = 1'b0;   
    t3_cmdack = 1'b0;   
    t4_cmdack = 1'b0;   
  end
  else
  begin
    case (cmd_sel)
      3'b000,
      3'b101,
      3'b110,
      3'b111:
      begin
        t0_cmdack = i_cmdack;   
        t1_cmdack = 1'b0;   
        t2_cmdack = 1'b0;   
        t3_cmdack = 1'b0;   
        t4_cmdack = 1'b0;   
      end
      3'b001:
      begin
        t0_cmdack = 1'b0;   
        t1_cmdack = i_cmdack;   
        t2_cmdack = 1'b0;   
        t3_cmdack = 1'b0;   
        t4_cmdack = 1'b0;   
      end
      3'b010:
      begin
        t0_cmdack = 1'b0;   
        t1_cmdack = 1'b0;   
        t2_cmdack = i_cmdack;   
        t3_cmdack = 1'b0;   
        t4_cmdack = 1'b0;   
      end
      3'b011:
      begin
        t0_cmdack = 1'b0;   
        t1_cmdack = 1'b0;   
        t2_cmdack = 1'b0;   
        t3_cmdack = i_cmdack;   
        t4_cmdack = 1'b0;   
      end
      3'b100:
      begin
        t0_cmdack = 1'b0;   
        t1_cmdack = 1'b0;   
        t2_cmdack = 1'b0;   
        t3_cmdack = 1'b0;   
        t4_cmdack = i_cmdack;   
      end
      default;
    endcase
  end
end

//  Command Control --------------------------------------------------------
always @(   cmd_state_r
         or i_cmdval_int_r
         or i_cmdack
         or i_eop_int
         or i_cmd_int
         or fifo_full 
         or cmd_arb
         or cmd_arb_hold_r
         or cmd_lock_r
        )
begin : CCTRL_NXT_PROC

  cmd_state_next    = cmd_state_r;   
  cmd_lock_next     = cmd_lock_r;   
  cmd_arb_hold_next = cmd_arb_hold_r;   

  //  State Transistion ------------------------------
  
  case (cmd_state_r)
  
    //  Arbitration State --------------------------
    CMD_ST_ARB:
    begin

      //  Command state transistion
      if (   (   (   (i_cmdval_int_r == 1'b1)
                  && (i_cmdack == 1'b0))
              || (   (i_cmdval_int_r == 1'b1)
                  &&(i_cmdack == 1'b1)
                  &&(i_eop_int == 1'b0)))
          && (fifo_full == 1'b0))
      begin
        cmd_state_next = CMD_ST_HOLD;   
      end

      //  cmd_arb_hold_r next value
      if (cmd_lock_r == 1'b0)
      begin
         cmd_arb_hold_next = cmd_arb;   
      end
      
      //  cmd_lock_r next value
      if (cmd_lock_r == 1'b0)
      begin
        if (   (i_cmdval_int_r == 1'b1)
            && (i_cmd_int == 2'b11)
            && (fifo_full == 1'b0))
        begin
          cmd_lock_next = 1'b1;   
        end
      end
      else //  (cmd_lock_r = '1')
      begin
        if (   (i_cmdval_int_r == 1'b1)
            && (i_cmd_int == 2'b10)
            && (fifo_full == 1'b0))
        begin
            cmd_lock_next = 1'b0;   
        end
      end

    end

    //  Hold State ---------------------------------
    CMD_ST_HOLD:
    begin
      if (   (i_cmdval_int_r == 1'b1)
          && (i_cmdack == 1'b1)
          && (i_eop_int == 1'b1))
      begin
        cmd_state_next = CMD_ST_ARB;   
      end
    end
   
    default;
    
  endcase

  //  Control Signal Decoding ----------------------------------

  // only inhibit a new packet, not one that is already ongoing
  if (cmd_state_r == CMD_ST_ARB)
  begin
    cmd_inhibit_n = ~fifo_full;
  end
  else
  begin
    cmd_inhibit_n = 1'b1;
  end
  
  if (   (cmd_state_r == CMD_ST_HOLD)
      || (cmd_lock_r == 1'b1))
  begin
    cmd_sel = cmd_arb_hold_r;   
  end
  else
  begin
    cmd_sel = cmd_arb;   
  end
  
  if (   (cmd_state_r == CMD_ST_ARB)
      && (i_cmdval_int_r == 1'b1)
      && (fifo_full == 1'b0))
  begin
    cmd_load = 1'b1;   
  end
  else
  begin
    cmd_load = 1'b0;   
  end

end

always @(posedge clk or posedge rst_a)
begin : CCTRL_STATE_PROC
  if (rst_a == 1'b1)
  begin
    cmd_state_r    <= CMD_ST_ARB;   
    cmd_lock_r     <= 1'b0;   
    cmd_arb_hold_r <= {FIFO_WIDTH{1'b0}};   
  end
  else
  begin
    cmd_state_r    <= cmd_state_next;   
    cmd_lock_r     <= cmd_lock_next;   
    cmd_arb_hold_r <= cmd_arb_hold_next;   
  end
end

//  Wiring up the rest -----------------------------------------------------

assign i_eop    = i_eop_int; 
assign i_cmdval = i_cmdval_int_r; 
assign i_cmd    = i_cmd_int; 


//  ------------------------------------------------------------------------
//  Packet Tracking FIFO ---------------------------------------------------
//  ------------------------------------------------------------------------

//  Storage Registers loading and unloading --------------------------------

always @(posedge clk or posedge rst_a)
begin : FIFO_MEM_PROC

  if (rst_a == 1'b 1)
  begin
    fifo_regs_r <= {(FIFO_DEPTH * FIFO_WIDTH - 1 - 0 + 1){1'b 0}};   
  end
  else
  begin

    //  unload from fifo
        //  IF formality work around is needed use the following instead
        //  if ((fifo_unload == '1')and(FIFO_DEPTH > 1))
    if (fifo_unload == 1'b 1)
    begin
      for (dcnt = FIFO_DEPTH - 2; dcnt >= 0; dcnt = dcnt - 1)
      begin
        for (wcnt = FIFO_WIDTH - 1; wcnt >= 0; wcnt = wcnt - 1)
        begin
          fifo_regs_r[dcnt * FIFO_WIDTH + wcnt] <= fifo_regs_r[(dcnt + 1) * FIFO_WIDTH + wcnt];
        end
      end
    end
    
    //  load fifo
    if (fifo_load == 1'b 1)
    begin
      //  This work around is needed here for Formality.
      for (dcnt = FIFO_DEPTH - 1; dcnt >= 0; dcnt = dcnt - 1)
      begin
        if (dcnt == fifo_ptr_muxed)
        begin
          for (wcnt = FIFO_WIDTH - 1; wcnt >= 0; wcnt = wcnt - 1)
          begin
            fifo_regs_r[dcnt * FIFO_WIDTH + wcnt] <= fifo_in[wcnt];   
          end
        end
      end
    end

  end
end

//  Use fifo_ptr_m1 when unloading at the same time as loading.
assign fifo_ptr_muxed = (fifo_unload == 1'b1)? fifo_ptr_m1 : fifo_ptr_r; 

//  FIFO pointer update ----------------------------------------------------

always @(posedge clk or posedge rst_a)
begin : FIFO_PTR_PROC
  if (rst_a == 1'b1)
  begin
    fifo_ptr_r <= {FIFO_PTR_WIDTH{1'b0}};   
  end
  else
  begin
    if (fifo_load == 1'b0)
    begin
      if ((fifo_unload == 1'b1)&&(fifo_ptr_r != 0))
      begin
        fifo_ptr_r <= fifo_ptr_m1;
      end
    end
    else //  (fifo_load = '1')
    begin
      if ((fifo_unload == 1'b0)&&(fifo_ptr_r != FIFO_DEPTH))
      begin
        fifo_ptr_r <= fifo_ptr_p1;
      end
    end
  end
end

assign fifo_ptr_p1 = fifo_ptr_r + 1'b1; 
assign fifo_ptr_m1 = fifo_ptr_r - 1'b1; 

//  FIFO full signal -------------------------------------------------------

assign fifo_full = (fifo_ptr_r == FIFO_DEPTH)? 1'b1 : 1'b0; 

//  FIFO output ------------------------------------------------------------

assign fifo_out = fifo_regs_r[FIFO_WIDTH - 1:0]; 

//  FIFO empty -------------------------------------------------------------

assign fifo_empty_n = (fifo_ptr_r == {FIFO_WIDTH{1'b0}})? 1'b0 : 1'b1; 

//  Wiring up FIFO ---------------------------------------------------------

assign fifo_in     = cmd_sel; 
assign fifo_load   = cmd_load; 
assign fifo_unload = rsp_unload; 
assign rsp_sel     = (~fifo_empty_n)? cmd_sel : fifo_out;
assign iarb_busy   = fifo_empty_n; 


//  ------------------------------------------------------------------------
//  Response Switch --------------------------------------------------------
//  ------------------------------------------------------------------------

//  Response valid switch --------------------------------------------------

always @(i_rspval or rsp_sel)
begin : RSPSW_PROC
  case (rsp_sel)
    3'b000,
    3'b101,
    3'b110,
    3'b111:
    begin
      t0_rspval = i_rspval;   
      t1_rspval = 1'b0;   
      t2_rspval = 1'b0;   
      t3_rspval = 1'b0;   
      t4_rspval = 1'b0;   
    end
    3'b001:
    begin
      t0_rspval = 1'b0;   
      t1_rspval = i_rspval;   
      t2_rspval = 1'b0;   
      t3_rspval = 1'b0;   
      t4_rspval = 1'b0;   
    end
    3'b010:
    begin
      t0_rspval = 1'b0;   
      t1_rspval = 1'b0;   
      t2_rspval = i_rspval;   
      t3_rspval = 1'b0;   
      t4_rspval = 1'b0;   
    end
    3'b011:
    begin
      t0_rspval = 1'b0;   
      t1_rspval = 1'b0;   
      t2_rspval = 1'b0;   
      t3_rspval = i_rspval;   
      t4_rspval = 1'b0;   
    end
    3'b100:
    begin
      t0_rspval = 1'b0;   
      t1_rspval = 1'b0;   
      t2_rspval = 1'b0;   
      t3_rspval = 1'b0;   
      t4_rspval = i_rspval;   
    end
    default;
  endcase
end

//  Response acknowledgement mulitplexer -----------------------------------

always @(   t0_rspack
         or t1_rspack
         or t2_rspack
         or t3_rspack
         or t4_rspack
         or rsp_sel
        )
begin : RSPMX_PROC
  case (rsp_sel)
    3'b000,
    3'b101,
    3'b110,
    3'b111:
    begin
      i_rspack_int_r = t0_rspack;   
    end
    3'b 001:
    begin
      i_rspack_int_r = t1_rspack;   
    end
    3'b 010:
    begin
      i_rspack_int_r = t2_rspack;   
    end
    3'b 011:
    begin
      i_rspack_int_r = t3_rspack;   
    end
    3'b 100:
    begin
      i_rspack_int_r = t4_rspack;   
    end
    default;
  endcase
end

//  Response Control -------------------------------------------------------

assign rsp_unload = i_rspack_int_r & i_rspval & i_reop; 

//  Wiring up The rest of the response bus ---------------------------------

assign i_rspack = i_rspack_int_r; 
assign t0_rdata = i_rdata; 
assign t0_reop  = i_reop; 
assign t1_rdata = i_rdata; 
assign t1_reop  = i_reop; 
assign t2_rdata = i_rdata; 
assign t2_reop  = i_reop; 
assign t3_rdata = i_rdata; 
assign t3_reop  = i_reop; 
assign t4_rdata = i_rdata; 
assign t4_reop  = i_reop; 

//  ------------------------------------------------------------------------
//  ------------------------------------------------------------------------
//  ------------------------------------------------------------------------

endmodule // module ibus_iarb

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2003-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// ibus - Internal Bus Module
//                                     
//
// =============================================================================
// 
// =============================================================================

module ibus (        

        // Clocks and Resets ---------------------------------------------------

        clk,
        clk_ungated,
        clk_system,
        rst_a,
	sync,
        
       // Clock Gating Control ------------------------------------------------
        
        ibus_busy,

// Signals for initiators from the core.
	// Load/Store queue of highest priority
	q_address,	// byte address
	q_be     ,	// byte enables
	q_cmd    ,	// command
	q_cmdval ,	// command valid
	q_eop    ,	// end of packet
	q_rspack ,	// response acknowledge
	q_wdata  ,	// write data
	q_plen   ,	// packet length
	q_buffer  ,	// buffer transfer
	q_cache   ,	// cache transfer
	q_mode    ,	// data or opcode tranfer
	q_priv    ,	// privilege transfer
	q_cmdack ,	// command acknowledge
	q_rdata  ,	// read data
	q_reop   ,	// response end of packet
	q_rspval ,	// response valid

	// Data cache fetch of high priority

	// Data cache flush of medium priority

	// XY memory of low priority

	// icache fetch or IFQ of lowest priority

   hclk,
   hresetn,
   hgrant,
   hready,
   hresp,
   hrdata,
   hbusreq,
   hlock,
   htrans,
   haddr,
   hwrite,
   hsize,
   hburst,
   hprot,
   hwdata,
   mem_access,
   memory_error,
	   

        // Interrupts ----------------------------------------------------------

        ext_bus_error
);
        
`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "che_util.v"
`include "xdefs.v"
`include "ext_msb.v"

// Clocks and Resets ---------------------------------------------------
input         clk;
input         clk_ungated;
input         clk_system;
input         rst_a;

// Interrupts ----------------------------------------------------------
//output         mem_err;

// Clock Gating Control ------------------------------------------------
output                ibus_busy;

// Interrupts ----------------------------------------------------------
output                ext_bus_error;

input  [EXT_A_MSB:0]	q_address;	// byte address
input  [3:0]        	q_be     ;	// byte enables
input  [1:0]        	q_cmd    ;	// command
input               	q_cmdval ;	// command valid
input               	q_eop    ;	// end of packet
input               	q_rspack ;	// response acknowledge
input  [31:0]       	q_wdata  ;	// write data
input  [8:0]        	q_plen   ;	// packet length
input               	q_buffer  ;	// buffer transfer
input               	q_cache   ;	// cache transfer
input               	q_mode    ;	// data or opcode tranfer
input               	q_priv    ;	// privilege transfer
output             	q_cmdack ;	// command acknowledge
output [31:0]      	q_rdata  ;	// read data
output             	q_reop   ;	// response end of packet
output             	q_rspval ;	// response valid

input hclk; 
input hresetn;
	
input hgrant; 
input hready; 
input [1:0] hresp; 
input [31:0] hrdata;  
output hbusreq; 
output hlock; 
output [1:0] htrans; 
output [31:0] haddr; 
output hwrite; 
output [2:0] hsize; 
output [2:0] hburst; 
output [3:0] hprot; 
output [31:0] hwdata;

output mem_access;
output memory_error;

wire hbusreq; 
wire hlock; 
wire [1:0] htrans; 
wire [31:0] haddr; 
wire hwrite; 
wire [2:0] hsize; 
wire [2:0] hburst; 
wire [3:0] hprot; 
wire [31:0] hwdata;

wire mem_access;
wire memory_error;

// =============================================================================
// Internal Signal Declarations
// =============================================================================

wire [EXT_A_MSB:0] t0_address;
wire [3:0]         t0_be;
wire [1:0]         t0_cmd;
wire               t0_eop;
wire [8:0]         t0_plen;
wire [MEM_D_MSB:0] t0_wdata;
wire               t0_cmdval;
wire               t0_rspack;
wire               t0_cmdack;
wire [MEM_D_MSB:0] t0_rdata;
wire               t0_reop;
wire               t0_rspval;
wire               t0_buffer;
wire               t0_cache;
wire               t0_priv;
wire               t0_mode;

wire [EXT_A_MSB:0] t1_address;
wire [3:0]         t1_be;
wire [1:0]         t1_cmd;
wire               t1_eop;
wire [8:0]         t1_plen;
wire [MEM_D_MSB:0] t1_wdata;
wire               t1_cmdval;
wire               t1_rspack;
wire               t1_cmdack;
wire [MEM_D_MSB:0] t1_rdata;
wire               t1_reop;
wire               t1_rspval;
wire               t1_buffer;
wire               t1_cache;
wire               t1_priv;
wire               t1_mode;

wire [EXT_A_MSB:0] t2_address;
wire [3:0]         t2_be;
wire [1:0]         t2_cmd;
wire               t2_eop;
wire [8:0]         t2_plen;
wire [MEM_D_MSB:0] t2_wdata;
wire               t2_cmdval;
wire               t2_rspack;
wire               t2_cmdack;
wire [MEM_D_MSB:0] t2_rdata;
wire               t2_reop;
wire               t2_rspval;
wire               t2_buffer;
wire               t2_cache;
wire               t2_priv;
wire               t2_mode;

wire [EXT_A_MSB:0] t3_address;
wire [3:0]         t3_be;
wire [1:0]         t3_cmd;
wire               t3_eop;
wire [8:0]         t3_plen;
wire [MEM_D_MSB:0] t3_wdata;
wire               t3_cmdval;
wire               t3_rspack;
wire               t3_cmdack;
wire [MEM_D_MSB:0] t3_rdata;
wire               t3_reop;
wire               t3_rspval;
wire               t3_buffer;
wire               t3_cache;
wire               t3_priv;
wire               t3_mode;

wire [EXT_A_MSB:0] t4_address;
wire [3:0]         t4_be;
wire [1:0]         t4_cmd;
wire               t4_eop;
wire [8:0]         t4_plen;
wire [MEM_D_MSB:0] t4_wdata;
wire               t4_cmdval;
wire               t4_rspack;
wire               t4_cmdack;
wire [MEM_D_MSB:0] t4_rdata;
wire               t4_reop;
wire               t4_rspval;
wire               t4_buffer;
wire               t4_cache;
wire               t4_priv;
wire               t4_mode;

wire [EXT_A_MSB:0] iarb_address;
wire [3:0]         iarb_be;
wire [1:0]         iarb_cmd;
wire               iarb_eop;
wire [8:0]         iarb_plen;
wire [MEM_D_MSB:0] iarb_wdata;
wire               iarb_cmdval;
wire               iarb_rspack;
wire               iarb_cmdack;
wire [MEM_D_MSB:0] iarb_rdata;
wire               iarb_reop;
wire               iarb_rspval;
wire               iarb_rerror;
wire               iarb_cache;  
wire               iarb_buffer;
wire               iarb_mode;
wire               iarb_priv;    

input               sync;
wire               cbri_busy;
wire               iarb_busy;
//wire  [8:0]        i_plen;

wire               clk_ext;


// =============================================================================
// Instances
// =============================================================================

/*
// Clock Synchronisation Unit --------------------------------------------------

ibus_cksyn icksyn (
    .clk_ungated  (clk_ungated),
    .clk_ext      (clk_system),
    .rst_a        (rst_a),
    .sync         (sync)
);
*/

// Internal Arbiter Unit -------------------------------------------------------

ibus_iarb #(

  EXT_A_WIDTH, // ADDR_WIDTH
  MEM_D_WIDTH, // DATA_WIDTH
  4,           // BE_WIDTH  
  4            // FIFO_DEPTH

) iiarb (

    // Clocks and resets ----------------------------------------------
  .clk         (clk),
  .rst_a       (rst_a),
  
  // Target Port 0 with Highest Prioirty ----------------------------
  .t0_address  (t0_address),
  .t0_be       (t0_be),
  .t0_cmd      (t0_cmd), 
  .t0_eop      (t0_eop), 
  .t0_plen     (t0_plen),
  .t0_wdata    (t0_wdata),
  .t0_cmdval   (t0_cmdval),
  .t0_rspack   (t0_rspack),
  .t0_cache    (t0_cache),  
  .t0_buffer   (t0_buffer),
  .t0_mode     (t0_mode),
  .t0_priv     (t0_priv),    
  // Target Port 1 with High Priority -------------------------------
  .t1_address  (t1_address),
  .t1_be       (t1_be),
  .t1_cmd      (t1_cmd),
  .t1_eop      (t1_eop),
  .t1_plen     (t1_plen),
  .t1_wdata    (t1_wdata),
  .t1_cmdval   (t1_cmdval),
  .t1_rspack   (t1_rspack),
  .t1_cache    (t1_cache),  
  .t1_buffer   (t1_buffer),
  .t1_mode     (t1_mode),
  .t1_priv     (t1_priv),    
  // Target Port 2 with Medium Priority -----------------------------
  .t2_address  (t2_address),
  .t2_be       (t2_be),
  .t2_cmd      (t2_cmd),
  .t2_eop      (t2_eop),
  .t2_plen     (t2_plen),
  .t2_wdata    (t2_wdata),
  .t2_cmdval   (t2_cmdval),
  .t2_rspack   (t2_rspack),
  .t2_cache    (t2_cache),  
  .t2_buffer   (t2_buffer),
  .t2_mode     (t2_mode),
  .t2_priv     (t2_priv),    
  // Target Port 3 with Low Priority -------------------------------
  .t3_address  (t3_address),
  .t3_be       (t3_be),
  .t3_cmd      (t3_cmd),
  .t3_eop      (t3_eop),
  .t3_plen     (t3_plen),
  .t3_wdata    (t3_wdata),
  .t3_cmdval   (t3_cmdval),
  .t3_rspack   (t3_rspack),
  .t3_cache    (t3_cache),  
  .t3_buffer   (t3_buffer),
  .t3_mode     (t3_mode),
  .t3_priv     (t3_priv),    
  // Target Port 4 with Lowest Priority -----------------------------
  .t4_address  (t4_address),
  .t4_be       (t4_be),
  .t4_cmd      (t4_cmd),
  .t4_eop      (t4_eop),
  .t4_plen     (t4_plen),
  .t4_wdata    (t4_wdata),
  .t4_cmdval   (t4_cmdval),
  .t4_rspack   (t4_rspack),
  .t4_cache    (t4_cache),  
  .t4_buffer   (t4_buffer),
  .t4_mode     (t4_mode),
  .t4_priv     (t4_priv),    
  // Initiator Port -------------------------------------------------
  .i_cmdack    (iarb_cmdack),
  .i_rdata     (iarb_rdata),
  .i_reop      (iarb_reop),
  .i_rspval    (iarb_rspval),

  // OUTPUTS ========================================================

  // Target Port 0 with Highest Prioirty ----------------------------
  .t0_cmdack   (t0_cmdack),
  .t0_rdata    (t0_rdata),
  .t0_reop     (t0_reop),
  .t0_rspval   (t0_rspval),

  // Target Port 1 with Medium Priority -----------------------------
  .t1_cmdack   (t1_cmdack),
  .t1_rdata    (t1_rdata),
  .t1_reop     (t1_reop),
  .t1_rspval   (t1_rspval),

  // Target Port 2 with Lowest Priority -----------------------------
  .t2_cmdack   (t2_cmdack),
  .t2_rdata    (t2_rdata),
  .t2_reop     (t2_reop),
  .t2_rspval   (t2_rspval),

  // Target Port 3 with Medium Priority -----------------------------
  .t3_cmdack   (t3_cmdack),
  .t3_rdata    (t3_rdata),
  .t3_reop     (t3_reop),
  .t3_rspval   (t3_rspval),

  // Target Port 4 with Lowest Priority -----------------------------
  .t4_cmdack   (t4_cmdack),
  .t4_rdata    (t4_rdata),
  .t4_reop     (t4_reop),
  .t4_rspval   (t4_rspval),

  // Initiator Port -------------------------------------------------
  .i_address   (iarb_address),
  .i_be        (iarb_be),
  .i_cmd       (iarb_cmd),
  .i_eop       (iarb_eop),
  .i_plen      (iarb_plen),
  .i_wdata     (iarb_wdata),
  .i_cmdval    (iarb_cmdval),
  .i_rspack    (iarb_rspack),
  .i_cache     (iarb_cache),  
  .i_buffer    (iarb_buffer),
  .i_mode      (iarb_mode),
  .i_priv      (iarb_priv),    

  // Busy signal ----------------------------------------------------
  .iarb_busy   (iarb_busy)
    
);

// Interrupt Re-Sync and Extender Unit ------------------------------------

ibus_isyn isyn (

    // INPUTS =========================================================

  // System Bus Error Inputs ----------------------------------------
  .sys_bus_error (iarb_rerror),

  // Internal Bus Error Inputs --------------------------------------
  .iarb_rerror   (iarb_rerror),
  .iarb_rspval   (iarb_rspval),
  .iarb_rspack   (iarb_rspack),
  
  // OUTPUTS ========================================================
  
  // Re-Sync and Extended Bus Error Interrupt -----------------------
  .ext_bus_error (ext_bus_error));

ibus_cbri_ahb #(32, 1, 1, EXT_A_MSB) ibus_dcbri_ahb  
  (
   .hclk(hclk),
   .hresetn(hresetn),
   .rst_a(rst_a),
   .iclk(clk),   
   .t_address(iarb_address),
   .t_be(iarb_be),
   .t_cmd(iarb_cmd),
   .t_eop(iarb_eop),
   .t_plen(iarb_plen),
   .t_wdata(iarb_wdata),
   .t_cmdval(iarb_cmdval),
   .t_rspack(iarb_rspack),
   .t_buffer(iarb_buffer),
   .t_cache(iarb_cache),
   .t_priv(iarb_priv),
   .t_mode(iarb_mode),
   .hgrant(hgrant),
   .hready(hready),
   .hresp(hresp),
   .hrdata(hrdata),
   .sync_r(sync),
   .t_cmdack(iarb_cmdack),
   .t_rdata(iarb_rdata),
   .t_reop(iarb_reop),
   .t_rspval(iarb_rspval),
   .t_rerror(iarb_rerror),
   .hbusreq(hbusreq),
   .hlock(hlock),
   .htrans(htrans),
   .haddr(haddr),
   .hwrite(hwrite),
   .hsize(hsize),
   .hburst(hburst),
   .hprot(hprot),
   .hwdata(hwdata),
   .busy(cbri_busy)); 




// Combining Busy Signals -------------------------------------------------
assign ibus_busy = 
                                    cbri_busy |
                    iarb_busy;
	 
// Load/Store queue of highest priority
assign t0_address  	= q_address;	// byte address
assign t0_be       	= q_be     ;	// byte enables
assign t0_cmd      	= q_cmd    ;	// command
assign t0_cmdval   	= q_cmdval ;	// command valid
assign t0_eop      	= q_eop    ;	// end of packet
assign t0_rspack   	= q_rspack ;	// response acknowledge
assign t0_wdata    	= q_wdata  ;	// write data
assign t0_plen     	= q_plen   ;	// packet length
assign t0_buffer    	= q_buffer  ;	// buffer transfer
assign t0_cache     	= q_cache   ;	// cache transfer
assign t0_mode      	= q_mode    ;	// data or opcode tranfer
assign t0_priv      	= q_priv    ;	// privilege transfer
assign q_cmdack   	= t0_cmdack ;	// command acknowledge
assign q_rdata    	= t0_rdata  ;	// read data
assign q_reop     	= t0_reop   ;	// response end of packet
assign q_rspval   	= t0_rspval ;	// response valid

assign t1_address	= 0;
assign t1_be     	= 0;
assign t1_cmd    	= 0;
assign t1_cmdval 	= 0;
assign t1_eop    	= 0;
assign t1_rspack 	= 0;
assign t1_wdata  	= 0;
assign t1_plen   	= 0;
assign t1_buffer  	= 0;
assign t1_cache   	= 0;
assign t1_mode    	= 0;
assign t1_priv    	= 0;

assign t2_address	= 0;
assign t2_be     	= 0;
assign t2_cmd    	= 0;
assign t2_cmdval 	= 0;
assign t2_eop    	= 0;
assign t2_rspack 	= 0;
assign t2_wdata  	= 0;
assign t2_plen   	= 0;
assign t2_buffer  	= 0;
assign t2_cache   	= 0;
assign t2_mode    	= 0;
assign t2_priv    	= 0;

assign t3_address	= 0;
assign t3_be     	= 0;
assign t3_cmd    	= 0;
assign t3_cmdval 	= 0;
assign t3_eop    	= 0;
assign t3_rspack 	= 0;
assign t3_wdata  	= 0;
assign t3_plen   	= 0;
assign t3_buffer  	= 0;
assign t3_cache   	= 0;
assign t3_mode    	= 0;
assign t3_priv    	= 0;

assign t4_address	= 0;
assign t4_be     	= 0;
assign t4_cmd    	= 0;
assign t4_cmdval 	= 0;
assign t4_eop    	= 0;
assign t4_rspack 	= 0;
assign t4_wdata  	= 0;
assign t4_plen   	= 0;
assign t4_buffer  	= 0;
assign t4_cache   	= 0;
assign t4_mode    	= 0;
assign t4_priv    	= 0;

assign clk_ext      = clk_system;
assign mem_access = ibus_busy;
assign memory_error = (iarb_rerror & iarb_rspval)
		       
			;
   
endmodule // module ibus
// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
module ibus_cksyn_sys (
  clk_ext,
  rst_a,
  toggle
);

input   clk_ext; 
input   rst_a; 
output  toggle; 

wire    toggle; 

//  ============================================================================
//  SIGNAL DECLARATIONS 
//  ============================================================================

reg     toggle_int_r; 

//  ============================================================================
//  ARCHITECTURE
//  ============================================================================

always @(posedge clk_ext or posedge rst_a)
begin : TOG_PROC
  if (rst_a == 1'b1)
  begin
    toggle_int_r <= 1'b0;   
  end
  else
  begin
    toggle_int_r <= ~toggle_int_r;   
  end
end

assign toggle = toggle_int_r; 

endmodule // module ibus_cksyn_sys

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
module ibus_cksyn_main (
  clk_ungated,
  rst_a,
  toggle,
  sync
);

input         clk_ungated; 
input         rst_a; 
input         toggle; 
output        sync; 

wire          sync; 

//  ============================================================================
//  SIGNAL DECLARATIONS 
//  ============================================================================

reg           toggle_r; 
wire          edge_detect; 
reg    [1:0]  count_r; 
reg    [1:0]  ratio_r; 
wire          pulse_1; 
wire          pulse_2; 
wire          pulse_3; 
wire          pulse_4; 
reg           sec_last_ph; 
reg           mask_r0_r; 
reg           sync_mask_r; 
reg           sync_out_r; 

//  ============================================================================
//  ARCHITECTURE
//  ============================================================================

//  Edge Detect Logic ------------------------------------------------------

always @(posedge clk_ungated or posedge rst_a)
begin : EDGEDET_PROC
  if (rst_a == 1'b1)
  begin
     toggle_r <= 1'b0;   
  end
  else
  begin
     toggle_r <= toggle;   
  end
end

assign edge_detect = toggle_r ^ toggle; 

//  Phase Counter Logic ----------------------------------------------------

always @(posedge clk_ungated or posedge rst_a)
begin : PHCNT_PROC
  if (rst_a == 1'b1)
  begin
      count_r <= 2'b 00;   
  end
  else
  begin
    if (edge_detect == 1'b1)
    begin
      count_r <= 2'b 00;   
    end
    else
    begin
      count_r <= count_r + 1'b1;   
    end
  end
end

//  Startup mask Logic -----------------------------------------------------

always @(posedge clk_ungated or posedge rst_a)
begin : MASK_PROC
  if (rst_a == 1'b1)
  begin
    mask_r0_r   <= 1'b0;   
    sync_mask_r <= 1'b0;   
  end
  else
  begin
    if (edge_detect == 1'b1)
    begin
      mask_r0_r   <= 1'b1;   
      sync_mask_r <= mask_r0_r;   
    end
  end
end

//  Last Phase Detect Logic ------------------------------------------------

always @(posedge clk_ungated or posedge rst_a)
begin : PHDET_PROC
  if (rst_a == 1'b1)
  begin
    ratio_r    <= 2'b 00;   
    sync_out_r <= 1'b0;   
  end
  else
  begin
    if (edge_detect == 1'b1)
    begin
      ratio_r <= count_r;   
    end
    sync_out_r <= sec_last_ph & sync_mask_r;   
  end
end

assign pulse_1 = 1'b1; 
assign pulse_2 = (count_r == 2'b01)? 1'b1 : 1'b0; 
assign pulse_3 = (count_r == 2'b00)? 1'b1 : 1'b0; 
assign pulse_4 = pulse_2; 

always @(pulse_1 or pulse_2 or pulse_3 or pulse_4 or ratio_r)
  begin : PULSEL_PROC
  case (ratio_r)
    2'b00  : sec_last_ph = pulse_1;   
    2'b01  : sec_last_ph = pulse_2;   
    2'b10  : sec_last_ph = pulse_3;   
    2'b11  : sec_last_ph = pulse_4;   
    default;
  endcase
end

assign sync = sync_out_r; 

endmodule // module ibus_cksyn_main

// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
module ibus_cksyn (
    clk_ungated,
    clk_system,
    rst_a,
    sync
    );

input  clk_ungated; 
input  clk_system; 
input  rst_a;
output sync; 
wire   sync; 
wire clk_ext = clk_system;

// ============================================================================
// SIGNAL DECLARATIONS 
// ============================================================================

wire    toggle; 

// ============================================================================
// Architecture
// ============================================================================

//  System Clock toggle logic ----------------------------------------------

ibus_cksyn_sys icksyn_sys (
          .clk_ext (clk_ext),
          .rst_a   (rst_a),
          .toggle  (toggle)
    );

//  Main Clock domain sync generation unit ---------------------------------

ibus_cksyn_main icksyn_main (
          .clk_ungated (clk_ungated),
          .rst_a       (rst_a),
          .toggle      (toggle),
          .sync        (sync)
    );

endmodule // module ibus_cksyn

// *SYNOPSYS CONFIDENTIAL*
//
// This is an unpublished, proprietary work of Synopsys, Inc., and is fully 
// protected under copyright and trade secret laws.  You may not view, use, 
// disclose, copy, or distribute this file or any information contained herein 
// except pursuant to a valid written license from Synopsys.


// This file is generated automatically by 'veriloggen'.




module cpu_isle(rst_n_a,
                ctrl_cpu_start,
                xirq_n_4,
                xirq_n_5,
                xirq_n_6,
                xirq_n_7,
                xirq_n_8,
                xirq_n_9,
                xirq_n_10,
                xirq_n_11,
                xirq_n_12,
                xirq_n_13,
                xirq_n_14,
                xirq_n_15,
                xirq_n_16,
                xirq_n_17,
                xirq_n_18,
                xirq_n_19,
                jtag_tck,
                jtag_trst_n,
                test_mode,
                clk_in,
                clk_system_in,
                hclk,
                hresetn,
                hgrant,
                hready,
                hresp,
                hrdata,
                code_dmi_req,
                code_dmi_addr,
                code_dmi_wdata,
                code_dmi_wr,
                code_dmi_be,
                arc_start_a,
                ldst_dmi_req,
                ldst_dmi_addr,
                ldst_dmi_wdata,
                ldst_dmi_wr,
                ldst_dmi_be,
                jtag_tdi,
                jtag_tms,
                jtag_bsr_tdo,
                en,
                hbusreq,
                hlock,
                htrans,
                haddr,
                hwrite,
                hsize,
                hburst,
                hprot,
                hwdata,
                code_dmi_rdata,
                power_toggle,
                ldst_dmi_rdata,
                jtag_tdo,
                jtag_tdo_zen_n);


// Includes found automatically in dependent files.
`include "arcutil_pkg_defines.v"
`include "extutil.v"
`include "xdefs.v"
`include "che_util.v"
`include "arcutil.v"
`include "ext_msb.v"
`include "asmutil.v"
`include "uxdefs.v"


input  rst_n_a;
input  ctrl_cpu_start;
input  xirq_n_4;
input  xirq_n_5;
input  xirq_n_6;
input  xirq_n_7;
input  xirq_n_8;
input  xirq_n_9;
input  xirq_n_10;
input  xirq_n_11;
input  xirq_n_12;
input  xirq_n_13;
input  xirq_n_14;
input  xirq_n_15;
input  xirq_n_16;
input  xirq_n_17;
input  xirq_n_18;
input  xirq_n_19;
input  jtag_tck;
input  jtag_trst_n;
input  test_mode;
input  clk_in;
input  clk_system_in;
input  hclk;
input  hresetn;
input  hgrant;
input  hready;
input  [1:0]  hresp;
input  [31:0]  hrdata;
input  code_dmi_req;
input  [31:0]  code_dmi_addr;
input  [31:0]  code_dmi_wdata;
input  code_dmi_wr;
input  [3:0]  code_dmi_be;
input  arc_start_a;
input  ldst_dmi_req;
input  [31:0]  ldst_dmi_addr;
input  [31:0]  ldst_dmi_wdata;
input  ldst_dmi_wr;
input  [3:0]  ldst_dmi_be;
input  jtag_tdi;
input  jtag_tms;
input  jtag_bsr_tdo;
output en;
output hbusreq;
output hlock;
output [1:0]  htrans;
output [31:0]  haddr;
output hwrite;
output [2:0]  hsize;
output [2:0]  hburst;
output [3:0]  hprot;
output [31:0]  hwdata;
output [31:0]  code_dmi_rdata;
output power_toggle;
output [31:0]  ldst_dmi_rdata;
output jtag_tdo;
output jtag_tdo_zen_n;

wire rst_n_a;
wire ctrl_cpu_start;
wire xirq_n_4;
wire xirq_n_5;
wire xirq_n_6;
wire xirq_n_7;
wire xirq_n_8;
wire xirq_n_9;
wire xirq_n_10;
wire xirq_n_11;
wire xirq_n_12;
wire xirq_n_13;
wire xirq_n_14;
wire xirq_n_15;
wire xirq_n_16;
wire xirq_n_17;
wire xirq_n_18;
wire xirq_n_19;
wire jtag_tck;
wire jtag_trst_n;
wire test_mode;
wire clk_in;
wire clk_system_in;
wire hclk;
wire hresetn;
wire hgrant;
wire hready;
wire  [1:0] hresp;
wire  [31:0] hrdata;
wire code_dmi_req;
wire  [31:0] code_dmi_addr;
wire  [31:0] code_dmi_wdata;
wire code_dmi_wr;
wire  [3:0] code_dmi_be;
wire arc_start_a;
wire ldst_dmi_req;
wire  [31:0] ldst_dmi_addr;
wire  [31:0] ldst_dmi_wdata;
wire ldst_dmi_wr;
wire  [3:0] ldst_dmi_be;
wire jtag_tdi;
wire jtag_tms;
wire jtag_bsr_tdo;
wire en;
wire hbusreq;
wire hlock;
wire  [1:0] htrans;
wire  [31:0] haddr;
wire hwrite;
wire  [2:0] hsize;
wire  [2:0] hburst;
wire  [3:0] hprot;
wire  [31:0] hwdata;
wire  [31:0] code_dmi_rdata;
wire power_toggle;
wire  [31:0] ldst_dmi_rdata;
wire jtag_tdo;
wire jtag_tdo_zen_n;


// Intermediate signals
wire i_en;
wire i_clk_ungated;
wire  [LDST_A_MSB:0] i_ldst_addr;
wire  [31:0] i_ldst_din;
wire  [3:0] i_ldst_mask;
wire i_ldst_wren;
wire i_ldst_ck_en;
wire  [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] i_code_ram_addr;
wire  [31:0] i_code_ram_wdata;
wire i_code_ram_wr;
wire  [3:0] i_code_ram_be;
wire i_code_ram_ck_en;
wire  [31:0] i_ldst_dout;
wire  [31:0] i_code_ram_rdata;
wire i_rst_a;
wire i_wd_clear;
wire i_ctrl_cpu_start_sync_r;
wire i_l_irq_4;
wire i_l_irq_5;
wire i_l_irq_6;
wire i_l_irq_7;
wire i_l_irq_8;
wire i_l_irq_9;
wire i_l_irq_10;
wire i_l_irq_11;
wire i_l_irq_12;
wire i_l_irq_13;
wire i_l_irq_14;
wire i_l_irq_15;
wire i_l_irq_16;
wire i_l_irq_17;
wire i_l_irq_18;
wire i_l_irq_19;
wire i_jtag_trst_a;
wire i_ck_disable;
wire i_ck_dmp_gated;
wire i_en_debug_r;
wire i_clk;
wire i_clk_debug;
wire i_clk_dmp;
wire i_clk_system;
wire i_sync;
wire i_ibus_busy;
wire  [EXT_A_MSB:0] i_q_address;
wire  [3:0] i_q_be;
wire  [1:0] i_q_cmd;
wire i_q_cmdval;
wire i_q_eop;
wire i_q_rspack;
wire  [31:0] i_q_wdata;
wire  [8:0] i_q_plen;
wire i_q_buffer;
wire i_q_cache;
wire i_q_mode;
wire i_q_priv;
wire i_q_cmdack;
wire  [31:0] i_q_rdata;
wire i_q_reop;
wire i_q_rspval;
wire i_mem_access;
wire i_memory_error;
wire  [31:0] i_h_addr;
wire  [31:0] i_h_dataw;
wire i_h_write;
wire i_h_read;
wire i_aux_access;
wire i_core_access;
wire i_pcp_rd_rq;
wire i_pcp_wr_rq;
wire i_halt;
wire i_xstep;
wire  [EXT_A_MSB:0] i_pcp_addr;
wire  [31:0] i_pcp_d_wr;
wire i_hold_host;
wire i_noaccess;
wire i_reset_applied_r;
wire i_pc_sel_r;
wire  [31:0] i_h_datar;
wire  [31:0] i_pcp_d_rd;
wire i_pcp_ack;
wire i_pcp_dlat;
wire i_pcp_dak;


// Dummy signals for 'unconnected' ports
// (doing this, rather than leaving them genuinely unconnected, stops
//  simulators emitting pointless warnings)
wire u_unconnected_0;
wire u_unconnected_1;
wire u_unconnected_2;
wire  [7:0] u_unconnected_3;
wire  [3:0] u_unconnected_4;
wire u_unconnected_5;
wire u_unconnected_6;
wire u_unconnected_7;
wire u_unconnected_8;
wire u_unconnected_9;


// Instantiation of module arc_ram
arc_ram iarc_ram(
  .clk_ungated(i_clk_ungated),
  .ldst_addr(i_ldst_addr),
  .ldst_din(i_ldst_din),
  .ldst_mask(i_ldst_mask),
  .ldst_wren(i_ldst_wren),
  .ldst_ck_en(i_ldst_ck_en),
  .code_ram_addr(i_code_ram_addr),
  .code_ram_wdata(i_code_ram_wdata),
  .code_ram_wr(i_code_ram_wr),
  .code_ram_be(i_code_ram_be),
  .code_ram_ck_en(i_code_ram_ck_en),
  .ldst_dout(i_ldst_dout),
  .code_ram_rdata(i_code_ram_rdata)
);


// Instantiation of module io_flops
io_flops iio_flops(
  .clk_ungated(i_clk_ungated),
  .rst_n_a(rst_n_a),
  .en(i_en),
  .rst_a(i_rst_a),
  .wd_clear(i_wd_clear),
  .ctrl_cpu_start_sync_r(i_ctrl_cpu_start_sync_r),
  .ctrl_cpu_start(ctrl_cpu_start),
  .xirq_n_4(xirq_n_4),
  .xirq_n_5(xirq_n_5),
  .xirq_n_6(xirq_n_6),
  .xirq_n_7(xirq_n_7),
  .xirq_n_8(xirq_n_8),
  .xirq_n_9(xirq_n_9),
  .xirq_n_10(xirq_n_10),
  .xirq_n_11(xirq_n_11),
  .xirq_n_12(xirq_n_12),
  .xirq_n_13(xirq_n_13),
  .xirq_n_14(xirq_n_14),
  .xirq_n_15(xirq_n_15),
  .xirq_n_16(xirq_n_16),
  .xirq_n_17(xirq_n_17),
  .xirq_n_18(xirq_n_18),
  .xirq_n_19(xirq_n_19),
  .l_irq_4(i_l_irq_4),
  .l_irq_5(i_l_irq_5),
  .l_irq_6(i_l_irq_6),
  .l_irq_7(i_l_irq_7),
  .l_irq_8(i_l_irq_8),
  .l_irq_9(i_l_irq_9),
  .l_irq_10(i_l_irq_10),
  .l_irq_11(i_l_irq_11),
  .l_irq_12(i_l_irq_12),
  .l_irq_13(i_l_irq_13),
  .l_irq_14(i_l_irq_14),
  .l_irq_15(i_l_irq_15),
  .l_irq_16(i_l_irq_16),
  .l_irq_17(i_l_irq_17),
  .l_irq_18(i_l_irq_18),
  .l_irq_19(i_l_irq_19),
  .jtag_tck(jtag_tck),
  .jtag_trst_n(jtag_trst_n),
  .jtag_trst_a(i_jtag_trst_a),
  .test_mode(test_mode)
);


// Instantiation of module ck_gen
ck_gen ick_gen(
  .clk_in(clk_in),
  .clk_system_in(clk_system_in),
  .ck_disable(i_ck_disable),
  .ck_dmp_gated(i_ck_dmp_gated),
  .en_debug_r(i_en_debug_r),
  .clk(i_clk),
  .clk_debug(i_clk_debug),
  .clk_dmp(i_clk_dmp),
  .clk_ungated(i_clk_ungated),
  .clk_system(i_clk_system)
);


// Instantiation of module ibus
ibus iibus(
  .clk(i_clk),
  .clk_ungated(i_clk_ungated),
  .clk_system(i_clk_system),
  .rst_a(i_rst_a),
  .sync(i_sync),
  .ibus_busy(i_ibus_busy),
  .q_address(i_q_address),
  .q_be(i_q_be),
  .q_cmd(i_q_cmd),
  .q_cmdval(i_q_cmdval),
  .q_eop(i_q_eop),
  .q_rspack(i_q_rspack),
  .q_wdata(i_q_wdata),
  .q_plen(i_q_plen),
  .q_buffer(i_q_buffer),
  .q_cache(i_q_cache),
  .q_mode(i_q_mode),
  .q_priv(i_q_priv),
  .q_cmdack(i_q_cmdack),
  .q_rdata(i_q_rdata),
  .q_reop(i_q_reop),
  .q_rspval(i_q_rspval),
  .hclk(hclk),
  .hresetn(hresetn),
  .hgrant(hgrant),
  .hready(hready),
  .hresp(hresp),
  .hrdata(hrdata),
  .hbusreq(hbusreq),
  .hlock(hlock),
  .htrans(htrans),
  .haddr(haddr),
  .hwrite(hwrite),
  .hsize(hsize),
  .hburst(hburst),
  .hprot(hprot),
  .hwdata(hwdata),
  .mem_access(i_mem_access),
  .memory_error(i_memory_error),
  .ext_bus_error(u_unconnected_0)
);


// Instantiation of module arc600
arc600 iarc600(
  .clk_ungated(i_clk_ungated),
  .ldst_dout(i_ldst_dout),
  .code_ram_rdata(i_code_ram_rdata),
  .rst_a(i_rst_a),
  .ctrl_cpu_start_sync_r(i_ctrl_cpu_start_sync_r),
  .l_irq_4(i_l_irq_4),
  .l_irq_5(i_l_irq_5),
  .l_irq_6(i_l_irq_6),
  .l_irq_7(i_l_irq_7),
  .l_irq_8(i_l_irq_8),
  .l_irq_9(i_l_irq_9),
  .l_irq_10(i_l_irq_10),
  .l_irq_11(i_l_irq_11),
  .l_irq_12(i_l_irq_12),
  .l_irq_13(i_l_irq_13),
  .l_irq_14(i_l_irq_14),
  .l_irq_15(i_l_irq_15),
  .l_irq_16(i_l_irq_16),
  .l_irq_17(i_l_irq_17),
  .l_irq_18(i_l_irq_18),
  .l_irq_19(i_l_irq_19),
  .test_mode(test_mode),
  .clk(i_clk),
  .clk_debug(i_clk_debug),
  .clk_dmp(i_clk_dmp),
  .ibus_busy(i_ibus_busy),
  .q_cmdack(i_q_cmdack),
  .q_rdata(i_q_rdata),
  .q_reop(i_q_reop),
  .q_rspval(i_q_rspval),
  .mem_access(i_mem_access),
  .memory_error(i_memory_error),
  .h_addr(i_h_addr),
  .h_dataw(i_h_dataw),
  .h_write(i_h_write),
  .h_read(i_h_read),
  .aux_access(i_aux_access),
  .core_access(i_core_access),
  .pcp_rd_rq(i_pcp_rd_rq),
  .pcp_wr_rq(i_pcp_wr_rq),
  .code_dmi_req(code_dmi_req),
  .code_dmi_addr(code_dmi_addr),
  .code_dmi_wdata(code_dmi_wdata),
  .code_dmi_wr(code_dmi_wr),
  .code_dmi_be(code_dmi_be),
  .arc_start_a(arc_start_a),
  .halt(i_halt),
  .xstep(i_xstep),
  .ldst_dmi_req(ldst_dmi_req),
  .pcp_addr(i_pcp_addr),
  .pcp_d_wr(i_pcp_d_wr),
  .ldst_dmi_addr(ldst_dmi_addr),
  .ldst_dmi_wdata(ldst_dmi_wdata),
  .ldst_dmi_wr(ldst_dmi_wr),
  .ldst_dmi_be(ldst_dmi_be),
  .ldst_addr(i_ldst_addr),
  .ldst_din(i_ldst_din),
  .ldst_mask(i_ldst_mask),
  .ldst_wren(i_ldst_wren),
  .ldst_ck_en(i_ldst_ck_en),
  .code_ram_addr(i_code_ram_addr),
  .code_ram_wdata(i_code_ram_wdata),
  .code_ram_wr(i_code_ram_wr),
  .code_ram_be(i_code_ram_be),
  .code_ram_ck_en(i_code_ram_ck_en),
  .en(i_en),
  .wd_clear(i_wd_clear),
  .ck_disable(i_ck_disable),
  .ck_dmp_gated(i_ck_dmp_gated),
  .en_debug_r(i_en_debug_r),
  .q_address(i_q_address),
  .q_be(i_q_be),
  .q_cmd(i_q_cmd),
  .q_cmdval(i_q_cmdval),
  .q_eop(i_q_eop),
  .q_rspack(i_q_rspack),
  .q_wdata(i_q_wdata),
  .q_plen(i_q_plen),
  .q_buffer(i_q_buffer),
  .q_cache(i_q_cache),
  .q_mode(i_q_mode),
  .q_priv(i_q_priv),
  .hold_host(i_hold_host),
  .code_dmi_rdata(code_dmi_rdata),
  .noaccess(i_noaccess),
  .reset_applied_r(i_reset_applied_r),
  .power_toggle(power_toggle),
  .pc_sel_r(i_pc_sel_r),
  .h_datar(i_h_datar),
  .pcp_d_rd(i_pcp_d_rd),
  .pcp_ack(i_pcp_ack),
  .pcp_dlat(i_pcp_dlat),
  .pcp_dak(i_pcp_dak),
  .ldst_dmi_rdata(ldst_dmi_rdata)
);


// Instantiation of module ibus_cksyn
ibus_cksyn iibus_cksyn(
  .clk_ungated(i_clk_ungated),
  .clk_system(i_clk_system),
  .rst_a(i_rst_a),
  .sync(i_sync)
);


// Instantiation of module jtag_port
jtag_port ijtag_port(
  .clk_ungated(i_clk_ungated),
  .jtag_tck(jtag_tck),
  .jtag_trst_a(i_jtag_trst_a),
  .rst_a(i_rst_a),
  .test_mode(test_mode),
  .en(i_en),
  .reset_applied_r(i_reset_applied_r),
  .h_datar(i_h_datar),
  .noaccess(i_noaccess),
  .hold_host(i_hold_host),
  .pcp_d_rd(i_pcp_d_rd),
  .pcp_ack(i_pcp_ack),
  .pcp_dlat(i_pcp_dlat),
  .pcp_dak(i_pcp_dak),
  .pc_sel_r(i_pc_sel_r),
  .jtag_tdi(jtag_tdi),
  .jtag_tms(jtag_tms),
  .jtag_bsr_tdo(jtag_bsr_tdo),
  .jtag_busy(u_unconnected_1),
  .h_addr(i_h_addr),
  .h_dataw(i_h_dataw),
  .h_write(i_h_write),
  .h_read(i_h_read),
  .aux_access(i_aux_access),
  .core_access(i_core_access),
  .madi_access(u_unconnected_2),
  .halt(i_halt),
  .xstep(i_xstep),
  .pcp_wr_rq(i_pcp_wr_rq),
  .pcp_rd_rq(i_pcp_rd_rq),
  .pcp_addr(i_pcp_addr),
  .pcp_brst(u_unconnected_3),
  .pcp_mask(u_unconnected_4),
  .pcp_d_wr(i_pcp_d_wr),
  .jtag_tdo(jtag_tdo),
  .jtag_tdo_zen_n(jtag_tdo_zen_n),
  .jtag_extest_mode(u_unconnected_5),
  .jtag_sample_mode(u_unconnected_6),
  .updatedr_en(u_unconnected_7),
  .capturedr_en(u_unconnected_8),
  .shiftdr_en(u_unconnected_9)
);


// Output drives
assign en                     = i_en;

endmodule


