// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2001-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This modules controls access to the ICCM RAM. It arbitrates between
// the following three interfaces (mentioned in priority order): 
//  
//       1. ICCM RAM Direct Memory Interface (ICCM RAM DMI)
//       2. Data Memory Pipeline (DMP) interface
//       3. Instruction fetch interface.
// 
// 
// ===================== Inputs to this module =======================--
//
// clk_ungated      Core ungated clock. Ungated clock  is used so
//                  that if a DMI request comes in when the clock is
//                  asleep, the request is still handled.
//
// rst_a            Global asynchronous reset signal.
//
// test_mode        Global production test mode signal.
//
// ivic             Invalidate Instruction Cache (IVIC) signal. When set
//                  the instruction fetch state machine in this module
//                  returns to the idle state, where the ivalid signal
//                  is set to 0. The reason for doing this is to force 
//                  ivalid to 0 by the time the ifetch generated by the 
//                  ivic arrives. If ivalid would not be low when this 
//                  ifetch comes then the instruction fetch interface 
//                  would go into an illegal state, because the earliest 
//                  the first ivalid can arrive is on the cycle after the
//                  first ifetch.
//
//                  Unlike the intruction cache the data in the ICCM RAM 
//                  remains valid after an ivic has been performed.
//
// code_ram_rdata   Read data from the ICCM RAM.
//
// ifetch           Instruction request signal from the processor.
//
// next_pc          Address of the next instruction to be fetched.
//
// dmp_dwr          The load write data bus is connected to the DMP
//                  sub-modules, the peripherals and the ICCM RAM. Write
//                  data can come from either the ARC pipeline or the
//                  debug interface, depending on which module requests
//                  to write to memory.
//
// dmp_en3          Pipeline stage 3 enable signal is connected to the
//                  DMP sub-modules, the peripherals and the ICCM RAM.
//                  This signal is controlled by either the ARC
//                  pipeline or the debug access unit. When set
//                  a DMP sub-module, the ICCM RAM or a peripheral will
//                  service the load/store request.
//
// dmp_addr         The load/store address is connected to the DMP
//                  sub-modules, the peripherals and the ICCM RAM. This
//                  address can come from either the ARC pipeline or
//                  the debug interface, depending on which module
//                  requests access to memory.
//
// dmp_mload        The load instruction indicator. When it is set
//                  either the ARC or the debug interface wish to load
//                  data from an address in the LD/ST memory space.
//
// dmp_mstore       The store instruction indicator. When it is set
//                  either the ARC or the debug interface wish to store
//                  data to an address in the LD/ST memory space.
//
// dmp_size         The size of transfer signal is connected to the
//                  DMP-submodules, the peripherals and the ICCM RAM.
//                  This is always cleared in debug mode. In ARC access
//                  mode, it is controlled by the ARC pipeline.
//
// dmp_sex          The sign extend signal is connected to the
//                  DMP-submodules, the peripherals and the ICCM RAM.
//                  It is always cleared in debug mode. In ARC access
//                  mode it is controlled from the ARC pipeline.
//
// hold_loc         This is a hold signal for the ICCM RAM and the
//                  LD/ST RAM. If any of these RAM's are trying to
//                  return a load on the same cycle that hold_loc
//                  is set then the load return should be reissued on
//                  the next cycle.
//
// is_code_ram      This is set when the address (dmp_addr) is within
//                  the ICCM RAM address range.
//
// code_dmi_req     The DMI request to ICCM RAM. When set the direct
//                  memory interface (DMI) has immediate access
//                  to the ICCM RAM. Other ICCM RAM interfaces
//                  (instruction fetch and data memory pipeline) are
//                  held off as they have lower priority. During one
//                  access several reads and writes can be performed.
//                  The DMI access ends when this signal is again set
//                  low.
//
// code_dmi_addr    The address for the ICCM RAM Direct Memory
//                  Interface.
//
// code_dmi_wdata   The write data for the ICCM RAM Direct Memory
//                  Interface.
//
// code_dmi_wr      The write enable for the ICCM RAM Direct Memory
//                  Interface. Set means write and clear means read.
//
// code_dmi_be      The byte enables on the ICCM RAM Direct Memory
//                  Interface. There are four enables, one for each 
//                  byte.
//
// ================ outputs from this module =====================--
//
// p1iw             The instruction word supplied by the ICCM RAM to the
//                  pipeline stage 1 of the processor. It is valid when
//                  ivalid is true.
//
// ivalid           The valid signal for p1iw.
//
// code_drd         The load data return bus from the ICCM RAM.
//
// code_ldvalid_r   Indicates that the ICCM RAM wishes to perform a
//                  writeback on the next cycle.This signal is set when
//                  code_drd contains valid data.
//
// code_dmi_rdata   Read data to the ICCM RAM Direct Memory Interface.
//                  byte lane. The byte enable bus is little endian.
//
module iccm_control (
   clk_ungated,
   rst_a,
   ck_disable,
   test_mode,
   ivic,
   code_ram_rdata,
   ifetch,
   next_pc,
   dmp_dwr,
   dmp_en3,
   dmp_addr,
   dmp_mload,
   dmp_mstore,
   dmp_size,
   dmp_sex,
   hold_loc,
   is_code_ram,
   code_dmi_req,
   code_dmi_addr,
   code_dmi_wdata,
   code_dmi_wr,
   code_dmi_be,

   code_ram_addr,
   code_ram_wdata,
   code_ram_wr,
   code_ram_be,
   code_ram_ck_en,
   p1iw,
   ivalid,
   code_drd,
   code_ldvalid_r,
   code_dmi_rdata,
   code_stall_ldst,
   ic_busy);

`include "arcutil_pkg_defines.v"
`include "arcutil.v"
`include "extutil.v"
`include "xdefs.v"

input                       clk_ungated;
input                       rst_a; 
input                       ck_disable;
input                       test_mode; 
input                       ivic;

// ICCM RAM interface
//
input   [31:0]              code_ram_rdata; 

//  Instruction fetch interface
// 
input                       ifetch;
input   [PC_MSB:0]          next_pc; 

//  Data Memory Pipeline (DMP) interface
// 
input   [31:0]              dmp_dwr; 
input                       dmp_en3; 
input   [31:0]              dmp_addr; 
input                       dmp_mload; 
input                       dmp_mstore; 
input   [1:0]               dmp_size; 
input                       dmp_sex; 
input                       hold_loc; 
input                       is_code_ram; 
input                       code_dmi_req; 

//  ICCM RAM Direct Memory Interface (ICCM RAM DMI)
// 
input   [31:0]              code_dmi_addr; 
input   [31:0]              code_dmi_wdata; 
input                       code_dmi_wr; 
input   [3:0]               code_dmi_be; 

// ICCM RAM interface
//
output  [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] code_ram_addr; 
output  [31:0]              code_ram_wdata; 
output                      code_ram_wr; 
output  [3:0]               code_ram_be; 
output                      code_ram_ck_en; 

//  Instruction fetch interface
// 
output  [31:0]              p1iw; 
output                      ivalid; 

//  Data Memory Pipeline (DMP) interface
// 
output  [31:0]              code_drd; 
output                      code_ldvalid_r;

//  ICCM RAM Direct Memory Interface (ICCM RAM DMI)
// 
output  [31:0]              code_dmi_rdata; 

//  Instruction cache busy signal (tied low)
// 
output                      ic_busy; 

output                      code_stall_ldst;

wire    [CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:0] code_ram_addr; 
wire    [31:0]              code_ram_wdata; 
wire                        code_ram_wr; 
wire    [3:0]               code_ram_be; 
wire                        code_ram_ck_en; 

wire    [31:0]              p1iw; 
wire                        ivalid; 
wire    [31:0]              code_drd; 
wire                        code_ldvalid_r; 
wire    [31:0]              code_dmi_rdata;
wire                        ic_busy; 

reg     [31:0]              i_p1iw_last_r; 
reg     [3:0]               i_dmp_be_a; 
wire    [31:0]              i_long_a; 
wire    [15:0]              i_word; 
wire    [7:0]               i_byte; 
wire    [31:0]              i_sxtl; 
wire    [31:0]              i_extl; 
wire                        i_iccm_busy_nxt; 
reg                         i_iccm_busy_r; 
wire    [31:0]              i_iccm_drd_nxt; 
reg     [31:0]              i_iccm_drd_r; 
reg     [1:0]               i_iccm_state_r; 
wire                        i_code_dmp_req_a; 
reg                         i_dmp_sex_r; 
reg     [1:0]               i_dmp_size_r; 
reg     [1:0]               i_dmp_addr_lsb_r; 
reg                         i_ld_rtn_again_r; 
reg                         i_code_ldvalid_r;
reg     [1:0]               i_dmp_shift_a;
   

//  The instruction cache busy signal is always tied low
//  because a ICCM RAM cannot coexist with an instruction
//  cache.
// 
assign ic_busy = 1'b 0; 

assign code_stall_ldst = 1'b 0;

// =========================================================
// 
//  ICCM RAM interface
// 
// =========================================================
//  ICCM RAM address
// 
assign code_ram_addr = (code_dmi_req == 1'b 1) ?
       code_dmi_addr[2+CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:2] : 
                       (i_code_dmp_req_a == 1'b 1) ?
       dmp_addr[2+CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:2] :

    next_pc[2+CODE_RAM_ADDR_MSB-CODE_RAM_ADDR_LSB:2]; 

 // Endian aware write-data shifting:
   always @(dmp_addr)   
   begin : wdshift_calc_async_PROC

  // Little-endian: shift = long-word byte-offset
   i_dmp_shift_a = dmp_addr[1:0];
   end 

//  ICCM RAM write data
// 
assign code_ram_wdata = (code_dmi_req == 1'b 1) ?
       code_dmi_wdata : 
                        (i_dmp_shift_a == BYTE1) ?
       {dmp_dwr[23:0], dmp_dwr[31:24]} : 
                        (i_dmp_shift_a == BYTE2) ?
       {dmp_dwr[15:0], dmp_dwr[31:16]} : 
                        (i_dmp_shift_a == BYTE3) ?
       {dmp_dwr[7:0], dmp_dwr[31:8]} : 
       dmp_dwr; 

//  ICCM RAM write enable
// 
assign code_ram_wr = (((code_dmi_req == 1'b 1) & 
                       (code_dmi_wr == 1'b 1)) | 

                      ((dmp_mstore == 1'b 1) & 
                       (dmp_en3 == 1'b 1) & 
                       (is_code_ram == 1'b 1))) ?
       CODE_WR_ACTIVE : 
       CODE_RE_ACTIVE; 

//  ICCM RAM byte enable
// 
assign code_ram_be = (code_dmi_req == 1'b 1) ? code_dmi_be : 

                     (i_code_dmp_req_a == 1'b 1) ? i_dmp_be_a : 

               4'b 1111; 

//  ICCM RAM clock enable
// 
//  The ICCM RAM is enabled when:
// 
//     [1] During production test mode
//     [2] When there is a request on the DMI interface
//     [3] When there is a request on the DMP interface
//     [4] When there is a request on the ifetch interface
//     [5] The cycle after a DMI or DMP access in order to
//         update the read data.
// 
assign code_ram_ck_en = (test_mode      == 1'b 1) | 
                        (code_dmi_req   == 1'b 1) | 
                        (i_code_dmp_req_a == 1'b 1) | 
                        (ifetch == 1'b 1 & ck_disable == 1'b0) | 
                        (i_iccm_busy_r == 1'b 1) ? CODE_CK_EN_ACTIVE :

       ~CODE_CK_EN_ACTIVE; 

//  The ICCM RAM needs to be enabled one cycle after a DMP or 
//  DMI access, in order to update read data.
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : iccm_busy_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_iccm_busy_r <= 1'b 0;    
      end
   else
      begin
      i_iccm_busy_r <= i_iccm_busy_nxt;   
      end
   end

// =========================================================
// 
//  DMI interface
// 
// =========================================================

//  Read data 
// 
assign code_dmi_rdata = code_ram_rdata; 

// =========================================================
// 
//  DMP interface
// 
// =========================================================

//  Generation of the DMP request signal
// 
assign i_code_dmp_req_a = 

                 (((dmp_mload == 1'b 1) | (dmp_mstore == 1'b 1)) & 
                  (dmp_en3 == 1'b 1) & 
                  (is_code_ram == 1'b 1)) ? 1'b 1 : 
           1'b 0; 

//  Generation of the DMP byte enables
// 
always @(dmp_addr or dmp_size)
   begin : dmp_be_async_PROC

   case (dmp_size)

   //  Byte mask
   //
   LDST_BYTE:
      begin

      case (dmp_addr[1:0])
      BYTE0:
         begin
         i_dmp_be_a = BYTE0_MASK;
         end
      BYTE1:
         begin
         i_dmp_be_a = BYTE1_MASK;    
         end
      BYTE2:
         begin
         i_dmp_be_a = BYTE2_MASK;    
         end
      default:
         begin
         i_dmp_be_a = BYTE3_MASK;    
         end
      endcase
      end

   //  Word mask
   // 
   LDST_WORD:
      begin
      if (dmp_addr[1] == 1'b 0)
         begin
         i_dmp_be_a = WORD0_MASK;    
         end
      else
         begin
         i_dmp_be_a = WORD1_MASK;    
         end
      end

   //  Longword mask
   // 
   default:
      begin
      i_dmp_be_a = LONG_MASK;    
      end
   endcase
   end

//  Store DMP request data needed for the return data
// 
//  Part of the DMP's request is stored to allow return 
//  data to be processed on the next cycle. This is 
//  necessary in order to remember which byte lanes were
//  requested and whether return data needs to be sign 
//  extended.
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : dmp_req_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_dmp_size_r     <= {(TWO){1'b 0}};   
      i_dmp_addr_lsb_r <= {(TWO){1'b 0}};   
      i_dmp_sex_r      <= 1'b 0;    
      end
   else
      begin
      if ((dmp_mload == 1'b 1) & 
          (dmp_en3 == 1'b 1) & 
          (is_code_ram == 1'b 1))
         begin
         i_dmp_size_r     <= dmp_size;  
         i_dmp_addr_lsb_r <= dmp_addr[1:0]; 
         i_dmp_sex_r      <= dmp_sex;   
         end
      end
   end

//  Generation of DMP return data
//  
//  Requested byte lanes are sent back on the DMP 
//  interface. Return data (code_drd) always start
//  at bit 0 even if only the second, third or fourth 
//  byte lane was requested. Also, return data is 
//  extended or sign extended depending on the signal 
//  dmp_sex.
// 
assign i_long_a = code_ram_rdata; 

assign i_word = (i_dmp_addr_lsb_r[1] == 1'b 1) ? i_long_a[31:16] : 
    i_long_a[15:0]; 

assign i_byte = (i_dmp_addr_lsb_r[0] == 1'b 1) ? i_word[15:8] :
    i_word[7:0]; 

assign i_sxtl = (i_dmp_size_r == LDST_LWORD) ? i_long_a : 

                (i_dmp_size_r == LDST_BYTE) ? {{(TWENTY_FOUR){i_byte[7]}}, i_byte}:

            {{(SIXTEEN){i_word[15]}}, i_word}; 

assign i_extl = (i_dmp_size_r == LDST_LWORD) ? i_long_a : 

                (i_dmp_size_r == LDST_BYTE) ? {{(TWENTY_FOUR){1'b 0}}, i_byte} : 

            {{(SIXTEEN){1'b 0}}, i_word}; 

// Select whether to sign extended.
//
assign i_iccm_drd_nxt = (i_dmp_sex_r == 1'b 1) ? i_sxtl : 
       i_extl; 

//  If there is a returning load from the ICCM RAM on
//  the DMP interface that has been held back (hold_loc=1),
//  store the data so that it can be returned during
//  the next cycle.
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : iccm_drd_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_iccm_drd_r <= {(THIRTY_TWO){1'b 0}};    
      i_ld_rtn_again_r <= 1'b 0;    
      end
   else
      begin
      i_ld_rtn_again_r <= hold_loc & i_code_ldvalid_r;

      if ( (hold_loc         == 1'b 1) & 
           (i_code_ldvalid_r == 1'b 1) &
           (i_ld_rtn_again_r == 1'b 0) )
         begin
         i_iccm_drd_r <= i_iccm_drd_nxt;  
         end
      end
   end

//  Return data on the DMP interface
// 
//  If the return data did not manage to return on the 
//  previous cycle then return this stored data. Otherwise, 
//  return data directly from ICCM RAM output.
// 
assign code_drd = (i_ld_rtn_again_r == 1'b 1) ? i_iccm_drd_r : 
       i_iccm_drd_nxt; 

//  Generate a valid signal for the returning load.
// 
//  The valid signal is set if there was a DMP request that
//  was serviced on the previous cycle or if the load was 
//  not allowed to return and a new attempt is needed.
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : code_ldvalid_PROC
   if (rst_a == 1'b 1)
      begin
      i_code_ldvalid_r <= 1'b 0;    
      end
   else
      begin
      if (((dmp_mload == 1'b 1) & 
           (dmp_en3 == 1'b 1) & 
           (is_code_ram == 1'b 1)) | 

         ((hold_loc == 1'b 1) & 
          (i_code_ldvalid_r == 1'b 1)))
         begin
         i_code_ldvalid_r <= 1'b 1; 
         end
      else
         begin
         i_code_ldvalid_r <= 1'b 0; 
         end
      end
   end

assign code_ldvalid_r = i_code_ldvalid_r; 

// =========================================================
// 
//  Instruction fetch interface
// 
// =========================================================

//  The ICCM RAM is busy (as seen by the instruction fetch 
//  interface) when a request is issued on either the DMI or
//  the DMP interface.
// 
assign i_iccm_busy_nxt = code_dmi_req | 
                         i_code_dmp_req_a; 

//  Finite state machine
// 
//  Based entirely on the example in the aim ifetch section
//  Plus, added read capability. KS
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : iccm_fsm_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_iccm_state_r <= `ICCM_IDLE;   
      end
   else
      begin
      case (i_iccm_state_r)

         //Idle state - before any ifetches have been received.
         //
         `ICCM_IDLE:
            begin

            // If an Invalidate Instruction Cache (IVIC) signal is
            // received then remain in the idle state.
            //
            if (ivic == 1'b 1)

                i_iccm_state_r <= `ICCM_IDLE;

            else if (ifetch == 1'b 1)
               begin
               //  Move to active state if we receive an ifetch 
               //  and it can be accomodated. Move to wait state if
               //  we receive an ifetch and it cannot be accomodated.
               // 
               if (i_iccm_busy_nxt == 1'b 1)
                  begin
                  i_iccm_state_r <= `ICCM_STALL;  
                  end
               else
                  begin
                  i_iccm_state_r <= `ICCM_ACTIVE; 
                  end
               end
            else
               //  If not, stay where we are.
               // 
               begin
               i_iccm_state_r <= `ICCM_IDLE;  
               end
            end

         //  Ifetch Active state - an ifetch is underway this cycle!
         // 
         `ICCM_ACTIVE:
            begin

            // If an Invalidate Instruction Cache (IVIC) signal is
            // received then go to the idle state.
            //
            if (ivic == 1'b 1)

                i_iccm_state_r <= `ICCM_IDLE;

            //  Move to hold state if we do not receive another 
            //  ifetch and we will not have a RAM access on the next 
            //  cycle.
            // 
            else if (ifetch == 1'b 0 & i_iccm_busy_nxt == 1'b 1)
               begin
               i_iccm_state_r <= `ICCM_HOLD;  
               end

            //  Move to wait state if we do receive another ifetch
            //  which cannot be accomodated on this cycle.
            //
            else if (ifetch == 1'b 1 & i_iccm_busy_nxt == 1'b 1)
               begin
               i_iccm_state_r <= `ICCM_STALL; 
               end

            //  Otherwise, stay where we are if we will have access
            //  to the RAM on the next cycle.
            //
            else
               begin
               i_iccm_state_r <= `ICCM_ACTIVE;    
               end
            end

         //  Maintain the last correctly fetched instruction word.
         //
         `ICCM_HOLD:
            begin

            // If an Invalidate Instruction Cache (IVIC) signal is
            // received then go to the idle state.
            //
            if (ivic == 1'b 1)

                i_iccm_state_r <= `ICCM_IDLE;

            //  If the RAM will be available to us on the next cycle
            //  then return to the 'active ifetch state'
            // 
            else if (i_iccm_busy_nxt == 1'b 0)
               begin
               i_iccm_state_r <= `ICCM_ACTIVE;    
               end

            //  Move to wait state if we do receive another ifetch
            //  which cannot be accomodated on this cycle.
            // 
            else if (ifetch == 1'b 1 & i_iccm_busy_nxt == 1'b 1)
               begin
               i_iccm_state_r <= `ICCM_STALL; 
               end

            //  Remain in hold state if we do not receive another 
            //  ifetch and we will not have RAM access on the next 
            //  cycle.
            // 
            else
               begin
               i_iccm_state_r <= `ICCM_HOLD;  
               end
            end

            //  A collision has occured between the ifetch access and 
            //  some other type of access to the RAM. We tell the ARC 
            //  that no instruction is available, and wait until we have
            //  access again before we can fetch the instruction.
            // 

         `ICCM_STALL:
            begin

            // If an Invalidate Instruction Cache (IVIC) signal is
            // received then go to the idle state.
            //
            if (ivic == 1'b 1)

                i_iccm_state_r <= `ICCM_IDLE;

            //  If the RAM will be available to us on the next cycle,
            //  then return to the 'active ifetch state'.
            // 
            else if (i_iccm_busy_nxt == 1'b 0)
               begin
               i_iccm_state_r <= `ICCM_ACTIVE;    
               end
            else
               begin
               i_iccm_state_r <= `ICCM_STALL; 
               end
            end
         default: i_iccm_state_r <= `ICCM_IDLE;
      endcase
      end
   end

//  Hold the last instruction word when we are in the 'hold' state.
// 
assign p1iw = (i_iccm_state_r == `ICCM_HOLD) ?
       i_p1iw_last_r :
       code_ram_rdata; 

//  An instruction will only be available when we are in the 'active'
//  or 'instruction hold' states.
// 
assign ivalid = ( (i_iccm_state_r == `ICCM_ACTIVE)
                | (i_iccm_state_r == `ICCM_HOLD) 
                ) ? 1'b 1 : 
    1'b 0; 

//  Storage of last instruction fetched
// 
always @(posedge clk_ungated or posedge rst_a)
   begin : hold_sync_PROC
   if (rst_a == 1'b 1)
      begin
      i_p1iw_last_r <= {(THIRTY_TWO){1'b 0}}; 
      end
   else
      //  Whenever the RAM actively supplies an instruction word,
      //  store it in case it is required on the next cycle
      // 
      begin
      if (i_iccm_state_r == `ICCM_ACTIVE)
         begin
         i_p1iw_last_r <= code_ram_rdata;   
         end
      end
   end

endmodule 
