// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// This file is extension auxiliary register unit for:
//       Gate-level power meterics toggle switch, power_toggle signal.
//       On-chip LD/ST RAM.
//       ICCM RAM Configuration (i.e. IVIC)
//       JTAG Port Interface, i.e. pc_sel signal.
//       Small Score Boarded Multiply Instruction, Revision info. :  600 Architecture IP Library version 4.9.7, file revision  $Date$
//       Auxiliary Timer Counter 0
// 
//
//=========================== Inputs to this block ==========================--
//
// aux_access       U Auxiliary Access. This signal is flagged by the host to
//                  inform the ARC that the address supplied on h_addr[31:0]
//                  applies to the auxiliary register set. 
//
// aux_addr[31:0]   U Auxiliary Register Address. This is produced by the 
//                  hostif.v, from the host address when the ARC is halted
//                  (en = '0') or from source 1 from pipeline stage 3, when
//                  the ARC is running. Width of decode is set by AUXDECSZ 
//                  in extutil.v. 
//
// aux_dataw[31:0]  U Auxiliary Write Data. The auxiliary register bus 
//                  write data value is latched into auxiliary register
//                  specified by aux_addr[31:0] at the end of the cycle when
//                  aux_write is true. This is generated by hostif.v, 
//                  either from the host's write data bus when the ARC is 
//                  halted (en = '0') or from source 1 from pipeline stage 3,
//                  when the ARC is running.
//
// aux_read         U Auxiliary Read. This signal indicates that a read is 
//                  taking place on this cycle. This is initiated either by
//                  an LR instruction when the ARC is running, or by a host
//                  read when the ARC is halted (for single access aux 
//                  registers). The data stored at location aux_addr[31:0]
//                  should be placed on drx_reg[31:0]. The xreg_hit signal
//                  should be asserted if the register in question is
//                  recognised as a valid extension auxiliary register.
//                  For dual access registers, aux_regs.v and hostif.v
//                  will select the correct data values to go to the ARC and
//                  the host.
//
// aux_write        U Auxiliary Write. This signal indicates that a write
//                  (either from the ARC or host) is being performed to
//                  the auxiliary register specified on aux_addr[31:0] on 
//                  this cycle. This signal is set by hostif.v by a SR
//                  instruction when the ARC is running or a host when it is
//                  halted. The data supplied by aux_dataw[31:0] should be 
//                  latched into register specified by aux_addr[31:0] at the
//                  end of the cycle.
//                  For dual access extension registers, writes are ignored
//                  from regular auxiliary register bus aux_write, aux_addr[],
//                  and aux_dataw[] when the ARC is halted.
//
// core_access      U Core Access. This enable signal is held high by the host
//                  to indicate that it is accessing core registers.
//
// en2b             U Pipeline stage 2B enable. When this signal is true, the
//                  instruction in stage 2B can pass into stage 3 at the end
//                  of the cycle. When it is false, it will hold up stage 2B,
//                  stage 2 and stage 1 (pcen).
//
// en3              U Pipeline stage 3 enable. When this signal is true, the
//                  instruction in stage 3 can pass into stage 4 at the end
//                  of the cycle. When it is false, it will probably hold up
//                  stages one (pcen), two (en2), two B (en2b)and three. It
//                  is set in the rctl block.
//
// h_addr[31:0]     L Host Address. This is a longword-granularity address
//                  latched by the host before being presented to the register
//                  module. This is a 32-bit address (it may be smaller,
//                  but packed with zeroes) from the host which is used to
//                  access registers in the ARC in conjuction with aux_access
//                  and core_access. The width of the decode applied to this
//                  32-bit quantity is defined by the AUXDECSZ constant, found
//                  in extutil.v. It is defined as being a 32-bit bus
//                  at this level to maintain compatibility with the LR and 
//                  SR instructions which can generate a 32-bit value for the
//                  address to be used for auxiliary register accesses.
//
// h_dataw[31:0]    L Host Write Data. This bus carries the data which is to
//                  be stored into registers in the ARC/extensions. It is 
//                  latched by the host as is the address, h_addr[31:0].
//                  
// h_write          U Host Write. When the host signals h_write is true, this 
//                  signal indicates that a host write is taking place, and
//                  the register module should latch the data on h_dataw[31:0]
//                  at the end of the cycle.
//
// h_read           U Host Read. This signal is held high by the host to
//                  indicate that a host read is taking place, and the data
//                  will be latched from h_datar[31:0] at the end of the
//                  cycle.
//
// ic_busy          U No Invalidate Instruction Cache. This signal is set true
//                  by dmcc.v, to indicate that no instruction cache
//                  invalidate requests (ivic) are to be made as the cache is
//                  busy. It is set true during tag clearing and line loads 
//                  from memory.
//
// l_irq[31:3]      L Latched external interrupts. A maximum of 8 external
//                  external interrupt may be generated.
//
// p3sr             U Pipeline Stage 3, SR. This signal is generated by 
//                  rctl.v to indicate that a valid SR instruction is in 
//                  stage 3.  It is produced from a decode of p3i[4:0], 
//                  p3iw(25) (check for SR) and includes p3iv. Here it is
//                  basically used for separate decoding of auxiliary accesses
//                  from host and ARC.
//
// p3lr             U Pipeline Stage 3, LR. This signal is generated by 
//                  rctl.v to indicate that a valid LR instruction is in 
//                  stage 3 and includes p3iv. Here it is basically used for
//                  separate decoding of auxiliary accesses from host and ARC.
//
// s1val[31:0]      U This bus is the source 1 bus latched from s1bus[31:0] 
//                  when the instruction in stage 2 passes on to stage 3.
//                  It is used as an input to the ALU, and for various other
//                  purposes outside rctl.v.
//
// s2val[31:0]      U This bus is the source 2 bus latched from s2bus[31:0] 
//                  when the instruction in stage 2 passes on to stage 3.
//                  It is used as an input to the ALU, and for various other
//                  purposes outside rctl.v.
//
// sr_xhold_host_a  U Stall From Register File for Host Access. The register
//                  file signals a stall to xhold_host if it has not completed
//                  a read from the register file. Hence a stall is
//                  generated when :
//
//                  The ARC is halted,
//                  The host is attempting a core register read,
//                  The previous cycle's host access was OK (not stalled).
//                  This is not necessary for the ARCAngel build.
//
// aux_lv12         L signal directly from the l_aux_lv12 register in int_unit
//                  module. This 2 bit register indicates when either level 1
//                  or level 2 interrupts are taken in the interrupt subsystem.
//
// aux_hint         L signal directly from the l_aux_h_int register in int_unit
//                  module. This 5 bit register contains the interrupt number
//                  for the software triggered interrupt.
//
// aux_lev          L signal directly from the l_aux_lev register in int_unit
//                  module. This 13 (or 29 bit for extended case) register
//                  is used for programming the interrupt level of each
//                  configured interrupt signal.
//
//========================= Output from this block ==========================--
//
// drx_reg[31:0]    U Data Read Extension Register. This bus carries the value
//                  from the extension auxiliary register specified by 
//                  aux_addr[31:0]. The data is placed onto aux_datar[31:0] by
//                  the ARC auxiliary register unit when xreg_hit is true. 
//                  Note this will be ignored unless enabled using the
//                  XT_AUXREG constant in extutil.v.
//
// xreg_hit         U Extension Register Hit. This signal is used to indicate
//                  to the auxiliary register module that the location
//                  aux_addr[31:0] is valid extension auxiliary register,
//                  hence the data present on the drx_regs[31:0] bus, and 
//                  should be driven onto aux_datar[]. This controls the data
//                  that gets onto the bus between hostif.v and
//                  aux_regs.v for single access reads. For dual access 
//                  reads xreg_hit is ignored by hostif.v when the ARC is
//                  halted.
//                  ** Note that existing auxiliary registers take priority
//                     if this signal is true when internal aux registers are
//                     being accessed **
//
// x_da_am          U Extension Dual Access Address Match. This signal is true
//                  when the address on h_addr[31:0] matches a dual access
//                  auxiliary registers provided by extension logic, and
//                  indicates that aux_regs should place the data on x_dar[]
//                  onto the aux_dar[] bus.
//
// x_dar[31:0]      U Extension Dual Access Read. This is the host-side data
//                  from a extension dual access register to xaux_regs.v,
//                  where it is multiplexed with data from basecase dual 
//                  access registers before being passed onto the hostif.v.
//
// id_arcnum[7:0]   C ARC Identity Number. This signal defines bits 15:8 of 
//                  the ARC's identity register. It will be fixed at some 
//                  value to allow different ARCs in a multiple ARC system to
//                  have a unique identity.
//
// xnoaccess        U Extension No Host Access. This indicates to the host 
//                  interface that the extension auxiliary unit rejects the
//                  host access when it is true.
//
// xhold_host       U Stall Host Access. When true this signal indicates that
//                  the host must be held off for a cycle since the extension
//                  auxiliary unit is busy completing a task.
//
// dc_disable_r     L Data cache disable flag (DC flag). If there is no data
//                  cache in the build then this signal is always set.
//
// ivic             U Invalidate Instruction Cache. This indicates that all 
//                  values in the cache are to be invalidated. (it stands for
//                  InValidate Instruction Cache). It is anticipated that this
//                  signal will be generated from a decode of an store (SR) 
//                  instruction.
//                  Note that due to the pipelined nature of the ARC, up to  
//                  three instructions could be issued following the SR which 
//                  generates the ivic signal to dmcc.v. Cache invalidates  
//                  must be supressed when a line is being loaded from memory. 
//
// irq[31:3]        L Interrupt signals send to the interrupt unit. The
//                  interrupts may be externally generated i.e. connected to
//                  external pins, connected to on-chip peripherals, e.g. UARTs
//                  and VMACs or be diconnected i.e. assigned to zero. The
//                  system builder should assign the interrupt connectivity
//                  as specified by the user.
//
// wd_clear         This signal is produced by or-ing all the watchdog clear
//                  signals from timers and is input to io_flops.v where it
//                  check synchronously and if asserted then the system reset
//                  line is activated for one cycle.
//
//===========================================================================--
//

module xaux_regs (clk,
                  rst_a,
                  en,
                  aux_addr,
                  aux_dataw,
                  aux_write,
                  aux_read,
                  h_addr,
                  h_dataw,
                  h_write,
                  h_read,
                  aux_access,
                  core_access,
                  en2b,
                  en3,
                  s1val,
                  s2val,
                  x_s_flag,
                  x_set_sflag,
		  // external or external peripheral IRQs.
	          l_irq_4,
	          l_irq_5,
	          l_irq_6,
	          l_irq_7,
	          l_irq_8,
	          l_irq_9,
	          l_irq_10,
	          l_irq_11,
	          l_irq_12,
	          l_irq_13,
	          l_irq_14,
	          l_irq_15,
	          l_irq_16,
	          l_irq_17,
	          l_irq_18,
	          l_irq_19,
		  // Internal peripherals (e.g. timer)
		  l_irq_3,
                  sr_xhold_host_a,
                  ic_busy,
                  p3lr,
                  p3sr,
                  aux_lv12,
                  aux_hint,
                  aux_lev,
                  uxdrx_reg,  
                  uxreg_hit,  
                  ux_da_am,   
                  ux_dar,     
                  uxivic,     
                  uxhold_host,
                  uxnoaccess, 
   ap_ahv0,
   ap_ahv1,
   ap_ahv2,
   ap_ahv3,
   ap_ahv4,
   ap_ahv5,
   ap_ahv6,
   ap_ahv7,
   ap_ahc0,
   ap_ahc1,
   ap_ahc2,
   ap_ahc3,
   ap_ahc4,
   ap_ahc5,
   ap_ahc6,
   ap_ahc7,
   ap_ahm0,
   ap_ahm1,
   ap_ahm2,
   ap_ahm3,
   ap_ahm4,
   ap_ahm5,
   ap_ahm6,
   ap_ahm7,
                  timer_r,
                  tlimit_r,
                  timer_pirq_r,
                  tcontrol_r,
                  timer_mode_r,
                  timer_clr_r,
                  twatchdog_r,

                  drx_reg,
                  xreg_hit,
                  x_da_am,
                  x_dar,
                  id_arcnum,
                  xnoaccess,
                  xhold_host,
                  xcache_hold_host,
                  dc_disable_r,
                  // extra signals for host interface                  
                  power_toggle,
                  lram_base,
                  // extra signals for host interface                  
                  pc_sel_r,
                  aux_st_mulhi_a,
                  int_vector_base_r,
                  irq,
                  ivic,
                  wd_clear
                  );
   
`include "arcutil_pkg_defines.v" 
`include "arcutil.v"
`include "asmutil.v"
`include "ext_msb.v"
`include "extutil.v"
`include "che_util.v"
`include "xdefs.v"

// Extra include files required for extensions are inserted here.

   input         clk; //  system clock
   input         rst_a; //  system reset
   input         en; //  system go
   
   input  [31:0] aux_addr; 
   input  [31:0] aux_dataw; 
   input         aux_write; 
   input         aux_read; 
   input  [31:0] h_addr; 
   input  [31:0] h_dataw; 
   input         h_write; 
   input         h_read; 
   input         aux_access; 
   input         core_access;
   input         en2b; 
   input         en3; 
   input  [31:0] s1val;
   input  [31:0] s2val;
   input  [1:0]  x_s_flag;
   input         x_set_sflag;
   input         l_irq_4;
   input         l_irq_5;
   input         l_irq_6;
   input         l_irq_7;
   input         l_irq_8;
   input         l_irq_9;
   input         l_irq_10;
   input         l_irq_11;
   input         l_irq_12;
   input         l_irq_13;
   input         l_irq_14;
   input         l_irq_15;
   input         l_irq_16;
   input         l_irq_17;
   input         l_irq_18;
   input         l_irq_19;
   input         l_irq_3;
   input         sr_xhold_host_a;
   input         ic_busy; 
   input         p3lr; 
   input         p3sr; 
   input  [1:0]  aux_lv12; 
   input  [4:0]  aux_hint; 
   input  [31:3] aux_lev; 
   
   input  [31:0] uxdrx_reg;
   input         uxreg_hit;  
   input         ux_da_am;   
   input  [31:0] ux_dar;     
   input         uxivic;     
   input         uxhold_host;
   input         uxnoaccess; 

// <add more signals as appropriate>--
//
//  Signals required for extensions are inserted here. The automatic
//  hierarchy generation system can be used to create the structural
//  HDL to tie all the components together, provided that certain
//  naming and usage rules are followed. Please see the document
//  'Automatic Hierarchy Generator' - $ARCHOME/arc/docs/hiergen.pdf
// 
   input [31:0] ap_ahv0; 
   input [31:0] ap_ahv1; 
   input [31:0] ap_ahv2; 
   input [31:0] ap_ahv3; 
   input [31:0] ap_ahv4; 
   input [31:0] ap_ahv5; 
   input [31:0] ap_ahv6; 
   input [31:0] ap_ahv7; 
   input [31:0] ap_ahc0; 
   input [31:0] ap_ahc1; 
   input [31:0] ap_ahc2; 
   input [31:0] ap_ahc3; 
   input [31:0] ap_ahc4; 
   input [31:0] ap_ahc5; 
   input [31:0] ap_ahc6; 
   input [31:0] ap_ahc7; 
   input [31:0] ap_ahm0; 
   input [31:0] ap_ahm1; 
   input [31:0] ap_ahm2; 
   input [31:0] ap_ahm3; 
   input [31:0] ap_ahm4; 
   input [31:0] ap_ahm5; 
   input [31:0] ap_ahm6; 
   input [31:0] ap_ahm7; 
   input   [TIMER_MSB:0] timer_r; 
   input   [TIMER_MSB:0] tlimit_r;
   input         timer_pirq_r; 
   input         tcontrol_r; 
   input         timer_mode_r; 
   input         timer_clr_r; 
   input         twatchdog_r;

   output [31:0] drx_reg; 
   output        xreg_hit; 
   output        x_da_am; 
   output [31:0] x_dar; 
   output [7:0]  id_arcnum;
   output        xnoaccess; 
   output        xhold_host; 
   output        xcache_hold_host; 
   output        dc_disable_r;

// <add more signals as appropriate>--
//
//  Signals required for extensions are inserted here. The automatic
//  hierarchy generation system can be used to create the structural
//  HDL to tie all the components together, provided that certain
//  naming and usage rules are followed. Please see the document
//  'Automatic Hierarchy Generator' - $ARCHOME/arc/docs/hiergen.pdf
// 
   output        power_toggle;
   output  [EXT_A_MSB:LDST_A_MSB + 3] lram_base; 
   wire    [EXT_A_MSB:LDST_A_MSB + 3] lram_base;
   output        pc_sel_r;
   output        aux_st_mulhi_a;

   output [PC_MSB:`INT_BASE_LSB] int_vector_base_r;
   output [31:3] irq;
   output        ivic; 
   output        wd_clear; 

   reg           power_toggle;
   reg           pc_sel_r;
   wire   [31:0] drx_reg; 
   wire          xreg_hit; 
   wire          x_da_am; 
   wire   [31:0] x_dar; 
   wire   [7:0]  id_arcnum; 
   wire          xnoaccess; 
   wire          xhold_host;
   wire          dc_disable_r;
   wire          wd_clear; 
   wire   [PC_MSB:`INT_BASE_LSB] int_vector_base_r;
   wire          ivic; 
   wire          i_ivic; 
   reg    [PC_MSB:`INT_BASE_LSB]  i_int_vector_base_r;

//  extra signals for LD/ST RAM for load/store accesses
   reg     [EXT_A_MSB-1:LDST_A_MSB + 3] i_ldst_ram_base_addr_r;
   wire    [31:0]                     i_ldst_ram_full_a; 
   wire    [LDST_A_MSB + 2:0]         i_ldst_ram_fill_a; 
   wire          aux_st_mulhi_a;

// =========================== Extension Aux. Reads =========================--
// 
//  The data read extension register carries the value specified by the
//  auxiliary address, aux_addr[31:0], from the basecase ARC when the signal
//  xreg_hit is true. The bus drx_reg[31:0] carries data from single access
//  registers, or the ARC side of dual access registers, but never the host
//  side of dual access registers which are always on x_dar[31:0].
// 
//  auxdc : Aux Register Decode
//  
//  This function provides an invaluable facility of performing the register
//  decode on a 32-bit quantity using the appropriate decode width set by the
//  constant AUXDECSZ. These are to be found in extutil.v.
// 
//  The first 13 address decodes represent the build configuration registers.
//  These registers allow embedded software or host debug software to detect
//  the configuration of ARC hardware. All current v2.1 and v3.0 extensions 
//  are represented. 
// 
//  These registers are always present. The value returned is set to zero if 
//  the extension is not present, if it is present the version number and
//  configuration information is returned.
// 
//  These are just address decodes assigning constants to the data read bus
//  'drx_reg'. The values may be found in 'xdefs.v'.
// 
   assign drx_reg = 
//  Example : auxdc(aux_addr,aux_ext_addr) == 1'b 1 ? ext_aux_data :
// 
// Extension auxiliary reads decodes inserted here
 
    auxdc(aux_addr, aux_ap_amv0) == 1'b1 ?  ap_ahv0 : 
    auxdc(aux_addr, aux_ap_amv1) == 1'b1 ?  ap_ahv1 : 
    auxdc(aux_addr, aux_ap_amv2) == 1'b1 ?  ap_ahv2 : 
    auxdc(aux_addr, aux_ap_amv3) == 1'b1 ?  ap_ahv3 : 
    auxdc(aux_addr, aux_ap_amv4) == 1'b1 ?  ap_ahv4 : 
    auxdc(aux_addr, aux_ap_amv5) == 1'b1 ?  ap_ahv5 : 
    auxdc(aux_addr, aux_ap_amv6) == 1'b1 ?  ap_ahv6 : 
    auxdc(aux_addr, aux_ap_amv7) == 1'b1 ?  ap_ahv7 : 
    auxdc(aux_addr, aux_ap_ac0)  == 1'b1 ?  ap_ahc0 : 
    auxdc(aux_addr, aux_ap_ac1)  == 1'b1 ?  ap_ahc1 : 
    auxdc(aux_addr, aux_ap_ac2)  == 1'b1 ?  ap_ahc2 : 
    auxdc(aux_addr, aux_ap_ac3)  == 1'b1 ?  ap_ahc3 : 
    auxdc(aux_addr, aux_ap_ac4)  == 1'b1 ?  ap_ahc4 : 
    auxdc(aux_addr, aux_ap_ac5)  == 1'b1 ?  ap_ahc5 : 
    auxdc(aux_addr, aux_ap_ac6)  == 1'b1 ?  ap_ahc6 : 
    auxdc(aux_addr, aux_ap_ac7)  == 1'b1 ?  ap_ahc7 : 
    auxdc(aux_addr, aux_ap_amm0) == 1'b1 ?  ap_ahm0 : 
    auxdc(aux_addr, aux_ap_amm1) == 1'b1 ?  ap_ahm1 : 
    auxdc(aux_addr, aux_ap_amm2) == 1'b1 ?  ap_ahm2 : 
    auxdc(aux_addr, aux_ap_amm3) == 1'b1 ?  ap_ahm3 : 
    auxdc(aux_addr, aux_ap_amm4) == 1'b1 ?  ap_ahm4 : 
    auxdc(aux_addr, aux_ap_amm5) == 1'b1 ?  ap_ahm5 : 
    auxdc(aux_addr, aux_ap_amm6) == 1'b1 ?  ap_ahm6 : 
    auxdc(aux_addr, aux_ap_amm7) == 1'b1 ?  ap_ahm7 : 
    auxdc(aux_addr, AUX_LDST_RAM)        == 1'b 1 ? i_ldst_ram_full_a :
    //  Timer 0
    // 
    (auxdc(aux_addr, aux_timer)           == 1'b 1) ? timer_r : 
    (auxdc(aux_addr, aux_tlimit)          == 1'b 1) ? tlimit_r : 
    (auxdc(aux_addr, aux_tcontrol)        == 1'b 1) ?
    {{(DATAWORD_WIDTH - (4)){1'b 0}}, timer_pirq_r, twatchdog_r, timer_mode_r,
     tcontrol_r} : 

    // Interrupt subsystem programming registers

    (auxdc(aux_addr, AUX_IRQ_LV12)        == 1'b 1) ? {{(30){1'b 0}}, aux_lv12} : 
    (auxdc(aux_addr, AUX_IRQ_HINT)        == 1'b 1) ? {{(27){1'b 0}}, aux_hint} : 
    (auxdc(aux_addr, AUX_IRQ_LEV)         == 1'b 1) ? {aux_lev, 3'b 0} :

    // Common configuration registers (dual access)

    (auxdc(aux_addr, AUX_INT_VECTOR_BASE) == 1'b 1) ? {{32-24{1'b0}}, i_int_vector_base_r,
                                                     TEN_ZERO} :
    (auxdc(aux_addr, ARC600_BUILD)        == 1'b 1) ? ARC600_BUILD_VALUE :
    (auxdc(aux_addr, BCR_VERSION_BUILD)   == 1'b 1) ? BCR_VERSION_BUILD_VALUE :
    (auxdc(aux_addr, DATASPACE_BUILD)     == 1'b 1) ? DATASPACE_BUILD_VALUE:
    (auxdc(aux_addr, MEMSUBSYS_BUILD)     == 1'b 1) ? MEMSUBSYS_BUILD_VALUE:
    (auxdc(aux_addr, VECBASE_AC_BUILD)    == 1'b 1) ? VECBASE_AC_BUILD_VALUE :
    (auxdc(aux_addr, PERIPH_BUILD)        == 1'b 1) ? PERIPH_BUILD_VALUE :
    (auxdc(aux_addr, RF_BUILD)            == 1'b 1) ? RF_BUILD_VALUE :
    (auxdc(aux_addr, AA2_BUILD)           == 1'b 1) ? RESERVED_BUILD_VALUE :
    (auxdc(aux_addr, MADI_BUILD)          == 1'b 1) ? MADI_BUILD_VALUE : 
    (auxdc(aux_addr, LDSTRAM_BUILD)       == 1'b 1) ? LDSTRAM_BUILD_VALUE : 
    (auxdc(aux_addr, TIMER_BUILD)         == 1'b 1) ? TIMER_BUILD_VALUE : 
    (auxdc(aux_addr, AP_BUILD)            == 1'b 1) ? AP_BUILD_VALUE : 
    (auxdc(aux_addr, ICCM_BUILD)          == 1'b 1) ? ICCM_BUILD_VALUE : 
    (auxdc(aux_addr, MULTIPLY_BUILD)      == 1'b 1) ? MULTIPLY_BUILD_VALUE : 
    (auxdc(aux_addr, SWAP_BUILD)          == 1'b 1) ? SWAP_BUILD_VALUE : 
    (auxdc(aux_addr, NORM_BUILD)          == 1'b 1) ? NORM_BUILD_VALUE : 
//UNUSEDUNUSED    (auxdc(aux_addr, BARREL_BUILD)        == 1'b 1) ? BARREL_BUILD_VALUE :
//    (auxdc(aux_addr, BARREL_BUILD)        == 1'b 1) ? BARREL_BUILD_VALUE :
(auxdc(aux_addr, BARREL_BUILD) == 1'b1) ? BARREL_BUILD_VALUE :
    ((!(|aux_addr[AUXDECSZ:8])) && ((aux_addr[7:6] == 2'b11) || (aux_addr[7:5] == 3'b011))) ?  UNUSED_BUILD_VALUE : 
    uxdrx_reg; 
// 
//  The extension register hit informs the auxiliary register unit, aux_regs, 
//  the location address, aux_addr[31:0], is a valid extension register
// 
//  The build configuration register decodes are always present.
// 
   assign xreg_hit = 
//  Example : auxdc(aux_addr,aux_ext_addr) == 1'b 1 ? ext_aux_data :
// 
// Extension auxiliary register hits inserted here
    auxdc(aux_addr, aux_ap_amv0) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv1) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv2) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv3) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv4) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv5) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv6) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amv7) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac0)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac1)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac2)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac3)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac4)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac5)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac6)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_ac7)  == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm0) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm1) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm2) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm3) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm4) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm5) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm6) == 1'b1 ? 1'b1 :
    auxdc(aux_addr, aux_ap_amm7) == 1'b1 ? 1'b1 :
    auxdc(aux_addr,AUX_LDST_RAM)         == 1'b 1 ? 1'b 1 :
    //  Timer 0
    // 
    (auxdc(aux_addr, aux_timer)           == 1'b 1) ? 1'b 1 : 
    (auxdc(aux_addr, aux_tcontrol)        == 1'b 1) ? 1'b 1 : 
    (auxdc(aux_addr, aux_tlimit)          == 1'b 1) ? 1'b 1 : 

    // Interrupt subsystem programming registers
    (auxdc(aux_addr, AUX_IRQ_LV12)        == 1'b 1) ? 1'b 1 : 
    (auxdc(aux_addr, AUX_IRQ_HINT)        == 1'b 1) ? 1'b 1 : 
    (auxdc(aux_addr, AUX_IRQ_LEV)         == 1'b 1) ? 1'b 1 : 


    // Common configuration registers (dual access)
    (auxdc(aux_addr, AUX_INT_VECTOR_BASE) == 1'b 1) ? 1'b 1 : 
    auxdc(aux_addr, AUX_SYSTEM_BUILD)   == 1'b 1 ? 1'b 1 :
    ((!(|aux_addr[AUXDECSZ:8])) && ((aux_addr[7:6] == 2'b11) || (aux_addr[7:5] == 3'b011))) ? 1'b 1 : 
    uxreg_hit; 
// 
//  The facility for adding extension dual access registers has been provided
//  to facilitate accesses to auxiliary registers whilst the ARC is running.
//  Hence, these registers must be able to handle being accessed siultaneously
//  from the ARC and the host. Source of problems may arise from the case where
//  both the host and the ARC attempt to write to the same dual access auxiliary
//  register. These conflicts must be resolved by the ext. auxiliary registers
//  by design or by stalling the ARC or the host.
//  It must be noted that accesses from the host will appear on both ARC side
//  (drx_reg) and the host side (x_dar) when the ARC is halted (en = '0').
//  This may appear to be a possible conflict as the ARC is halted. When
//  designing the extension the logic which detects and resolves conflicts must
//  account for this.
// 
//  The dual access configuration registers are always present
// 
   assign x_da_am = 
//  Example : auxdc(h_addr,aux_ext_addr2) == 1'b 1 ?  1'b 1 :
// 
// Extension dual access address match decodes inserted here
    auxdc(h_addr, aux_ap_amv0) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv1) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv2) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv3) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv4) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv5) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv6) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amv7) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac0)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac1)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac2)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac3)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac4)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac5)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac6)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_ac7)  == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm0) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm1) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm2) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm3) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm4) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm5) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm6) == 1'b1 ? 1'b1 :
    auxdc(h_addr, aux_ap_amm7) == 1'b1 ? 1'b1 :

    // Interrupt subsystem programming registers - host interface

    (auxdc(h_addr, AUX_IRQ_LV12)        == 1'b 1) ? 1'b 1 : 
    (auxdc(h_addr, AUX_IRQ_HINT)        == 1'b 1) ? 1'b 1 : 
    (auxdc(h_addr, AUX_IRQ_LEV)         == 1'b 1) ? 1'b 1 : 

    // Common configuration registers (dual access)
    (auxdc(h_addr, AUX_INT_VECTOR_BASE) == 1'b 1) ? 1'b 1 : 
    auxdc(h_addr, AUX_SYSTEM_BUILD)   == 1'b 1 ? 1'b 1 :
    ((!(|h_addr[AUXDECSZ:8])) && ((h_addr[7:6] == 2'b11) || (h_addr[7:5] == 3'b011))) ? 1'b 1 : 
    ux_da_am; 
// 
//  The read data from the host side is passed through this interface to the
//  host interface via the ARC auxiliary register unit, aux_regs.v.
// 
//  The dual access configuration registers are always present
// 
   assign x_dar = 

    auxdc(h_addr, aux_ap_amv0) == 1'b1 ?  ap_ahv0 : 
    auxdc(h_addr, aux_ap_amv1) == 1'b1 ?  ap_ahv1 : 
    auxdc(h_addr, aux_ap_amv2) == 1'b1 ?  ap_ahv2 : 
    auxdc(h_addr, aux_ap_amv3) == 1'b1 ?  ap_ahv3 : 
    auxdc(h_addr, aux_ap_amv4) == 1'b1 ?  ap_ahv4 : 
    auxdc(h_addr, aux_ap_amv5) == 1'b1 ?  ap_ahv5 : 
    auxdc(h_addr, aux_ap_amv6) == 1'b1 ?  ap_ahv6 : 
    auxdc(h_addr, aux_ap_amv7) == 1'b1 ?  ap_ahv7 : 
    auxdc(h_addr, aux_ap_ac0)  == 1'b1 ?  ap_ahc0 : 
    auxdc(h_addr, aux_ap_ac1)  == 1'b1 ?  ap_ahc1 : 
    auxdc(h_addr, aux_ap_ac2)  == 1'b1 ?  ap_ahc2 : 
    auxdc(h_addr, aux_ap_ac3)  == 1'b1 ?  ap_ahc3 : 
    auxdc(h_addr, aux_ap_ac4)  == 1'b1 ?  ap_ahc4 : 
    auxdc(h_addr, aux_ap_ac5)  == 1'b1 ?  ap_ahc5 : 
    auxdc(h_addr, aux_ap_ac6)  == 1'b1 ?  ap_ahc6 : 
    auxdc(h_addr, aux_ap_ac7)  == 1'b1 ?  ap_ahc7 : 
    auxdc(h_addr, aux_ap_amm0) == 1'b1 ?  ap_ahm0 : 
    auxdc(h_addr, aux_ap_amm1) == 1'b1 ?  ap_ahm1 : 
    auxdc(h_addr, aux_ap_amm2) == 1'b1 ?  ap_ahm2 : 
    auxdc(h_addr, aux_ap_amm3) == 1'b1 ?  ap_ahm3 : 
    auxdc(h_addr, aux_ap_amm4) == 1'b1 ?  ap_ahm4 : 
    auxdc(h_addr, aux_ap_amm5) == 1'b1 ?  ap_ahm5 : 
    auxdc(h_addr, aux_ap_amm6) == 1'b1 ?  ap_ahm6 : 
    auxdc(h_addr, aux_ap_amm7) == 1'b1 ?  ap_ahm7 : 

    // Interrupt subsystem programming registers - host interface

    (auxdc(h_addr, AUX_IRQ_LV12)        == 1'b 1) ? {{(30){1'b 0}}, aux_lv12} : 
    (auxdc(h_addr, AUX_IRQ_HINT)        == 1'b 1) ? {{(27){1'b 0}}, aux_hint} : 
    (auxdc(h_addr, AUX_IRQ_LEV)         == 1'b 1) ? {aux_lev, 3'b 0} :

    // Common configuration registers (dual access)
        
    (auxdc(h_addr, AUX_INT_VECTOR_BASE) == 1'b 1) ? {{32-24{1'b0}}, i_int_vector_base_r,
                                                   TEN_ZERO} :
    (auxdc(h_addr, ARC600_BUILD)        == 1'b 1) ? ARC600_BUILD_VALUE :
    (auxdc(h_addr, BCR_VERSION_BUILD)   == 1'b 1) ? BCR_VERSION_BUILD_VALUE :
    (auxdc(h_addr, DATASPACE_BUILD)     == 1'b 1) ? DATASPACE_BUILD_VALUE:
    (auxdc(h_addr, MEMSUBSYS_BUILD)     == 1'b 1) ? MEMSUBSYS_BUILD_VALUE:
    (auxdc(h_addr, VECBASE_AC_BUILD)    == 1'b 1) ? VECBASE_AC_BUILD_VALUE :
    (auxdc(h_addr, PERIPH_BUILD)        == 1'b 1) ? PERIPH_BUILD_VALUE : 
    (auxdc(h_addr, RF_BUILD)            == 1'b 1) ? RF_BUILD_VALUE : 
    (auxdc(h_addr, AA2_BUILD)           == 1'b 1) ? RESERVED_BUILD_VALUE :
    (auxdc(h_addr, MADI_BUILD)          == 1'b 1) ? MADI_BUILD_VALUE : 
    (auxdc(h_addr, LDSTRAM_BUILD)       == 1'b 1) ? LDSTRAM_BUILD_VALUE : 
    (auxdc(h_addr, TIMER_BUILD)         == 1'b 1) ? TIMER_BUILD_VALUE : 
    (auxdc(h_addr, AP_BUILD)            == 1'b 1) ? AP_BUILD_VALUE : 
    (auxdc(h_addr, ICCM_BUILD)          == 1'b 1) ? ICCM_BUILD_VALUE :  
    (auxdc(h_addr, MULTIPLY_BUILD)      == 1'b 1) ? MULTIPLY_BUILD_VALUE : 
    (auxdc(h_addr, SWAP_BUILD)          == 1'b 1) ? SWAP_BUILD_VALUE : 
    (auxdc(h_addr, NORM_BUILD)          == 1'b 1) ? NORM_BUILD_VALUE : 
    ((!(|h_addr[AUXDECSZ:8])) && ((h_addr[7:6] == 2'b11) || (h_addr[7:5] == 3'b011))) ?  UNUSED_BUILD_VALUE : 
    ux_dar;

//========================= Int Vector Base Address ========================--
//
// The interrupt vector base address is generated here and is employed for
// handling interrupts and exceptions.
//
//
   always @(posedge clk or posedge rst_a)
   begin : INT_VECT_PROC

   if (rst_a == 1'b 1)

      begin
      i_int_vector_base_r[PC_MSB : `INT_BASE_LSB] <= 
// leda W557 off
      VECBASE_AC_BUILD_VALUE[PC_MSB:`INT_BASE_LSB];
// leda W557 on
      end

   else

      begin
       if ((auxdc(aux_addr, AUX_INT_VECTOR_BASE) == 1'b 1) &
           (aux_write == 1'b 1))
          begin
          i_int_vector_base_r[PC_MSB : `INT_BASE_LSB] <=
          aux_dataw[PC_MSB : `INT_BASE_LSB];
          end
       else if ((auxdc(h_addr, AUX_INT_VECTOR_BASE) == 1'b 1) &
                (h_write == 1'b 1) &
                (aux_access == 1'b 1))
          begin
          i_int_vector_base_r[PC_MSB : `INT_BASE_LSB] <=
          h_dataw[PC_MSB : `INT_BASE_LSB];
          end
      end

   end

   assign int_vector_base_r = i_int_vector_base_r[PC_MSB : `INT_BASE_LSB];

// ========================== Saturate Flag register ========================--
//
// Aux Reg 41.  This register slot is used by the macmode register when XMAC
//              is in the build, or a Stick Saturate flag register when no
//              XMAC is present and the Extended_arith package is.
//   
 
// ======================= Invalidate Instruction Cache =====================--
// 
// 
//  The i-cache cannot be invalidated when ic_busy is true. This will be the
//  case when the cache is clearing its tags, after reset, or is in the process
//  of doing a line load.
// 
//  If the cache cannot be cleared, then the requesting client must be stalled 
//  until the cache is ready.
// 
//  Note: The ivic signal is set to '0' when no cache is selected.
// 
   assign ivic = 
// 
//  Example : ic_busy == 1'b 0 & aux_write == 1'b 1 ? i_ivic :
//
// Instruction invalidate signal inserted here
       ((ic_busy == 1'b 0) & (aux_write == 1'b 1)) ? i_ivic : 
                 uxivic;

// ============================ Ext. Aux. Stalling ==========================--
// 
//  For systems using more than one ARC the identity register has a field,
//  i.e. bits 15 to 8, where a value is    assigned to give each ARC a unique
//  identity. This value is then available to programs running on the ARC
//  through auxiliary register 0x04 (identity register).  
// 
   assign id_arcnum = `ARCNUM; //  0x01 = Only ARC in the system

//  This indicates to the host interface that the extension auxiliary unit
//  rejects the host access when it is true.
//
                
   assign xnoaccess = 
                      uxnoaccess; 

//  The host is stalled when it tries to access a resource which is
//  currently busy. For example, a stall can be generated from the register
//  file when it is being accessed by the ARC or when cache is being 
//  cleared while the host is trying to write to an auxiliary register when
//  the ARC is halted.
//  
//  This signal should be generated by ORing together multiple stall 
//  signals.
//
   assign xhold_host =  
// 
//  Example :   ext_hold_signal |
// 
// Stalling signal to host inserted here
                       sr_xhold_host_a | 
                       uxhold_host;

//  The host is stalled when it tries to access the instruction fetch logic
//  which is currently busy.
//
// This signal should be generated bt ORing together multiple stall signals.
//
   assign xcache_hold_host =
                             1'b 0;
       

// ========================= Interrupt connectivity ==========================--
// 
//  Interrupt connectivity
//  This code maps the interrupt signal output to their sources.
// 
//  1) interrupts connected to external pins
//  2) interrupts connected to peripherals
//  3) interrupts diconnected
// 
//  note1: ext_irq(n), per_irq(n) and dis_irq(n) are mutually exclusive so 
//  that if one of them is true (ie. is equal to " " (space) then the 
//  other two are equal to "--".
// 
//  note 2: The peripheral connectivity (eg. timer(s) or uart(s) should be
//  done before the signals arrive at this module
// 
//  1) if interrupts are connected to external pins

   assign irq[4] = l_irq_4;
   assign irq[5] = l_irq_5;
   assign irq[6] = l_irq_6;
   assign irq[7] = l_irq_7;
   assign irq[8] = l_irq_8;
   assign irq[9] = l_irq_9;
   assign irq[10] = l_irq_10;
   assign irq[11] = l_irq_11;
   assign irq[12] = l_irq_12;
   assign irq[13] = l_irq_13;
   assign irq[14] = l_irq_14;
   assign irq[15] = l_irq_15;
   assign irq[16] = l_irq_16;
   assign irq[17] = l_irq_17;
   assign irq[18] = l_irq_18;
   assign irq[19] = l_irq_19;

//  2) if interrupts are connected to peripherals

   assign irq[3] = l_irq_3;

//  2a) inter-core interrupts


//  3) if interrupts are disconnected

   assign irq[20] = 1'b 0;
   assign irq[21] = 1'b 0;
   assign irq[22] = 1'b 0;
   assign irq[23] = 1'b 0;
   assign irq[24] = 1'b 0;
   assign irq[25] = 1'b 0;
   assign irq[26] = 1'b 0;
   assign irq[27] = 1'b 0;
   assign irq[28] = 1'b 0;
   assign irq[29] = 1'b 0;
   assign irq[30] = 1'b 0;
   assign irq[31] = 1'b 0;

// Watchdog signal to generate a system reset if asserted by either of the
// timers.

   assign wd_clear =

                  timer_clr_r | 
                     1'b 0;

// ====================== Miscellaneous Extensions Logic ====================--
// 
// Miscellaneous extension logic functions are inserted here.
// ======================== Power toggle select logic ========================--
// 
   // Latch bit 0 if a write to the power register is detected.
   // This is a write-only register.
   // It is initialized to '0' 
   // 
   always @(posedge clk or posedge rst_a)
      begin : power_toggle_sync_PROC
      if (rst_a == 1'b 1)
         begin
         power_toggle <= 1'b 0;        
         end
      else
         begin
         if (auxdc(aux_addr, AUX_POWER) == 1'b 1 & aux_write == 1'b 1)
            begin
            power_toggle <= aux_dataw[0];        
            end
         end

      end

// ----------------------------------------------------------------------------
//  Control Register for setting base address of the LD/ST RAM.
//
always @(posedge clk or posedge rst_a)
   begin : ldst_ram_PROC
   if (rst_a == 1'b 1)
      begin
      i_ldst_ram_base_addr_r <= LDST_RAM_BASE_DEFAULT[EXT_A_MSB-1:LDST_A_MSB+3];
      end
   else
      begin
      if (auxdc(aux_addr, AUX_LDST_RAM) == 1'b 1 & aux_write == 1'b 1)
         begin
         i_ldst_ram_base_addr_r <= aux_dataw[EXT_A_MSB-1:LDST_A_MSB + 3];   
         end
      end
   end

assign lram_base  = { LDST_RAM_BASE_DEFAULT[EXT_A_MSB], i_ldst_ram_base_addr_r}; 
assign i_ldst_ram_fill_a = {(LDST_A_MSB+3){1'b 0}}; 
 assign i_ldst_ram_full_a = {
                    {32 - (EXT_A_MSB + 1){1'b 0}},
                    {LDST_RAM_BASE_DEFAULT[EXT_A_MSB], i_ldst_ram_base_addr_r, i_ldst_ram_fill_a}}; 

// ---------------------------------------------------------------------


// Address decode of the IVIC register
//
assign i_ivic = (auxdc(aux_addr, AUX_IVIC) == 1'b1) ?  1'b 1 :
       1'b 0;    


// ========================= JTAG Select Control Logic ======================--
// 
// Latch bit 0 if a write to the JTAG control register is detected.
// This is a write-only register.
// It is initialized to '1' to make Sun comms work ... (ie when used with a
// Sun // port this register must not be changed from a '1'!
// 
always @(posedge clk or posedge rst_a)
   begin : JTAG_SYNC_PROC
   if (rst_a == 1'b 1)
      begin
      pc_sel_r <= 1'b 1;        
      end
   else
      begin
      if ((auxdc(aux_addr, AUX_PCPORT) == 1'b 1) & (aux_write == 1'b 1))
         begin
         pc_sel_r <= aux_dataw[0];        
         end
      end

   end


//  Multiplier result register --
// 
//  Detect an auxiliary register write to the high part of the multiplier result
//  The actual register is located in xalu.v
// 
//  Note that no interlock is provided to prevent aux writes from taking place
//  at the same time as a multiply - This can be easily done in software.
// 

   assign aux_st_mulhi_a = (auxdc(aux_addr, AUX_MULHI) == 1'b 1) &
                           (aux_write == 1'b 1) ?
          1'b 1 : 
          1'b 0;


// ----------------------------------------------------------------------------
//  DC flag
// 
//  The DC flag (dc_disable_r) is always set if there is no data cache in the
//  build. If there is a data cache in the build this flag can be set from
//  a program using LR/SR instructions.
//
   assign dc_disable_r = 
                         1'b 1; 

endmodule // module xaux_regs

