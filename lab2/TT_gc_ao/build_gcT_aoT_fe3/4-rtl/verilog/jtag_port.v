// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 2004-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
//
// JTAG communications interface.
//  
// This is the overall structural code for the JTAG port. Note that it contains
// two clock domains: the JTAG clock domain and the ungated core clock
// domain.
// The tap_controller and debug_port modules run off of the JTAG clock, and the
// sys_clk_sync and hif2bt modules run off of the core clock.  The
// synchronization philosophy is that all the signals generated by the BVCI
// initiator are generated on JTAG clock. Then a request is made to
// sys_clk_sync, which synchronizes the request to the core clock and
// generates cmdval. All the other signals are thus guaranteed to be stable long
// before they can be latched by the BVCI target. Once this request is
// generated, the logic on the JTAG clock *assumes* that the transaction will
// complete, and in the case of a read the data will be returned, within
// a single cycle of the JTAG clock.  Since the synchronization of the request
// takes two core clocks, the BVCI transaction takes one core clock, and the
// setup of the returning data into the receiving flip-flops takes one core
// clock, the period of the JTAG clock must be at least two times that of the
// core clock.  Note that if a fabric is interposed between the BVCI initiator
// and target, the latency of that fabric must be added to this time.  JTAG
// communications interface.
//
// Connection to a Bounary Scan Register (scan chain) will involve decoding
// eight signals called:
//
//          jtag_bsr_tdo,
//          jtag_extest_mode,
//          jtag_sample_mode,
//          capturedr_en,
//          shiftdr_en,
//          updatedr_en,
//          jtag_tdi.
//
// The jtag_tdi is connected to the first cell in the Boundary Scan Register.
// The jtag_bsr_tdo pin is wired to the final cell of the Boundary Scan
// Register. The jtag_extest_mode and jtag_sample_mode signals are used as
// master enables. This allow the Boundary Scan Register to be activated
// whenever the EXTEST or SAMPLE  instruction is selected.
// The shiftdr_en, capturedr_en and updatedr_en enable signals are combined
// with decoding logic allowing the shift and latch elements of the Boundary
// Scan Register to be controlled in the Shift-DR, Capture-DR and Update-DR
// TAP states.
//
//--------------------------------------------------------------------

module jtag_port(clk_ungated,
                 jtag_tck,
                 jtag_trst_a,
		 rst_a,
                 test_mode,
                 en,
                 reset_applied_r,
                 h_datar,
                 noaccess,
                 hold_host,
                 pcp_d_rd,
                 pcp_ack,
                 pcp_dlat,
                 pcp_dak,
                 pc_sel_r,
                 jtag_tdi,
                 jtag_tms,
                 jtag_bsr_tdo,

                 jtag_busy,
                 h_addr,
                 h_dataw,
                 h_write,
                 h_read,
                 aux_access,
                 core_access,
                 madi_access,
                 halt,
                 xstep,
                 pcp_wr_rq,
                 pcp_rd_rq,
                 pcp_addr,
                 pcp_brst,
                 pcp_mask,
                 pcp_d_wr,
                 jtag_tdo,
                 jtag_tdo_zen_n,
                 jtag_extest_mode,
                 jtag_sample_mode,
                 updatedr_en,
                 capturedr_en,
                 shiftdr_en);

  `include "arcutil_pkg_defines.v"
  `include "arcutil.v"
  `include "extutil.v"
  `include "ext_msb.v"

  input           clk_ungated;
  input           jtag_tck;
  input           jtag_trst_a;
  input   	  rst_a;
  input           test_mode;
  input           en;
  input           reset_applied_r;
  input  [31 : 0] h_datar;
  input           noaccess;
  input           hold_host;
  input  [31 : 0] pcp_d_rd;
  input           pcp_ack;
  input           pcp_dlat;
  input           pcp_dak;
  input           pc_sel_r;
  input           jtag_tdi;
  input           jtag_tms;
  input           jtag_bsr_tdo;

  output          jtag_busy;
  output [31 : 0] h_addr;
  output [31 : 0] h_dataw;
  output          h_write;
  output          h_read;
  output          aux_access;
  output          core_access;
  output          madi_access;
  output          halt;
  output          xstep;
  output          pcp_wr_rq;
  output          pcp_rd_rq;
  output [EXT_A_MSB : 0] pcp_addr;
  output [7 : 0]  pcp_brst;
  output [3 : 0]  pcp_mask;
  output [31 : 0] pcp_d_wr;
  output          jtag_tdo;
  output          jtag_tdo_zen_n;
  output          jtag_extest_mode;
  output          jtag_sample_mode;
  output          updatedr_en;
  output          capturedr_en;
  output          shiftdr_en;

  wire jtag_busy;
  wire [31 : 0] h_addr;
  wire [31 : 0] h_dataw;
  wire h_write;
  wire h_read;
  wire aux_access;
  wire core_access;
  wire madi_access;
  wire halt;
  wire xstep;
  wire pcp_wr_rq;
  wire pcp_rd_rq;
  wire [EXT_A_MSB : 0] pcp_addr;
  wire [7 : 0] pcp_brst;
  wire [3 : 0] pcp_mask;
  wire [31 : 0] pcp_d_wr;
  wire jtag_tdo;
  wire jtag_tdo_zen_n;
  wire jtag_extest_mode;
  wire jtag_sample_mode;
  wire updatedr_en;
  wire capturedr_en;
  wire shiftdr_en;

  wire i_test_logic_reset;
  wire i_run_test_idle;
  wire i_shift_ir;
  wire i_update_ir;
  wire i_shift_dr;
  wire i_capture_dr;
  wire i_capture_ir;
  wire i_update_dr;
  wire i_select_r;
  wire i_test_logic_reset_nxt;
  wire i_run_test_idle_nxt;
  wire i_select_dr_scan_nxt;
  wire i_capture_dr_nxt;
  wire i_update_dr_nxt;

  wire i_do_bvci_cycle;
  wire [`ADDR_SIZE - 1 : 2] i_bvci_addr;
  wire [1 : 0] i_bvci_cmd;
  wire [31 : 0] i_debug_address;
  wire [3 : 0] i_debug_be;
  wire [1 : 0] i_debug_cmd;
  wire i_debug_cmdval;
  wire i_debug_eop;
  wire i_debug_rspack;
  wire [31 : 0] i_debug_wdata;
  wire i_debug_cmdack;
  wire [31 : 0] i_debug_rdata;
  wire i_debug_reop;
  wire i_debug_rspval;
  wire i_debug_rerror;

  wire jtag_tck_muxed;

`ifndef IS_ARCv1_TB

  // Invert jtag_tck in functional mode to be able to use posedge registers,
  // for test mode all registers are clocked on same edge
// leda NTL_CLK07 off
  assign jtag_tck_muxed =  test_mode  ? jtag_tck : ~jtag_tck ;
// leda NTL_CLK07 on

  debug_port
    u_debug_port(.jtag_trst_a(jtag_trst_a),
                 .debug_rdata_r(i_debug_rdata),
                 .jtag_tck(jtag_tck),
                 .jtag_tck_muxed(jtag_tck_muxed),
                 .jtag_tdi(jtag_tdi),
                 .jtag_bsr_tdo(jtag_bsr_tdo),
                 .test_logic_reset(i_test_logic_reset),
                 .run_test_idle(i_run_test_idle),
                 .shift_ir(i_shift_ir),
                 .update_ir(i_update_ir),
                 .shift_dr(i_shift_dr),
                 .capture_dr(i_capture_dr),
                 .capture_ir(i_capture_ir),
                 .select_r(i_select_r),
                 .test_logic_reset_nxt(i_test_logic_reset_nxt),
                 .run_test_idle_nxt(i_run_test_idle_nxt),
                 .select_dr_scan_nxt(i_select_dr_scan_nxt),
                 .capture_dr_nxt(i_capture_dr_nxt),
                 .update_dr_nxt(i_update_dr_nxt),

                 .bvci_addr_r(i_bvci_addr),
                 .debug_be(i_debug_be),
                 .bvci_cmd_r(i_bvci_cmd),
                 .debug_rspack(i_debug_rspack),
                 .debug_eop(i_debug_eop),
                 .debug_wdata(i_debug_wdata),
                 .do_bvci_cycle(i_do_bvci_cycle),
                 .arca_busy(jtag_busy),
                 .jtag_tdo_r(jtag_tdo),
                 .jtag_extest_mode(jtag_extest_mode),
                 .jtag_sample_mode(jtag_sample_mode));

  sys_clk_sync
    u_sys_clk_sync(.clk_ungated(clk_ungated),
                   .rst_a(rst_a),
                   .test_mode(test_mode),
                   .do_bvci_cycle(i_do_bvci_cycle),
                   .bvci_addr_r(i_bvci_addr),
                   .bvci_cmd_r(i_bvci_cmd),

                   .debug_address(i_debug_address),
                   .debug_cmd(i_debug_cmd),
                   .debug_cmdval(i_debug_cmdval));

  tap_controller
    u_tap_controller(.jtag_tck(jtag_tck),
                     .jtag_tck_muxed(jtag_tck_muxed),
                     .jtag_trst_a(jtag_trst_a),
                     .jtag_tms(jtag_tms),

                     .test_logic_reset(i_test_logic_reset),
                     .run_test_idle(i_run_test_idle),
                     .shift_ir(i_shift_ir),
                     .update_ir(i_update_ir),
                     .shift_dr(i_shift_dr),
                     .capture_dr(i_capture_dr),
                     .capture_ir(i_capture_ir),
                     .update_dr(i_update_dr),
                     .jtag_tdo_zen_n(jtag_tdo_zen_n),
                     .select_r(i_select_r),
                     .test_logic_reset_nxt(i_test_logic_reset_nxt),
                     .run_test_idle_nxt(i_run_test_idle_nxt),
                     .select_dr_scan_nxt(i_select_dr_scan_nxt),
                     .capture_dr_nxt(i_capture_dr_nxt),
                     .update_dr_nxt(i_update_dr_nxt));
	     
`endif

  hif2bt
    u_hif2bt(.clk_ungated(clk_ungated),
	     .rst_a(rst_a),
             .noaccess(noaccess),
             .hold_host(hold_host),
             .h_datar(h_datar),
             .pc_sel_r(pc_sel_r),
             .en(en),
             .reset_applied_r(reset_applied_r),

             .h_addr(h_addr),
             .h_dataw(h_dataw),
             .h_write(h_write),
             .h_read(h_read),
             .aux_access(aux_access),
             .core_access(core_access),
             .madi_access(madi_access),
             .halt(halt),
             .xstep(xstep),

             .debug_address(i_debug_address),
             .debug_be(i_debug_be),
             .debug_cmd(i_debug_cmd),
             .debug_cmdval(i_debug_cmdval),
             .debug_eop(i_debug_eop),
             .debug_rspack(i_debug_rspack),
             .debug_wdata(i_debug_wdata),
             .pcp_ack(pcp_ack),
             .pcp_dlat(pcp_dlat),
             .pcp_dak(pcp_dak),
             .pcp_d_rd(pcp_d_rd),

             .debug_cmdack(i_debug_cmdack),
             .debug_rdata_r(i_debug_rdata),
             .debug_reop(i_debug_reop),
             .debug_rspval(i_debug_rspval),
             .debug_rerror_r(i_debug_rerror),
             .pcp_wr_rq(pcp_wr_rq),
             .pcp_rd_rq(pcp_rd_rq),
             .pcp_addr(pcp_addr),
             .pcp_brst(pcp_brst),
             .pcp_mask(pcp_mask),
             .pcp_d_wr(pcp_d_wr));

  //  output drives
  assign shiftdr_en   = i_shift_dr;
  assign updatedr_en  = i_update_dr;
  assign capturedr_en = i_capture_dr;

endmodule // module jtag_port
