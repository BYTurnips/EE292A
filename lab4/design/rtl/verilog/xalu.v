// CONFIDENTIAL AND PROPRIETARY INFORMATION
// Copyright 1996-2012 ARC International (Unpublished)
// All Rights Reserved.
//
// This document, material and/or software contains confidential
// and proprietary information of ARC International and is
// protected by copyright, trade secret and other state, federal,
// and international laws, and may be embodied in patents issued
// or pending.  Its receipt or possession does not convey any
// rights to use, reproduce, disclose its contents, or to
// manufacture, or sell anything it may describe.  Reverse
// engineering is prohibited, and reproduction, disclosure or use
// without specific written authorization of ARC International is
// strictly forbidden.  ARC and the ARC logotype are trademarks of
// ARC International.
// 
// ARC Product:  ARC 600 Architecture v4.9.7
// File version:  600 Architecture IP Library version 4.9.7, file revision 
// ARC Chip ID:  0
//
// Description:
// 
// This file contains the logic for:
//       Single-cycle Barrel shifter instructions, Revision info. : $Workfile$  600 Architecture IP Library version 4.9.7, file revision  $Date$
//       Small Score Boarded Multiply Instruction, Revision info. :  600 Architecture IP Library version 4.9.7, file revision  $Date$
//       Normalise Instruction
//       Swap Instruction, Revision info. :  600 Architecture IP Library version 4.9.7, file revision  $Date$
//
//========================== Inputs to this block ==========================--
//
// aluflags_r       ALU Flags. The current state of the ALU flags are
//                  supplied from flags direct from the latches. Thus,
//                  the Z N C V flags can be used with the extension
//                  condition units, but can also be used to suppress flag
//                  setting in extension instructions re-presenting it on the
//                  xflags[3:0] bus. This will have the effect (when flag 
//                  setting is enabled) of latching the current value back
//                  into the latch. 
//
// p3opcode[4:0]    Opcode word. This bus contains the instruction word
//                  which is being executed by stage 3. It must be
//                  qualified by p3iv. The extension instructions take the
//                  upper 16 instruction slots, i.e. 0x10 to 0x1F.
//
// p3iv             L Opcode valid. This signal is used to indicate that the 
//                  opcode in pipeline stage 3 is a valid instruction. The
//                  instruction may not be valid if a junk instruction has
//                  been allowed to come into the pipeline in order to allow
//                  the pipeline to continue running when an instruction 
//                  cannot be fetched by the memory controller, or when an
//                  instruction has been killed.
//                   It should be noted that it is possible for a stall 
//                  condition to occur in stage 2 whilst stage 3 completes.
//                  This will mean that a 'bubble' will be introduced to the
//                  pipeline. State machines should always bear in mind that
//                  if an instruction moves out of stage 3, this does not 
//                  always mean that a new instruction will come into stage 3.
//
// p3c[5:0]         Instruction C field. This bus carries the region of 
//                  the instruction which contains the operand C field. This
//                  is used to encode extra single-operand functions onto
//                  the FLAG instruction opcode.
//
// p3condtrue       This signal is produced from the result of the internal
//                  stage 3 condition code unit or from an extension cc unit
//                  (if implemented). A bit (bit 5) in the instruction selects
//                  between the internal and extension cc unit results. In 
//                  addition, this signal is set true if the instruction is
//                  using short immediate data.
//                    For extensions use it should always be qualified with
//                  an instruction decode and p3iv. 
//  
// s1val[]          Source 1 Data Value. This bus is the source 1 bus  
//                  latched from cr_int, when the instruction in stage 2
//                  passes on to stage 3. It is used as an input to the ALU, 
//                  and for various other purposes outside rctl.
//
// s2val[]          Source 2 Data Value. This bus is the source 2 bus 
//                  latched from cr_int, when the instruction in stage 2
//                  passes on to stage 3.It is used as an input to the ALU,
//                  and for various other purposes outside rctl.
//
// aux_dataw        Auxiliary Write Data. This is the auxiliary register
//                  bus write data value from the host interface. This 
//                  is generated by hostif, either from the host's write  
//                  data bus when the ARC is halted (en = '0') or from 
//                  source 1 from pipeline stage 3, when the ARC is
//                  running. 
//
// x_multic_wben    Multi-cycle extension writeback enable. This signal
//                  is true when the multi-cycle instruction wants to
//                  write-back. It should have been qualified with p3iv,
//                  and p3condtrue and the extension  opcode. If any
//                  other instruction requires a write back at the same
//                  time this signal is true the ARCompact pipeline will
//                  stall and the multi-cycle extension will write back.
//
// x_snglec_wben    Single-cycle extension writeback enable. This signal
//                  is true when the single cycle instruction wants to
//                  write-back. It should have been qualified with p3iv,
//                  and p3condtrue and the extension  opcode. If any
//                  other instruction requires a write back at the same
//                  time this signal is true the ARCompact pipeline will
//                  stall and the multi-cycle extension will write back.
//
// ======================== Output from this block =========================--
//
// xflags           Extension Flags. This bus contains the flag result
//                  (Z, N, C, V) of the extension ALU operations. It is
//                  selected to be latched into the ALU result flags
//                  when x_idecode3, p3iv, p3condtrue are all true.
//                  The flag setting option wouldhave to be requested
//                  as part of the normal instruction encoding or the
//                  xsetflags signal has been forced by xrctl.
//
// xresult          Extension Result. The 32-bit result of an ALU
//                  operation is asserted here. This is selected by the 
//                  ARC when the x_idecode3 is true(in xrctl). This
//                  result is latched into the writeback stage when en3,
//                  p3iv, and p3condtrue signals are true at the end of
//                  the cycle.
//
//==========================================================================--
//

module xalu (clk,
             rst_a,
             
             p3iv,
             aluflags_r,
             p3opcode,
             p3subopcode,
             p3subopcode2_r,
             p3a_field_r,
             p3b_field_r,
             p3c_field_r,
             p3subopcode3_r,
             p3subopcode4_r,
             p3subopcode5_r,
             p3subopcode6_r,
             p3subopcode7_r,
             p3minoropcode,  
             p3condtrue,
             en3,
             ext_s1val,
             ext_s2val,
             s1val,
             s2val,
             aux_dataw,
             x_idecode3,
             x_multic_wben,
             x_snglec_wben, 
             uxsetflags,
             uxresult,
             uxflags,
    
                          barrel_type_r,
             x_p3_brl_decode_16_r,
             x_p3_brl_decode_32_r,
             // Multiply
             p2b_opcode,
             p2b_subopcode,
             p2b_iv,
             en2b,
             aux_st_mulhi_a,
             
             x_p3_norm_decode_r,
             x_p3_snorm_decode_r,
             x_p3_swap_decode_r,
             

                          mulatwork_r,
             lmul_en,
             lmulres_r,
             

             x_s_flag,
             xflags,
             xresult);


// Extra include files required for extensions are inserted here.
`include "arcutil_pkg_defines.v" 
`include "arcutil.v" 
`include "asmutil.v" 
`include "extutil.v" 
`include "xdefs.v" 

   input          clk;
   input          rst_a;

   input          p3iv;
   input   [3:0]  aluflags_r; 
   input   [4:0]  p3opcode; 
   input   [5:0]  p3subopcode; 
   input   [4:0]  p3subopcode2_r; 
   input   [5:0]  p3a_field_r;
   input   [5:0]  p3b_field_r;
   input   [5:0]  p3c_field_r;
   input   [2:0]  p3subopcode3_r; 
   input          p3subopcode4_r; 
   input   [1:0]  p3subopcode5_r; 
   input   [2:0]  p3subopcode6_r; 
   input   [1:0]  p3subopcode7_r; 
   input   [5:0]  p3minoropcode; 
   input          p3condtrue;
   input          en3;

   input   [31:0] ext_s1val; 
   input   [31:0] ext_s2val; 
   input   [31:0] s1val; 
   input   [31:0] s2val; 
   input   [31:0] aux_dataw; 
   input          x_idecode3; 
   input          x_multic_wben; 
   input          x_snglec_wben; 
   input          uxsetflags;
   input   [31:0] uxresult; 
   input   [3:0]  uxflags; 

// Barrel shifter
input   [1:0]  barrel_type_r; 
input          x_p3_brl_decode_16_r; 
input          x_p3_brl_decode_32_r;
 
   input   [4:0]  p2b_opcode;
   input   [5:0]  p2b_subopcode;
   input          p2b_iv;
   input          en2b;
   input          aux_st_mulhi_a;
// Normalise
   input          x_p3_norm_decode_r;
   input          x_p3_snorm_decode_r;
// SWAP
   input          x_p3_swap_decode_r;
//
   output         mulatwork_r;
   output         lmul_en;
   output  [63:0] lmulres_r;
//
   output  [1:0]  x_s_flag;
   output  [3:0]  xflags; 
   output  [31:0] xresult;

//
   wire    [1:0]  x_s_flag;
   wire    [3:0]  xflags; 
   wire    [31:0] xresult; 

// Signal declarations for extensions to be added.
// Barrel Shift signals
reg            i_barrel_c_flag_a; 
reg            i_barrel_c_flag1_a; 
reg            i_barrel_c_flag2_a; 
reg            i_barrel_c_flag3_a; 
reg            i_barrel_c_flag4_a; 
reg            i_barrel_c_flag5_a; 
wire    [ALUFLAG_MSB:0]  i_barrel_flags_a; 
reg     [DATAWORD_MSB:0] i_barrel_result_a; 
reg     [DATAWORD_MSB:0] i_barrel_result1_a; 
reg     [DATAWORD_MSB:0] i_barrel_result2_a; 
reg     [DATAWORD_MSB:0] i_barrel_result3_a; 
reg     [DATAWORD_MSB:0] i_barrel_result4_a; 
reg     [DATAWORD_MSB:0] i_barrel_result5_a; 
wire    [SUBOPCODE2_16_MSB:0] i_brlshift_val_a; 
wire    [1:0]  i_brlshift_type;
wire    [1:0]  i_barrel_type_a;


   reg            lmul_en; 
   wire    [63:0] lmulres_r; 
   reg            mulatwork_r; 
   reg     [63:0] i_multiply_res_r;

//** This specifies how wide our partial multiplier is **
// 
   parameter mul_width  = 4; 
   parameter mul_msb    = (mul_width - 1); 
   parameter mul_lstate = 4'b 1010;
   parameter prod_width = mul_width + DATAWORD_WIDTH; 

   reg     [mul_msb:0] i_mul_state_r; 

   wire    [mul_width:0] i_mul_a; 
   wire    [DATAWORD_MSB:0] i_mul_b; 
   wire    [prod_width - 1:0] i_mul_c; 
   wire    [mul_width + DATAWORD_WIDTH:0] i_mul_product_a; 
   wire    [mul_width + DATAWORD_MSB:0] i_madd_product_a; 
   reg     [mul_width + DATAWORD_MSB:0] i_int_mul_res_r;    
   wire    [mul_width + DATAWORD_WIDTH:0] i_mul_ws;    // intermediate result components from the Wallace Tree
   wire    [mul_width + DATAWORD_WIDTH:0] i_mul_wc;    // intermediate result components from the Wallace Tree

   
   reg            i_mul_signed_r; 
   reg            i_do_signed_r; 
   reg     [DATAWORD_MSB:0] i_m1val_r; 

// Normalise
   wire    [2:0]  i_a_res_a;
   wire    [3:0]  i_b_res_a;
   wire           i_b_sel_a;
   wire    [3:0]  i_c_res_a;
   wire           i_c_sel_a;
   wire    [3:0]  i_d_res_a;
   wire           i_d_sel_a;
   wire           i_n_signbit_a;
   wire    [3:0]  i_normflags_a;
   wire    [DATAWORD_MSB:0] i_normres_a;
   wire           i_nz_a;
   wire    [4:0]  i_res_a;
   wire    [DATAWORD_MSB:0] i_norm_input_a;
   wire           i_norm_n_flag_a;
   // SWAP
   wire    [31:0] i_swap_res_a;
   wire           i_swap_z_a;
   wire           i_swap_n_a;
   wire    [3:0]  i_swap_flags_a;
   

// ================== Functional bit of the instruction ====================--
//
// This section of the file is for the logical description of the ALU
// operation which you are implementing as part of this extension.
// 
// Notes on design of extension instructions:
// 
// Flag Setting : The generation of flags for a particular ALU
// extension should be evaluated in this section. 
// 
//  Functional/Logical Descriptions are inserted here
// ===================== Barrel shifter Extension =====================--
// 


//  Shift value comes directly from the source 2 field --    
//
assign i_brlshift_val_a = ext_s2val[SUBOPCODE2_16_MSB:0];

assign i_barrel_type_a = barrel_type_r;

   
always @(i_brlshift_val_a or ext_s1val or
         i_barrel_type_a 
	 //or i_barrel_c_flag1_a or 
         //i_barrel_c_flag2_a or i_barrel_c_flag3_a or 
         //i_barrel_c_flag4_a or i_barrel_result1_a or 
         //i_barrel_result2_a or i_barrel_result3_a or 
         //i_barrel_result4_a
	 )
   begin : BRLSHIFT_PROC
   case (i_barrel_type_a)
   MULTIBIT_ASL:
      begin

      //  LSL/ASL
      //
      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_result1_a = {ext_s1val[30:0], ONE_ZERO};    
         end
      else
         begin
         i_barrel_result1_a = ext_s1val;  
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_result2_a = {i_barrel_result1_a[29:0], TWO_ZERO};    
         end
      else
         begin
         i_barrel_result2_a = i_barrel_result1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_result3_a = {i_barrel_result2_a[27:0], FOUR_ZERO};   
         end
      else
         begin
         i_barrel_result3_a = i_barrel_result2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_result4_a = {i_barrel_result3_a[23:0], EIGHT_ZERO};  
         end
      else
         begin
         i_barrel_result4_a = i_barrel_result3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_result5_a = {i_barrel_result4_a[15:0], SIXTEEN_ZERO};    
         end
      else
         begin
         i_barrel_result5_a = i_barrel_result4_a;  
         end

      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_c_flag1_a = ext_s1val[DATAWORD_MSB];    
         end
      else
         begin
         i_barrel_c_flag1_a = 1'b 0;   
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_c_flag2_a = i_barrel_result1_a[30];  
         end
      else
         begin
         i_barrel_c_flag2_a = i_barrel_c_flag1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_c_flag3_a = i_barrel_result2_a[28];  
         end
      else
         begin
         i_barrel_c_flag3_a = i_barrel_c_flag2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_c_flag4_a = i_barrel_result3_a[24];  
         end
      else
         begin
         i_barrel_c_flag4_a = i_barrel_c_flag3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_c_flag5_a = i_barrel_result4_a[16];  
         end
      else
         begin
         i_barrel_c_flag5_a = i_barrel_c_flag4_a;  
         end

      end
   MULTIBIT_LSR:
      begin
      //  LSR
      //  
      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_result1_a = {ONE_ZERO, ext_s1val[DATAWORD_MSB:1]};  
         end
      else
         begin
         i_barrel_result1_a = ext_s1val;  
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_result2_a = {TWO_ZERO, i_barrel_result1_a[DATAWORD_MSB:2]};  
         end
      else
         begin
         i_barrel_result2_a = i_barrel_result1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_result3_a = {FOUR_ZERO, i_barrel_result2_a[DATAWORD_MSB:4]}; 
         end
      else
         begin
         i_barrel_result3_a = i_barrel_result2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_result4_a = {EIGHT_ZERO, i_barrel_result3_a[DATAWORD_MSB:8]};    
         end
      else
         begin
         i_barrel_result4_a = i_barrel_result3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_result5_a = {SIXTEEN_ZERO, i_barrel_result4_a[DATAWORD_MSB:16]}; 
         end
      else
         begin
         i_barrel_result5_a = i_barrel_result4_a;  
         end

      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_c_flag1_a = ext_s1val[0];   
         end
      else
         begin
         i_barrel_c_flag1_a = 1'b 0;   
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_c_flag2_a = i_barrel_result1_a[1];   
         end
      else
         begin
         i_barrel_c_flag2_a = i_barrel_c_flag1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_c_flag3_a = i_barrel_result2_a[3];   
         end
      else
         begin
         i_barrel_c_flag3_a = i_barrel_c_flag2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_c_flag4_a = i_barrel_result3_a[7];   
         end
      else
         begin
         i_barrel_c_flag4_a = i_barrel_c_flag3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_c_flag5_a = i_barrel_result4_a[15];  
         end
      else
         begin
         i_barrel_c_flag5_a = i_barrel_c_flag4_a;  
         end

      end
   MULTIBIT_ASR:
      begin
      //  ASR
      // 
      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_result1_a = {ext_s1val[DATAWORD_MSB],
                                ext_s1val[DATAWORD_MSB:1]};    
         end
      else
         begin
         i_barrel_result1_a = ext_s1val;  
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_result2_a = {{(2){i_barrel_result1_a[DATAWORD_MSB]}},
                                i_barrel_result1_a[DATAWORD_MSB:2]};
         end
      else
         begin
         i_barrel_result2_a = i_barrel_result1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_result3_a = {{(4){i_barrel_result2_a[DATAWORD_MSB]}},
                                i_barrel_result2_a[DATAWORD_MSB:4]};    
         end
      else
         begin
         i_barrel_result3_a = i_barrel_result2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_result4_a = {{(8){i_barrel_result3_a[DATAWORD_MSB]}},
                                i_barrel_result3_a[DATAWORD_MSB:8]};    
         end
      else
         begin
         i_barrel_result4_a = i_barrel_result3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_result5_a = {{(16){i_barrel_result4_a[DATAWORD_MSB]}},
                                i_barrel_result4_a[DATAWORD_MSB:16]};   
         end
      else
         begin
         i_barrel_result5_a = i_barrel_result4_a;  
         end

      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_c_flag1_a = ext_s1val[0];   
         end
      else
         begin
         i_barrel_c_flag1_a = 1'b 0;   
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_c_flag2_a = i_barrel_result1_a[1];   
         end
      else
         begin
         i_barrel_c_flag2_a = i_barrel_c_flag1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_c_flag3_a = i_barrel_result2_a[3];   
         end
      else
         begin
         i_barrel_c_flag3_a = i_barrel_c_flag2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_c_flag4_a = i_barrel_result3_a[7];   
         end
      else
         begin
         i_barrel_c_flag4_a = i_barrel_c_flag3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_c_flag5_a = i_barrel_result4_a[15];  
         end
      else
         begin
         i_barrel_c_flag5_a = i_barrel_c_flag4_a;  
         end

      end
   MULTIBIT_ROR:
      begin
      //  ROR
      // 
      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_result1_a = {ext_s1val[0],
                                ext_s1val[DATAWORD_MSB:1]};    
         end
      else
         begin
         i_barrel_result1_a = ext_s1val;  
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_result2_a = {i_barrel_result1_a[1:0],
                                i_barrel_result1_a[DATAWORD_MSB:2]};
         end
      else
         begin
         i_barrel_result2_a = i_barrel_result1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_result3_a = {i_barrel_result2_a[3:0],
                                i_barrel_result2_a[DATAWORD_MSB:4]};    
         end
      else
         begin
         i_barrel_result3_a = i_barrel_result2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_result4_a = {i_barrel_result3_a[7:0],
                                i_barrel_result3_a[DATAWORD_MSB:8]};    
         end
      else
         begin
         i_barrel_result4_a = i_barrel_result3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_result5_a = {i_barrel_result4_a[15:0],
                                i_barrel_result4_a[DATAWORD_MSB:16]};   
         end
      else
         begin
         i_barrel_result5_a = i_barrel_result4_a;  
         end

      if (i_brlshift_val_a[0] == 1'b 1)
         begin
         i_barrel_c_flag1_a = ext_s1val[0];   
         end
      else
         begin
         i_barrel_c_flag1_a = 1'b 0;   
         end

      if (i_brlshift_val_a[1] == 1'b 1)
         begin
         i_barrel_c_flag2_a = i_barrel_result1_a[1];   
         end
      else
         begin
         i_barrel_c_flag2_a = i_barrel_c_flag1_a;  
         end

      if (i_brlshift_val_a[2] == 1'b 1)
         begin
         i_barrel_c_flag3_a = i_barrel_result2_a[3];   
         end
      else
         begin
         i_barrel_c_flag3_a = i_barrel_c_flag2_a;  
         end

      if (i_brlshift_val_a[3] == 1'b 1)
         begin
         i_barrel_c_flag4_a = i_barrel_result3_a[7];   
         end
      else
         begin
         i_barrel_c_flag4_a = i_barrel_c_flag3_a;  
         end

      if (i_brlshift_val_a[4] == 1'b 1)
         begin
         i_barrel_c_flag5_a = i_barrel_result4_a[15];  
         end
      else
         begin
         i_barrel_c_flag5_a = i_barrel_c_flag4_a;  
         end

        end
   default:
      ;
   endcase
   end // block: brlshift_proc

   
   always @(i_barrel_result5_a or i_barrel_c_flag5_a)
         begin
                
       i_barrel_result_a  = i_barrel_result5_a;
       i_barrel_c_flag_a  = i_barrel_c_flag5_a;

         end
   
   
   
 
   //  Barrel shift result flags. 
   //
   assign i_barrel_flags_a[A_N_N] = i_barrel_result_a[DATAWORD_MSB];
    
   assign i_barrel_flags_a[A_Z_N] = (i_barrel_result_a == THIRTY_TWO_ZERO) ?
          1'b 1 : 
          1'b 0;
   
   assign i_barrel_flags_a[A_C_N] = i_barrel_c_flag_a;
   
   assign i_barrel_flags_a[A_V_N] = aluflags_r[A_V_N]; 

   
   
// =========================================================================--

//========================== Multi-cycle multiplier =========================--
//
// This section implements a unsigned multiply using a technique which
// operates on a small number of bits at once.
//
// The unused portion of the result register is used to store the multiplier,
// whilst the i_m1val_r register is used to hold the multiplicand.
//
// The first cycle (when the mul instruction is in p3) is used to load the
// bottom half of the result register with the multiplier.
//
// States :                                                    mulatwork_r
//
// 0    idle                                                        0
// 1    load mulres(31:0) with multiplier. Evaluate cc              1
// 2    first partial result generated                              1
// ..
// (32/mul_width)       cycle before final multiply will take place
// (32/mul_width)+1     final multiply
// (32/mul_width)+2     final partial result ready for addition.
//

always @(posedge clk or posedge rst_a)
   begin : MULFSM_PROC
   if (rst_a == 1'b 1)
      begin
      i_mul_state_r <= 4'b 0000;        
      mulatwork_r <= 1'b 0;        
      i_do_signed_r <= 1'b 0;        
      i_mul_signed_r <= 1'b 0;        
      lmul_en <= 1'b 0;        

      end
   else
      // Set up sign bit for last multiply
      //
      begin
      if ((i_mul_state_r == 4'b 1000) & (i_do_signed_r == 1'b 1))
         begin
         i_mul_signed_r <= i_multiply_res_r[mul_width + mul_width - 1];        
         end
      else
         begin
         i_mul_signed_r <= 1'b 0;        
         end

      case (i_mul_state_r)

      // If there's a mul a-coming round the mountain, (i.e. in p2)
      // then move out if the idle state, setting the 'signed' flag
      // accordingly.
      // 
      4'b 0000:
         begin
         if ((p2b_iv == 1'b1) & (en2b == 1'b1))
            begin
            if ((p2b_opcode == OP_FMT2) & (p2b_subopcode == MO_MULU64))
               begin
               i_mul_state_r <= 4'b 0001;
               mulatwork_r <= 1'b 1;
               i_do_signed_r <= 1'b 0;
               end
            else if (((p2b_opcode == OP_FMT2) & (p2b_subopcode == MO_MUL64)) | 
                     ((p2b_opcode == OP_16_ALU_GEN)                        &
                      (p2b_subopcode[SUBOPCODE2_16_MSB:0] == SO16_MUL64)))
               begin
               i_mul_state_r <= 4'b 0001;
               mulatwork_r <= 1'b 1;
               i_do_signed_r <= 1'b 1;
               end
            end

         lmul_en <= 1'b 0;
         end

      // First multiplier state - load the result register, and evaluate 
      // the condition codes.
      //
      // If the cc is false, fall back into the idle state. 
      // 
      4'b 0001:
         begin
         if ((p3condtrue & p3iv) == 1'b1)
            begin
            i_mul_state_r <= 4'b 0010;        
            end
         else
            begin
            i_mul_state_r <= 4'b 0000;        
            mulatwork_r <= 1'b 0;        
            end
         lmul_en <= 1'b 0;
         end

      // If it's the last state, then go back to the idle state
      // 
      mul_lstate:
         begin
         i_mul_state_r <= 4'b 0000;        
         mulatwork_r <= 1'b 0;        
         lmul_en <= 1'b 1;
         end

      // The rest of the multiplier states.
      // 
      default:
         begin
         i_mul_state_r <= i_mul_state_r + 4'b 0001;        
         lmul_en <= 1'b 0;        

         end
      endcase
      end

   end

//  The multiplier input is always the bottom mul_width bits of lmulres_r
// 
assign i_mul_a = {i_mul_signed_r, i_multiply_res_r[mul_width - 1:0]}; 

//  The multiplier always gets i_m1val_r on the multiplicand input --
// 
assign i_mul_b = i_m1val_r; 

//  The madd adder input always gets the top 32 bits of the product register.
// 
assign i_mul_c = (i_do_signed_r == 1'b 0) ?
      {{(prod_width - (DATAWORD_WIDTH)){1'b 0}}, i_multiply_res_r[63:32]} : 
      {{(prod_width - (DATAWORD_WIDTH)){i_multiply_res_r[63]}},
       i_multiply_res_r[63:DATAWORD_WIDTH]}; 
       


   mult32x5cs u_mul32x5(
                    .res_sum(i_mul_ws),
                    .res_carry(i_mul_wc),
                    .dataa(i_mul_a),
                    .datab(i_mul_b),
                    .signed_op_a(i_do_signed_r),
                    .signed_op_b(i_do_signed_r)
                   );
   
   assign i_mul_product_a = i_mul_ws + i_mul_wc;   // full-adder

// Latch the multiply result.
// 
always @(posedge clk or posedge rst_a)
   begin : INTERMEDIATE_PROC
   if (rst_a == 1'b 1)
      begin
      i_int_mul_res_r <= {(mul_width + DATAWORD_WIDTH){1'b 0}};        
      end
   else
      begin
      i_int_mul_res_r <= i_mul_product_a[mul_width + DATAWORD_MSB:0];        
      end
   end

// Adder
// 
assign i_madd_product_a = i_int_mul_res_r + i_mul_c; 


// It's a 64-bit wide latch. 
// 
// Data either comes from the multiplier, or from an auxiliary register
// write to the high part of the register.
// 
always @(posedge clk or posedge rst_a)
   begin : MRES_LATCH_PROC
   if (rst_a == 1'b 1)
      begin
      i_multiply_res_r <= {(SIXTY_FOUR){1'b 0}};        
      i_m1val_r <= {(DATAWORD_WIDTH){1'b 0}};        

      end
   else
      // Load multiplier high result from auxiliary register write.
      // 
      begin

      if (aux_st_mulhi_a == 1'b 1)
         begin
         i_multiply_res_r <= {aux_dataw, i_multiply_res_r[DATAWORD_MSB:0]};        

         end
      else
         begin
         case (i_mul_state_r)

         // We are going to use the 'others' case to specify a shift, so we
         // need to separately specify the retain-the-value case.
         // 
         4'b 0000:
            begin
            i_multiply_res_r <= i_multiply_res_r;        
            end

         // If we are going to do the multiply, then preload result register
         // with 00000000 & ext_s2val.
         // We also load i_m1val_r from s1val_lowpower at this stage.
         // 
         4'b 0001:
            begin
            if ((p3condtrue & p3iv) == 1'b1)
               begin
               i_multiply_res_r <= {{(DATAWORD_WIDTH){1'b0}}, ext_s2val};
               end

            i_m1val_r <= ext_s1val;
            end

         // After the first multiply has taken place, the multiply result is
         // junk, but we still want to shift the multiplicand down.
         // 
         4'b 0010:
            begin
            i_multiply_res_r <= {{(DATAWORD_WIDTH + mul_width){1'b 0}},
                                 i_multiply_res_r[DATAWORD_MSB:mul_width]};        
            end

         // If we are in the process of multiplying, accept the adder result,
         // and shift the whole lot right by mul_width bits.
         // 
         // The multiplicand is shifted right in order to make space for the 
         // result of the add operation.
         // 
         default:
            begin
            i_multiply_res_r <= {i_madd_product_a,
                                 i_multiply_res_r[DATAWORD_MSB:mul_width]};        
            end

         endcase
         end

      end

   end


assign lmulres_r = i_multiply_res_r; 


   //=========================== Normalise function ==========================--
   //
   // I am assuming that if s2val_lowpower[30] == ~sign bit then no shift 
   // has to take place, and if s2val_lowpower[29] == ~sign bit that there
   // has to be a shift of 1, etc.
   //
   assign i_norm_input_a = (x_p3_snorm_decode_r == 1'b1) ? 
                           {ext_s2val[WORD_MSB:0],{WORD_WIDTH{1'b0}}} :
                           ext_s2val;

   assign i_n_signbit_a = (~i_norm_input_a[DATAWORD_MSB]);

   // top two bits 00 --
   //
   assign i_d_res_a = (i_norm_input_a[30] == i_n_signbit_a) ? 4'b1000 : 
                      (i_norm_input_a[29] == i_n_signbit_a) ? 4'b1001 : 
                      (i_norm_input_a[28] == i_n_signbit_a) ? 4'b1010 : 
                      (i_norm_input_a[27] == i_n_signbit_a) ? 4'b1011 :
                      (i_norm_input_a[26] == i_n_signbit_a) ? 4'b1100 : 
                      (i_norm_input_a[25] == i_n_signbit_a) ? 4'b1101 :
                      (i_norm_input_a[24] == i_n_signbit_a) ? 4'b1110 :
                      (i_norm_input_a[23] == i_n_signbit_a) ? 4'b1111 : 4'b0xxx;

 
   // top two bits 01 --
   //
   assign i_c_res_a = (i_norm_input_a[22] == i_n_signbit_a) ? 4'b1000 : 
                      (i_norm_input_a[21] == i_n_signbit_a) ? 4'b1001 : 
                      (i_norm_input_a[20] == i_n_signbit_a) ? 4'b1010 :
                      (i_norm_input_a[19] == i_n_signbit_a) ? 4'b1011 : 
                      (i_norm_input_a[18] == i_n_signbit_a) ? 4'b1100 :
                      (i_norm_input_a[17] == i_n_signbit_a) ? 4'b1101 :
                      (i_norm_input_a[16] == i_n_signbit_a) ? 4'b1110 :
                      (i_norm_input_a[15] == i_n_signbit_a) ? 4'b1111 : 4'b0xxx;
 
   // top two bits 10 --
   //
   assign i_b_res_a = (i_norm_input_a[14] == i_n_signbit_a) ? 4'b1000 :
                      (i_norm_input_a[13] == i_n_signbit_a) ? 4'b1001 :
                      (i_norm_input_a[12] == i_n_signbit_a) ? 4'b1010 :
                      (i_norm_input_a[11] == i_n_signbit_a) ? 4'b1011 : 
                      (i_norm_input_a[10] == i_n_signbit_a) ? 4'b1100 : 
                      (i_norm_input_a[9]  == i_n_signbit_a) ? 4'b1101 :
                      (i_norm_input_a[8]  == i_n_signbit_a) ? 4'b1110 : 
                      (i_norm_input_a[7]  == i_n_signbit_a) ? 4'b1111 : 4'b0xxx; 

   // top two bits 11 --
   //
   assign i_a_res_a = (i_norm_input_a[6] == i_n_signbit_a) ? 3'b000 : 
                      (i_norm_input_a[5] == i_n_signbit_a) ? 3'b001 : 
                      (i_norm_input_a[4] == i_n_signbit_a) ? 3'b010 : 
                      (i_norm_input_a[3] == i_n_signbit_a) ? 3'b011 : 
                      (i_norm_input_a[2] == i_n_signbit_a) ? 3'b100 : 
                      (i_norm_input_a[1] == i_n_signbit_a) ? 3'b101 :
                      (i_norm_input_a[0] == i_n_signbit_a) ? 3'b110 : 3'b111; 
                             
   // choose which result to select --
   //
   assign i_d_sel_a = i_d_res_a[3]; 
   assign i_c_sel_a = i_c_res_a[3]; 
   assign i_b_sel_a = i_b_res_a[3]; 

   // select the result --
   //
   assign i_res_a = (i_d_sel_a == 1'b1) ? {2'b00, i_d_res_a[2:0]} :
                    (i_c_sel_a == 1'b1) ? {2'b01, i_c_res_a[2:0]} :
                    (i_b_sel_a == 1'b1) ? {2'b10, i_b_res_a[2:0]} :
                    {x_p3_norm_decode_r, // Using the decode here
                     1'b1,               // allows the production
                     i_a_res_a};         // of 0x1f for norm 0x0 and
                                         // 0x0f for normw 0x0

   assign i_nz_a = (i_norm_input_a == THIRTY_TWO_ZERO) ? 1'b1 : 1'b0;

   assign i_normres_a = {TWENTYSEVEN_ZERO, i_res_a};

   assign i_norm_n_flag_a = i_norm_input_a[DATAWORD_MSB];

   assign i_normflags_a = {i_nz_a, i_norm_n_flag_a, aluflags_r[A_C_N],
                           aluflags_r[A_V_N]};

// ===========================================================================--


// ============================ Swap function =============================--
// 
//  Swaps upper and lower 16 bits of the source 1 value.
// 
  assign i_swap_res_a = {ext_s2val[15:0], ext_s2val[31:16]};

  //  Generate flag values
  //  Only Z and N are set. C and V remain unchanged.
  // 
  assign i_swap_z_a = (i_swap_res_a == {(THIRTY_TWO){1'b0}}) ?
                      1'b1 :
                      1'b0;

  assign i_swap_n_a = i_swap_res_a[DATAWORD_MSB];

  assign i_swap_flags_a = {i_swap_z_a,
                           i_swap_n_a,
                           aluflags_r[A_C_N],
                           aluflags_r[A_V_N]};


// =========================================================================--

// ========================= ALU result selection ==========================--
// 
// Note that only the normalise and barrel shift results are present
// here, since the multiply result never gets onto the ALU result bus.
// 
// For single operand extensions the result is switched to i_sopres when
// there is a match with the C-field in the instruction longword at
// stage 3, i.e. p3c. There is the possibility that instructions that
// are not single operands will also be selected. This is trapped since 
// i_sopres is only forwarded to the extension result multiplexer when
// p3c is equal to the denotation for single operand instruction. 
// 
// The 32-bit result of an ALU operation is selected based on the
// instruction in stage 3, i.e. p3i. This is selected by the ARC when
// the x_idecode3 is true, and (in xrctl.v). This result is latched
// into the writeback stage when en3, p3iv, and p3condtrue signals are
// true at the end of the cycle.
//
// As the result from the final ALU multiplexer has to be fed back to
// the operand fetch stage through the shortcut mechanism, this signal
// is likely to be part of the critical path, so this should be borne in
// mind when designing extensions.
//  
// Multic-Cycle results take priority over single cycle extensions, so
// must use a priority encoder.  All single cycle extensions are or'd 
// together, so must return '0' when they are not enabled in stage3, 
// and must be the lowest priority.

   assign xresult = 
  
//
//Result for Extension instructions decodes are inserted here.

                     x_multic_wben ? uxresult :

                 (i_barrel_result_a &
                  ({(DATAWORD_WIDTH){(x_p3_brl_decode_32_r | 
                                     x_p3_brl_decode_16_r)}})) |
                    (i_normres_a & ({32{(x_p3_norm_decode_r      |
                                        x_p3_snorm_decode_r)}})) |
                 (i_swap_res_a & ({(DATAWORD_WIDTH){x_p3_swap_decode_r}})) |
                     uxresult;

// This bus contains the flag result (Z, N, C, V) of the extension ALU
// operations. It is selected to be latched into the ALU result flags
// when x_idecode3, p3iv, p3condtrue are all true. The flag setting
// option would have to be requested as part of the normal instruction
// encoding or the xsetflags signal has been forced by xrctl.
//
// If the D field of an extension instruction is being used in a
// non-standard way, indicated by the setting of xshimm signal, then
// the flags are not set, unless xsetflags is used to force flag
// setting.
//
// If the extension ALU wants to supress flag setting, then the latched
// ALU flag result from aluflags_r[3:0] can be placed on xflags[3:0]. 
//
   assign xflags =
// For Example :
//              p3opcode == OP_FMT3 & p3subopcode == another_ext ?
//              extension_flags :
//              p3opcode == OP_FMT3 & p3subopcode == yet_another_ext ?
//              i_sopflags :    
//   
// Flags for extension instructions decodes are inserted here.

                    uxsetflags ? uxflags :

                (i_barrel_flags_a & 
                 ({(ALUFLAG_WIDTH){x_p3_brl_decode_32_r}})) |
                   (i_normflags_a & ({4{(x_p3_norm_decode_r      |
                                        x_p3_snorm_decode_r)}})) |
                (i_swap_flags_a & ({(ALUFLAG_WIDTH){x_p3_swap_decode_r}})) |
                    uxflags;


//This signal is used to in conjuction with the x_sets_sflag signal to set the
//Saturate flag in the extension AUX. reg. 41
   assign x_s_flag =
// For Example :
//              p3opcode == OP_FMT3 & p3subopcode == another_ext ?
//              extension_s_flag :
// Saturate Flag for extension instructions decodes are inserted here.
                      2'b 00;

endmodule // module xalu

